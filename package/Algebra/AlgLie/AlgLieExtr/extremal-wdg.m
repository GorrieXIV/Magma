freeze;

/*
 * Computing with Lie algebras generated by extremal elements.
 *
 * This file contains the code to compute the nilpotent basis of such
 * a Lie algebra using Groebner basis techniques. 
 *
 * Most of the code by Willem de Graaf, some smaller modifications by
 *   Dan Roozemond. April 2011 
 */

///////////////////////////////////////////////////////////////////////////

make_basis:= procedure( ~BB )
	
	if #BB eq 0 then return; end if;

	// produce a basis of the subspace of the free Lie ring spanned by BB

	mns:= SetToSequence(&join{ Seqset(Monomials(b)) : b in BB });
	Sort(~mns);

	n:= #mns;

	mat:= SparseMatrix( #BB, #mns );
	for j in [1..#BB] do
		mb:= Monomials(BB[j]); cb:= Coefficients(BB[j]);
		for i in [1..#mb] do
			mat[j][ n-Index( mns, mb[i] )+1 ]:= cb[i];
		end for;
	end for;

	vprintf AlgLieExtr, 3 : "  Echelonize %o x %o, dens: %o ...",NumberOfRows(mat),NumberOfColumns(mat),Density(mat);
	Echelonize( ~mat );
	vprintf AlgLieExtr, 3 : "done.\n";
	
	Reverse( ~mns );

	bas:= [ ];
	for i in [1..NumberOfRows( mat )] do
		b:= 0*BB[1];
		s:= Support( mat, i );
		for j in s do
			b +:= mat[i][j]*mns[j];
		end for;
		Append( ~bas, b );
	end for;

	BB:= bas;
end procedure;


normal_form:= function( f, G, dd )

    // special normal form: all monomials of degree > dd are zero as well.

    h:= NormalForm( f, G ); 
    if Degree(h) gt dd then
       mns:= Monomials(h);
       cfs:= Coefficients( h );
       h0:= 0*h;
       for i in [1..#mns] do
           if Degree( mns[i] ) le dd then
              h0 +:= cfs[i]*mns[i];
           end if;
       end for;
       h:= h0;
    end if;

    return h;

end function;

get_rid_of_hdeg:= function( f, dd )

    // all monomials of degree > dd are zero.

    if Degree(f) gt dd then
       mns:= Monomials(f);
       cfs:= Coefficients( f );
       h0:= 0*f;
       for i in [1..#mns] do
           if Degree( mns[i] ) le dd then
              h0 +:= cfs[i]*mns[i];
           end if;
       end for;
       return h0;
    end if;

    return f;

end function;


add_elm_to_G:= function( G, f, deg, nq )

   // Here G is a GB (i.e self reduced, monic). f is a monic element,
   // assumed reduced wrt G.
   // We add f to G. Maybe some elements of G reduce modulo f, so
   // we have to take them from G, reduce them modulo f, and if they
   // remain monic, to add them to G. Otherwise they are added to a list
   // of nonmonic elements that will be returned as well.

   // nq is the nilpotent quotient bound; can be Infinity. 

   U:= [ f ];
   V:= [ ];
   ldeg:= false;
   while #U gt 0 do
      newelms:= [ ];
      i:= 1;
      while i le #G do
          g:= G[i];
          m:= LeadingMonomial(g);
          g:= NormalForm( g, U );
          if not IsZero(g) then
             if LeadingMonomial(g) eq m and LeadingCoefficient(g) eq 1 then
                // leave it in G
                G[i]:= g;
                i +:= 1;
             else
                Append( ~newelms, g );
                Remove( ~G, i );
             end if;
          else
             Remove( ~G, i );
          end if;
      end while;
      G cat:= U;
      if &or[ Degree(v) lt deg : v in U ] then
         ldeg:= true;
      end if;
           
      U:= [ ];
      for g in newelms do
          c:= LeadingCoefficient(g);
          h:= g;
          if c eq -1 then h:= -h; c:= 1; end if;
          if c eq 1 then
             Append( ~U, h );
          else
             Append( ~V, h );
          end if;
      end for;
      if #U gt 0 then
         U:= Reduce( U );
      end if;
      for i in [1..#U] do
          U[i]:= normal_form( U[i], G, nq );
      end for;
      // this may have resulted in non monic elements again...
      i:= 1;
      while i le #U do
         c:= LeadingCoefficient(U[i]);
         if c ne 1 then
            Append( ~V, U[i] );
            Remove( ~U, i );
         else
            i:= i+1;
         end if;
      end while;

   end while;

   return G, V, ldeg;

end function;



Bdatum:= recformat< B, mons, mtrx : SeqEnum, V,W : ModED >;

extended_make_basis:= function( BB )

      // Here BB is a set of elements of the free algebra;
      // we make the Bdatum for the subspace spanned by it.

      if #BB eq 0 then 
         V:= RModule( Integers(), 0 );
         return rec< Bdatum | B:= [], mons:= [], mtrx:= [ ], V:=V, W:= V >;
      end if;

      mns:= [ ];
      for b in BB do
          mb:= Monomials(b);
          for m in mb do
              if not m in mns then Append( ~mns, m ); end if;
          end for;
      end for;

      Sort( ~mns );
      Reverse( ~mns );
      mat:= SparseMatrix( Integers(), #BB, #mns );
      for i in [1..#BB] do
          mb:= Monomials( BB[i] );
          cb:= Coefficients( BB[i] );
          for j in [1..#mb] do
              mat[i][ Index( mns, mb[j] ) ]:= cb[j];
          end for;
      end for;

      Echelonize( ~mat );

      V:= RModule( Integers(), #mns );
      W:= sub< V | [ V!mat[i] : i in [1..NumberOfRows(mat)]]>;

      bas:= [ ];
      zero:= 0*BB[1]; 
      mt:= [ ];
      for i in [1..NumberOfRows(mat)] do
          s:= Support( mat, i );
          b:= zero; 
          for j in s do
              b +:= mat[i][j]*mns[j];
              Append( ~mt, <i,j,mat[i][j]> );
          end for;
          Append( ~bas, b );
      end for;      
 
      return rec< Bdatum | B:= bas, mons:= mns, mtrx:= mt, 
                   V:= V, 
                   W:= W >;


end function;


is_contained:= function( Bdat, f )

    // Here Bdat is a Bdatum. We produce a new Bdatum,
    // of which the span is equal to the old one plus f.

    if IsZero(f) then return true,Bdat; end if;

    v:= Vector( Integers(), [ 0 : i in [1..#Bdat`mons] ] );
    mf:= Monomials( f );
    cf:= Coefficients( f );
    for k in [1..#mf] do
        pos:= Index( Bdat`mons, mf[k] );
        if pos eq 0 then
           BB:= Bdat`B; 
           Append( ~BB, f );
           return false, extended_make_basis( BB );
        else
           v[pos]:= cf[k];
        end if;
    end for;

    // see whether v is in Bdat`W:
    iscontained:= (Bdat`V)!v in Bdat`W;
     
    if not iscontained then


       V:= Bdat`V;
       n:= Dimension(Bdat`W);
       mns:= Bdat`mons;
       mat:= SparseMatrix( n+1, #mns, Bdat`mtrx );
       for j in [1..#mns] do
           mat[n+1][j]:= v[j];
       end for;
 
       Echelonize( ~mat );
 
       W:= sub< V | [ V!mat[i] : i in [1..NumberOfRows(mat)]]>;

       bas:= [ ];
       zero:= 0*(Bdat`B)[1]; 
       mt:= [ ];
       for i in [1..NumberOfRows(mat)] do
           s:= Support( mat, i );
           b:= zero; 
           for j in s do
               b +:= mat[i][j]*mns[j];
               Append( ~mt, <i,j,mat[i][j]> );
           end for;
           Append( ~bas, b );
       end for;      
 
       return false,rec< Bdatum | B:= bas, mons:= mns, mtrx:= mt, 
                   V:= V, 
                   W:= W >;


    else
       return true, Bdat;
    end if;

end function;


is_contained_0:= function( Bdat, f )

    // Same as is_contained, except that the answer is just yes/no
    // and the basis is not extended.

    if IsZero(f) then return true; end if;

    v:= Vector( Integers(), [ 0 : i in [1..#Bdat`mons] ] );
    mf:= Monomials( f );
    cf:= Coefficients( f );
    for k in [1..#mf] do
        pos:= Index( Bdat`mons, mf[k] );
        if pos eq 0 then
           return false;
        else
           v[pos]:= cf[k];
        end if;
    end for;

    return (Bdat`V)!v in Bdat`W;

end function;


add_elm_to_B:= procedure( ~B, G, f, gens, dg, nq )

   // Here B is a Bdatum.
   // f is a (presumably) non-monic element; we add it
   // to B, and make a new basis. If in the course of this operation
   // a new element of degree < dg appears then we add all products
   // of that element with generators, in order to reach id-closedness 
   // of degree dg in the end.   
   // We will not change G. 
   // The method runs as follows:
   //
   //    1. We add the element, obtaining a new basis B0.
   //    2. If there are elements h in B0 with the property that 
   //       they are not contained in the span of B, and deg(h) < dg,
   //       then we add all (x,h) for generators x (in gens). We
   //       obtain yet another new basis, B1.
   //    3. If B1 was made, then B:= B0; B0:= B1; and back to 2.
   //       Otherwise we are done.

   // nq is the nilpotent quotient parameter.

   is_c,B0:= is_contained( B, f );

   if not is_c then
      B1:= B0; 
      made_basis:= false;
      while not made_basis do
          made_basis:= true;
          for h in B0`B do
              is_c:= is_contained_0( B, h );
              if not is_c then

                 if Degree(h) lt dg then
                    for x in gens do
                        hh:= normal_form( x*h, G, nq );
                        is_c,B1:= is_contained( B1, hh );
                        if not is_c then
                           made_basis:= false;
                        end if;
                    end for;
                 end if;
              end if;
          end for;
          B:= B0; 
          B0:= B1; 
      end while;
   end if;

   //return B;

end procedure;

is_hom_elm:= function( f )

   mns:= Monomials(f);
   return Degree(mns[1]) eq Degree(mns[#mns]);
   
end function;


function ExtremalLieRingBasis( R : bound := Infinity()) //R::Setq[AlgFPLieElt] : bound := Infinity() ) -> SeqEnum, SeqEnum, SeqEnum
/* Basis for Lie ring generated by extremal elements with relations relations R, max degree bound, can be infinity.
Returns 
(1) non-monomial basis reflecting torsion (sequence of AlgFPLieElt)
(2) torsion (sequence of Integers); 
(3) monomial basis (sequence of AlgFPLieElt); 
*/
	if IsNull(R) then error "Illegal null sequence"; end if;
	if not (bound cmpeq Infinity() or (Type(bound) eq RngIntElt and bound gt 0)) then
		error "bound must be a positive integer or Infinity()";
	end if;

	A:= Universe(R);
	if BaseRing(A) cmpne Integers() then error "ExtremalLieRingBasis currently only over the integers."; end if;

	g:= Reverse( [ A.i : i in [1..Rank(A)] ] );

	B:= [ ];
	Bd:= [ ];

	NB:= [ ];   // basis in "normal form" i.e., displaying torsion etc.
	Tors:= [ ]; // the torsion corresponding to the elements of NB

	G:= [ ];
	BB:= [ ];    // G, BB will be the reduction pair...
	Gd:= [ ];   // same as G but then split up in equal degree parts.
	Qs:= [* *]; //the Q-matrices for each degree (coming out of the Smith form).

	deg:= 1;

	is_nilquot:= bound lt Infinity();
	hermite_offset:= 5000;

	while deg le bound do
		vprintf AlgLieExtr, 3 : "[ZBasis] deg: %o, count: %o = %o\n", deg, &+[Integers() | #u : u in Bd ], [ Integers() | #u : u in Bd ];
		vprintf AlgLieExtr, 3 : "[ZBasis] torsion: %o\n", &join[ SequenceToMultiset(t) : t in Tors ];

		rels:= [ ];
		for r in R do 
			if Degree(r) eq deg then
				f:= NormalForm( r, G );
				if f ne 0 then Append( ~rels, f ); end if;
			end if;
		end for;

		//split into monic/nonmonic
		BBdeg:=  [ ];
		Gdeg:= [ ];

		if deg ge 3 then
			len:= #rels;
		
			//Add Jacobi (?)
			for i in [1..#Bd[1]] do
				m1:= Bd[1][i];
				for u in [1..#Bd] do
					v:= deg-1-u;
					if not ((v gt 0) and (v le #Bd)) then continue; end if;
					
					for j in [1..#Bd[u]] do
						m2:= Bd[u][j];
						if not (m1 lt m2) then continue; end if;
						
						for k in [1..#Bd[v] ] do
							m3:= Bd[v][k];
							if m1 lt m2 and m2 lt m3 then
								f1:= NormalForm( m2*m3, Gd[u+v] );
								f2:= NormalForm( m1*m2, Gd[1+u] );
								f3:= NormalForm( m3*m1, Gd[1+v] );
								f:= m1*f1+m3*f2+m2*f3;
								Append( ~rels, f );
							end if;
						end for;
					end for;
				end for;
			end for; 

			// Add [x,[x,b]]
			for i in [1..#Bd[1]] do
				m1:= Bd[1][i];
				if not (#Bd ge deg-2) then continue; end if;

				for u in Bd[deg-2] do
					f:= m1*(m1*u);
					f:= NormalForm( f, G );
					if not IsZero(f) then
						Append( ~rels, f );
					end if;
				end for;
			end for;
		end if; //if deg ge 3 then

		if deg ge 4 and deg le bound then
			for u in [1..#Bd] do
				v:= deg-u-2;
		
				if not ((v ge 1) and (v le #Bd)) then continue; end if;
			
				for i in [1..#Bd[u]] do
					m1:= Bd[u][i];
					for j in [1..#Bd[v]] do
						m2:= Bd[v][j];
						for k in [1..#Bd[1]] do
							m3:= Bd[1][k];
					
							//Add [x,[y,[x,z]]]
							f:= m3*(m1*(m3*m2));
							f:= NormalForm( f, G );
							if not IsZero(f) then
								Append( ~rels, f );
							end if;
					
							//Add [[x,y], [x,z]]
							f:= (m3*m1)*(m3*m2);
							f:= NormalForm( f, G );
							if not IsZero(f) then
								Append( ~rels, f );
							end if;

							if #rels - len gt hermite_offset then 
								make_basis(~rels);
								len:= #rels;
							end if;
						end for;
					end for;
				end for;
			end for;
		end if; //if deg ge 4 and deg le bound then


		// now add elements of the form (x,b) where x is a generator,
		// and b an element of BB of degree deg-1.
		for f in BB do
			if Degree(f) ne deg-1 then continue; end if;
			
			for x in Bd[1] do     
				h:= NormalForm( x*f, Gdeg );      
				if not IsZero(h) then
					Append( ~rels, h );
				end if;
			end for;
		end for;

		make_basis( ~rels );


		for f in rels do 
			if not IsZero(f) then 
				c:= Coefficients(f)[1]; 
				if c eq -1 then
					f0:= -f;
					c:= 1;
				else
					f0:= f;
				end if;

				if c eq 1 then
					Append( ~Gdeg, f0 );
				else
					Append( ~BBdeg, f0 ); 
				end if;
			end if;
		end for;
		Append( ~Gd, Gdeg );
		G cat:= Gdeg;


		// make the normal monomials of degree deg:
		if deg eq 1 then
			newB:= g;
			i:= 1;
			while i le #newB do
				f:= NormalForm( newB[i], G );
				if f ne newB[i] then 
					Remove( ~newB, i );
				else
					i:= i+1;
				end if;
			end while;
		else
			newB:= [ ];
			lms:= [ Monomials(u)[1] : u in Gdeg ];
			for x in Bd[1] do
				for m in Bd[deg-1] do
					if x lt m then
						m1:= x*m;
						if not m1 in lms then 
							Append( ~newB, m1 );
						end if;
					end if;
				end for;
			end for;
		end if;

		// Note that newB is sorted small to big 
		// (follows from the above piece of code). 
		if #BBdeg gt 0 then
			mat:= ZeroMatrix( Integers(), #BBdeg, #newB );
			for j in [1..#BBdeg] do
				mb:= Monomials(BBdeg[j]); cb:= Coefficients(BBdeg[j]);
				for i in [1..#mb] do
					mat[j][ Index( newB, mb[i] ) ]:= cb[i];
				end for;
			end for;

			S,P,Q:= SmithForm( mat );
			Append( ~Qs, Q );
			Qi:= Q^-1;

			bas:= [ ];
			tor:= [ ];
			nocol:= NumberOfColumns( mat );
			for k in [1..nocol] do
				cc:= Qi[k];
				b:= Zero(A);
				for i in [1..nocol] do
					if cc[i] ne 0 then
						b +:= cc[i]*newB[i];
					end if;
				end for;

				Append( ~bas, b );

				if k le NumberOfRows( S ) then
					Append( ~tor, S[k][k] );
				else
					Append( ~tor, 0 );
				end if;
			end for;      

			Append( ~NB, bas );
			Append( ~Tors, tor ); 
		else
			Append( ~NB, newB );
			Append( ~Tors, [ 0 : i in [1..#newB] ] );
			Append( ~Qs, ZeroMatrix( Integers(), 0, 0 ) );
		end if;

		BB cat:= BBdeg;
		Append( ~Bd, newB );

		if #newB eq 0 and bound gt 2*deg-1 then
			bound:= deg;
			bound:= Maximum([bound] cat [ Integers()| Degree(u) : u in R ]);
		end if;
		deg:= deg+1;      
	end while; // main while loop


	bas:= [ ];
	tors:= [ ];
	basinds:= [ ]; 

	// a list of lists, e.g., if the k-th element is [0,0,6,7,8], then
	// the "normal basis" has 5 elements of degree k, the first two 
	// with torsion 1, the last three with positions 6, 7, 8 in the final basis.
	// The first two willl then not be part of the final basis.

	grading:= [ ];

	k:= 1;
	for i in [1..#NB] do
		Append( ~basinds, [ ] );
		grad:= 0;
		for j in [1..#NB[i]] do
			if Tors[i][j] ne 1 then
				Append( ~bas, NB[i][j] );
				Append( ~tors, Tors[i][j] );
				Append( ~basinds[i], k ); k:= k+1;
				grad +:= 1;
			else
				Append( ~basinds[i], 0 );
			end if;
		end for;
		Append( ~grading, grad );
	end for;
	
	//We have computed the basis and the torsion; that's all we care about for now.
	return bas, tors, &cat(Bd);
end function;


function ExtremalLieAlgebra(R : bound := Infinity()) //::Setq[AlgFPLieElt] : d := Infinity()) -> AlgLie, SeqEnum, SeqEnum, UserProgram
/*
Return a structure constant Lie algebra which is isomorphic to the
sandwich algebra corresponding to the free Lie algebra L = Universe(R),
modulo teh relations in R.
*/

	// R: relations
	// If NilQuot is an integer, then we only loop until that degree,
	// i.e., we do a nilpotent quotient. 

	if IsNull(R) then error "Illegal null sequence"; end if;
	if not (bound cmpeq Infinity() or (Type(bound) eq RngIntElt and bound gt 0)) then
		error "bound must be a positive integer or Infinity()";
	end if;

	NilQuot := bound;
	FpL := Universe(R);

	if not IsField(BaseRing(FpL)) then error "ExtremalLieAlgebra only for fields."; end if;

	R := [r: r in R];

	// We take the reverse list of generators, to have the 
	// smallest one first.
	gen:= Reverse( [ FpL.i : i in [1..Rank(FpL)] ] );

	// Check whether the relations are homogeneous.
	IS_HOM:= true;
	for g in R do
		d:= [ Degree(y) : y in Monomials( g ) ];
		if #Set( d ) gt 1 then
			IS_HOM:= false;
			break;
		end if;
	end for;
	
	// If we do a nilpotent quotient, then we only enumerate until 
	// degree NilQuot. Otherwise we determine the correct bound later.
	if NilQuot lt Infinity() and not IS_HOM then
		nilq_nothom:= true;
		bound:= 2*NilQuot;

		// we reduce the relations so that their degrees will be <= bound.
		newRels:= [ ];
		for r in R do
			mns:= Monomials( r );
			cfs:= Coefficients( r );
			rel:= Zero( FpL );
			for i in [1..#mns] do
				if Degree( mns[i] ) le NilQuot then
					rel:= rel + cfs[i]*mns[i];
				end if;
			end for;
			Append( ~newRels, rel );
		end for;
		R:= newRels;
	else
		nilq_nothom:= false;
		bound:= NilQuot;
	end if; //if NilQuot lt Infinity() and not IS_HOM then

	// Get relations of degree 1 (if any):
	G:= [R | r : r in R | Degree(r) eq 1 ];
	if #G gt 0 then
		G:= Reduce( G );
		GD:= [ G ];
		LMS:= [ { Monomials(g)[1] : g in G } ];
		B:= [ ];
		for g in gen do
			if not g in LMS[1] then
				Append( ~B, g );
			end if;
		end for;
	else
		B:= gen;  // basis to be    
		G:= [ ]; // The Groebner basis to be.
		GD:= [ ]; // The Groebner basis to be, by degrees.
		LMS:= [ {@FpL| @} ]; //leading monomials
	end if;


	newBasElt:= true;
	degs:= [ Degree( x ) : x in B ];  // a list for stroring the degree of each basis element.
	l:= 1;

	while l lt bound do
		l +:= 1;
		newRels:= [ ];

		vprintf AlgLieExtr, 3: "[Nilpotent Basis] length = %o; #B = %o\n", l, #B;

		vprintf AlgLieExtr, 4 : "  Generating relations... ";

		// find all relations of degree l...
		for i in [1..#R] do
			if Degree( R[i] ) eq l then
				g:= NormalForm( R[i], G );
				if g ne 0 then Append( ~newRels, g ); end if;
			end if;
		end for;

		for i in [1..#B] do
			if Degree(B[i]) ne 1 then continue; end if;
				
			for j in [1..#B] do
				if Degree(B[j])+2 eq l then
					g:= NormalForm( B[i]*(B[i]*B[j]), G );
					if g ne 0 then Append( ~newRels, g ); end if;
				end if;
			end for;
		end for;

		// if we are in the nilpotent quotient, non-hom case, and l
		// is bigger than NilQuot, then we have to add the commutators
		// of basis elements of degree l as relations..
		if nilq_nothom and l gt NilQuot then
			for i in [1..#B] do for j in [i+1..#B] do
				dm:= degs[i]+degs[j];
				if dm eq l then
					g:= NormalForm( B[i]*B[j], G );
					if g ne 0 then Append( ~newRels, g ); end if;
				end if;
			end for; end for;
		end if;

		if #newRels gt 0 then
			newRels:= Reduce( newRels );
		end if;

		// Jacobi identities (only Jac(x,a,b) where x is a generator).
		newRels := InternalJacRelations(l, B, GD, G, newRels, IS_HOM);
		
		for i in [1..#newRels] do
			c:= Coefficients( newRels[i] )[1];
			newRels[i]:= newRels[i]/c;
		end for;

		// Now we add the new relations. We only do a reduce if a
		// relation of lower degree was found.
		lowDeg:= false;
		newLMS:= {@FpL| @};
		for g in newRels do
			if Degree(g) lt l then
				lowDeg:= true;
			end if;
			Append( ~G, g );

			dg := Degree(g);
			for d := #GD to dg do
				Append(~GD, [FpL|]);
			end for;
			Append(~GD[dg], g);

			Include( ~newLMS, Monomials(g)[1] );
		end for;
		if lowDeg then
			if #G gt 0 then
				G:= Reduce( G );
				Sort( ~G );

				GD := [];
				for g in G do
					dg := Degree(g);
					for d := #GD to dg do
						Append(~GD, [FpL|]);
					end for;
					Append(~GD[dg], g);
				end for;

				LMS:= [ ];
				for g in G do
					dg:= Degree( g );
					if not IsDefined( LMS, dg ) then
						LMS[dg]:= {@FpL| @};
					end if;
					Include( ~LMS[dg], Monomials(g)[1] );
				end for;
				for i in [1..#LMS] do
					if not IsDefined( LMS, i ) then
						LMS[i]:= {@FpL| @};
					end if;
				end for;
			end if;
		else
			Append( ~LMS, newLMS );
		end if;

		// see whether any of the basis elements reduce...
		// not necessary if no new rels of low deg found...
		if lowDeg then
			newB:= [ ];
			newdegs:= [ ];
			for i in [1..#B] do
				p:= NormalForm( B[i], G );
				// If the basis element does not reduce, then it remains
				// a basis element; otherwise we get rid of it.

				if B[i] eq p then
					Append( ~newB, B[i] );
					Append( ~newdegs, degs[i] );
				end if;
			end for;

			B:= newB;
			degs:= newdegs;
		end if;

		vprintf AlgLieExtr, 4 : "Done.\n";

		if nilq_nothom and l gt NilQuot then
			// no need to search for new basis elements, as these already 
			// have been added as relations...
			newBasElt:= false;
		end if;

		if newBasElt then
			// in the previous round new basis elements have been found,
			// so we must see whether the same holds in this round.
			
			vprintf AlgLieExtr, 4 : "  Searching for new basis elements... ";

			// make new basis elements
			newBasElt:= false;
			len:= #B;
			
			for i in [1..len] do for j in [i+1..len] do
				if degs[i] + degs[j] eq l then
					mn:= ( B[i], B[j] );
					// This monomial reduces if and only if it is equal
					// to a leading monomial of a GB element (this follows
					// from the fact that B[i], B[j] are reduced).
					if not mn in LMS[ l ] then
						vprintf AlgLieExtr, 4 : "!";
						Append( ~B, mn );
						Append( ~degs, l );
						newBasElt:= true;
					end if;
				end if;
			end for; end for;
			
			vprintf AlgLieExtr, 4 : "Done.\n  #B = %o = %o\n", #B, SequenceToMultiset(degs);

			if not newBasElt then
				// No new basis elements are found. This means that we can
				// determine the bound up to which we have to enumerate 
				// relations. If the relations are homogeneous, then we 
				// stop immediately, because all monomials of higher degree
				// will reduce. Because of homogeneity they cannot reduce
				// to things of lower degree, so they will reduce to zero.
				// In the non-homgeneous case we have to enumerate until
				// 2*l-1, and we have to include all relations.
				if IS_HOM then
					bound:= l;
				elif not nilq_nothom then
					bound:= Maximum( 2*l-1, Maximum( [ Degree( r ) : r in R ] ) );
				end if;
				// if nilq_nothom then we leave the bound as it is.
			end if;

		end if;

	end while; //End of main loop
	
	// in the homogeneous case the thing is graded...
	if IS_HOM then
		gr:= [ ];
		k:= 1;
		while k le #B do 
			dm:= Degree( B[k] );
			n:= 0;
			while k le #B and Degree( B[k] ) eq dm do
				k:= k+1;
				n:= n+1;
			end while;
			Append( ~gr, [dm,n] );
		end while;
	else
		gr:= [ ];
	end if; 

	L:= InternalGBLieAlgebra(FpL, bound, B, GD, IS_HOM);

	bas:= {@@};
	for i in [1..#B] do Include( ~bas, B[i] ); end for;

	// We add a function that takes two bracketed expressions, and 
	// returns their product as a lin co of bracketed expressions.
	mult := function( a, b )
		k1:= Position( bas, a );
		k2:= Position( bas, b );
		x:= Eltseq( L.k1*L.k2 );
		u:= Zero( FpL );
		for i in [1..#x] do
			if not IsZero( x[i] ) then
				u:= u + x[i]*bas[i];
			end if;
		end for;
		return u;
	end function;

	return L, gr, B, mult;
end function;


/* 
 * Converting fp lie monomials to other things
 */
function is_monomial(x) //IsMonomial(x::AlgFPLieElt) -> SeqEnum[RngIntElt]
/* returns boolean whether it is a monomial (x_1, (x_2, (x_3, ...))), and if so, 
  a sequence of generator indices [1,2,3,...] */

	ret := [Integers() | ];
	while true do
		il, l, x := IsLeaf(x);
		if il then 
			Append(~ret, l); 
			break; 
		else
			il2, i := IsLeaf(l);
			if not il2 then return false, _; end if;
			Append(~ret, i);
		end if;
	end while;
	
	return true, ret;
end function;

function AlgFPLieElt_to_AlgLieExtrElt(L, x)
/* return L!x */
	b, Q := is_monomial(x);
	assert b;
	return elt<L | Q>;
end function;

function AlgFPLieElt_to_UserProgram(x)
	b, Q := is_monomial(x);
	assert b;
	
	f := function(gens, comp)
		if #Q eq 1 then 
			return gens[Q[1]]; 
		else
			n := #Q;
			r := comp(gens[Q[n-1]], gens[Q[n]]);
			for i in [n-2..1 by -1] do r := comp(gens[Q[i]], r); end for;
			return r;
		end if;
	end function;
	
	return f;
end function;


/* 
 * Below: the AlgLieExtr intrinsics
 */
intrinsic Basis(L::AlgLieExtr) -> SeqEnum, SeqEnum
{ Compute a basis for L, using the fact that the nilpotent basis is
  equal to the non-nilpotent one. Return basis elements as
(1) sequence of FP Lie elts
(2) sequence of user programs
}
	local BED, BElts, g, c;

	R := BaseRing(L);
	n := NumberOfGenerators(L);
	fla := FreeLieAlgebra(R, n);

	if assigned L`BasisUP then
		assert assigned L`BasisElts;
		if not assigned L`BasisFP then
			L`FPLieAlg := fla;
			gens := [ fla.i : i in [1..n] ];
			comp := func<x,y | (x,y)>;
			L`BasisFP := [ f(gens, comp) : f in L`BasisUP ];
		end if;
		return L`BasisFP, L`BasisUP;
	end if;
	
	rels := {fla | (fla.(p[1]), fla.(p[2])) : p in L`CommGens };
	_,_,BFP,_ := ExtremalLieAlgebra(rels);
	
	//Make sure the generators of fla are the first n elements of BFP...
	assert {BFP[i]: i in [1..n]} eq {fla.i : i in [1..n]};
	for i in [1..n] do BFP[i] := fla.i; end for;
	
	//Make the other representations of the basis
	BElts := [ L | AlgFPLieElt_to_AlgLieExtrElt(L, x) : x in BFP ];
	BUP := [ AlgFPLieElt_to_UserProgram(x) : x in BFP ];
	
	//Assign fields
	L`FPLieAlg := fla;
	L`BasisElts := BElts;
	L`BasisFP := BFP;
	L`BasisUP := BUP;
	
	//Return
	return BFP, BUP;
end intrinsic;


intrinsic ZBasis(L::AlgLieExtr) -> SeqEnum[AlgFPLieElt], SeqEnum[RngIntElt], SeqEnum[AlgFPLieElt]
{ Compute an integral basis of L. Return a basis as 1st argument, and corresponding torsion as 2nd argument.
  Return a monomial basis (not corresponding to 1st or 2nd argument) as 3rd return value. }
	require Characteristic(BaseRing(L)) eq 0 : "ZBasis does not make sense if BaseRing(L) is of nonzero char. ";

	n := L`NumGens;
	
	fl := FreeLieAlgebra(Integers(), n);
	rels := {fl | (fl.p[1], fl.p[2]) : p in L`CommGens };
	
	bas, tor, monmbas := ExtremalLieRingBasis(rels);
	
	return bas, tor, monmbas;
end intrinsic;

