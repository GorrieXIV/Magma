freeze;

/*
 * Computing with Lie algebras generated by extremal elements.
 *
 * This file contains constructors, and some trivial call to the C code that
 * computes the multiplication table.   
 *
 * Dan Roozemond, 2010.
 */

function commgens_to_graph(n, commgens)
	local cg, edges;

	cg := [ {t[1], t[2]} : t in commgens ];
	edges := { {i,j} : i,j in [1..n] | i lt j and {i,j} notin cg };
	return Graph<n | edges>;	
end function;

function graph_to_commgens(gamma)
	local vs;
	vs := VertexSet(gamma);
	return [<i,j> : i,j in [1..#vs] | i lt j and vs.i notadj vs.j ];
end function;

intrinsic Dimension(L::AlgLieExtr) -> RngIntElt
{ The dimension of L (obtained by computing a basis, so potentially slow) }
	_ := Basis(L);
	return L`Dimension;
end intrinsic;

intrinsic ExtremalLieAlgebra(F::Rng, n::RngIntElt : CommGens := [], HeisenbergPairs := []) -> AlgLieExtr
{Lie algebra over F generated by n extremal elements}
	local L;

	require IsInvertible(F!2) : "2 should be an invertible element of F.";
	require Type(CommGens) eq SeqEnum and (#CommGens eq 0 or ExtendedType(CommGens) eq SeqEnum[Tup])
		: "CommGens should be a sequence of 2-tuples";
	require Type(HeisenbergPairs) eq SeqEnum and (#HeisenbergPairs eq 0 or ExtendedType(HeisenbergPairs) eq SeqEnum[Tup])
		: "HeisenbergPairs should be a sequence of 2-tuples";
	
	L := InternalLieExtr(F, n);
	if #CommGens gt 0 then L`CommGens := CommGens; end if;
	if #HeisenbergPairs gt 0 then L`HeisenbergPairs := HeisenbergPairs; end if;
		
	return L;
end intrinsic;

intrinsic ExtremalLieAlgebra(F::Rng, Gamma::GrphUnd : HeisenbergPairs := []) -> AlgLieExtr
{Lie algebra over F described by the graph Gamma}
	local L;
	
	require IsField(F): "F should be a field";
	require Characteristic(F) ne 2: "The characteristic of F should be distinct from 2";
	require Type(HeisenbergPairs) eq SeqEnum and (#HeisenbergPairs eq 0 or ExtendedType(HeisenbergPairs) eq SeqEnum[Tup])
		: "HeisenbergPairs should be a sequence of 2-tuples";
	
	L := InternalLieExtr(F, #VertexSet(Gamma));
	L`CommGens := graph_to_commgens(Gamma);
	if #HeisenbergPairs gt 0 then L`HeisenbergPairs := HeisenbergPairs; end if;
	
	return L;
end intrinsic;


intrinsic CommutatorGraph(L::AlgLieExtr) -> GrphUnd
{The graph Gamma describing the commutation relations of L}
	return commgens_to_graph(L`NumGens, L`CommGens);
end intrinsic;



intrinsic MultiplicationTable(~L::AlgLieExtr : HowMuch := "Auto", MemLimit := Infinity(), FullJacobi := false)	
{ Force computation of the multiplication table of L. 
Takes three optional parameters: Firstly, HowMuch ("Auto", "Top" or "Full"), designating
how big a portion of the multiplication table should be computed. Second, MemLimit (integer, in MB)
which stops the computation of the "Full" mult. table once that much memory has been allocated.
Thirdly, FullJacobi (true or false) that decides whether once the appropriate part of
the multiplication table has been computed, the Jacobi identity is tested in an attempt to reduce
the rank of the coefficient ring. Potentially really rather slow.}
	require Type(HowMuch) eq MonStgElt : "HowMuch should be a string";
	require HowMuch in {"Auto", "Top", "Full"} : "HowMuch should be \"Auto\", \"Top\", or \"Full\"";
	require Type(FullJacobi) eq BoolElt : "FullJacobi should be a boolean.";
	require MemLimit cmpeq Infinity() or Type(MemLimit) eq RngIntElt : "MemLimit should be Infinity() or an integer";

	if HowMuch cmpeq "Top" and MemLimit cmpne Infinity() then
		print "Warning: MemLimit not respected in computation of Top part of multiplication table.";
	end if;
	
	/* Set the howmuch parameter for the call to C-level */
	case HowMuch:
		when "Top": hm := 0;
		when "Full": hm := 2;
		when "Auto": hm := -1;
		else: error "Whoa!";
	end case;

	/* Set the memlimit parameter for the call to C-level */
	if MemLimit cmpeq Infinity() then
		ml := 0;
	else
		ml := MemLimit;
	end if;
	
	/* Set the fulljac parameter for the call to C-level */
	fj := FullJacobi;

	/* Call the actual function at C-level */
	InternalComputeMT(~L, hm, ml, fj);
end intrinsic;
	
	