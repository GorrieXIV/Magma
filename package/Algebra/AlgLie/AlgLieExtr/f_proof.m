freeze;

/*
 * Computing with Lie algebras generated by extremal elements.
 *
 * This file contains code to investigate the tracing of the f-values.
 *
 * Dan Roozemond, 2010.
 */
procedure check_no_zerorels_todo(L : DoErr := false)
	n := L`NumZerorelsTodo;
	if n gt 0 then
		s := Sprintf("There are %o unresolved relations among the f-values. This means the set of free f-values is currently not minimal!", n);
		if DoErr then error s; else print "WARNING:", s; end if;
	end if;
end procedure;

procedure fval_proof_rec(L, FVT, BS, x, b)
	t := FVT[x][b];
	if (t[2] eq "") then
		//Free element
		printf "f(%o, %o) = %o {%o}\n", x, BS[b], t[1], t[3];
	else
		//Not free.
		printf "f(%o, %o) -> %o", x, BS[b], t[2];
		if #t[3] le 40 then 
			printf " {%o}\n", t[3];
		else
			printf "\n"; printf "{%o}\n", t[3];
		end if;
		//Possibly recurse
		dep := t[4];
		if #dep ne 0 then
			IndentPush();
			for p in dep do
				$$(L, FVT, BS, p[1], p[2]);
			end for;
			IndentPop();
		end if;
		//Final value.
		printf "= %o\n", t[1];
	end if;
end procedure;

intrinsic fValue(L::AlgLieExtr, x::RngIntElt, b::RngIntElt) -> RngElt
{ The value of f_x(b) }
	
	MultiplicationTable(~L : FullJacobi := true);
	require assigned L`FvalTraces : "Trace data not available. Has the computation table been computed?";
	requirerange x, 1, Ngens(L);
	requirerange b, 1, Dimension(L);
	check_no_zerorels_todo(L);
	
	FVT := L`FvalTraces;
	return FVT[x][b][1];
end intrinsic;

intrinsic FreefValues(L::AlgLieExtr) -> SeqEnum, SeqEnum
{ The values f_x(b) (in the first returned sequence) that can be chosen arbitrarily, 
  and corresponding pairs (x,b) (in the second sequence) }

	MultiplicationTable(~L : FullJacobi := true);
	require assigned L`FvalTraces : "Trace data not available. Has the computation table been computed?";
	check_no_zerorels_todo(L : DoErr);
	
	CR := CoefficientRing(L);
	Z := Integers();	
	
	if CR cmpeq L`OrigBaseRing then
		return [CR|], [CartesianProduct(Z,Z)|];
	end if;
	
	FVT := L`FvalTraces;
	n := Ngens(L);
	d := Dimension(L);
	
	Q := &cat[ [ <Z!x, Z!b, CR!FVT[x][b][1]> : x in [1..n] | FVT[x][b][3] cmpeq "Free" ] : b in [1..d] ];

	//Check order
	vars := [ CR.i : i in [1..Rank(CR)] ];
	assert [ CR | q[3] : q in Q] eq vars;
	
	return [ CR | q[3] : q in Q], [ CartesianProduct(Z,Z) |  <q[1], q[2]> : q in Q ];
end intrinsic;

intrinsic fValueProof(L::AlgLieExtr, x::RngIntElt, b::RngIntElt)
{ Prints a proof for the value of f_x(b) }
	
	MultiplicationTable(~L : FullJacobi := true);
	_,B := Basis(L);
	require assigned L`FvalTraces : "Trace data not available. Has the computation table been computed?";
	requirerange x, 1, Ngens(L);
	requirerange b, 1, Dimension(L);
	check_no_zerorels_todo(L);
	
	FVT := L`FvalTraces;
	
	/* Basis elements as concise strings */
	gens := [ IntegerToString(i) : i in [1..Ngens(L)] ];
	comp := func<x,y | x cat y>;
	BS := [ "[" cat b(gens, comp) cat "]" : b in B ];
	
	/* Go into the recursion */
	fval_proof_rec(L, FVT, BS, x, b);
end intrinsic;

