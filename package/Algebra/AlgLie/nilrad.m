freeze;

//////////////////////////////////////////////////////////////////////////////

// The Jacobson radical also for the case of characteristic 0. The algorithm 
// is based on the following characterisation of the radical:
//
//  Rad(A) = { x\in A | Tr(xy)=0 for all y \in A}.
//
JacRad:=function(A)

   F:=CoefficientRing(A);
   if Characteristic(F) gt 0 then
     return JacobsonRadical( A );
   else

      V:= VectorSpace( F, Dimension(A) );
      eqs:= Zero( Hom(V,V) );
      bas:= Basis(A);
      for i in [1..#bas] do
        for j in [i..#bas] do
          eqs[i][j]:= Trace( bas[i] * bas[j] );
          eqs[j][i]:= eqs[i][j];
        end for;
      end for;

      sol:= Kernel( eqs );

      b:= [ &+[Eltseq(sol.i)[j]*bas[j] : j in [1..#bas] ] :
                                       i in [1..Dimension(sol)]];

      return ideal< A | b >;
   end if;

end function;


intrinsic NilRadical( L:: AlgLie ) -> AlgLie
{ The nilradical of the Lie algebra L}

    if assigned L`NilRadical then return L`NilRadical; end if;

    F:= CoefficientRing( L );
    p:= Characteristic( F );

    if p eq 0 then

      // For L of characteristic 0.

      R:= SolvableRadical( L );
 
      if Dimension( R ) eq 0 then
         L`NilRadical:= R;
         return R;
      end if;

      H:= CartanSubalgebra( R );
      if Dimension( H ) eq Dimension( R ) then // R is nilpotent, so equal 
                                               // to the nilradical
         L`NilRadical:= R;
         return R;
      end if;
      // R1 will be the Fitting-one component ( R1 = R_1(H) ).
      R1:= R;
      d:= Dimension( R1 );
      ready:= false;
      while not ready do
           R1:= H*R1;
           if Dimension( R1 ) eq d then
              ready:= true;
           else
              d:= Dimension( R1 );
           end if;
      end while;

      // we compute the associative algebra A generated by ad_{R_1}( H.i )
      mats:= [ ];
      v:= Basis(R1);
      for i in [1..Dimension(H)] do
          m:= [ ];
          for j in [1..d] do
              Append( ~m, Coordinates( R1, Basis(H)[i]*v[j] ) );
          end for;
          Append( ~mats, Matrix( m ) );
      end for;

      A:= MatrixAlgebra< BaseRing(L), d | mats >;

      // The first part of the nilrarical is R1:
      BN:= [ L!R1.i : i in [1..d] ];

      rad:= JacRad( A );
      // we compute h\in H such that \ad h \in rad; those will be 
      // added to the nilradical.
      eqs:= [ ];
      bR:= Basis( rad );
      for i in [1..d] do
          for j in [1..d] do
              eqn:= [ ];
              for k in [1..Dimension(H)] do
                  Append( ~eqn, mats[k][i][j] );
              end for;
              for k in [1..Dimension( rad )] do
                  Append( ~eqn, -bR[k][i][j] );
              end for;
              Append( ~eqs, eqn );
          end for;
      end for;

      eqs:= Transpose( Matrix( eqs ) );
      sol:= NullSpace( eqs );
         
      for i in [1..Dimension(sol)] do
          c:= [ Eltseq( sol.i )[m] : m in [1..Dimension(H) ] ];
          Append( ~BN, L!( H!Vector( c ) ) );
      end for;

      N:= ideal< L | BN : Basis >;
      L`NilRadical:= N;
      return N;

    else

      n:= Dimension( L );

      if n eq 1 then 
        N:=ideal< L | [L.1] : Basis >; 
        L`NilRadical:= N;
        return N;
      end if;     
      if n eq 0 then 
        N:= ideal< L | [Zero(L)] : Basis >; 
        L`NilRadical:= N;
        return N;
      end if; 

      adL:= [ AdjointMatrix( L, L.i ) : i in [1..n] ];
      A:= MatrixAlgebra< F, n | adL >;
// "NilRadical of", L; "Get JacobsonRadical of A:", A; time
      R:= JacobsonRadical( A );
// _:=Dimension(A); "New A:", A; "JR:", R;

      if Dimension( R ) eq 0 then

        // In this case the intersection of 'ad L' and 'R' is the 
        // centre of L.
        N:= Centre( L );
        L`NilRadical:= N;
        return N;

      end if;

      t:= Dimension( R );

      // Now we compute the intersection of 'R' and '<ad L>'.

      V1:= VectorSpace( F, n+t );
      V2:= VectorSpace( F, n^2 );
      H:= Hom( V1, V2 );
      eqs:= Zero( H );
      for i in [1..n] do
        for j in [1..n] do
          for k in [1..n] do
            eqs[k][j+(i-1)*n]:= adL[k][i][j];
          end for;
          for k in [1..t] do
            m:= R.k;
            eqs[n+k][j+(i-1)*n]:= -m[i][j];
          end for;
        end for;
      end for;

      sol:= Kernel( eqs );
      sol:= [ L![ Eltseq(sol.i)[j] : j in [1..n] ] : 
                     i in [1..Dimension(sol)] ];
      if #sol eq 0 then 
        N:= ideal< L | [Zero(L)] : Basis >; 
      else
        N:= ideal< L | sol : Basis >;
      end if;
      L`NilRadical:= N;
      return N;

    end if;

end intrinsic;

intrinsic Nilradical( L:: AlgLie ) -> AlgLie
{ The nilradical of the Lie algebra L}
  return NilRadical(L);
end intrinsic;


///////////////////////////////////////////////////////////////////////////////
intrinsic SolvableRadical( L::AlgLie ) -> AlgLie
{ The soluble radical of the Lie algebra L}

  if assigned L`SolvableRadical then return L`SolvableRadical; end if;

  F:= CoefficientRing( L );

  if Characteristic( F ) eq 0 then

// Here we use the following characterisation of the radical:
//
// R(L)= { x\in L | Tr( \ad x \ad y )=0 for all y \in [L,L] }

    LL:=L*L;
    eqs:= [ ];
    MatAlg:= MatrixAlgebra( F, Dimension(L) );
    adL:= [ MatAlg!AdjointMatrix( L, L.i ) : i in [1..Dimension(L)] ];
    for j in [1..Dimension(LL)] do
      M:= MatAlg!AdjointMatrix( L, LL.j );
      eqs cat:= [ Trace( adL[i]*M ) : 
                             i in [1..Dimension(L)] ];
    end for;

    Vm:= VectorSpace( F, Dimension( LL ) );
    Vn:= VectorSpace( F, Dimension( L ) );
    H:= Hom( Vm, Vn );
    eqs:= Transpose( H!eqs );

    sol:= Kernel( eqs );

    if Dimension( sol ) eq 0 then
      sol:= [ Zero(L) ];
    else
      sol:= [ L!Eltseq(sol.i) : i in [1..Dimension( sol ) ] ];
    end if;

    R:= ideal< L | sol : Basis >;
    L`SolvableRadical:= R;
    return R;

  else

// We successively divide by the nilradical until it is zero. Then
// we take all pre-images.

    algs:= [ L ];
    N:= NilRadical( L );

    if Dimension( N ) in [0,Dimension(L)] then
      L`SolvableRadical:= N;
      return N;
    end if;

    nils:= [N];
    homs:= [PowerStructure(Map) |]; //Changed by Chris Krook 30-09-2003
    ready:= false;
    k:=1;
    while not ready do

      qq,f:= quo< algs[k] | N >;
      Append( ~algs, qq );
      Append( ~homs, f );
      N:= NilRadical( qq );

      if Dimension( N ) ne  0 then
        nils[k+1]:=N;
      else
        ready:=true;
      end if;
      k:= k+1;
    end while;

    k:= #nils;
    bb:= [ algs[k]!nils[k].i : i in [1..Dimension(nils[k])] ];
    while k gt 1 do
      k:=k-1;
      bb:= [ bb[i]@@homs[k] : i in [1..#bb] ];
      bb cat:= [ nils[k].i : i in [1..Dimension( nils[k] )] ];
    end while; 

    R:= ideal< L | bb : Basis >;
    L`SolvableRadical:= R;
    return R; 

  end if;

end intrinsic;
