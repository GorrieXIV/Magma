freeze;

declare type SmpCpx;

declare attributes SmpCpx:
    Faces,
    HomologyModules,
    HomologyMaps,
    ordering;

// Constructors and type-connected tools

intrinsic SimplicialComplex(faces :: Setq[SetEnum]) -> SmpCpx
    { Constructs an abstract simplicial complex with the faces in the
    list faces }
    smp := HackobjCreateRaw(SmpCpx);
    smp`Faces := { s : s in Subsets(f), f in faces };

    if # smp`Faces eq 0 then
	Include(~smp`Faces,{});
    end if;

    return smp;
end intrinsic;

intrinsic Print(smp :: SmpCpx, level :: MonStgElt)
    {}
    print "Simplicial complex";
    if level eq "Maximal" then
	print smp`Faces;
    else
	print Facets(smp);
    end if;
end intrinsic;

intrinsic AddSimplex(smp :: SmpCpx, s :: SetEnum) -> SmpCpx
    { Adds the simplex s to the simplicial complex smp returning a new
    complex. }

    faces := smp`Faces;
    Include(~faces, s);
    return SimplicialComplex(faces);
end intrinsic;

intrinsic AddSimplex(~smp :: SmpCpx, s :: SetEnum)
    { Adds the simplex s to to the simplicial complex smp. }

    for f in Subsets(s) do
	Include(~smp`Faces, f);
    end for;
    delete smp`HomologyMaps;
    delete smp`HomologyModules;    
    if assigned(smp`ordering) then delete smp`ordering; end if;
end intrinsic;

intrinsic AddSimplex(smp :: SmpCpx, s :: SeqEnum) -> SmpCpx
    { Adds all simplices in s to the simplicial complex smp. }

    faces := smp`Faces;
    for f in s do
	Include(~faces, f);
    end for;
    return SimplicialComplex(faces);
end intrinsic;

intrinsic AddSimplex(~smp :: SmpCpx, s :: SeqEnum)
    { Adds all simplices in s to the simplicial complex smp. }

    for f in s do
	for t in Subsets(f) do
	    Include(~smp`Faces, t);
	end for;
    end for;
    delete smp`HomologyModules;
    delete smp`HomologyMaps;
    if assigned(smp`ordering) then delete smp`ordering; end if;
end intrinsic;

// Extracting basic information

intrinsic Dimension(smp :: SmpCpx) -> RngIntElt
    { Returns the dimension of the highest dimensional face of smp. }
    return Maximum([ #f : f in smp`Faces])-1;
end intrinsic;

intrinsic Faces(smp :: SmpCpx, deg :: RngIntElt) -> SeqEnum[SetEnum]
    { Returns the faces of one degree of the simplicial
    complex. Requires deg to be dimension+1. }
    return [ f : f in smp`Faces | # f eq deg ];
end intrinsic;

intrinsic Facets(smp :: SmpCpx) -> SeqEnum[SetEnum]
    { Returns the facets of the simplicial complex smp. }

    faces := smp`Faces;
    for f in faces do
	faces := [ g : g in faces | g notsubset f or g eq f ];
    end for;
    return faces;
end intrinsic;

// Immediate derived complexes

intrinsic Boundary(smp :: SmpCpx) -> SmpCpx
    { Returns the simplicial complex generated by all simplexes that
    lie in the boundary of the simplicial complex smp. }

    faces := [];
    for f in Facets(smp) do
	for p in f do
	    Append(~faces,f diff {p});
	end for;
    end for;
    return SimplicialComplex(faces);
end intrinsic;

intrinsic BarycentricSubdivision(s :: SmpCpx) -> SmpCpx
    { Returns the barycentric subdivision of the simplicial complex
    s. }

    facets := Facets(s);
    faces := [];
    
    for f in facets do
	for p in Permutations(f) do
	    newface := {f};
	    ff := f;
	    for i in p do
		Exclude(~ff,i);
		Include(~newface,ff);
	    end for;
	    Exclude(~newface,{});
	    Append(~faces,newface);
	end for;
    end for;

    return SimplicialComplex(faces);
end intrinsic;

intrinsic Skeleton(smp :: SmpCpx, q :: RngIntElt) -> SmpCpx
    { Returns the q-skeleton of the simplicial complex smp. }

    ret := SimplicialComplex([]);
    ret`Faces := { f : f in smp`Faces | #f le q+1 };
    if ret`Faces eq {} then
	ret`Faces := {{Integers()|}};
    end if;
    return ret;
end intrinsic;

// Topological operations

intrinsic '+'(s :: SmpCpx, t :: SmpCpx) -> SmpCpx
    { Returns the topological sum, or disjoint union, of two
    simplicial complexes. Requires both complexes to be normalized. }

    require Universe(s`Faces) cmpeq Universe({{Integers()|}}):
	"Not a normalized simplicial complex";

    require Universe(t`Faces) cmpeq Universe({{Integers()|}}):
	"Not a normalized simplicial complex";
    
    n := Maximum(&join s`Faces);
    sf :=  Facets(s);
    tf := [ { p+n : p in f} : f in Facets(t) ];

    return SimplicialComplex(sf cat tf);
end intrinsic;

intrinsic Product(s :: SmpCpx, t :: SmpCpx) -> SmpCpx
    { Returns the cartesian product of two simplicial complexes }

    sf := Facets(s);
    tf := Facets(t);

    faces := [ ];

    for fs in sf do
	for ft in tf do
	    vertices := { <ss,tt> : ss in fs, tt in ft };
	    for f in Subsets(vertices) do
		seq := Sort([v : v in f]);
		seq2 := [ v[2] : v in seq ];
		if seq2 eq Sort(seq2) and #seq2 gt 0 then
		    newface := { v : v in seq };
		    Append(~faces,newface);
		end if;
	    end for;
	end for;
    end for;

    return SimplicialComplex(faces);    
end intrinsic;

intrinsic 'eq'(s :: SmpCpx, t :: SmpCpx) -> BoolElt
    { Compares two simplicial complexes. Will not do any isomorphism
    finding, only compare whether the two abstract simplicial
    complexes are the very same. }

    return s`Faces cmpeq t`Faces;
end intrinsic;

intrinsic Prune(smp :: SmpCpx, f :: SetEnum) -> SmpCpx
    { Removes a face f and all faces containing f from a simplicial
    complex smp }

    ret := SimplicialComplex(Facets(smp));
    Prune(~ret, f);
    return ret;    
end intrinsic;

intrinsic Prune(~smp :: SmpCpx, f :: SetEnum)
    { Removes a face f and all faces containing f from a simplicial
    complex smp }

    try 
	faces := { fs : fs in smp`Faces | f notsubset fs };
    catch e  // failure indicates that f is from the wrong universe
	faces := smp`Faces;
    end try;

    smp`Faces := faces;
    delete smp`HomologyMaps;
    delete smp`HomologyModules;
    if assigned(smp`ordering) then delete smp`ordering; end if;
end intrinsic;

intrinsic Glue(smp :: SmpCpx, eqs :: SeqEnum) -> SmpCpx
    { In the simplicial complex smp, identify all points identified by
    pairs in the sequence eqs. }

    ret := SimplicialComplex(Facets(smp));
    Glue(~ret,eqs);
    return ret;
end intrinsic;

intrinsic Glue(~smp :: SmpCpx, eqs :: SeqEnum)
    { In the simplicial complex smp, identify all points identified by
    pairs in the sequence eqs. }

    faces := {};
    points := &join Faces(smp,1);
    fsts := {e[1] : e in eqs};
    mapping := eqs;
    for p in points diff fsts do
	Append(~mapping,<p,p>);
    end for;
    
    f := map<points -> points | mapping>;
    
    for fs in smp`Faces diff {{}} do
	newface := { p@f : p in fs };
	Include(~faces,newface);
    end for;

    Include(~faces,{});

    smp`Faces := faces;
    delete smp`HomologyMaps;
    delete smp`HomologyModules;
    if assigned(smp`ordering) then delete smp`ordering; end if;
end intrinsic;

intrinsic Join(s :: SmpCpx, t :: SmpCpx) -> SmpCpx
    { Constructs the join of two simplicial complexes. Requires both
    simplicial complexes to be normalized. }

    require Universe(s`Faces) cmpeq Universe({{Integers()|}}):
	"Not a normalized simplicial complex";

    require Universe(t`Faces) cmpeq Universe({{Integers()|}}):
	"Not a normalized simplicial complex";
    
    faces := [];
    p := Maximum(&join s`Faces);
    tt := Shift(t,p);
    for sf in s`Faces do
	for tf in tt`Faces do
	    Append(~faces,sf join tf);
	end for;
    end for;
    
    return SimplicialComplex(faces);
end intrinsic;

intrinsic '*'(s :: SmpCpx, t :: SmpCpx) -> SmpCpx
    { Constructs the join of two simplicial complexes. Requires both
    simplicial complexes to be normalized. }

    return Join(s,t);
end intrinsic;

intrinsic Cone(smp :: SmpCpx) -> SmpCpx
    { Constructs a cone over the given complex. The cone is generated
    by all faces of the complex, with an additional vertex included
    into each face. Requires a normalized simplicial complex. }

    return Join(smp,SimplicialComplex([{1}]));
end intrinsic;

intrinsic Suspension(smp :: SmpCpx) -> SmpCpx
    { Constructs the suspension (double cone) over the given
    complex. Requires a normalized simplicial complex. }

    return Join(smp,SimplicialComplex([{1},{2}]));
end intrinsic;

// Internal convenience operations

intrinsic Normalization(smp :: SmpCpx) -> SmpCpx
    { Replaces the points with integers from 1 and upwards. }
    
    sc := SimplicialComplex(Facets(smp));
    Normalization(~sc);
    return sc;
end intrinsic;

intrinsic Normalization(~smp :: SmpCpx)
    { Replaces the points with integers from 1 and upwards. }

    f0 := &join Faces(smp,1);
    points := {@ p : p in f0 @};
    
    faces := {};

    for f in smp`Faces do
	newface := { Integers() | Index(points,p) : p in f };
	Include(~faces,newface);
    end for;

    smp`Faces := faces;
    delete smp`HomologyMaps;
    delete smp`HomologyModules;
    if assigned(smp`ordering) then delete smp`ordering; end if;
end intrinsic;

intrinsic Shift(smp :: SmpCpx, n :: RngIntElt) -> SmpCpx
    { Shifts all integers in the point labels in smp by an offset
    given by n. Requires the complex to be normalized. }

    ret := SimplicialComplex(Facets(smp));
    Shift(~ret, n);
    return ret;
end intrinsic;

intrinsic Shift(~smp :: SmpCpx, n :: RngIntElt)
    { Shifts all integers in the point labels in smp by an offset
    given by n. Requires the complex to be normalized. }

    require Universe(smp`Faces) cmpeq Universe({{Integers()|}}):
	"Not a normalized simplicial complex";

    faces := {};

    for f in smp`Faces do
	newface := {Integers() | p + n : p in f };
	Include(~faces, newface);
    end for;

    smp`Faces := faces;
    delete smp`HomologyMaps;
    delete smp`HomologyModules;
    if assigned(smp`ordering) then delete smp`ordering; end if;
end intrinsic;

// Conversion to and from graphs

intrinsic UnderlyingGraph(smp :: SmpCpx) -> GrphUnd,GrphVertSet,GrphEdgeSet
    { The underlying graph of the simplicial complex smp }

    vertices := &join smp`Faces;
    edges := { e : e in Facets(Skeleton(smp,1)) | #e eq 2};

    return Graph<vertices|edges>;
end intrinsic;

intrinsic FlagComplex(G :: Grph) -> SmpCpx
    { Returns the flag complex of the graph G. }

    return CliqueComplex(G);
end intrinsic;

intrinsic CliqueComplex(G :: Grph) -> SmpCpx
    { Returns the clique complex of the graph G. }

    return SimplicialComplex(AllCliques(G));
end intrinsic;

intrinsic SimplicialComplex(G :: Grph) -> SmpCpx
    { Returns the 1-dimensional simplicial complex of the
    graph. }

    faces := [ {InitialVertex(e), TerminalVertex(e)} : e in Edges(G) ];
    return SimplicialComplex(faces);
end intrinsic;

// Commonly used spaces

intrinsic Simplex(n :: RngIntElt) -> SmpCpx
    { Returns an n-dimensional simplex as a simplicial complex. }

    return SimplicialComplex([{1..n+1}]);
end intrinsic;

intrinsic Sphere(n :: RngIntElt) -> SmpCpx
    { Returns a triangulation of the n-sphere. }

    return Boundary(Simplex(n+1));
end intrinsic;

intrinsic KleinBottle() -> SmpCpx
    { Returns a triangulation of the Klein bottle as a simplicial
    complex. }

    faces := [
	{1,2,4},{2,4,7},{4,5,7},{5,7,8},
	{5,6,8},{6,8,9},{1,6,9},{1,2,9},
	{2,3,7},{3,7,10},{7,8,10},{8,10,11},
	{8,9,11},{9,11,12},{2,9,12},{2,3,12},
	{1,3,10},{1,6,10},{6,10,11},{5,6,11},
	{5,11,12},{4,5,12},{3,4,12},{1,3,4}
	];
    return SimplicialComplex(faces);
end intrinsic;

intrinsic Torus() -> SmpCpx
    { Returns a triangulation of the torus as a simplicial complex. }

    return Product(Sphere(1),Sphere(1));
end intrinsic;

intrinsic Cylinder() -> SmpCpx
    { Returns a triangulation of a circular cylinder as a simplicial
    complex. }

    return Product(Sphere(1),Simplex(1));
end intrinsic;

intrinsic MoebiusStrip() -> SmpCpx
    { Returns a triangulation of the Moebius strip as a simplicial
    complex. }

    faces := [
	{1,2,4},{2,4,5},{4,5,7},{5,7,8},{3,7,8},{2,3,8},
	{2,3,5},{3,5,6},{5,6,8},{6,8,9},{2,8,9},{1,2,9}
	];
    return SimplicialComplex(faces);
end intrinsic;

intrinsic SimplicialProjectivePlane() -> SmpCpx
    { Returns one triangulation of the projective plane }

    return SimplicialComplex([{1,2,6},{1,3,6},{3,5,6},{2,3,5},
	{1,2,5},{1,4,5},{1,3,4},{2,3,4},{2,4,6},{4,5,6}]);
end intrinsic;

intrinsic LensSpace(p :: RngIntElt) -> SmpCpx
    { Constructs the lens space L(p,1). }

    faces := [];
    
    k := p+2;
    xidx := 2*k;
    yidx := 2*k+1;
    zidx := 2*k+2;
    for i := 0 to k-3 do
	for ci := 0 to 2*k-1 do
	    Append(~faces,
		{ci mod (2*k),(1+ci) mod (2*k),
	    (k-i+ci) mod (2*k), (k-i+1+ci) mod (2*k) });
	end for;
    end for;
    for ci := 0 to 2*k-1 by 2 do
	Append(~faces,
	    {ci mod (2*k), (1+ci) mod (2*k), (3+ci) mod (2*k),yidx});
	Append(~faces,
	    {ci mod (2*k), (2+ci) mod (2*k), (3+ci) mod (2*k), yidx});
	Append(~faces,
	    {(1+ci) mod (2*k), (2+ci) mod (2*k), (4+ci) mod (2*k), zidx});
	Append(~faces,
	    {(1+ci) mod (2*k), (3+ci) mod (2*k), (4+ci) mod (2*k), zidx});
	Append(~faces,
	    {ci mod (2*k), (2+ci) mod (2*k), yidx, zidx});
	Append(~faces,
	    {(1+ci) mod (2*k), (3+ci) mod (2*k), xidx, yidx});
	Append(~faces,
	    {(1+ci) mod (2*k), (3+ci) mod (2*k), xidx, zidx});
    end for;

    return SimplicialComplex(faces);
end intrinsic;

//*********************************************
// Homology computation

intrinsic ChainComplex(smp :: SmpCpx, A :: Rng) -> ModCpx
    { Constructs a chaincomplex of A-modules corresponding to the
    abstract simplicial complex s. }

    s := smp`Faces;
    
    require #s ne 0: "Not a simplicial complex";

    faces := [* [ f : f in s | # f eq 0 ] *];

    require # faces[1] eq 1: "Not a simplicial complex";
    
    mods := [* RSpace(A,1) *];
    maps := [* *];
    
    md := Maximum({ # f : f in s});
    for i:= 1 to md do
	fs := Faces(smp,i);
	Append(~faces, fs);
	Append(~mods, RSpace(A,#fs));

	M := BoundaryMatrix(smp,i-1,A);
	
	Append(~maps,M);
    end for;

    maps :=  [* Hom(mods[1],mods[1])!0 *] cat
	maps cat
	[* Hom(mods[1],mods[#mods])!0 *];
    
    return Complex(Reverse(maps),-1);
end intrinsic;

intrinsic Homology(cpx) -> SeqEnum, SeqEnum
    { Calculates the homology of a simplicial complex with coefficients in
    the ring of integers. }

    return Homology(cpx, Integers());
end intrinsic;

intrinsic Homology(~cpx)
    { Calculates and caches the homology of a simplicial complex with
    coefficients in the ring of integers. }

    Homology(~cpx, Integers());
end intrinsic;

intrinsic Homology(~cpx :: SmpCpx, A :: Rng)
    { Calculates the homology of a simplicial complex with coefficients in
    A }

    H,M := Homology(ChainComplex(cpx,A));

    cpx`HomologyModules := H;
    cpx`HomologyMaps := M;
end intrinsic;

intrinsic Homology(cpx :: SmpCpx, A :: Rng) -> SeqEnum,SeqEnum
    { Calculates the homology of a simplicial complex with coefficients in
    A}

    return Homology(ChainComplex(cpx,A));
end intrinsic;

intrinsic FormalChain(h :: ModTupRngElt, dim :: RngIntElt,
    H :: SeqEnum, M :: SeqEnum, smp :: SmpCpx)
    { Prints a chain in the homology class h of dimension d using the
    lists H and M from H,M := Homology(ChainComplex(smp,R)); for
    some ring R. }

    totdim := Dimension(smp);
    hv := h@@M[totdim - dim+1];
    faces := Faces(smp,dim+1);
    printed := false;

    for i:= 1 to #faces do
	f := faces[i];
	c := hv[i];
		
	if c ne 0 then
	    if printed then
		if c ge 0 then
		    printf " + ";
		else
		    printf " - ";
		    c := -c;
		end if;
	    end if;
	    
	    if c eq 1 then
		printf "%o", f;
	    else
		printf "%o*%o", c, f;
	    end if;
	    printed := true;
	end if;
    end for;
    print "\n";
end intrinsic;

intrinsic HomologyGenerators(H :: SeqEnum, M :: SeqEnum, smp :: SmpCpx)
    { Prints generators of the homology groups together with their
    order, in order of dimension. }

    totdim := Dimension(smp);
    printed := false;
    
    for i:= 1 to #H-1 do
	basis := Basis(H[i]);
	try
	    moduli := Moduli(H[i]);
	catch e
	    moduli := [ 0 : b in basis ];
	end try;
	mapping := M[i];
	if #basis gt 0 then
	    printed := true;
	    printf "\n*** dimension %o ***\n", totdim-i+1;
	    for j:= 1 to #basis do
		if moduli[j] eq 0 then
		    printf "inf: ";
		else
		    printf "%3o: ", moduli[j];
		end if;
		FormalChain(basis[j],totdim-i+1,H,M,smp);
	    end for;
	end if;
    end for;
    if not printed then
	print "Complex is acyclic.\n";
    else
	print "\n";
    end if;
end intrinsic;

intrinsic HomologyGenerators(smp :: SmpCpx)
    { Prints generators of the integral homology groups of the simplicial
    complex smp together with their order, in order of dimension. }

    HomologyGenerators(smp, Integers());
end intrinsic;

intrinsic HomologyGenerators(smp :: SmpCpx, A :: Rng)
    { Prints generators of the homology groups of the simplicial
    complex smp together with their order, in order of dimension. }
    
    if assigned(smp`HomologyModules) and
	assigned(smp`HomologyMaps) and
	#smp`HomologyModules ge 1 and
	CoefficientRing(smp`HomologyModules[1]) cmpeq A then
	HomologyGenerators(smp`HomologyModules, smp`HomologyMaps, smp);
    else
	H,M := Homology(smp, A);
	HomologyGenerators(H,M,smp);
    end if; 
end intrinsic;

intrinsic HomologyGroup(smp :: SmpCpx, q :: RngIntElt) -> ModRng
    { Returns the qth homology of the simplicial complex smp. }

    return HomologyGroup(smp,q,Integers());
end intrinsic;

intrinsic HomologyGroup(smp :: SmpCpx, q :: RngIntElt, A :: Rng)->ModRng
    { Returns the qth homology of the simplicial complex smp with
    coefficients in A. }
    s := smp`Faces;
    
    require #s ne 0: "Not a simplicial complex";

    if assigned(smp`HomologyModules) then
	idx := #smp`HomologyModules - 1 - q;
	if idx lt 1 or idx gt #smp`HomologyModules then
	    return RSpace(A,0);
	else
	    return smp`HomologyModules[idx];
	end if;
    else
	din := BoundaryMatrix(smp,q+1,A);
	dout := BoundaryMatrix(smp,q,A);
	ret := quo<Kernel(dout)|Image(din)>;
	return ret;
    end if;
end intrinsic;

intrinsic BoundaryMatrix(smp :: SmpCpx, q :: RngIntElt, A :: Rng) -> Mtrx
    { Constructs the qth boundary matrix of the simplicial complex smp
    with coefficients in A. }

    require #smp`Faces ne 0 : "Not a simplicial complex.";

    f1 := Faces(smp,q+1);
    f0 := Faces(smp,q);
    f0lookup := {@ f0[x]:x in [1..#f0] @};
    assert #f0 eq #f0lookup;

    m1 := RSpace(A,#f1);
    m0 := RSpace(A,#f0);

    M := Hom(m1,m0)!0;

    minus1 := A!-1;
    for k:= 1 to #f1 do
	elts := [e : e in f1[k]];
	try
	    Sort(~elts);
	catch err
	    if not assigned(smp`ordering) then
		smp`ordering := {@ Rep(f):f in smp`Faces|#f eq 1 @};
	    end if;
	    cmp := func<x,y| Index(smp`ordering, x) - Index(smp`ordering, y)>;
	    Sort(~elts, cmp);
	end try;
	u := minus1;
	for j:= 1 to #elts do
	    u *:= minus1;
	    x := Index(f0lookup, Exclude(f1[k], elts[j]));
	    
	    error if x eq 0, "Not a simplicial complex!";
	    
	    M[k][x] := M[k][x] + u;
	end for;
    end for;
    
    return M;
end intrinsic;

intrinsic BettiNumber(smp :: SmpCpx, q :: RngIntElt) -> RngIntElt
    { Returns the qth betti number of the simplicial complex. }

    return BettiNumber(smp, q, Integers());
end intrinsic;

intrinsic BettiNumber(smp :: SmpCpx, q :: RngIntElt, A :: Rng)
    -> RngIntElt
    { Returns the qth betti number of the simplicial complex. }

    // Note that Betti numbers correspond to ranks of nonreduced
    // homology, whereas the algorithms currently implemented
    // compute reduced homology. 
    
    if q eq 0 then
	delta := 1;
    else
	delta := 0;
    end if;
    
    return Rank(HomologyGroup(smp,q,A)) + delta;
end intrinsic;

intrinsic TorsionCoefficients(smp :: SmpCpx, q :: RngIntElt)
     -> SeqEnum[RngElt]
    { Returns the torsion coefficients of the qth homology group of
    smp. }

    return TorsionCoefficients(smp,q,Integers());
end intrinsic;

intrinsic TorsionCoefficients(smp :: SmpCpx, q :: RngIntElt, A :: Rng)
    -> SeqEnum[RngElt]
    { Returns the torsion coefficients of the qth homology group of
    smp with coefficients in A. }

    try
	ret := Moduli(HomologyGroup(smp,q,A));
    catch e
	error "This ring does not admit torsion coefficients:", A;
    end try;
    return ret;
end intrinsic;

intrinsic EulerCharacteristic(smp :: SmpCpx) -> RngIntElt
    { Returns the Euler characteristic of the complex. }

    chi := 0;
    if assigned(smp`HomologyModules) then
	n := #smp`HomologyModules;
	for i:=1 to n-1 do
	    chi := chi + (-1)^(n-i-1)*Rank(smp`HomologyModules[i]);
	end for;
	chi := chi + 1; // Betti numbers work with nonreduced homology
    else
	for f in smp`Faces do
	    chi := chi + (-1)^(#f+1);
	end for;
	chi := chi + 1; // we counted {} superflously in the loop here
    end if;
    return chi;
end intrinsic;
