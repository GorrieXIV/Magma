//////////////////////////////////////////////////////////////////// 
//                                                                //  
//                RATIONAL NUMBER FIELD COMPATIBILITY             //     
//  Trivial interface so number field commands can be used over Q //
//                                                                // 
//////////////////////////////////////////////////////////////////// 
 
freeze;

intrinsic RationalsAsNumberField() -> FldNum
{Returns the number field Q[x]/(x-1)}
  return NumberField(Polynomial([-1,1]) : DoLinearExtension);
end intrinsic;

intrinsic QNF() -> FldNum
{"}//"
  return NumberField(Polynomial([-1,1]) : DoLinearExtension);
end intrinsic;

// Bad!! Do not use unless absolutely necessary (should be never)
function FixedQNF()
  return NumberField(Polynomial([-1,1]) : DoLinearExtension, Global);
end function;

// Compatibility: the NumberField of a FldAlg is itself.
// (Previously this returned Q as a FldNum, which was a bad 
// mistake by me.  We need Q to behave exactly like a FldNum.)
// --- SRD, November 2010
intrinsic NumberField(K::FldRat) -> FldRat
{Returns K}
  return K;
end intrinsic;

// Compatibility with NumberField(FldOrd)
intrinsic NumberField(K::FldNum) -> FldNum
{Returns K}
  return K;
end intrinsic;

// The NumberField of an order is the field it was created from.
intrinsic NumberField(Z::RngInt) -> FldRat
{Returns Rationals()}
   return Rationals();
end intrinsic;

intrinsic MaximalOrder(Q::FldRat) -> RngInt
   {Returns Integers()}
   return Integers();
end intrinsic;

intrinsic Decomposition(O::RngInt, p::RngIntElt) -> SeqEnum
   {The factorization of rational prime p into prime ideals in order O}
   require O cmpeq Integers(): 
      "Argument 1 must be the ring of integers.";
   require IsPrime(p): "Argument 2 must be prime";
   return [ <ideal<O | p>, 1> ];
end intrinsic;

intrinsic Minimum(I::RngInt) -> RngIntElt
   {A generator for the Z-ideal I}
   return Generator(I);
end intrinsic;

intrinsic PrimitiveElement(I::RngInt) -> RngIntElt
   {"} // "
   return Generator(I);
end intrinsic;

intrinsic Basis(I::RngInt) -> RngIntElt
   {A basis consisting of the generator of the Z-ideal I}
   return [Generator(I)];
end intrinsic;

intrinsic Norm(I::RngInt) -> RngIntElt
   {"} // "
   return Generator(I);
end intrinsic;

intrinsic RamificationIndex(I::RngInt, p::RngIntElt) -> RngIntElt
   {The ramification index for I}
   require IsPrime(p): "Argument 2 must be a prime";
   require Generator(I) eq p: "Argument 1 must contain argument 2.";
   return 1;
end intrinsic;

intrinsic RamificationIndex(I::RngInt) -> RngIntElt
   {"} // "
   require IsPrime(Generator(I)): "Argument must be a prime ideal";
   return 1;
end intrinsic;

intrinsic Degree(I::RngInt) -> RngIntElt
   {The inertia degree of I}
   if I cmpeq Integers() then
     return 1;
   end if;
   require IsPrime(Generator(I)): "Argument must be a prime ideal";
   return 1;
end intrinsic;

intrinsic TwoElementNormal(I::RngInt) -> RngIntElt, RngIntElt
   {Two generators and g for the ideal I forming a two-element g-normal presentation}
   n := Generator(I);
   return n, n;
end intrinsic;

intrinsic '^'(I::RngInt, n::RngIntElt) -> RngInt
   {Ideal arithmetic}
   require n ge 0: "The exponent must be non-negative.";
   return ideal<Integers() | Generator(I)^n>;
end intrinsic;

intrinsic '*'(a::RngIntElt, I::RngInt) -> RngInt
   {"} // "
   return ideal<Integers() | a*Generator(I)>;
end intrinsic;

intrinsic '*'(a::FldRatElt, I::RngInt) -> RngInt
   {"} // "
   Z := Integers();
   bool, a := IsCoercible(Z, a);
   require bool : "The first argument is not integral";
   return ideal< Z | a*Generator(I)>;
end intrinsic;

intrinsic '/'(I::RngInt, J::RngInt) -> RngInt
   {"} // "
   a := Generator(I); b := Generator(J);
   require a mod b eq 0: "Argument 2 must divide argument 1.";
   return ideal<Integers() | a div b>;
end intrinsic;

intrinsic IsIntegral(I::RngInt) -> BoolElt
   {Returns true}
   return true;
end intrinsic;

intrinsic IsOne(I::RngInt) -> BoolElt
   {True iff I is the trivial ideal generated by 1}
   return Generator(I) eq 1;
end intrinsic;

intrinsic IsZero(I::RngInt) -> BoolElt
   {True iff I is the zero ideal}
   return Generator(I) eq 0;
end intrinsic;

intrinsic Order(I::RngInt) -> RngInt
   {Returns IntegerRing()}
   return IntegerRing();
end intrinsic;

intrinsic ChineseRemainderTheorem(I::RngInt, J::RngInt, 
                                  a::RngIntElt, b::RngIntElt) -> RngIntElt
   {The Chinese remainder theorem formulated with ideals}
   return ChineseRemainderTheorem([a, b], [Generator(I), Generator(J)]);
end intrinsic;

intrinsic AbsoluteMinimalPolynomial(x::FldRatElt) -> RngUPolElt
  {The absolute minimal polynomial of x over Q}
  return PolynomialRing(Rationals())![-x, 1];
end intrinsic;

intrinsic Valuation(x::FldRatElt, p::RngInt) -> RngIntElt
  {The valuation of x at the prime ideal p}
  return Valuation(x, Generator(p));
end intrinsic;

intrinsic Valuation(x::RngIntElt, p::RngInt) -> RngIntElt
  {"} // "
  return Valuation(x, Generator(p));
end intrinsic;

intrinsic Valuation(x::RngInt, p::RngInt) -> RngIntElt
  {"} // "
  return Valuation(Generator(x), Generator(p));
end intrinsic;

intrinsic Valuation(x::RngInt, p::RngIntElt) -> RngIntElt
  {"} // "
  return Valuation(Generator(x), p);
end intrinsic;

intrinsic ClassRepresentative(I::RngInt) -> RngInt
   {The representative of I in the basis of the class group}
   return ideal<Integers()|1>;
end intrinsic;

intrinsic UnitGroup(Q::FldRat) -> GrpAb, Map
   {The unit group of the maximal order of Q (i.e. of Z)}
   U := AbelianGroup([2]);
   return U, map< U -> Q | <U!0, Q!1>, <U.1, Q!-1> >;
end intrinsic;

intrinsic pFundamentalUnits(Q::FldRat, p::RngIntElt) -> GrpAb, Map
   {The unit group of the maximal order of Q (i.e. of Z)}
   U := AbelianGroup([2]);
   return U, map< U -> Q | <U!0, Q!1>, <U.1, Q!-1> >;
end intrinsic;

intrinsic TorsionUnitGroup(Q::FldRat) -> GrpAb, Map
   {The unit group of the maximal order of Q (i.e. of Z)}
   U := AbelianGroup([2]);
   return U, map< U -> Q | <U!0, Q!1>, <U.1, Q!-1> >;
end intrinsic;

intrinsic Eltseq(x::FldRatElt) -> SeqEnum
   {Returns [x]}
   return [x];
end intrinsic;

intrinsic Eltseq(x::RngIntElt) -> SeqEnum
   {Returns [x]}
   return [x];
end intrinsic;

intrinsic Signature(Z::RngInt) -> RngIntElt, RngIntElt
   {The signature (number of real embeddings and pairs of complex 
           embeddings) of Q}
   return 1, 0;
end intrinsic;

intrinsic Signature(Q::FldRat) -> RngIntElt, RngIntElt
   {"} // "
   return 1, 0;
end intrinsic;

intrinsic Generators(Q::FldRat) -> []
  {Returns [1]}
  return [Q!1];
end intrinsic; 

intrinsic IsTotallyPositive(x::FldRatElt) -> BoolElt
  {True iff x is positive}
  return (x gt 0);
end intrinsic;

intrinsic IsTotallyPositive(x::RngIntElt) -> BoolElt
  {"} // "
  return (x gt 0);
end intrinsic;

intrinsic Generators(n::RngIntElt) -> SeqEnum
  {Returns [n]}
  return [n];
end intrinsic;

intrinsic AbsoluteNorm(x::RngIntElt) -> RngIntElt
{Returns x} 
  return x;
end intrinsic;

intrinsic AbsoluteNorm(x::FldRatElt) -> FldRatElt
{"} // "
  return x;
end intrinsic;

intrinsic AbsoluteNorm(I::RngInt) -> RngIntElt
{The norm of the ideal I}
  return Norm(I);
end intrinsic;

intrinsic Basis(K::FldRat) -> [ ]
{The basis of Q as a Q vector space.}
 return [K!1];
end intrinsic;

intrinsic AbsoluteDegree(K::FldRat) -> RngIntElt
{The absolute degree of K over Q.}
  return 1;
end intrinsic;

intrinsic AbsoluteDegree(O::RngInt) -> RngIntElt
{The absolute degree of O over Z}
  return 1;
end intrinsic;

intrinsic BaseField(K::FldRat) -> FldRat
{The base field of Q.}
  return K;
end intrinsic;

intrinsic BaseRing(K::FldRat) -> FldRat
{"} // "
  return K;
end intrinsic;

intrinsic AbsoluteBasis(K::FldRat) -> [ ]
{A Q-basis of K.}
  return [1];
end intrinsic;

intrinsic AbsoluteDiscriminant(K::FldRat) -> RngIntElt
{The absolute discrimiant of Q.}
  return 1;
end intrinsic;

intrinsic AbsoluteDiscriminant(Z::RngInt) -> RngIntElt
{The absolute discrimiant of Z.}
  return 1;
end intrinsic;

intrinsic ClassNumber(K::FldRat) -> RngIntElt
{Returns 1}
  return 1;
end intrinsic;

intrinsic ClassNumber(Z::RngInt) -> RngIntElt
{"} // "
  return 1;
end intrinsic;

intrinsic NarrowClassNumber(K::FldRat) -> RngIntElt
{"} // "
  return 1;
end intrinsic;

intrinsic NarrowClassNumber(Z::RngInt) -> RngIntElt
{"} // "
  return 1;
end intrinsic;

intrinsic NarrowClassGroup(K::FldRat) -> GrpAb, Map
{The narrow class group of the rationals}
  C, mC := ClassGroup(K);
  return C, mC;
end intrinsic;

intrinsic NarrowClassGroup(Z::RngInt) -> GrpAb, Map
{The narrow class group of the integers}
  C, mC := ClassGroup(Z);
  return C, mC;
end intrinsic;

intrinsic AbsoluteField(K::FldRat) -> FldRat
{Returns K}
  return K;
end intrinsic;

intrinsic Automorphisms(K::FldRat) -> SeqEnum
{Sequence containing the identity map}
  return [map< K->K | x:->x >];
end intrinsic;

intrinsic BachBound(Q::FldRat) -> RngIntElt
{Returns 1}
  return 1;
end intrinsic;

intrinsic MinkowskiBound(Q::FldRat) -> RngIntElt
{Returns 1}
  return 1;
end intrinsic;

intrinsic CompositeFields(K::FldAlg, Q::FldRat) -> FldAlg
{Returns [K]}
  return [K];
end intrinsic;

intrinsic CompositeFields(Q::FldRat, K::FldAlg) -> FldAlg
{Returns [K]}
  return [K];
end intrinsic;

intrinsic CompositeFields(Q1::FldRat, Q2::FldRat) -> FldRat
{Returns [Rationals()]}
  return [Q1];
end intrinsic;

intrinsic Compositum(K::FldAlg, Q::FldRat) -> FldAlg
{Returns K}
  return K;
end intrinsic;

intrinsic Compositum(Q::FldRat, K::FldAlg) -> FldAlg
{Returns K}
  return K;
end intrinsic;

intrinsic Compositum(Q1::FldRat, Q2::FldRat) -> FldRat
{Returns [Rationals()]}
  return Q1;
end intrinsic;

intrinsic Embed(Q::FldRat, K::FldAlg, a::Any)
{Do nothing}
  return;
end intrinsic;

intrinsic Embed(Q::FldRat, K::FldRat, a::Any)
{Do nothing}
  return;
end intrinsic;

intrinsic PowerIdeal(R::RngInt) -> PowStr
{The set of ideals over R.}
  return Parent(R);
end intrinsic;

intrinsic LLL(R::RngInt) -> RngInt
{Returns R}
  return R, MatrixRing(Integers(), 1) ! 1;
end intrinsic;

