freeze;

/**********************************************************************
 mch - 07/06 - Specialised edit of the GenericGroup code to generate
 automorphism groups of function fields. The main speed up is in using
 indexed sets ("eltshash") of sequences of images of generators to
 represent the field morphisms. This hugely improves the speed of the
 look-up functions is_in_G and is_in_T over the GenericGroup version.
 Also elthash is kept for the inverse translation map from maps ->G
 which again vastly improves the efficiency.

**********************************************************************/

autGrp := recformat<gen, Mult, elts, G, Gelts, eltshash, Id, seq>;

function gen_seq(F)
/* get sequence of field generators of F over the constant field */
    seq := [];
    F1 := F;
    while IsFinite(Degree(F1)) do
        seq cat:= [F!(F1.i) : i in [1..Ngens(F1)]];
	F1 := BaseField(F1);
    end while;
    Append(~seq,F!(F1.1));
    return seq;
end function;

is_in_G := function(a_gp, x)
    return [x(s): s in a_gp`seq] in a_gp`eltshash;
end function;

is_in_T := function(Th, x, seq)
  r := Index(Th,[x(s): s in seq]);
  if r eq 0 then
    return false,_;
  else
    return true, r;
  end if;  
end function;         


// AddGenerator together with GenericGroup acts as an interface to Dimino's
// algorithm.
function addGenerator(a_gp, gen)

  G := a_gp`G;

  if is_in_G(a_gp, gen) then
    return false, _;
  end if;   


  Append(~a_gp`gen, gen);
  if G cmpne 1 then 
    GG := AddGenerator(G);
    phi := hom<G -> GG | [GG.i : i in [1..#a_gp`gen-1]]>;
  else
    GG := FreeGroup(1);
    phi := map<Integers() -> GG | x:->GG.0>;
  end if;  
  GT := [phi(x) : x in a_gp`Gelts];
  r := [ ];


  Cl :=  [ GG.0];
  cl := [a_gp`Id];
  seq := a_gp`seq;
  T := a_gp`elts;
  Th := a_gp`eltshash;
  if #T eq 0 then
    T := [ a_gp`Id ];
    Th := {@ [(T[1])(s) : s in seq] @};
  end if;  

  repeat
    t := cl[1]; 
    Remove(~cl, 1);
    tt := Cl[1]; 
    Remove(~Cl, 1);
    for si in [1..#a_gp`gen] do
      if tt*GG.si in GT then
        continue;
      end if;  
      s := a_gp`gen[si];
      p := a_gp`Mult(t, s);
      f, pos := is_in_T(Th, p, a_gp`seq);
      vprint GrpGen, 2: "(Dimino: using generator ", GG.si, ")";
      if not f then  
        vprint GrpGen, 3: "(Dimino: adding coset)";
        Append(~cl, p);
        Append(~Cl, tt*GG.si);
        for i in [1..#a_gp`elts] do
	  etmp := a_gp`Mult(a_gp`elts[i], p);
          Append(~T, etmp);
	  Include(~Th,[etmp(s): s in seq]);
          Append(~GT, phi(a_gp`Gelts[i])* tt*GG.si);
        end for;
      else
        Append(~r, GT[pos] = tt*GG.si);
      end if;
    end for;
  until #cl eq 0;
  
  a_gp`elts := T;
  a_gp`eltshash := Th;
  a_gp`G := quo<GG | r>;
  ChangeUniverse(~GT, a_gp`G);
  a_gp`Gelts := GT;

  return true, a_gp;
end function;  

// Computes the group generated by a set of automorphisms, gen, of
// function field F (over its constant field!). Returns this
// as a permutation group G along with an invertible map from
// G to Map(F,F).
intrinsic CrvGenericGroup(gen::[ ]:Mult := '*', Eq := 'eq', Id) -> GrpPerm, Map
{}
  r := rec<autGrp | Mult := Mult, gen := [ ], elts := [  ],
                   eltshash := {@ @}, G := 1, Gelts := [ 1 ], seq := []>;

  F := Domain(gen[1]);
  seq := gen_seq(F);
  if Id cmpeq true then
    l := [gen[1]];
    g := gen[1];
    G := FreeGroup(1);
    Gelts := [ ];
    elts := [ ];
    eltsh := {@ @};
    //eltsh1 := {@ @};
    gg := G.1;
    repeat
      go := g;
      Append(~Gelts, gg);
      Append(~elts, g);
      Include(~eltsh,[g(s) : s in seq]/*hashelt(g)*/);

      gg := gg*G.1;
      g := Mult(g, gen[1]);
    until Eq(g, gen[1]);
    Id := go;
    go := Gelts[#Gelts];
    G := quo<G|go>;
    r`G := G;
    r`elts := elts;
    r`eltshash = eltsh;
    r`Gelts := Gelts;
    r`gen := [gen[1]];
    Remove(~gen, 1);
  else
    G := FreeGroup(1);
  end if;  

  r`Id := Id;
  r`seq := seq;

  a_gp := r;

  for i in gen do
    f, g := addGenerator(a_gp, i);
    if f then
      a_gp := g;
    end if;
  end for;

  // get nice permutation rep
  G := a_gp`G;
  ordG := #G;
  for i := NumberOfGenerators(G) to 1 by -1 do
    q,Gprm := CosetAction(G, sub<G|[G|G.j : j in [1..i-1]]>);
    if #Gprm eq ordG then break; end if;
  end for;

  Gelts := [q(g): g in a_gp`Gelts];
  elts := a_gp`elts;
  eltsh := a_gp`eltshash;
  G := Gprm;

  g := function(y)
    ind := Index(eltsh,[y(s) : s in seq]);
    if ind eq 0 then 
	Traceback();
	error "Preimage does not exist";
    end if;
    return Gelts[ind];
  end function;

  M := map<G -> Maps(F,F) |
           x :-> elts[Position(Gelts, x)],
           y :-> g(y)>;
   
  return G, M;
end intrinsic;

