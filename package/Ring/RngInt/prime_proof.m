freeze;

// Version of June 8, 1999

// Certificate Checker for primality certificates 
// produced by Magma (actually Morain's ECPP)
//
// Usage:
//
// IsPrimeCertificate(c : ShowCertificate := false, Trust := 0)
//
// Returns true or false depending whether c is a valid
// primality certificate (as generated by c := PrimalityCertificate(p)
// where p is a prime).  If ShowCertificate is set to true, 
// an explanation of the certificate is printed.  If Trust is 
// set to a positive integer, all primes less that Trust will
// be believed prime and will not be checked.
//
// References:
//
// Four theorems are used.
//
// Theorem 1
//    Let N - 1 =  m*p where p is an odd prime such that 2*p+1 > sqrt(N).
//    If there exists an integer a such that 
//      1. a^((N - 1)/2) = -1 mod N, and 
//      2. a^(m/2) <> -1 mod N
//    then N is prime.
//
// Ref: J. Brillhart, D.H. Lehmer, J. Selfridge, New Primality Criteria
// and Factorizations of 2^m\pm 1, Math. Comp., 29 (1975), pp. 620-647.
//
// Theorem 2
//   Let N - 1 =  p_1^b_1 *...* p_k^b_k. If, for each p_i,
//   there exists an element a_p in Z/NZ such that:
//     1. a_p^((N - 1)/p_i) - 1 <> 1 mod N, and 
//     2. a_p^(N - 1) = 1 mod N
//   then N is prime
//
// Ref: J. Brillhart, D.H. Lehmer, J. Selfridge, New Primality Criteria
// and Factorizations of 2^m\pm 1, Math. Comp., 29 (1975), pp. 620-647.
//
// Theorem 3 (paper from H. Cohen and A. K. Lenstra):
//  If N + 1 =  q1^b1 ... qk^bk and let A be the ring defined by
//  (Z/NZ)[T]/(T^2-u*T-a) where u and a are such that
//        a is prime, a^((N - 1)/2) = -1 mod N and u = 0 if N = 1 mod 4
//  and such that
//        a = 1 and (u^2+4)^((N - 1)/2) = -1 if N = 3 mod 4.
//  Then N is a prime if, for each qi, there exists an element Xi of norm 1
//  in A such that Xi^((N + 1)/qi) - 1 = xi0 + T xi1 <> 1, Xi^(N + 1) = 1
//  and GCD(xi{0, 1}, N) = 1 where xi{0, 1} <> 0.
//
// Ref: ?????
//
// Theorem 4 
// Let N be an integer greater than 1 and prime to 6. Let E be an
// elliptic curve over Z/NZ, m and s two integers such that s divides
// m. Suppose we have found a point P on E that satisfies mP = O_E, and
// that for each prime factor q of s, we have verified that (m/q)P <> O_E.
// If s > (sqrt[4](N)+1)^2 then N is prime. 
//
// Ref: S. Goldwasser and J. Kilian, Almost all primes can be quickly
// certified, Proc. 18th Annual ACM Symp. on Theory of Computing,
// (1986), pp. 316-329.

debug := false;

/* 
 * Error found
 ***************************************************************************/

function ferr(pd)
 "Aie!! This certificate has not the good format.";
 "So, I give up.";
 return false, pd;
end function;

/* 
 * N - 1 stuf
 ***************************************************************************/

/* 
 * N - 1 usual stuf
 ****************/

procedure ProofHeader(N)
  printf "Statement: N = %o is prime\n", N;
 "----------";
end procedure;


forward ProvePrime;

procedure PrintThNm1(N)
    ProofHeader(N);
 "";
 "We are going to use the following theorem:";
 "";
 "Theorem 2:"; 
 "  Let N - 1 =  p_1^b_1 *...* p_k^b_k. If, for each p_i,";
 "  there exists an element a_p in Z/NZ such that:";
 "    1. a_p^((N - 1)/p_i) - 1 <> 1 mod N, and ";
 "    2. a_p^(N - 1) = 1 mod N";
 "  then N is prime";
 "";
 "Here:\n";
end procedure;

function TheoremNm1(ShowCertificate, N, Nm1fact, Xlist, pd, Trust)
// apply theorem Nm1

  // print the theorem used 
  if ShowCertificate then
    PrintThNm1(N);
  end if;
 
  // check that the factorization of N - 1 is good 
  Nm1 := N - 1; 
  for f in Nm1fact do
    while (Nm1 mod f[1]) eq 0 do
      Nm1 := Nm1 div f[1];
    end while;
  end for;
  if Nm1 ne 1 then
    if ShowCertificate then
      "The factorization of N - 1 is not correct.";
    end if;
    return false, pd;
  end if;
 
  if ShowCertificate then
    printf "  N - 1 = ";
    for i := 1 to #Nm1fact do
      f := Nm1fact[#Nm1fact-i+1];
      if i eq 1 then
        if f[2] eq 1 then
          printf "%o", f[1];
        else 
          printf "%o^%o", f[1], f[2];
        end if;
      else
        if f[2] eq 1 then
          printf " * %o", f[1];
        else
          printf " * %o^%o", f[1], f[2];
        end if;
      end if;
    end for;
    printf ".\n";
 
    for i := 1 to #Nm1fact do
      f := Nm1fact[#Nm1fact-i+1];
     if f[1] le Trust then
       "  It is believed that", f[1], "is a prime.";
     elif f[1] in pd then
       "  It was already proved that", f[1], "is a prime.";
     else
       "  It was NOT already proved that", f[1], "is a prime";
       return false, pd;
     end if;
    end for;
   
    // Print a_p
    "\nLet:\n";
    for i:= #Xlist to 1 by -1 do
      X := Xlist[i];
      p := Nm1fact[i][1];
      printf "  a_%o := %o\n", p, X;
    end for;
  end if; // ShowCertificate
 
  // Check the conditions of the theorem
  if ShowCertificate then
    "\nThen:";
  end if;
  for i:= #Xlist to 1 by -1 do
    p := Nm1fact[i][1];
    X := Xlist[i];
    x := Modexp(X, (N - 1) div p, N);
    if x eq (1 mod N) then
       if ShowCertificate then
         printf "Aie!! a_%o^((N - 1)/2) = 1 mod N.", p;
       end if;
       return false, pd;
    end if;
    x1 := Modexp(x, p, N);
    if x1 ne (1 mod N) then
      if ShowCertificate then
        printf "Aie!! a_%o^(N - 1) = %o mod N.", p, x1;
      end if;
      return false, pd;
    end if;
    if ShowCertificate then 
      "";
      printf "  a_%o^((N - 1)/%o) = %o\n", p, p, x;
      printf "  a_%o^(N - 1) = 1\n", p;
    end if;
  end for;
  if ShowCertificate then
    "";
  end if;
 
  // Conclusion
  if ShowCertificate then
    printf "Therefore, N=%o is prime.\n\n", N;
  end if;

  return true, pd join {N};
end function;


function PrimeCertificateNm1Recursive(Cur, pd, ShowCertificate, Trust)

  if debug then
    printf "PrimeCertificateNm1Recursive\n";
    print Cur;
    print pd;
  end if;

 /* Checking arguments
  *********************/
 if Type(Cur) ne List then return ferr(pd); end if;
 if Type(Cur[1]) ne RngIntElt then return ferr(pd); end if;
 if Type(Cur[2]) ne RngIntElt then return ferr(pd); end if;
 N := Cur[1]; X := Cur[2];

 if N le Trust then
  pd join:= {N};
  return true, pd;
 end if;

 if N in pd then
   return true, pd;
 end if;

 /* Is N is equal to 2 ?
  ***********************/
 if (N eq 2) and (X eq 1) then
    if ShowCertificate then
      ProofHeader(N);
     "";
     "One can easily check that the only divisors of 2 are 1 and 2.";
     "";
     "Therefore, 2 is prime.";
     "";
    end if;
   return true, pd join {2};
 end if;

 /* Otherwise N > 2
  *****************/
 if #Cur ne 3 then return ferr(pd); end if;
 for i := #Cur[3] to 1 by -1 do
  ret, pd := PrimeCertificateNm1Recursive(Cur[3][i], pd, ShowCertificate, Trust);
  if ret eq false then
   return false, pd;
  end if;
 end for; 
 
 Nm1fact := [**]; Xlist := [**]; Nm1 := N - 1;
 for i := #Cur[3] to 1 by -1 do
  if Type(Cur[3]) ne List then return ferr(pd); end if;
  if Type(Cur[3][i]) ne  List then return ferr(pd); end if;
  if Type(Cur[3][i][1]) ne RngIntElt then return ferr(pd); end if;
  p := Cur[3][i][1]; e := 0;
  while (Nm1 mod p) eq 0 do
   e := e+1;
   Nm1 := Nm1 div p;
  end while;
  Nm1fact[#Cur[3]-i+1] := [* p, e *];
  Xlist[#Cur[3]-i+1] := X;
 end for; 
 
  Cur := [* N, -1, 1, Nm1fact, Xlist *];
  ans, pd := TheoremNm1(ShowCertificate, N, Nm1fact, Xlist, pd, Trust);
  return ans, pd;
end function;


function PrimeCertificateNm1(Cur, pd, ShowCertificate, Trust)

  if debug then
    printf "PrimeCertificateNm1\n";
    print Cur;
    print pd;
  end if;


 /* Checking arguments
  *********************/
 if (Type(Cur) ne List) or (#Cur ne 5) then return ferr(pd); end if;
 if Type(Cur[1]) ne RngIntElt then return ferr(pd); end if;
 if Type(Cur[2]) ne RngIntElt then return ferr(pd); end if;
 if Type(Cur[3]) ne RngIntElt then return ferr(pd); end if;
 if Type(Cur[4]) ne List then return ferr(pd); end if;
 for f in Cur[4] do
  if Type(f) ne List then return ferr(pd); end if;
  if #f ne 2 then return ferr(pd); end if;
  if Type(f[1]) ne RngIntElt then return ferr(pd); end if;
  if Type(f[2]) ne RngIntElt then return ferr(pd); end if;
 end for;
 if Type(Cur[5]) ne List then return ferr(pd); end if;
 if (#Cur[5] ne #Cur[4]) and (#Cur[5] ne #Cur[4]+1) then return ferr(pd); end if;
 for f in Cur[5] do
  if Type(f) ne RngIntElt then return ferr(pd); end if;
 end for;
 N := Cur[1]; Nm1fact := Cur[4]; Xlist := Cur[5];

  if N le Trust then
    pd join:= {N};
    return true, pd;
  end if;

  /* if primes in factorization have not been proved, prove them */
  for f in Nm1fact do
    if (f[1] gt Trust) and not (f[1] in pd) then
      if debug then
        printf "Certificate for %o has not been provided, make one\n",f[1];
      end if;
      ret, pd := ProvePrime(f[1], pd, ShowCertificate, Trust); 
      if ret eq false then
        return false, pd;
      end if;
    end if;
  end for;

  ans, pd := TheoremNm1(ShowCertificate, N, Nm1fact, Xlist, pd, Trust);
  return ans, pd;
end function;


/* 
 * N - 1 easy stuf
 ****************/

procedure PrintThNm1Easy(N)
    ProofHeader(N);
    "";
    "We are going to use the following theorem:";
    "";
    "Theorem 1:";
    "  Let N - 1 =  m*p where p is an odd prime such that 2*p+1 > sqrt(N).";
    "  If there exists an integer a such that ";
    "    1. a^((N - 1)/2) = -1 mod N, and ";
    "    2. a^(m/2) <> -1 mod N";
    "  then N is prime.";
    "";
end procedure;


function PrimeCertificateNm1Easy(Cur, pd, ShowCertificate, Trust)

  if debug then
    printf "PrimeCertificateNm1Easy\n";
    print Cur;
    print pd;
  end if;

 // Check arguments
 if (Type(Cur) ne List) or (#Cur ne 5) then return ferr(pd); end if;
 if Type(Cur[1]) ne RngIntElt then return ferr(pd); end if;
 if Type(Cur[2]) ne RngIntElt then return ferr(pd); end if;
 if Type(Cur[3]) ne RngIntElt then return ferr(pd); end if;
 if Type(Cur[4]) ne List then return ferr(pd); end if;
 for f in Cur[4] do
   if Type(f) ne List then return ferr(pd); end if;
   if #f ne 2 then return ferr(pd); end if;
   if Type(f[1]) ne RngIntElt then return ferr(pd); end if;
   if Type(f[2]) ne RngIntElt then return ferr(pd); end if;
 end for;
 if Type(Cur[5]) ne List then return ferr(pd); end if;
 if #Cur[5] ne 1 then return ferr(pd); end if;
 if Type(Cur[5][1]) ne RngIntElt then return ferr(pd); end if;
 N := Cur[1]; Nm1fact := Cur[4]; a := Cur[5][1];

 if N le Trust then
   pd join:= {N};
   return true, pd;
 end if;

 // Check that the factorization of N - 1 is good 
 Nm1 := N - 1; 
 m := 1;
 for f in Nm1fact do
   if Nm1 mod f[1]^f[2] ne 0 then
     if ShowCertificate then
       "The factorization of N - 1 is not what is in the certificate.";
     end if;
     return false, pd;
   end if;
   Nm1 := Nm1 div (f[1]^f[2]);
   m *:= f[1]^f[2];
 end for;
 val, b, _ := IsPower(Nm1);  // Needed for p=42437
 if val then
   Np := b;
   m := Nm1 div Np;
 else
   Np := Nm1;
 end if;

 // if prime has not been proved, prove it
 if (Np gt Trust) and not (Np in pd) then
   if debug then
     printf "Certificate for %o has not been provided, make one\n",Np;
   end if;
   ret, pd := ProvePrime(Np, pd, ShowCertificate, Trust); 
   if ret eq false then
     return false, pd;
   end if;
 end if;

 // Print the theorem 
 if ShowCertificate then
   PrintThNm1Easy(N);

   "Here:";
   printf "  N - 1 = %o * %o\n",m,Np;
   printf "  It was already proved that p=%o is a prime.\n",Np;
 end if;

 // Check that 2p+1 > sqrt(N)
 if 2*Np+1 le Sqrt(N) then
  if ShowCertificate then
    "2 *", Np, "+1 <= sqrt(N).";
  end if;
  return false, pd;
 end if;
 if ShowCertificate then
   printf "  2*p+1 = %o > sqrt(N) = %o\n\n",2*Np+1,Sqrt(N);
   printf "Let a := %o\n\nThen:\n\n",a;
 end if;


 // Check that a^((N - 1)/2) <> -1 mod N
 b2 := Modexp(a, (N - 1) div 2, N);
 if b2 ne (-1 mod N) then
   if ShowCertificate then
     a, "^((N - 1)/2) = -1 mod N.";
   end if;
   return false, pd;
 end if;
 if ShowCertificate then
   "  a^((N - 1)/2) = -1 mod N";
 end if;

 // Check that a^(m/2) <> -1 mod N
 b1 := Modexp(a, m div 2, N);
 if b1 eq (-1 mod N) then
   if ShowCertificate then
     a, "^(m/2) = -1.";
   end if;
   return false, pd;
 end if;
 if ShowCertificate then
   printf "  a^(m/2) = %o mod N\n",b1;
 end if;

 // Conclusion
 if ShowCertificate then
   "";
    printf "Therefore, N=%o is prime.\n",N;
   "";
 end if;

 return true, pd join {N};
end function;

/* 
 * N + 1 stuf
 ****************************************************************************/

procedure PrintThNp1(N)
    ProofHeader(N);
 "";
 "We are going to use the following theorem:";
 "";
 "Theorem 3 (paper from H. Cohen and A. K. Lenstra):";
 "  If N + 1 =  q1^b1 ... qk^bk and let A be the ring defined by";
 "  (Z/NZ)[T]/(T^2-u*T-a) where u and a are such that";
 "        a is prime, a^((N - 1)/2) = -1 mod N and u = 0 if N = 1 mod 4";
 "  and such that";
 "        a = 1 and (u^2+4)^((N - 1)/2) = -1 if N = 3 mod 4.";
 "  Then N is a prime if, for each qi, there exists an element Xi of norm 1";
 "  in A such that Xi^((N + 1)/qi) - 1 = xi0 + T xi1 <> 1, Xi^(N + 1) = 1 and";
 "  GCD(xi{0, 1}, N) = 1 where xi{0, 1} <> 0.";
 "";
 "Here:\n";
end procedure;


function PrimeCertificateNp1(Cur, pd, ShowCertificate, Trust)

  if debug then
    printf "PrimeCertificateNp1\n";
    printf "%o\n",Cur;
    printf "pd=%o\n",pd;
  end if;
 
 /* Checking arguments
  ***********************************/
 if (Type(Cur) ne List) or (#Cur ne 6) then return ferr(pd); end if;
 if Type(Cur[1]) ne RngIntElt then return ferr(pd); end if;
 if Type(Cur[2]) ne RngIntElt then return ferr(pd); end if;
 if Type(Cur[3]) ne RngIntElt then return ferr(pd); end if;
 if Type(Cur[4]) ne List then return ferr(pd); end if;
 for f in Cur[4] do
  if Type(f) ne List then return ferr(pd); end if;
  if #f ne 2 then return ferr(pd); end if;
  if Type(f[1]) ne RngIntElt then return ferr(pd); end if;
  if Type(f[2]) ne RngIntElt then return ferr(pd); end if;
 end for;
 if Type(Cur[5]) ne RngIntElt then return ferr(pd); end if;
 if Type(Cur[6]) ne List then return ferr(pd); end if;
 for f in Cur[6] do
  if Type(f) ne RngIntElt then return ferr(pd); end if;
 end for;
 if #Cur[6] ne #Cur[4]+1 then return ferr(pd); end if;
 N := Cur[1]; Np1factL := Cur[4]; a := Cur[5]; u := a; mlist := Cur[6];

  // Convert list Np1factL to sequence Np1fact
  Np1fact := [];
  for f in Np1factL do
    Append(~Np1fact, f);
  end for;
 
  // Check that the factorization of N + 1 is good
  Np1 := N + 1; 
  for f in Np1fact do
    if Np1 mod f[1]^f[2] ne 0 then
      if ShowCertificate then
        "The factorization of N + 1 is not what is in the certificate.";
      end if;
     return false, pd;
    end if;
    Np1 := Np1 div (f[1]^f[2]);
  end for;
  // Place Np1 at head of Np1fact 
  Insert(~Np1fact, 1, [* Np1, 1 *]);
 
  // if primes in factorization have not been proved, prove them 
  for f in Np1fact do
    if (f[1] gt Trust) and not (f[1] in pd) then
      if debug then
        printf "Certificate for %o has not been provided, make one\n",f[1];
      end if;
      ret, pd := ProvePrime(f[1], pd, ShowCertificate, Trust); 
      if ret eq false then
        return false, pd;
      end if;
    end if;
  end for;

  // if N mod 4 eq 1 then make sure a is a prime
  if N mod 4 eq 1 then
    if (a gt Trust) and not (a in pd) then
      if debug then
        printf "a= %o not shown to be prime.  Proving it.\n", a;
      end if;
      ret, pd := ProvePrime(a, pd, ShowCertificate, Trust);
      if ret eq false then
        return false, pd;
      end if;
    end if;
  end if;


  // Print the theorem
  if ShowCertificate then
    PrintThNp1(N);

    printf "  N + 1 = ";
    for i := 1 to #Np1fact do
      f := Np1fact[#Np1fact-i+1];
      if i eq 1 then
        if f[2] eq 1 then
          printf "%o", f[1];
        else
          printf "%o^%o", f[1], f[2];
        end if;
      else
        if f[2] eq 1 then
          printf " * %o", f[1];
        else
          printf " * %o^%o", f[1], f[2];
        end if;
      end if;
    end for;
    printf ".\n";

    for i := 1 to #Np1fact do
      f := Np1fact[#Np1fact-i+1];
      if f[1] le Trust then
        "  It is believed that", f[1], "is a prime.";
      elif f[1] in pd then
        "  It was already proved that", f[1], "is a prime.";
      else  // should never get here
        "  It was NOT already proved that", f[1], "is a prime";
        return false, pd;
      end if;
    end for;
  end if;


 /* Checking conditions on u and a
  **********************************/
 if ShowCertificate then
   printf "\n";
 end if;
 if N mod 4 eq 1 then
   u := 0;
   if ShowCertificate then
     "  N mod 4 = 1, so a =", a, "and u = ", u, ".";
   end if;
   if a le Trust then
     if ShowCertificate then
       "  It is believed that a is a prime.";
     end if;
   elif a in pd then
     if ShowCertificate then
       "  It was already proved that a is a prime.";
     end if;
   else // should never get here
     if ShowCertificate then
       "  It was NOT already proved that a is a prime";
     end if;
     return false, pd;
   end if;
   b := Modexp(a, (N - 1) div 2, N);
   if b ne (-1 mod N) then
     if ShowCertificate then
       "Aie!! a ^((N - 1)/2) =", b, ".";
       "So, I give up.";
     end if;
     return false, pd;
   end if;
 else
   a := 1; 
   if ShowCertificate then
     "  N mod 4 = 3, so a =", a, "and u = ", u, ".";
   end if;
   b := Modexp(u^2+4, (N - 1) div 2, N);
   if b ne (-1 mod N) then
     if ShowCertificate then
       "Aie!! (u^2+4)^((N - 1)/2) =", b, ".";
        "So, I give up.";
     end if;
     return false, pd;
   end if;
 end if;
 if ShowCertificate then
   printf "\nThen:\n\n";
 end if;

 /* Checking the conditions of the theorem
  ******************************************/
 Rg := GF(N);
 A<T> := ExtensionField<Rg, X | X^2-u*X-a>;
 for i:= #mlist to 1 by -1 do
   m := mlist[i];
   p := Np1fact[i][1];
   if debug then
     printf "T+m= %o\n",T+m;
     printf "u-T+m= %o\n",u-T+m;
   end if;
   X := (T+m) / (u-T+m);
   if ShowCertificate then
     printf "  X_%o = %o.\n", p, X;
   end if;
   if Norm(X) ne A!1 then
     if ShowCertificate then
       printf "Aie!! Norm(X_%o) = %o.", p, Norm(X);
       "So, I give up.";
     end if;
     return false, pd;
   end if;
   x := X^((N + 1) div p);
   if x eq A!1 then
     if ShowCertificate then
       printf "Aie!! X_%o^((N + 1)/2) = 1.", p;
       "So, I give up.";
     end if;
     return false, pd;
   end if;
   if Eltseq(x)[1] ne Rg!0 then
    idx := 1;
   else
    idx := 2;
   end if;
   if GCD(IntegerRing()!Eltseq(x)[idx], N) ne 1 then
     if ShowCertificate then
       printf "Aie!! GCD(X_%o.%o,N) = %o", p, idx, GCD(IntegerRing()!Eltseq(x)[idx], N);
       "So, I give up.";
     end if;
     return false, pd;
   end if;
   x := x^p;
   if x ne A!1 then
     if ShowCertificate then
       printf "Aie!! X_%o^(N + 1) <> 1.", p;
       "So, I give up.";
     end if;
     return false, pd;
   end if;
   if ShowCertificate then
     printf "  Norm(X_%o) = 1,  X_%o^((N + 1)/%o) = %o, X_%o^(N + 1) = 1, GCD(X_%o.%o, N) = 1.\n", p, p, p, x, p, p, idx;
   end if;
 end for;

  // Conclusion
  if ShowCertificate then
    "";
    printf "Therefore, N is prime.\n";
    "";
  end if;

 return true, pd join {N};
end function;

/* 
 * ECPP stuf
 ****************************************************************************/

procedure PrintECPP(N)
    ProofHeader(N);
 "";
 "We are going to use the following theorem:";
 "";
 "Theorem 4:";
 "Let N be an integer greater than 1 and prime to 6. Let E be an";
 "elliptic curve over Z/NZ, m and s two integers such that s divides";
 "m. Suppose we have found a point P on E that satisfies mP = O_E, and";
 "that for each prime factor q of s, we have verified that (m/q)P <> O_E.";
 "If s > (sqrt[4](N)+1)^2, then N is prime.";
 "";
 "Here:";
end procedure;


function PrimeCertificateECPP(Cur, pd, ShowCertificate, Trust)
 
 /* Checking arguments
  ***********************************/
 if (Type(Cur) ne List) or (#Cur ne 7) then return ferr(pd); end if;
 if Type(Cur[1]) ne RngIntElt then return ferr(pd); end if;
 if Type(Cur[2]) ne RngIntElt then return ferr(pd); end if;
 if Type(Cur[3]) ne RngIntElt then return ferr(pd); end if;
 if Type(Cur[4]) ne RngIntElt then return ferr(pd); end if;
 if Type(Cur[5]) ne List then return ferr(pd); end if;
 if #Cur[5] ne 2 then  return ferr(pd); end if;
 for f in Cur[5] do
  if Type(f) ne RngIntElt then return ferr(pd); end if;
 end for;
 if Type(Cur[6]) ne List then return ferr(pd); end if;
 if #Cur[6] ne 3 then  return ferr(pd); end if;
 for f in Cur[6] do
  if Type(f) ne RngIntElt then return ferr(pd); end if;
 end for;
 if Type(Cur[7]) ne List then return ferr(pd); end if;
 for f in Cur[7] do
  if Type(f) ne List then return ferr(pd); end if;
  if #f ne 2 then return ferr(pd); end if;
  if Type(f[1]) ne RngIntElt then return ferr(pd); end if;
  if Type(f[2]) ne RngIntElt then return ferr(pd); end if;
 end for;
 N := Cur[1]; D := Cur[2];
 m := Cur[4]; E := Cur[5]; P := Cur[6]; mfact := Cur[7];

  for f in mfact do
    if (f[1] gt Trust) and not (f[1] in pd) then
      if debug then
        printf "Certificate for %o has not been provided, make one\n",f[1];
      end if;
      ret, pd := ProvePrime(f[1], pd, ShowCertificate, Trust); 
      if ret eq false then
        return false, pd;
      end if;
    end if;
  end for;

 /* Printing the theorem used 
  ****************************/
 if ShowCertificate then
   PrintECPP(N);
 end if;

 /* Building the elliptic curve
  ******************************/
 Rg := GF(N);
 ret, Ec := IsEllipticCurve([Rg!E[1], Rg!E[2]]);
 if ret eq false then
   if ShowCertificate then
   "Aie!! The proposed curve is not an elliptic curve.";
   "So, I give up";
   end if;
   return(false, pd);
 end if;
 if ShowCertificate then
   "  E : Y^2 = X^3 +", Rg!E[1], "* X + ", Rg!E[2], ".";
 end if;
	
 /* Checking that the point P is really on the curve
  ***************************************************/
 Pt := Ec ! [P[1], P[2]];
 if IsPoint(Ec, [P[1], P[2], 1]) then
  if ShowCertificate then
    "  P = ", Pt, ".";
  end if;
 else
   if ShowCertificate then
     "Aie!! The proposed point is not on the elliptic curve.";
     "So, I give up";
   end if;
   return(false, pd);
 end if;

  // Make sure ord(P) divides m
  if m*Pt ne Ec!0 then
    if ShowCertificate then
      "Aie!! The proposed order", m, "of P is not the good one.";
      "So, I give up";
    end if;
    return(false, pd);
  end if;
  // Find ord(P), set new m to ord(P) 
  c := m;
  s := 1;
  for f in mfact do
    if (c mod f[1]^f[2]) ne 0 then
      "Aie!! The factorization of m is not what is in the certificate.";
      "So, I give up.";
      return false, pd;
    end if;
    c div:= f[1]^f[2];
    s *:= f[1]^f[2];
  end for;
  m := s;
  if c gt 1 then
    fact := Factorization(c);
    for f in fact do
      while ((c mod f[1]) eq 0) and (((f[1] * m) * Pt) ne Ec!0) do
        m *:= f[1];
        c div:= f[1];
      end while; 
    end for;
  end if;

   if ShowCertificate then
     "  m * P =", m, "* P =", Ec!0, ".";
   end if;
 /* Checking that the factorization of m works
  *********************************************/
 c := m; s := 1;
 for f in mfact do
   if (c mod f[1]^f[2]) ne 0 then
    "Aie!! The factorization of m is not what is in the certificate.";
    "So, I give up.";
    return false, pd;
   end if;
   p := f[1];
   e := f[2];
   c div:= f[1]^f[2];
   s *:= f[1]^f[2];
 end for;
 if ShowCertificate then
   printf "  m := c*s where c = %o and s = ", c;
 end if;
 if ShowCertificate then
   for i := 1 to #mfact do
     f := mfact[i];
     if i eq 1 then
       if f[2] eq 1 then
         printf "%o", f[1];
       else
         printf "%o^%o", f[1], f[2];
       end if;
     else
       if f[2] eq 1 then
         printf " * %o", f[1];
       else 
         printf " * %o^%o", f[1], f[2];
       end if;
     end if;
   end for;
   printf ".\n";
 end if;
 for f in mfact do
   if f[1] le Trust then
     if ShowCertificate then
       "  It is believed that q = ", f[1], "is a prime.";
     end if;
   elif f[1] in pd then
     if ShowCertificate then
        "  It was already proved that q = ", f[1], "is a prime.";
     end if;
   else  // should never get here
     if ShowCertificate then
       "  It was NOT already proved that q = ", f[1], "is a prime";
     end if;
     return false, pd;
   end if;
   Rt := (m div f[1])*Pt;
   if Rt ne Ec ! 0 then
     if ShowCertificate then
       "  (m/q)*P =", Rt, ".";
     end if;
   else
     if ShowCertificate then
       "Aie!! (m/q)*P = O.";
       "So, I give up.";
     end if;
     return false, pd;
   end if;
 end for;


 /* Checking that s > (sqrt[4](N)+1)^2
  **************************************/
 if s gt (Sqrt(Sqrt(N))+1)^2 then
   if ShowCertificate then
     "  s > (sqrt[4](N)+1)^2 =", (Sqrt(Sqrt(N))+1)^2, ".";
   end if;
 else
   if ShowCertificate then
     "Aie!! s <= (sqrt[4](N)+1)^2 =", (Sqrt(Sqrt(N))+1)^2, ".";
     "So, I give up.";
    end if;
    return false, pd;
 end if;

 /* Conclusion
  *************/
  if ShowCertificate then
    "";
    printf "Therefore, N is prime.\n";
    "";
  end if;

 return true, pd join {N};
end function;


function ProvePrime(p, pd, ShowCertificate, Trust)
  cert := PrimalityCertificate(p);
  for i:=#cert to 1 by -1 do
    c := cert[i];
    case c[2]:
      when -1:
        case c[3]:
          when 0:
            ret, pd := PrimeCertificateNm1Recursive(c[4], pd, ShowCertificate, Trust);
          when 1:
            ret, pd := PrimeCertificateNm1(c, pd, ShowCertificate, Trust);
          when 3:
            ret, pd := PrimeCertificateNm1Easy(c, pd, ShowCertificate, Trust);
          else
            "error1 - unidentified type";
            exit;
        end case
      when 1:
        ret, pd := PrimeCertificateNp1(c, pd, ShowCertificate, Trust);
      else
        ret, pd := PrimeCertificateECPP(c, pd, ShowCertificate, Trust);
    end case;
    if ret eq false then
      return false, pd;
    end if;
  end for;
  return ret, pd;
end function;

/*
 * The main procedure
 *****************************************************************************/
// Check certificate Ce
intrinsic IsPrimeCertificate(Ce::List : ShowCertificate:=false, Trust:=0) -> BoolElt
{ Returns true or false depending whether c is a valid primality certificate 
  (as generated by c := PrimalityCertificate(p) where p is a prime).  If 
  ShowCertificate is set to true, an explanation of the certificate is printed.  
  If Trust is set to a positive integer, all primes less that Trust will
  be believed prime and will not be checked.}

N := 0; pd := {}; 
for i := #Ce to 1 by -1 do
  Cur := Ce[i]; // i, "-th certificates";
  Np := N;
  N := Cur[1]; type := Cur[2]; th := Cur[3];
  if debug then
    printf "N= %o  type= %o  th= %o\n",N,type,th;
  end if;
  case type:
    when -1:  // minus1
      case th:
        when 0:
          // Smallest example p=2
          if (Type(Cur) ne List) or (#Cur ne 4) then 
            return ferr(pd); 
          end if;
          if (Type(Cur[4]) ne List) then 
            return ferr(pd); 
          end if;
          ret, pd := PrimeCertificateNm1Recursive(Cur[4], pd, ShowCertificate, Trust);
        when 1:
          // Smallest example p=101
          ret, pd := PrimeCertificateNm1(Cur, pd, ShowCertificate, Trust);
        when 3:
          // Smallest example p=227
          ret, pd := PrimeCertificateNm1Easy(Cur, pd, ShowCertificate, Trust);
        else
          "Aie!! This certificate is not a certificate I am able to understand.";
          ret = false;
      end case; // plus1
    when 1:
      // Smallest example p=201520967
      ret, pd := PrimeCertificateNp1(Cur, pd, ShowCertificate, Trust);
    else // elliptic curve
      // Small example p= 100000000951
      ret, pd := PrimeCertificateECPP(Cur, pd, ShowCertificate, Trust);
  end case;
  if ret eq false then
    return false, pd;
  end if;
  pd := {N} join pd;
end for;
return true;
end intrinsic;

// ***** Test code **********************************

//p := 100000000951;
//p := 6228201295465871;
//p := 50969958305565443;
//p := 1000000000000000014797;
//c := PrimalityCertificate(p);
//c;
//IsPrimeCertificate(c: ShowCertificate := true, Trust := 10^4);

//p := NextPrime(10^10: Proof := false);
//while true do
//  p := NextPrime(p);
//  p;
//  c := PrimalityCertificate(p);
//  val := IsPrimeCertificate(c : Trust:=201520967);
//  if val eq false then
//    exit;
//  end if;
//end while;


