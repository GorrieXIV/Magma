freeze;

/*
  <example>
    K := CyclotomicField(5);
    S := [Random(K, 3) : x in [1..40]];
    p := Position(S, 0);
    while p ne 0 do
      Remove(~S, p);
      p := Position(S, 0);
    end while;
    U, mU := MultiplicativeGroup(S);
    [ x@@ mU : x in S];

    Q, mQ := SUnitGroup(2*3*5*MaximalOrder(K));
    S := [<Q!x, mQ(x)> where x := [Random(5) : i in [1..Ngens(Q)]] : j in [1..30]];
    U, mU := MultiplicativeGroup(S);
  </example>
*/
ErrorOnFail := false;

/*
 Plan:
   given elements in the field, construct the group generated by them.
 This should be done step-by-step:
   find the CorpimeBasis (Support) for all elements involved
   find the relations between the 1st 2 elts
     then add the 3rd, ...
   in an attempt to keep the matrices for the LLL managable.
   
   relations:
     build matrix with (pseudo) valuations
     find relations (HNF over Z)
     this gives units (=kernel)
     for the units, compute p-adic embeddings and their logs
     compute p-adic kernel
     LLL (over Z) on the kernel to find relations between units
     each relation defines a torsion unit
     find group generated by that
    
*/     


declare attributes GrpAb: FldNum, Type;
declare verbose GrpMult, 3;

FldNum_fmt := recformat<Base : SeqEnum, // Elements generating the subgroup
                        Support : SeqEnum, // the support, not nec. prime ideals
                        Valuation : Assoc, // "valuation" for the support
                        pAdic : SeqEnum, // p-adic mebeddigs for the logs
                        valMat : Mtrx, // matrix with the vals of Base at Sup
                        logMat : Mtrx, // p-adic logs of Base
                        torMat : Mtrx, // finite field logs
                        torP   : RngOrdIdl,
                        tor    : RngIntElt,
                        mU     : Map  ,
                        M, N, MN : Mtrx
                          >;
FldNum_type := "MultSubGrp of FldNum";

intrinsic InternalNewPowerProduct(S::[FldAlgElt], X::[RngIntElt]:FldNum := false) -> FldAlgElt
  {}
  //plan:
  //  compute the size of the conjugates of this element
  //  from there, get a bound of the coefficients
  //  or, maybe don't do that?
  //  compute power product mod N 
  //  until conjugates are correct and torsion is correct.
  //  Don't compare logs, compare conjugates! (we don't need the logs
  //  as we only do comparison)

  // Very important
  inds := [i : i in [1..#X] | X[i] ne 0];
  X := X[inds];
  S := S[inds];

  // No idea why a nontrivial algorithm should be used in this context?
  // Anyhow, at least handle easy cases easily.
  // SRD, July 2014
  if X eq [1] then
    return S[1];
  elif &+[Abs(x) : x in X] le 100 then  // TO DO: crossover criterion
    return PowerProduct(S, X);
  end if;
  
  p := 2^20;
  Z := Integers();
  K := Universe(S);
  if assigned K`MaximalOrder then
    F := FieldOfFractions(MaximalOrder(K));
  else
    F := FieldOfFractions(GeneralisedEquationOrder(K));
  end if;
  S_Z := {Z|Norm(x*d)*d where d := Denominator(F!x) : x in S};
  p_res := Matrix(CoefficientRing(FldNum`logMat), [X])*FldNum`logMat;
  den := Matrix([X])*FldNum`valMat;
  den := Eltseq(den);
  den := &* [Z|Minimum(FldNum`Support[i])^-den[i] : i in [1..#den] | den[i] lt 0];
  if Maximum([Abs(x) : x in X]) lt 10 then
    return &* [S[i]^X[i] : i in [1..#X]];
  end if;
  res := false;
  M := MaximalOrder(Universe(S));
  pR := BaseRing(CoefficientRing(p_res));
  repeat
    repeat
      p := NextPrime(p);
    until forall{x : x in S_Z | GCD(x, p) eq 1};
    new :=  M!(den*PowerProduct(ChangeUniverse(S, quo<M|p>), X));
    if res cmpeq false then
      res := new;
      old_p := p;
    else
      res := ChineseRemainderTheorem(old_p*M, p*M, res, new);
      old_p *:= p;
    end if;
    m := Logs([Universe(S)|res/den], pR: Completions := FldNum`pAdic);
    m := [ &cat [Eltseq(x) : x in Eltseq(m)]];
    m := Matrix(CoefficientRing(p_res), m);
//    if Precision(p_res[1][1]) lt Ilog(Prime(pR), old_p) then
//      error "not found";
//    end if;
//    "in power_prod, now at", Ilog2(old_p), "bits";
  until forall{x : x in Eltseq(m-p_res) | IsWeaklyZero(x)};
  return res/den;
end intrinsic;

  function DL(x, data)
    if ErrorOnFail then "DL on ", x; end if;
    P := data`torP;
    _, mP := ResidueClassField(P);
    em := data`pAdic;
    pS := Codomain(em[1]);
    pR := BaseRing(pS);
    p := Integers()!UniformizingElement(pR);

    full_pr := Precision(pR);
    semi_pr := (4*full_pr) div 5;

    K := Domain(em[1]);
    U := Codomain(data`mU);

    gU := [U.i : i in [1..Ngens(U)] | Order(U.i) eq 0];

    lo_x := Log(x@mP);

    m := Logs([x], pR: Completions := em);
    m := [ &cat [Eltseq(x) : x in Eltseq(m)]];
    m := VerticalJoin(data`M, 
      HorizontalJoin(Matrix([[Integers()|data`Valuation[p](x) : p in data`Support]]), 
      Matrix(Integers(), m)));
    m := VerticalJoin(m, HorizontalJoin(ZeroMatrix(Integers(), Degree(K)*Degree(pS), #data`Support), DiagonalMatrix([p^semi_pr : i in [1..Degree(K)*Degree(pS)]])));
//    "m:", m;
    k := KernelMatrix(m);
//    "k:", k;
    k := Submatrix(k, 1, 1, Nrows(k), #gU+1);
    
    k := VerticalJoin(k, DiagonalMatrix([p^semi_pr : i in [1..Ncols(k)]]));
    l := LLL(k);
//    "l:", l;
    f := exists(x){x : x in [1..Nrows(l)] | l[x][#gU+1] in {1, -1}};
    if not f then
      error if ErrorOnFail, "fail 1"; 
      return false;
    end if;
    u := -l[x][#gU+1]* &+ [U| gU[i]*l[x][i] : i in [1..#gU]];
    R := Integers(Norm(P)-1);
    if #TorsionSubgroup(U) eq 1 then
      ss := -l[x][#gU+1]*Matrix([Eltseq(l[x])[1..#gU]])*data`MN;
      if (ss[1][1]-  lo_x) mod (Norm(P)-1) ne 0 then
//        ss, lo_x, Norm(P);
        error if ErrorOnFail, "fail 2"; 
        return false;
      end if;
      return u;
    end if;
    ss := Matrix([Eltseq(l[x])[1..#gU]])*data`MN;
    ss := -l[x][#gU+1]*ss;
    ss := ss - Matrix([[lo_x]]);
    fl, ss := IsConsistent(Matrix(R, data`N), Matrix(R,  ss));
    if not fl then
      error if ErrorOnFail, "fail 3"; 
      return false;
    end if;
    ss := Matrix(Integers(), ss);
    u +:= -ss[1][1]*U.1;
    return u;
  end function;

intrinsic ShowDL(S::GrpAb, x::FldAlgElt) -> .
  {}
  return DL(x, S`FldNum);
end intrinsic;

intrinsic MultiplicativeGroup(S::[FldAlgElt] : s := false, full_pr := 100, prime_degree_bound := 0) -> GrpAb, Map
  {The abelian group generated by the elements in S}

  require IsAbsoluteField(NumberField(Universe(S))) :
    "Not implemented for relative extensions";

//  "MultiplicativeGroup", S;
  semi_pr := (4*full_pr) div 5;

  data := rec<FldNum_fmt|>;
  data`Base := S;

  R := MaximalOrder(Universe(S));
  FR := FieldOfFractions(R);
  K := NumberField(R);
  if s cmpeq false then
    s := CoprimeBasis([x*R : x in S]);
  end if;
//  "CoprimeBasis", [IsPrime(x) : x in s];
//  [Support(x) : x in s];
  s_pe := AssociativeArray(Universe(s));
  for p in s do
    if IsPrime(p) then
      s_pe[p] := func<x|Valuation(FR!x, p)>;
    else
      // Magma currently does not allow TwoElementNormal for fractional ideals
      // so we do it ourselves...
      a,b := TwoElementNormal(p);
      b := b^-1;
      d := Denominator(b);
      a := Integers()!a;
      repeat
        g := GCD(a, d);
        d div:= g;
      until g eq 1;
      b *:= d;
      assert 1*R+b*R eq p^-1;  // at this point <1, b> is the normal form for p^-1
      v := function(x)
        x := FR!x;
        v := -1;
        repeat
          x *:= b; 
          v +:= 1;
        until Denominator(x) ne 1;
        return v;
      end function;
      s_pe[p] := func<x|d eq 1 select v(x) 
                          else v(d*x) - v(d) where d := Denominator(FR!x)>;
    end if;
  end for;

  data`Support := s;
  data`Valuation := s_pe; 

  sP := {Minimum(p) : p in s};

  if #s ne 0 then
    m := Matrix([[s_pe[p](x) : p in s] : x in S]);
  else
    m := Matrix(Integers(), #S, 0, []);
  end if;
  data`valMat := m;

  Z := Integers();
  if Type(K) eq FldCyc then
    d := Conductor(K);
  else
    if IsTotallyComplex(K) then
      if assigned K`MaximalOrder then
        fl := MaximalAbelianSubfield(K:Conductor := Discriminant(MaximalOrder(K)));
      else
        fl := MaximalAbelianSubfield(K);
      end if;
      ZZ := Order(Conductor(fl));
      f, c := IsPrincipal(Conductor(fl));
      assert f;
      c := Integers()!c;
      c := Abs(c);
    else
      c := 1;
      ZZ := ext<Z|Polynomial([0,1])>;
    end if;
    d := 1;
    for i in Factorisation(c) do
      j := 1;
      while j le i[2] and AbelianExtension(ZZ*i[1]^j, [1]) subset fl do
        j +:= 1;
        d *:= i[1];
      end while;
    end for;
  end if;

  if IsOdd(d) then 
    tor := 2*d; 
  else 
    tor := d; 
  end if;
  data`tor := tor;

  if prime_degree_bound gt 0 then
    d := prime_degree_bound;
  else
    d := Maximum(2, Degree(K)/4); // TO DO
  end if;
  p := 1000;
  repeat
    p := NextPrime(p);
    if IsSimple(K) then
      lf := Factorisation(Polynomial(GF(p), DefiningPolynomial(K)));
    else
      lf := &cat [Factorisation(Polynomial(GF(p), f)) 
                                    : f in DefiningPolynomial(K)];
    end if;
  until not p in sP and 
        (p-1) mod tor eq 0 and
        forall{x : x in lf | x[2] eq 1} and 
        LCM([Degree(x[1]) : x in lf]) le d;

  vprintf GrpMult : "Using p = %o\n", p;

  pR := pAdicRing(p, full_pr);

  l, em := Logs(S, pR);
  data`pAdic := em;

  pS := Integers(CoefficientRing(l));
  l := Matrix(pS, l);
  l := [ &cat [Eltseq(l[i][j]) : j in [1..Ncols(l)]] : i in [1..#S]];
  data`logMat := Matrix(l);
  l := Matrix(Integers(), l);

  lP := Decomposition(R, p);
  _, P := Minimum([Degree(x[1]) : x in lP]);
  P := lP[P][1];
  _, mP := ResidueClassField(P);
  lo := Matrix([[Log(x@mP)] : x in S]);
  data`torP := P;
  data`torMat := lo;

  units := KernelMatrix(m);
//  "found", Nrows(units), "units";
//  units := Submatrix(units, 1, 1, Minimum(5, Nrows(units)), Ncols(units));
  // OK, now the work. We add units one-by-one to avoid overly large
  // matrices.
  // We have 
  //  - m: the matrix with valuations
  //  - l: the pAdic logs
  //  - lo: the finite field logs
  //  I the index of the element we are adding in.
  //  R the relations found so far and therefore
  //  U the exponents of the group generators so far.
  R := Matrix(Z, 0, #S, []);
  U := Matrix(Z, 0, #S, []);
  units_l := units*l;
  r := #InfinitePlaces(K)-1;
  for I := 1 to Nrows(units) do
//    "doing", I;
    M := VerticalJoin(U*l, units_l[I]);
    M := VerticalJoin(M, p^semi_pr*IdentityMatrix(Z, Ncols(M)));
    k := KernelMatrix(M);
    k := Submatrix(k, 1, 1, Nrows(k), Nrows(U)+1);
//    "LLL for", I, "on ", Nrows(k), Ncols(k);
    k := LLL(k);
    kk := [&+ [ k[i][j]^2 : j in [1..Ncols(k)]] : i in [1..Nrows(k)]];
    c := [i : i in [1..#kk] | kk[i] ne 0 and kk[i] le p^(full_pr div 2)];
    assert Nrows(U)+1-#c le r;
    assert #c le 1; // we add 1 unit to a free group, so
                    // either we get a new unit (c=0) or one
                    // relation.
    if c eq [] then
      U := VerticalJoin(U, units[I]);
    elif Nrows(U) gt 0 then
      U := VerticalJoin(U, units[I]);
      k := Matrix([k[i] : i in c]);
      s, _, B := SmithForm(k);
      U := B^-1*U;
      assert #[i : i in [1..Nrows(s)] | s[i][i] ne 1] eq 0;
      R := VerticalJoin(R, U[1]);
      U := Matrix([U[i] : i in [Nrows(s)+1..Nrows(U)]]);
    else
      R := VerticalJoin(R, units[I]);
    end if;
  end for;
  
  
  R2 := KernelMatrix(Matrix(Integers(Norm(P)-1), R*lo));
  R2 := Matrix(Integers(), R2);
  Rel := R2*R;
  Rel := VerticalJoin(Rel, tor*R);
//  "Creating group with ", Nrows(Rel), "relations";
  A := FreeAbelianGroup(#S);
  U, mU := quo<A|[A!Eltseq(Rel[i]) : i in [1..Nrows(Rel)]]>;
  U`Type := FldNum_type;
  data`mU := mU;

  gU := [U.i : i in [1..Ngens(U)] | Order(U.i) eq 0];
  tU := [U.1];
  if (#gU) eq Ngens(U) then
    noTor := true;
  else
    assert #gU eq Ngens(U)-1;
    assert Order(U.1) ne 0;
    noTor := false;
  end if;

  T := &cat [Eltseq(u @@ mU) : u in tU];
  N := Matrix(Integers(), #S, T)*lo;
  T := &cat [Eltseq(u @@ mU) : u in gU];
  M := Matrix(Integers(), #S, T)*HorizontalJoin(data`valMat, Matrix(Z, data`logMat));
  MN := Matrix(Integers(), #S, T)*lo;
  data`MN := MN;
  data`M := M;
  data`N := N;
  U`FldNum := data;

  return U, map<U -> K | x:-> InternalNewPowerProduct(S, Eltseq(x@@mU):FldNum := data), y:->DL(y, data)>;
 
end intrinsic;

intrinsic ExtendMultiplicativeGroup(mU::Map, A::FldAlgElt:Relation := false) -> GrpAb, Map
  {Extend the multiplicative group by one element}

  U := Domain(mU);
  require U`Type eq FldNum_type :
    "The map must be the one returned from MultiplicativeGroup";

  Z := Integers();  

//  We first need to 1st check if the support set is the same

  data := U`FldNum;

  new_data := rec<FldNum_fmt|>;
  new_data`Base := data`Base cat [A];

  R := MaximalOrder(Universe(data`Base));
  FR := FieldOfFractions(R);
  K := NumberField(R);

  ns := data`Support;
  CoprimeBasisInsert(~ns, R*A);
  if Set(ns) ne Set(data`Support) then
    ns_pe := AssociativeArray(Universe(ns));
    s_pe := data`Valuation;
    for p in ns do
      if IsDefined(s_pe, p) then
        ns_pe[p] := s_pe[p];
      elif IsPrime(p) then
        ns_pe[p] := func<x|Valuation(x, p)>;
      else
        pi := p^-1;
        a,b := TwoElement(pi);
        assert a eq b or a eq 1;
        v := function(x)
          x := FR!x;
          v := -1;
          repeat
            x *:= b; 
            v +:= 1;
          until Denominator(x) ne 1;
          return v;
        end function;
        ns_pe[p] := func<x|d eq 1 select v(x) 
                            else v(d*x) - v(d) where d := Denominator(FR!x)>;
      end if;
    end for;
  else
    ns := data`Support;
    ns_pe := data`Valuation;
  end if;

  new_data`Support := ns;
  new_data`Valuation := ns_pe; 

  sP := {Minimum(p) : p in ns};

  if data`Support eq ns then
    if ns eq [] then
      new_data`valMat := Matrix(Integers(), Nrows(data`valMat)+1, 0, []);
    else
      new_data`valMat := VerticalJoin(data`valMat,
        Matrix([[ns_pe[p](A) : p in ns]]));
    end if;
  else
    new_data`valMat := Matrix([[ns_pe[p](x) : p in ns] : x in new_data`Base]);
  end if;

  tor := data`tor;
  new_data`tor := tor;


  //we assume that the same p-adic logs can be used!

  em := data`pAdic;
  new_data`pAdic := em;
  l := data`logMat;
  pR := BaseRing(CoefficientRing(l));
  p := Integers()!UniformizingElement(pR);
  full_pr := Precision(pR);
  semi_pr := (4*full_pr) div 5;
  if Relation cmpeq false then
    nl := Logs([A], pR:Completions := em);
  else
    nl := Matrix(CoefficientRing(data`logMat), [Eltseq(Relation[2]@@ data`mU)])*data`logMat;
    nl := nl / Relation[1];
//    assert nl eq Matrix(CoefficientRing(nl), Logs([A], pR:Completions := em));
  end if;
  pS := Integers(CoefficientRing(nl));
  nl := Matrix(pS, nl);
  nl := [ &cat [Eltseq(nl[i][j]) : j in [1..Ncols(nl)]] : i in [1]];
  new_data`logMat := VerticalJoin(l, Matrix(nl));
  l := Matrix(Integers(), new_data`logMat);

  P := data`torP;
  _, mP := ResidueClassField(P);
  lo := Matrix([[Log(x@mP)] : x in [A]]);
  new_data`torP := P;
  new_data`torMat := VerticalJoin(data`torMat, lo);
  lo := new_data`torMat;
  S := new_data`Base;

  m := new_data`valMat;
  
  //now, if we have a relation now it's time to use it.
  //Otherwise, we'll have to do as below...
  if Relation cmpne false then
    // Relation is a tuple <n, a> where A^n = a in U
    NU := AbelianGroup(AbelianInvariants(U) cat[0]);
    NU, inj, pro := DirectProduct([U, AbelianGroup([0])]);
//    assert Relation[2]@mU eq A^Relation[1];
    NU, mNU := quo<NU|Eltseq(Relation[2]) cat [-Relation[1]]>;
    new_data`mU := hom<FreeAbelianGroup(#new_data`Base) -> NU | 
      [data`mU(Domain(data`mU).i)@inj[1]@mNU : i in [1..#data`Base]] cat
      [inj[2](Domain(inj[2]).1)@mNU]>;
    NU`Type := FldNum_type;
    function DE(x)
      x := x@@mNU;
      x := Eltseq(x);
      return mU(U!x[1..Ngens(U)]) * A^x[#x];
    end function;
    U := NU;
    mU := new_data`mU;
    inj := inj[1]*mNU;
  else

    units := KernelMatrix(m);
    // OK, now the work. We add units one-by-one to avoid overly large
    // matrices.
    // We have 
    //  - m: the matrix with valuations
    //  - l: the pAdic logs
    //  - lo: the finite field logs
    //  I the index of the element we are adding in.
    //  R the relations found so far and therefore
    //  U the exponents of the group generators so far.
    R := Matrix(Z, 0, #S, []);
    U := Matrix(Z, 0, #S, []);
    units_l := units*l;
    for I := 1 to Nrows(units) do
  //    "doing", I;
      M := VerticalJoin(U*l, units_l[I]);
      M := VerticalJoin(M, p^semi_pr*IdentityMatrix(Z, Ncols(M)));
      k := KernelMatrix(M);
      k := Submatrix(k, 1, 1, Nrows(k), Nrows(U)+1);
  //    "LLL for", I, "on ", Nrows(k), Ncols(k);
      k := LLL(k);
      kk := [&+ [ k[i][j]^2 : j in [1..Ncols(k)]] : i in [1..Nrows(k)]];
      c := [i : i in [1..#kk] | kk[i] ne 0 and kk[i] le p^(full_pr div 2)];
      assert Nrows(U)+1-#c lt #InfinitePlaces(K);
      assert #c le 1; // we add 1 unit to a free group, so
                      // either we get a new unit (c=0) or one
                      // relation.
      if c eq [] then
        U := VerticalJoin(U, units[I]);
      elif Nrows(U) gt 0 then
        U := VerticalJoin(U, units[I]);
        k := Matrix([k[i] : i in c]);
        s, _, B := SmithForm(k);
        U := B^-1*U;
        assert #[i : i in [1..Nrows(s)] | s[i][i] ne 1] eq 0;
        R := VerticalJoin(R, U[1]);
        U := Matrix([U[i] : i in [Nrows(s)+1..Nrows(U)]]);
      else
        R := VerticalJoin(R, units[I]);
      end if;
    end for;
    
    
    R2 := KernelMatrix(Matrix(Integers(Norm(P)-1), R*lo));
    R2 := Matrix(Integers(), R2);
    Rel := R2*R;
    Rel := VerticalJoin(Rel, tor*R);
  //  "Creating group with ", Nrows(Rel), "relations";
    A := FreeAbelianGroup(#S);
    U, mU := quo<A|[A!Eltseq(Rel[i]) : i in [1..Nrows(Rel)]]>;
    U`Type := FldNum_type;
    new_data`mU := mU;
    function DE(x)
      return InternalNewPowerProduct(S, Eltseq(x@@mU):FldNum := new_data);
    end function;
    i := map<a -> Domain(new_data`mU) | [<a.i, A.i> : i in [1..Ngens(A)-1]]> where a := Domain(data`mU);
    inj := Inverse(data`mU)*i*mU;  
  end if;  

  gU := [U.i : i in [1..Ngens(U)] | Order(U.i) eq 0];
  tU := [U.1];
  if (#gU) eq Ngens(U) then
    noTor := true;
  else
    assert #gU eq Ngens(U)-1;
    assert Order(U.1) ne 0;
    noTor := false;
  end if;

  T := &cat [Eltseq(u @@ mU) : u in tU];
  N := Matrix(Integers(), #S, T)*lo;
  T := &cat [Eltseq(u @@ mU) : u in gU];
  M := Matrix(Integers(), #S, T)*HorizontalJoin(new_data`valMat, Matrix(Z, new_data`logMat));
  MN := Matrix(Integers(), #S, T)*lo;
  new_data`MN := MN;
  new_data`M := M;
  new_data`N := N;
  U`FldNum := new_data;

  return U, map<U -> K | x:-> DE(x), y:->DL(y, new_data)>, inj;
 
end intrinsic;


function FindP(a, p)
  //find a prime ideal P such that
  //t^p-a is irreducible mod P
  //(ie: assuming a is not a p-th power, find P such that a is not
  // a p-th power mod P)

  vprint GrpMult, 2: "Finding P for", a, "and", p;

  d_a := Denominator(a);
  a *:= d_a^p;
  M := MaximalOrder(Parent(a));

  q := 100;
  repeat
    q := NextPrime(q);
    vprint GrpMult, 3: "q now", q;
    lq := Decomposition(M, q);
    for P in lq do
      if Norm(P[1]) mod p ne 1 then continue; end if;
      F, mF := ResidueClassField(P[1]);
      ap := mF(a);
      if ap eq 0 then continue; end if;
      if ap^((Norm(P[1])-1) div p) ne 1 then
        return P[1];
      end if;
    end for;
  until false;
end function;


intrinsic IspMaximal(mS::Map, p::RngIntElt) -> BoolElt, FldAlgElt
{Tests is the multiplicative group S is p-maximal. If not, returns an element
in a supergroup of index p}

  S := Domain(mS);
  require S`Type eq FldNum_type :
    "S must be created by MultiplicativeGroup";
  require IsPrime(p) : "p must be prime";

  //Plan: follow Wildanger's Diploma:
  //

  if Ngens(S) lt 1 then return true, _, _; end if;
  
  U := S;
  if Order(S.1) mod p ne 0 then
   U := sub<S|[S.i : i in [2..Ngens(S)]]>;
  end if;
  IsPower := func<a,b|HasRoot(Polynomial([-a] cat [0 : x in [1..b-1]] cat [1]))>;
  while Ngens(U) gt 0 do
    a := S!U.1;
    A := S![x mod p : x in Eltseq(a)];
    a := mS(A);
    //SetKantVerbose("ORDER_ELT_ROOT", 4);
    fl, ap := IsPower(a, p);
    
    if fl then 
      return false, ap, A;
    end if;
    P := FindP(a,p);
    F, mF := ResidueClassField(P);
    iB := [mF(x) : x in S`FldNum`Base];
    ap := mF(a);
    la := Log(ap);
    _, la := XGCD(-la, p);
    ng := [];
    for i in [2..Ngens(U)] do
      b := S!U.i;
      b := S![x mod p : x in Eltseq(b)];
      mb := PowerProduct(iB, Eltseq(b@@S`FldNum`mU));
      lb := Log(mb);
      Append(~ng, lb*la*U.1+U.i);
    end for;
    U := sub<U|ng>;
  end while;
  return true, _, _;
end intrinsic;


intrinsic IsSurjective(h::Map[GrpAb, GrpAb]) -> BoolElt
  {}
  return Image(h) eq Codomain(h);
end intrinsic;


intrinsic Saturate(mS::Map, p::RngIntElt:Confidence:= 5 ) -> Map
{Saturates the group at p - probably}

  S := Domain(mS);
  require S`Type eq FldNum_type :
    "S must be created by MultiplicativeGroup";
  require IsPrime(p) : "p must be prime";

  if Ngens(S) lt 1 then return mS; end if;

  M := MaximalOrder(Parent(S`FldNum`Base[1]));

  if GCD(S`FldNum`tor div #TorsionSubgroup(S), p) ne 1 then
    T, mT := TorsionUnitGroup(M);
    t := TorsionSubgroup(S);
    // both T and t are cyclic. We need to know:
    //  n*T.1 = t.1
    //  thus n := #T div #t;
    //  And n =p^l*d, thus
    //  p^l*(n div p^l) = t.1
    l, d := Valuation(#T div #t, p);
    if Ngens(t) eq 1 then
      g := t.1;
    else
      g := t.0;
    end if;
//<p^l, S!g>;
//(d*T.1)@mT;
    n := Codomain(mS)!((d*T.1)@mT);
    S, mS, e := ExtendMultiplicativeGroup(mS, n:Relation := <p^l, (n^(p^l))@@mS>);
  end if;
 
  bad := Discriminant(NumberField(M));
  IsPower := func<a,b|HasRoot(Polynomial([-a] cat [0 : x in [1..p-1]] cat [1]))>;
  Q := 100;
  repeat
    pS := p*S;
    U := S;
    n0 := Confidence;
    while #quo<U|pS> ge p and n0 gt 0 do
//AbelianInvariants(quo<U|pS>);
      repeat
        Q := NextPrime(Q);
      until Q mod p eq 1 and Gcd(Q, bad) eq 1 and exists{x : x in DecompositionType(M, Q)| x[1] eq 1 or Q^x[1] lt 10000};
      P := Decomposition(M, Q);
      f := exists(P){x : x in P|Degree(x[1]) eq 1 or Norm(x[1]) lt 10000};
      assert f;
    
      F, mF := ResidueClassField(P[1]);
      iB := func<|[mF(x) : x in S`FldNum`Base]>();
      N, mN := MultiplicativeGroup(F);
      q, mq := quo<N|p*N>;
      iB := func<|[x@@mN@mq : x in iB]>();
      h := hom<FreeAbelianGroup(#iB) -> q | iB>;
      k := Kernel(h);
      k := func<|[S`FldNum`mU(x) : x in Generators(k)]>();
      k := sub<S|k>;
      Uk := U meet k;
      if Index(U, Uk) eq 1 then
        n0 -:= 1;
      else
        n0 := Confidence;
      end if;
      U := Uk;
    end while;

    if U eq pS then
      return mS;
    end if;

    q, mq := quo<U|pS>;
    x := func<|[S!(q.i@@mq) : i in [1..Ngens(q)]]>();

//"found new elements", x;
    y := func<|[t@mS : t in x]>();
    Y := [];
    for i in [1..#y] do
      f, s := IsPower(y[i], p);
      if f then
        Append(~Y, <p, x[i], s>);
      else
//"failed on", x[i];
      end if;
    end for;
    for i in [1..#Y] do
//"merging", Y[i];
      S, mS, e := ExtendMultiplicativeGroup(mS, Y[i][3]:Relation := <p, Y[i][2]>);
      Y := func<|[<Y[i][1], Y[i][2]@e, Y[i][3]> : i in [1..#Y]]>();
    end for;
  until false;
end intrinsic;


/*
 D := SmallGroupDatabase();
 G := SmallGroup(8*5, 3);
 C := CharacterTable(G);
 [<i, SchurIndices(C[i])> : i in [1..#C] | C[i][1] gt 1];
 M := GModule(C[10]:SparseCyclo := false, Best);M;
 SetVerbose("Reduce", 2);
 SetVerbose("Cohomology", 2);
 MM := AbsoluteModuleOverMinimalField(M);
 K := Compositum(CoefficientRing(M), CoefficientRing(MM));

 SetVerbose("GrpMult", 3);
 S, mS := SUnitSubGroup(SetToSequence(Support(15*MaximalOrder(K))));
 IspMaximal(mS, 2);

 */

