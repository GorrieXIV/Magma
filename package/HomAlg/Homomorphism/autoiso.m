freeze;

// Jon F, Carlson, June, 2012

import "autofunc.m": AutosModuloRadicalSquared;
import "autofunc.m": AutoMatsOnSocle;
import "autofunc.m": AdditionalAutomorphisms;
import "autofunc.m": AdditionalAutomorphismsWithIdempotents;
import "autofunc.m": TruncationMatrix;
import "autofunc.m": RadicalDimensions;
import "autofunc.m": ExtendHomomorphism;
import "autofunc.m": Least;
import "autofunc.m": LeftInverseMatrix;
import "autofunc.m": ReduceGroupFirst;
// import "autofunc.m": ReduceGroupSecond;
import "autofunc.m": UnipotentKernel;
import "autofunc.m": NongradedGenerators;
import "autofunc.m": CreateTGroup;
import "graded.m": IsGradedIsomorphicMI;
import "graded.m": StabilizerOfList;

 // checks := true;
checks := false;

////////////////////////////////////////////////////////////////////

KMtrx := function(X);

        return KMatrixSpace(BaseRing(Parent(X)), Nrows(X), Ncols(X))!X;

end function;

////////////////////////////////////////////////////////////////////

Matchseq := function(S,T);

S2 := T;
match := [];
for i := 1 to #S do
   for j := 1 to #S do
      if S2[j] eq S[i] then 
         Append(~match, j);
         S2[j] := 0;
         break j;
      end if;
   end for;
end for;

	return Sym(#S)!match;

end function;

////////////////////////////////////////////////////////////////////

AutoNextStep := function(A, TA, E, ends, projl, theta, gmats, nmats, n);
// A is the original algebra
// TA is the previous truncation
// E is the standard algebra
// ends is the idempotent ends of generators
// projl is the lengths of the projectives of A
// theta is the isomorphism form E to TA
// gplst is stabilizer group of E generated by then nonunipotent elements
// uplst is the unipotent subgroup of the stabilizer
// n is the level of the truncation

k := BaseRing(A);
B, muuu := TruncatedAlgebra(A,n);
sigma := TruncationMatrix(B,TA);
ends := GeneratorAssociatedIdempotents(E);
vprint Automorphisms: "Getting cover algebra";
vtime Automorphisms: C, rho := CoverAlgebra(E);
rrc := RadicalDimensions(C);
	if checks then   /////////////////////////////////////////////////
	   print  "DimensionTest for cover algebra",                  ////
				IsDimensionCompatible(C);             ////
	   print  "PathTreeTest for cover algebra", IsPathTree(C);    ////
	   print  "HomomorphismTest for cover algebra",               ////
	              IsAlgebraHomomorphism(C,E,rho);                 ////
	end if;  /////////////////////////////////////////////////////////

beta := ExtendHomomorphism(E,C,TA,B,rho,LeftInverseMatrix(sigma), theta);
vprint Automorphisms:  "Extended homomorphism to truncation has ",
       Nrows(beta), "rows and ", Ncols(beta), "columns.";

	if checks then   /////////////////////////////////////////////////
	   print "Homomorphism test for extension",                 //////
	            IsAlgebraHomomorphism(C,B, beta);               //////
	end if;  /////////////////////////////////////////////////////////

rhi := LeftInverseMatrix(rho);
vprint Automorphisms: "Extending Automorphisms from previous step";
vtime Automorphisms:
           Gmats := [ExtendHomomorphism(E,C,E,C, rho,rhi,x):x in gmats];
Nmats := [ExtendHomomorphism(E,C,E,C, rho,rhi,x):x in nmats];

	if checks then    /////////////////////////////////////////////////
	   print "checking extended automorphisms: ";                 /////
	   print [IsAlgebraHomomorphism(C,C,x):x in Gmats];           /////
	   print [IsAlgebraHomomorphism(C,C,x):x in Nmats];           /////
	end if;     ///////////////////////////////////////////////////////

AlgGL := GL(Dimension(C),k);
xi := BasisMatrix(Kernel(rho));
ix := RightInverseMatrix(xi);
vprint Automorphisms : "Getting action and kernel on Socle ";
vtime Automorphisms : ggmats := AutoMatsOnSocle(Gmats,xi,ix);
vprint Automorphisms : "getting unipotent kernel on socle";
vtime Automorphisms : kermats, ngmats, numats, UUgrp, muu :=
               UnipotentKernel(Nmats,xi,ix);

       if checks then     //////////////////////////////////////////////////
          print "checking upper triangular of unipotent group on socle"; ///
          print [IsUpperTriangular(x):x in numats];                      ///
       end if;       ///////////////////////////////////////////////////////

SocGL := GL(Dimension(Kernel(rho)), k);

      if checks then    ////////////////////////////////////////////////
         print "Checking upper triangular of group",               /////
            [IsUpperTriangular(y): y in Generators(UUgrp)];         /////
      end if;    ///////////////////////////////////////////////////////

Hgrp := sub<AlgGL|Gmats>;
vtime Automorphisms :
      gggmats := AutoMatsOnSocle([Hgrp.i: i in [1 .. Ngens(Hgrp)]],xi,ix);
Ggrp := sub<SocGL|gggmats>;
ftheta := hom<Hgrp -> Ggrp|gggmats>;

      if checks then //////////////////////////////////////////////////
          print "Size of nonunipotent group", #Ggrp;              /////
      end if; /////////////////////////////////////////////////////////


vprint Automorphisms : "Getting intersection with nipotent group";
vtime Automorphisms :   Sy := Ggrp meet UUgrp;
if #Sy eq 1 then
   Sy := sub<Ggrp|>;
end if;

KK := Kernel(xi*beta);
vprint Automorphisms: "Getting stabilizer of kernel";
vtime Automorphisms: ST := Stabilizer(Ggrp, KK);
vprint Automorphisms: "Getting coset action";
if #Sy gt #ST then
   vtime Automorphisms : QQ, phi := quo<Ggrp|Sy>;
   vprint Automorphisms: "Getting Double cosets";
   vtime Automorphisms : dcr1 := DoubleCosetRepresentatives(QQ,phi(Sy),phi(ST));
   dcr := [x^-1:x in dcr1];
   DCR := [x@@phi:x in dcr];
else
   vprint Automorphisms: "Getting coset action";
   vtime Automorphisms : a,b,c := CosetAction(Ggrp,ST);
   vprint Automorphisms: "Getting double cosets";
   vtime Automorphisms: dcr := DoubleCosetRepresentatives(b,a(ST),a(Sy));
   DCR := [x@@a:x in dcr];
end if;
Ob := [];
vprint Automorphisms: "Unipotent stabilizer: ";
vtime Automorphisms: for x in DCR do
   aa,bb,uu, vv := UnipotentStabiliser(UUgrp,KK*x);
   Append(~Ob,<x,aa,bb,uu>);
end for;
vprint Automorphisms: "Getting least conjugate of kernel :";
vtime Automorphisms: ll := Least([x[3]:x in Ob]);
Ob1 := Ob[ll];

gam := Ob1[4];
addlst := [];
if #Ob gt 1 then
   for i := 1 to #Ob do
      if not  i eq ll then
         if Ob[i][3] eq Ob1[3] then
            vprint Automorphisms: "Adding generators";
              Append(~addlst, <Ob[i][1],Ob[i][4]*gam^-1>);

     if checks then    /////////////////////////////////////////////////////
       print "checking additional stabilizer element";   ///////////////////
       print KK*Ob[i][1]*Ob[i][4] eq KK*Ob[ll][1]*Ob[ll][4];   /////////
       print KK*Ob[i][1]*Ob[i][4] eq Ob[ll][3];     //////////////////////
     end if;    ////////////////////////////////////////////////////////////

         end if;
      end if;
   end for;
end if;
vprint Automorphisms : "Lifting general automorphisms";
omega := Ob1[1]@@ftheta;
vtime Automorphisms :
    NGmats := [AlgGL!x : x in Setseq(Generators((ST@@ftheta)^omega))];
if #ngmats eq 0 then
   gamma := AlgGL!1;
   NNmats := kermats;
else
   vprint Automorphisms : "Lifting unipotent automorphisms";
   gamma := Evaluate(muu(gam),sub<AlgGL|ngmats>);
   NNmats := [Evaluate(muu(x),sub<AlgGL|ngmats>):
       x in Generators(Ob1[2])]
       cat kermats;
end if;
if #addlst ne 0 then
   for x in addlst do
      Append(~NGmats, AlgGL!(omega^-1*(x[1]@@ftheta*
                   Evaluate(muu(x[2]),sub<AlgGL|ngmats>))));
   end for;
end if;
SS := Ob1[3]*gam^-1*xi;

       if checks then ////////////////////////////////////////////////////
          print "checking kernel:   ", SS*omega^-1 eq Kernel(beta); //////
       end if;    ////////////////////////////////////////////////////////

       if checks then    /////////////////////////////////////////////////
          print "elements in stabilizer";   //////////////////////////////
          print [SS*x eq SS: x in NGmats];  //////////////////////////////
          print [SS*x eq SS: x in NNmats];  //////////////////////////////
       end if;   /////////////////////////////////////////////////////////

alph := AlgGL!gamma^-1*omega^-1;
vprint Automorphisms: "Getting quotient algebra ";
vtime Automorphisms:  EE, zeta := quo<C|SS>;
zeta1 := KMtrx(Matrix(zeta));

       if checks then    /////////////////////////////////////////////////
          print "Dimension test for quotient algebra: ",              ////
                     IsDimensionCompatible(EE);                       ////
          print "PathTree test for quotient algebra: ",               ////
                     IsPathTree(EE);                                  ////
          print "Homomorphism test for quotient map: ",               ////
                     IsAlgebraHomomorphism(C,EE, zeta);               ////
       end if;   /////////////////////////////////////////////////////////

vprint Automorphisms: "The dimension of the quotient algebra is   ",
                                 Dimension(EE);
vprint Automorphisms: "Obtaining induced homomorphisms on quotient";
vtime Automorphisms: psi := InducedHomomorphism(omega^-1*beta, zeta1,
                               KIdentityMatrix(k,Dimension(B)));

       if checks then   //////////////////////////////////////////////////
          print "Checking induced map is homomorphism: ",             ////
                          IsAlgebraHomomorphism(EE,B, psi);           ////
       end if;   /////////////////////////////////////////////////////////

vtime Automorphisms : ngplst :=
       [InducedHomomorphism(KMatrixSpace(k,Nrows(x),Ncols(x))!x,
                  zeta1, zeta1): x in NGmats];

if #addlst ne 0 then
   vprint Automorphisms : "Reducing group";
   vtime Automorphisms : ngplst := CreateTGroup(ngplst, 
		DimensionsOfProjectiveModules(EE),
		[#[x:x in GeneratorAssociatedIdempotents(A)|x[1] eq i]: 
                     i in [1 .. NumberOfProjectives(A)]], k); 

		////ReduceGroupFirst(EE,ngplst);
end if;

if #projl gt 1 then
   vtime Automorphisms: nuplst1 := 
        [InducedHomomorphism(KMatrixSpace(k,Nrows(x),Ncols(x))!x,
                  zeta1, zeta1): x in NNmats]  cat
                 AdditionalAutomorphisms(EE, zeta1(Kernel(rho))) cat
                 AdditionalAutomorphismsWithIdempotents(EE,
                          zeta1(Kernel(rho)));
else
   vtime Automorphisms: nuplst1 := 
        [InducedHomomorphism(KMatrixSpace(k,Nrows(x),Ncols(x))!x,
                  zeta1, zeta1): x in NNmats]  cat
                 AdditionalAutomorphisms(EE,zeta1(Kernel(rho)));
end if;
GU := sub<GL(Dimension(EE),k)|nuplst1>;
UU := UnipotentMatrixGroup(GU);
nuplst := Generators(UU);

       if checks then /////////////////////////////////////////////////////
          print "Checking the conjugacy of subspaces with minimum: ", ////
                 SS*omega^-1 eq Kernel(beta);                         ////
          print "Transformation is automorphism",                     ////
		IsAlgebraHomomorphism(C,C,
		KMatrixSpace(k, Dimension(C),Dimension(C))!alph);     ////
          print "Kernel is an ideal: ", IsIdeal(C,SS);               ////
       end if;   //////////////////////////////////////////////////////////

       if checks then   //////////////////////////////////////////////////
          print "Checking automorphisms on quotient: ";               ////
          print [IsAlgebraHomomorphism(EE,EE,x):x in ngplst];         ////
          print [IsAlgebraHomomorphism(EE,EE,x):x in nuplst];         ////
       end if;   /////////////////////////////////////////////////////////

vprint Automorphisms : "Number of general automorphisms:   ", #ngplst;
vprint Automorphisms : "Number of unipotent automorphisms:   ", #nuplst;

         return B, EE, psi, ngplst, nuplst, SS, C;

end function;

/////////////////////////////////////////////////////////////////////////

AutofunctionMatchingIdempotents := function(C, gls, mls); 
// computes the automorphism group with matching idempotents, gls, and 
// mls are the inputs from graded automorphisms. 

gplst := gls;
k := BaseRing(C);
mgf := MinimalGeneratorForm(C);
A := mgf`Algebra;
AGL := GL(Dimension(A),k);
ends := GeneratorAssociatedIdempotents(A);
rdd := mgf`RadicalDimensions;
lp := [#x:x in rdd];
if #lp gt 1 then
   cls, B := NongradedGenerators(A, mgf`FilterDimensions);
else
   cls := [];
   B := TruncatedAlgebra(A,2);
end if;
uplst := mls cat cls;
if Dimension(A) eq Dimension(B) then 
   S := Matrix(mgf`Homomorphism);
   T := S^-1;
   return sub<AGL| [AGL!(T*x*S): x in gls cat mls cat uplst]>, 
           KIdentityMatrix(k, Dimension(A));
end if;
E := B;
theta := KIdentityMatrix(k, Dimension(B));
for i := 3 to Maximum(lp) do
   vprint Automorphisms: "";
   vprint Automorphisms: "                      =========     ";
   vprint Automorphisms: "Step",i;
   vtime Automorphisms: B, E, theta, gplst, uplst, V, CC:=
          AutoNextStep(A, B, E, ends, lp, theta, gplst, uplst, i);
end for;
S := theta*Matrix(mgf`Homomorphism);
T := S^-1;

	return sub<AGL| [AGL!(T*x*S): x in gplst] cat 
                    [AGL!(T*x*S): x in uplst]>, theta;

end function;

///////////////////////////////////////////////////////////////////////

intrinsic AutomorphismGroupMatchingIdempotents(A::AlgBas) ->
                  AlgBas, ModMatFldElt
{Returns the group of all automorphism of the basic algebra A that
preserve the basic idempotent structure. That is, any element of
this group induces the identity automorphism on the quotient
A/Rad(A) of A by its Jacobson radical.}

if Dimension(A) eq 1 then 
   return SL(1,BaseRing(A)), KIdentityMatrix(BaseRing(A),1);
end if;
C := MinimalGeneratorFormAlgebra(A);
X := AssociatedGradedAlgebra(C);
gfi := C`GradedFactorIsomorphism;
gfin := gfi^-1;
GG, gplst, mls := GradedAutomorphismGroupMatchingIdempotents(A);
gplt := [gfi*x*gfin:x in gplst];
ml := [gfi*x*gfin: x in mls];
autgp, sigma := AutofunctionMatchingIdempotents(A, gplt, ml);

	return autgp, sigma;

end intrinsic;

///////////////////////////////////////////////////////////////////////

IsoNextStep := function(A1, TA1, A2, TA2, E,
        ends, projl, theta1, theta2, gmats, nmats, n);
// A1, A2 are the original algebras
// TA1, TA2 are the previous truncations
// E is the standard algebra
// ends is the idempotent ends of generators
// projl is the lengths of the projectives of A
// theta1, theta2 are the isomorphism from E to TA1, TA2
// gplst is stabilizer group of E generated by then nonunipotent elements
// uplst is the unipotent subgroup of the stabilizer
// n is the level of the truncation

k := BaseRing(A1);
B1, muu1 := TruncatedAlgebra(A1,n);
sigma1 := TruncationMatrix(B1,TA1);
B2, muu2 := TruncatedAlgebra(A2,n);
sigma2 := TruncationMatrix(B2,TA2);
ends := GeneratorAssociatedIdempotents(E);
vprint Automorphisms: "Getting cover algebra";
vtime Automorphisms: C, rho := CoverAlgebra(E);
rrc := RadicalDimensions(C);

       if checks then   /////////////////////////////////////////////////
          print  "DimensionTest for cover algebra",                  ////
			IsDimensionCompatible(C);                    ////
          print  "PathTreeTest for cover algebra", IsPathTree(C);    ////
          print  "HomomorphismTest for cover algebra",             //////
                    IsAlgebraHomomorphism(C,E,rho);                //////
       end if;  /////////////////////////////////////////////////////////

beta1 := ExtendHomomorphism(E,C,TA1,B1,rho,
                  LeftInverseMatrix(sigma1), theta1);
beta2 := ExtendHomomorphism(E,C,TA2,B2,rho,
                  LeftInverseMatrix(sigma2), theta2);
vprint Automorphisms:  "Extended homomorphism to truncation has ",
       Nrows(beta1), "rows and ", Ncols(beta1), "columns.";

       if checks then   /////////////////////////////////////////////////
          print "Homomorphism tests for extensions",               //////
                        IsAlgebraHomomorphism(C,B1, beta1);             //////
                        IsAlgebraHomomorphism(C,B2, beta2);             //////
       end if;  /////////////////////////////////////////////////////////

rhi := LeftInverseMatrix(rho);
vprint Automorphisms: "Extending Automorphisms from previous step";
vtime Automorphisms:
           Gmats := [ExtendHomomorphism(E,C,E,C, rho,rhi,x):x in gmats];

Nmats := [ExtendHomomorphism(E,C,E,C, rho,rhi,x):x in nmats];

       if checks then    /////////////////////////////////////////////////
          print "checking extended automorphisms: ";                 /////
          print [IsAlgebraHomomorphism(C,C,x):x in Gmats];           /////
          print [IsAlgebraHomomorphism(C,C,x):x in Nmats];           /////
       end if;     ///////////////////////////////////////////////////////

AlgGL := GL(Dimension(C),k);
xi := BasisMatrix(Kernel(rho));
ix := RightInverseMatrix(xi);
vprint Automorphisms : "Getting action and kernel on Socle ";
vtime Automorphisms : ggmats := AutoMatsOnSocle(Gmats,xi,ix);
vprint Automorphisms : "getting unipotent kernel on socle";
vtime Automorphisms : kermats, ngmats, numats, UUgrp, muu :=
               UnipotentKernel(Nmats,xi,ix);

       if checks then     //////////////////////////////////////////////////
          print "checking upper triangular of unipotent group on socle"; ///
          print [IsUpperTriangular(x):x in numats];                      ///
       end if;       ///////////////////////////////////////////////////////

SocGL := GL(Dimension(Kernel(rho)), k);

      if checks then    ////////////////////////////////////////////////
         print "Checking upper triangular of group",               /////
            [IsUpperTriangular(y): y in Generators(UUgrp)];         /////
      end if;    ///////////////////////////////////////////////////////

Hgrp := sub<AlgGL|Gmats>;
Hmats := Setseq(Generators(Hgrp));
vtime Automorphisms :
      gggmats := AutoMatsOnSocle(Hmats,xi,ix);
NGmats2 := [];
if #Hmats gt 0 then 
   for i := #Hmats to 1 by -1 do
      if gggmats[i] eq KIdentityMatrix(k,Dimension(Kernel(rho))) then
         Append(~NGmats2, Hmats[i]);
         Remove(~Hmats, i);
         Remove(~gggmats, i);
      elif exists(t){j: j in [1 .. i-1]|gggmats[j] eq gggmats[i]} then
         Append(~NGmats2, Hmats[i]*Hmats[t]^-1);
         Remove(~Hmats, i);
         Remove(~ggmats, i);
      end if;
   end for;
end if;
Ggrp := sub<SocGL|gggmats>;
ftheta := InverseWordMap(Ggrp);

      if checks then //////////////////////////////////////////////////
          print "Size of nonunipotent group", #Ggrp;               /////
      end if; /////////////////////////////////////////////////////////

vprint Automorphisms : "Getting intersection with nipotent group";
vtime Automorphisms :   Sy := Ggrp meet UUgrp;
if #Sy eq 1 then
   Sy := sub<Ggrp|>;
end if;

KK1 := Kernel(xi*beta1);
vprint Automorphisms: "Getting first stabilizer of first kernel";
vtime Automorphisms: ST := Stabilizer(Ggrp, KK1);      
vprint Automorphisms: "Getting coset action";
if #Sy gt #ST then
   vtime Automorphisms : QQ, phi := quo<Ggrp|Sy>;
   vprint Automorphisms: "Getting Double cosets";
   vtime Automorphisms : dcr1 := DoubleCosetRepresentatives(QQ,phi(Sy),phi(ST));
   dcr := [x^-1:x in dcr1];
   DCR := [x@@phi:x in dcr];
else
   vprint Automorphisms: "Getting coset action";
   vtime Automorphisms : a,b,c := CosetAction(Ggrp,ST);
   vprint Automorphisms: "Getting double cosets";
   vtime Automorphisms: dcr := DoubleCosetRepresentatives(b,a(ST),a(Sy));
   DCR := [x@@a:x in dcr];
end if;
Ob := [];
vprint Automorphisms: "Unipotent stabilizers of first: ";
vtime Automorphisms: for x in DCR do
   aa,bb,uu, vv := UnipotentStabiliser(UUgrp,KK1*x);
   Append(~Ob,<x,aa,bb,uu>);
end for;
vprint Automorphisms: "Getting least conjugate of kernel :";
vtime Automorphisms: ll1 := Least([x[3]:x in Ob]);
Ob1 := Ob[ll1];

KK2 := Kernel(xi*beta2);
vprint Automorphisms: "Getting first stabilizer of second kernel";
vtime Automorphisms: ST := Stabilizer(Ggrp, KK2);
vprint Automorphisms: "Getting coset action";
if #Sy gt #ST then
   vtime Automorphisms : QQ, phi := quo<Ggrp|Sy>;
   vprint Automorphisms: "Getting Double cosets";
   vtime Automorphisms : dcr1 := DoubleCosetRepresentatives(QQ,phi(Sy),phi(ST));
   dcr := [x^-1:x in dcr1];
   DCR := [x@@phi:x in dcr];
else
   vprint Automorphisms: "Getting coset action";
   vtime Automorphisms : a,b,c := CosetAction(Ggrp,ST);
   vprint Automorphisms: "Getting double cosets";
   vtime Automorphisms: dcr := DoubleCosetRepresentatives(b,a(ST),a(Sy));
   DCR := [x@@a:x in dcr];
end if;
Ob := [];
vprint Automorphisms: "Unipotent stabilizers: ";
vtime Automorphisms: for x in DCR do
   aa,bb,uu, vv := UnipotentStabiliser(UUgrp,KK2*x);
   Append(~Ob,<x,aa,bb,uu>);
end for;
vprint Automorphisms: "Getting least conjugate of kernel :";
vtime Automorphisms: ll2 := Least([x[3]:x in Ob]);
Ob2 := Ob[ll2];

if Ob1[3] ne Ob2[3] then
        return false, RMatrixSpace(Integers(),1,1)!0,n,0,0,0,0,0,0,0;
end if;

gam := Ob2[4];
addlst := [];
if #Ob gt 1 then
   for i := 1 to #Ob do
      if not  i eq ll2 then
         if Ob[i][3] eq Ob2[3] then
            vprint Automorphisms: "Adding generators";
              Append(~addlst, <Ob[i][1],Ob[i][4]*gam^-1>);

       if checks then    ///////////////////////////////////////////////////
         print "checking additional stabilizer element";   /////////////////
         print KK2*Ob[i][1]*Ob[i][4] eq KK2*Ob[ll2][1]*Ob[ll2][4];   ///////
         print KK2*Ob[i][1]*Ob[i][4] eq Ob[ll2][3];     ////////////////////
       end if;    //////////////////////////////////////////////////////////

         end if;
      end if;
   end for;
end if;
vprint Automorphisms : "Lifting general automorphisms";
if #Hmats eq 0 then 
   omega1x := AlgGL!1;
else 
   omega1x := Evaluate(ftheta(Ob1[1]), Hmats);
end if;
if #ngmats ne 0 then
   nuxx  := Evaluate(muu(Ob1[4]*Ob2[4]^-1),sub<AlgGL|ngmats>);
   omega1 := omega1x*nuxx;
else
   omega1 := omega1x;
end if;
if #Hmats eq 0 then
   omega2 := AlgGL!1;
else
   omega2 := Evaluate(ftheta(Ob2[1]), Hmats);
end if;

vtime Automorphisms :
   if #Hmats eq 0 then 
      NGmats1 := [AlgGL!1] cat NGmats2;
   else
      NGmats1 := [Evaluate(ftheta(x), Hmats)^omega2: x in Generators(ST)]
                        cat NGmats2;
   end if;
NGmats := [AlgGL!x:x in NGmats1];
if #ngmats eq 0 then
   gamma := AlgGL!1;
   NNmats := kermats;
else
   vprint Automorphisms : "Lifting unipotent automorphisms";
   gamma := Evaluate(muu(gam),sub<AlgGL|ngmats>);
   NNmats := [Evaluate(muu(x),sub<AlgGL|ngmats>):
       x in Generators(Ob2[2])]
       cat kermats;
end if;
if #addlst ne 0 then
   for x in addlst do
      if #NGmats eq 0 then
         NGmats := [omega2^-1*Evaluate(ftheta(x[1]), Hmats)*
                   AlgGL!(Evaluate(muu(x[2]),sub<AlgGL|ngmats>))];
      else 
         Append(~NGmats, omega2^-1*Evaluate(ftheta(x[1]),Hmats)*
                   AlgGL!(Evaluate(muu(x[2]),sub<AlgGL|ngmats>)));
      end if;
   end for;
end if;

SS := Ob2[3]*gam^-1*xi;

       if checks then ////////////////////////////////////////////////////
          print "checking kernel:   ", SS*omega2^-1 eq Kernel(beta2); //////
       end if;    ////////////////////////////////////////////////////////

       if checks then    /////////////////////////////////////////////////
          print "elements in stabilizer";   //////////////////////////////
          print [SS*x eq SS: x in NGmats];  //////////////////////////////
          print [SS*x eq SS: x in NNmats];  //////////////////////////////
       end if;   /////////////////////////////////////////////////////////

alph := AlgGL!gamma^-1*omega2^-1;
vprint Automorphisms: "Getting quotient algebra ";
vtime Automorphisms:  EE, zeta := quo<C|SS>;
zeta1 := KMtrx(Matrix(zeta));

       if checks then    /////////////////////////////////////////////////
          print "Dimension test for quotient algebra: ",              ////
                     IsDimensionCompatible(EE);                       ////
          print "PathTree test for quotient algebra: ",               ////
                     IsPathTree(EE);                                ////
          print "Homomorphism test for quotient map: ",               ////
                     IsAlgebraHomomorphism(C,EE, zeta1);               ////
       end if;   /////////////////////////////////////////////////////////

vprint Automorphisms: "The dimension of the quotient algebra is   ",
                                 Dimension(EE);
vprint Automorphisms: "Obtaining induced homomorphisms on quotient";
vtime Automorphisms: psi1 := InducedHomomorphism(omega1^-1*beta1, zeta1,
   KIdentityMatrix(k,Dimension(B1)));
vtime Automorphisms: psi2 := InducedHomomorphism(omega2^-1*beta2, zeta1,
   KIdentityMatrix(k,Dimension(B2)));

       if checks then   //////////////////////////////////////////////////
          print "Checking induced map is homomorphism: ",             ////
                          IsAlgebraHomomorphism(EE,B1, psi1);          ////
                          IsAlgebraHomomorphism(EE,B2, psi2);         ////
          print Dimension(B1), Dimension(B2);
          print IsAlgebraHomomorphism(B1,B2, psi1^-1*psi2);           ////
       end if;   /////////////////////////////////////////////////////////

vtime Automorphisms : ngplst :=
       [InducedHomomorphism(KMatrixSpace(k,Nrows(x),Ncols(x))!x,
                  zeta1, zeta1): x in NGmats];
if #addlst ne 0 then
   vprint Automorphisms : "Reducing group";
   vtime Automorphisms : ngplst := ReduceGroupFirst(EE,ngplst);
end if;
if #projl gt 1 then
   vtime Automorphisms: nuplst1 :=
        [InducedHomomorphism(KMatrixSpace(k,Nrows(x),Ncols(x))!x,
                  zeta1, zeta1): x in NNmats]  cat
                 AdditionalAutomorphisms(EE, zeta1(Kernel(rho))) cat
                 AdditionalAutomorphismsWithIdempotents(EE, zeta1(Kernel(rho)));
else
   vtime Automorphisms: nuplst1 :=
        [InducedHomomorphism(KMatrixSpace(k,Nrows(x),Ncols(x))!x,
                  zeta1, zeta1): x in NNmats]  cat
                 AdditionalAutomorphisms(EE,zeta1(Kernel(rho)));
end if;

if #nuplst1 gt 0 then 
   GU := sub<GL(Nrows(nuplst1[1]),k)|nuplst1>;
   UU := UnipotentMatrixGroup(GU);
   nuplst := Generators(UU);
else
   nuplst := [];
end if;

       if checks then /////////////////////////////////////////////////////
          print "Checking the conjugacy of subspaces with minimum: ",  ////
                 SS*omega1^-1 eq Kernel(beta1);                        ////
          print "Checking the conjugacy of subspace with minimum: ",   ////
                SS*omega2^-1 eq Kernel(beta2);                         ////
          print "Transformation is automorphism",                      ////
			IsAlgebraHomomorphism(C,C,alph);               ////
          print "Kernel is an ideal: ", IsIdeal(C,SS);                 ////
       end if;   //////////////////////////////////////////////////////////

       if checks then   //////////////////////////////////////////////////
          print "Checking automorphisms on quotient: ";               ////
          print [IsAlgebraHomomorphism(EE,EE,x):x in ngplst];         ////
          print [IsAlgebraHomomorphism(EE,EE,x):x in nuplst];         ////
       end if;   /////////////////////////////////////////////////////////


vprint Automorphisms : "Number of general automorphisms:   ", #ngplst;
vprint Automorphisms : "Number of unipotent automorphisms:   ", #nuplst;
if Dimension(A1) eq Dimension(B1) then 
   psi1 := psi1*Matrix(muu1)^-1;
   psi2 := psi2*Matrix(muu2)^-1;
end if;

         return B1, B2, EE, psi1, psi2, ngplst, nuplst, SS, C;

end function;

/////////////////////////////////////////////////////////////////////

IsIsomorphicMI := function(X, Y); 
// Decides if the given basic algebras are isomorpic with the idempotents
// matched.  If so, the function also  returns the matrix of the isomorphism.

k := BaseRing(X);
if Dimension(X) eq NumberOfProjectives(X) then 
   if Dimension(Y) eq NumberOfProjectives(Y) then
      return true, KIdentityMatrix(k, Dimension(X)), 1;
   else 
      return false, KMatrixSpace(k,1,1)!0,0;
   end if;
end if;
if Dimension(Y) eq NumberOfProjectives(Y) then
      return false, KMatrixSpace(k,1,1)!0,0;
end if;
mgfx := MinimalGeneratorForm(X);
mgfy := MinimalGeneratorForm(Y);
A := mgfx`Algebra;
B := mgfy`Algebra;
if Dimension(A) eq NumberOfGenerators(A) then 
   if GeneratorAssociatedIdempotents(A) eq 
               GeneratorAssociatedIdempotents(B) then
      return true, 
                Matrix(mgfx`InverseHomomorphism)*Matrix(mgfy`Homomorphism), 1;
   else 
      return false, KMatrixSpace(k,1,1)!0,0;
   end if;
end if;
if Dimension(B) eq NumberOfGenerators(B) then
      return false, KMatrixSpace(k,1,1)!0,0;
end if;
if mgfx`RadicalDimensions ne mgfy`RadicalDimensions then
        return false, KMatrixSpace(k,1,1)!0,0;
end if;
tail := GeneratorAssociatedIdempotents(B);
rdd := mgfy`RadicalDimensions;
lp := [#x:x in rdd];
if #lp gt 1 then
   cls, B2 := NongradedGenerators(B, mgfy`FilterDimensions);
else
   cls := [];
   B2 := TruncatedAlgebra(B,2);
end if;
B1 := TruncatedAlgebra(A,2);
E := B2;
boo, giso, gls, mls, tiso  := IsGradedIsomorphicMI(B2,B1);
if not boo then
        return false, KMatrixSpace(k,1,1)!0,1;
end if;
theta1 := tiso;
theta2 := Matrix(IdentityMatrix(k, Dimension(B2)));
gplst := gls;
uplst := mls cat cls;
A1 := A;
A2 := B;

vprint Automorphisms:  "checking initial homomorphism ",
      IsAlgebraHomomorphism(B2,B1,theta1);
ww := Maximum(lp);
for i := 3 to ww do
   vprint Automorphisms: "";
   vprint Automorphisms: "                    ==========  ";
   vprint Automorphisms: "Step ", i;
   vtime Automorphisms: B1, B2, E, theta1, theta2, gplst, uplst, V, CC :=
    IsoNextStep(A1, B1, A2, B2, E, tail, lp, theta1, theta2, gplst, uplst, i);
   if Type(B1) eq BoolElt then
        return false, KMatrixSpace(k,1,1)!0, E;
   end if;
end for;
mux := Matrix(mgfx`InverseHomomorphism);
muy := Matrix(mgfy`Homomorphism);

	return true, mux*theta1^-1*theta2*muy, 0;

end function;

/////////////////////////////////////////////////////////////////////////

intrinsic IsIsomorphicMatchingIdempotents(A::AlgBas, B::AlgBas) -> 
        BoolElt, ModMatFldElt, RngIntElt
{True if there is an isomorphism from the basic algebra A to the basic 
algebra B that preserves the ordering of the idempotents. The function
also returns the matrix of the isomorphism. }

if Dimension(A) ne Dimension(B) then 
         return false, KMatrixSpace(BaseRing(A),1,1)!0, 1;
end if;


a, b, c := IsIsomorphicMI(A, B);

	return a, hom<A -> B|b>, c;

end intrinsic;


////////////////////////////////////////////////////////////////////////

intrinsic AutomorphismGroupWithoutBlocks(A::AlgBas) -> GrpMat, GrpPerm
{Returns the automorphism group of the basic Algebra A, together with
the group of permutations of the idempotents that match automorphisms. }

k := BaseRing(A);
gautgp, glmats, nilmats, permats, PG := GradedAutomorphismGroup(A);
C := MinimalGeneratorFormAlgebra(A);
X := AssociatedGradedAlgebra(C);
gfi := C`GradedFactorIsomorphism;
gfin := gfi^-1;
gplt := [gfi*x*gfin:x in glmats];
ml := [gfi*x*gfin: x in nilmats];

autgp, xi := AutofunctionMatchingIdempotents(A,gplt,ml);
np := NumberOfProjectives(A);
dpm := DimensionsOfProjectiveModules(A);
XGL := GL(Dimension(A),k);
ngrp := [];
ulst := [];
ugrp := sub<PG|>;
if #PG gt 1 then
   cycs := Reverse(CyclicSubgroups(PG));
   for x in cycs do
      if x`order gt 1 then
         ss := x`subgroup;
         nn := Normalizer(PG, sub<PG|ugrp,ss>);
         gplst := [ss.1^y: y in Transversal(PG,nn)];
         for t in gplst do
            if not t in ugrp then
               B, theta1 := ChangeIdempotents(A,t);
               boo, gamma := IsIsomorphicMI(A,B);
               if boo then
                  ugrp := sub<PG|ugrp, t>;
                  Append(~ulst,t);
                  Append(~ngrp, gamma*Matrix(theta1)^-1);
                  if #ugrp eq #PG then
                     break;
                  end if;
               end if;
            end if;
         end for;
      end if;
   end for;
end if;
if #ulst ne 0 then
   nautogp := sub<XGL| Setseq(Generators(autgp)) cat [XGL!x:x in ngrp]>;
else
   nautogp := autgp;
end if;

	return nautogp, ugrp;

end intrinsic;

//////////////////////////////////////////////////////////////////////

intrinsic IsIsomorphic(A::AlgBas, B::AlgBas) -> Bool, Map
{True if the basic algebra A is isomorphic to the basic algebra B 
and if so, returns the matrix of an isomorphism.}

if Dimension(A) ne Dimension(B) then 
	return false, KMatrixSpace(BaseRing(A),1,1)!0, 1;
end if;
dpa := DimensionsOfProjectiveModules(A);
dpb := DimensionsOfProjectiveModules(B);
if Sort(dpa) ne Sort(dpb) then 

	return false, KMatrixSpace(BaseRing(A), 1,1)!0;

end if;
sigma := Matchseq(dpa, dpb);
sgp := StabilizerOfList(dpa);
if NumberOfProjectives(A) eq 1 then 
   boo, theta := IsIsomorphicMI(A,B);
   if boo then

	return boo, hom<A -> B |theta>;
	
   else

	return false, KMatrixSpace(BaseRing(A), 1,1)!0;   

   end if;
end if;
for x in sgp do
   C, mu := ChangeIdempotents(B,x*sigma);
   boo, theta := IsIsomorphicMI(A,C); 
   if boo then

	return true,  hom<A -> B |theta*Matrix(mu)^-1>;

   end if;
end for;

	return false, KMatrixSpace(BaseRing(A), 1,1)!0;

end intrinsic;

//////////////////////////////////////////////////////////////////

intrinsic BlocksOfBasicAlgebra(A::AlgBas) -> SeqEnum
{Returns the block structure of a basic algebra, a sequence of sets, each
set consisting of the indexes of the idempotents in the block of that set.} 

ga := GeneratorAssociatedIdempotents(A);
np := NumberOfProjectives(A);
gai := Seqset([ga[i]: i in [np+1 .. #ga]]);
bks := [];
rek := {1 .. np};
while #rek ne 0 do
   newflag := true;
   bbb := {Minimum(rek)};
   while newflag do 

      rmlst := {};
      newflag := false;
      for x in gai do
         if x[1] in bbb then 
            bbb join:=  {x[2]};
            rmlst join:= {x};
            newflag := true;
         elif x[2] in bbb then 
            bbb join:= {x[1]}; 
            rmlst join:= {x};
            newflag := true;
         end if;
      end for;
      gai diff:= rmlst;
      rek diff:= bbb;
   end while;
   Append(~bks, bbb);
end while;

	return bks;

end intrinsic;

/////////////////////////////////////////////////////////////////////

intrinsic BlockAlgebra(A::AlgBas, S::Set) -> AlgBas, SeqEnum
{Returns the block algebra of a basic algebra A, where  S is a subset
set consisting of the indices of the idempotents that form a block of A.
Also returned is sequence of indices of the generators of A that are 
in the block.}

k := BaseRing(A);
dims := DimensionsOfProjectiveModules(A);
nigens := {};
for x in S do 
   nigens join:= {y[2]: y in PathTree(A, x)};
end for;
Nigens := Sort(Setseq(nigens));
SS := Sort(Setseq(S));
BA := [];
for x in SS do
   ACT1 := Action(ProjectiveModule(A, x));
   ACT2 := MatrixAlgebra<k, dims[x]| [ACT1.j: j in Nigens]>;
   pt := [<y[1],Index(Nigens,y[2])>:y in PathTree(A,x)];
   Append(~BA, <ACT2,pt>);
end for;

	return BasicAlgebra(BA), Nigens;

end intrinsic;

//////////////////////////////////////////////////////////////////

InsertAutomorphismGroup := function(B, dpA, S);
// This function inserts the automorphism group of the block algebra
// into the automorphism group of its parent algebra A. The set S is 
// list of projective module of A that define the block algebra B
// and the sequence dpa is the list of dimensions of the projective
// modules of A. 

a, b := AutomorphismGroupWithoutBlocks(B);
Gens := [];
PGens := [];
n := &+dpA;
Id := IdentityMatrix(BaseRing(B), n);
SS := Sym(#dpA);
dpB := DimensionsOfProjectiveModules(B);
bk := Sort(Setseq(S));
if 1 in bk then
   if #bk eq 1 then
      bigstarts := [0, dpA[1]];
   else 
      bigstarts := [0] cat [&+[dpA[i]: i in [1 .. bk[j]-1]]: 
                        j in [2 .. #bk]];
   end if;
else
   bigstarts := [&+[dpA[i]: i in [1 .. x-1]]: x in bk];
end if;
littlestart := [0] cat [&+[dpB[i]: i in [1 .. j]]: j in [1 .. #dpB]];
for mat in Generators(a) do
   U := Id;
   for i := 1 to #dpB do
      for j := 1 to #dpB do  
         InsertBlock(~U, 
            Submatrix(mat, littlestart[i]+1, littlestart[j]+1,dpB[i],dpB[j]),
              bigstarts[i]+1, bigstarts[j]+1);
      end for;
   end for;
   Append(~Gens, U);
end for;
if #Generators(b) gt 0 then
   for x in Generators(b) do
      xx := Eltseq(x);
      yy := [1 .. dpA];
      for j := 1 to #dpB do
         yy[bk[j]] := xx[j];
      end for;
      Append(~PGens, SS!yy);
   end for;
end if;

	return Gens, sub<SS|PGens>;

end function;

//////////////////////////////////////////////////////////////////

AddIsomorphism := function(mat, dpA, dp1, dp2, b1, b2);
// This function creates the matrix which switches two blocks that
// are isomorphic. mat is the isomorphism of the first to the second,
// dp1 and dp2 are the dimensions of the projective modules in the 
// two blocks, dpa is the dimensions of the projective modules for 
// the parent algebra, and b1 and b2 are the blocks -- the sequence
// of number of the projective modules of the parent algebra that
// are in the two blocks. 

n := &+dpA;
Zer := MatrixAlgebra(BaseRing(mat), n)!0;
if 1 in b1 then
   if #b1 eq 1 then
      bigstarts1 := [0, dpA[1]];
   else 
      bigstarts1 := [0] cat [&+[dpA[i]: i in [1 .. b1[j]-1]]: 
                        j in [2 .. #b1]];
   end if;
else
   bigstarts1 := [&+[dpA[i]: i in [1 .. x-1]]: x in b1];
end if;
if 1 in b2 then
   if #b2 eq 1 then
      bigstarts2 := [0, dpA[1]];
   else 
      bigstarts2 := [0] cat [&+[dpA[i]: i in [1 .. b2[j]-1]]: 
                        j in [2 .. #b2]];
   end if;
else
   bigstarts2 := [&+[dpA[i]: i in [1 .. x-1]]: x in b2];
end if;
littlestart1 := [0] cat [&+[dp1[i]: i in [1 .. j]]: j in [1 .. #dp1]];
littlestart2 := [0] cat [&+[dp2[i]: i in [1 .. j]]: j in [1 .. #dp2]];
imat := mat^-1;
for i := 1 to #b1 do
   for j := 1 to #b2 do
      InsertBlock(~Zer, 
            Submatrix(mat, littlestart1[i]+1, littlestart2[j]+1,dp1[i],dp2[j]),
              bigstarts1[i]+1, bigstarts2[j]+1);
      InsertBlock(~Zer, 
            Submatrix(imat, littlestart2[i]+1, littlestart1[j]+1,dp2[i],dp1[j]),
              bigstarts2[i]+1, bigstarts1[j]+1);
   end for;
end for;
for i := 1 to #dpA do
   if not i in b1 join b2 then 
      if i eq 1 then 
         stt := 0;
      else 
         stt := &+[dpA[s]: s in [1 .. i-1]];
      end if;
      for j := stt+1 to stt+dpA[i] do 
         Zer[j,j] := 1;
      end for;
   end if;
end for;


	return Zer;

end function;

//////////////////////////////////////////////////////////////////

intrinsic AutomorphismGroup(A::AlgBas) -> GrpMat, GrpPerm
{Returns the automorphism group of the basic Algebra A, together with
the group of permutations of the idempotents that match automorphisms. }

bks := BlocksOfBasicAlgebra(A);
if #bks eq 1 then 
   a, b := AutomorphismGroupWithoutBlocks(A);
   return a, b;
end if;
dpa := DimensionsOfProjectiveModules(A);
S := Sym(#dpa);
db := [bks[#bks]];
DB := [BlockAlgebra(A, bks[#bks])];
Gens, PGens := InsertAutomorphismGroup(DB[1], dpa, bks[#bks]);
done := #bks-1;   
                       // the number of blocks that we still have to do
for i := 1 to #bks-1 do
   flag := true;
   B := BlockAlgebra(A, bks[done]);
   dpB := DimensionsOfProjectiveModules(B);
   for j := 1 to #DB do   
            // First, we decide if it is reasonable to test for isomorphisms.

      if Sort(dpB) eq Sort(DimensionsOfProjectiveModules(DB[j])) then 
         u, v := IsIsomorphic(B, DB[j]);
         if u then 
            Append(~Gens, AddIsomorphism(Matrix(v), dpa, dpB, 
                 DimensionsOfProjectiveModules(DB[j]), bks[done], db[j]));
            done := done-1;
            flag :=  false;
            break j;
         end if;
      end if;
   end for;
   if flag then
      a, b := InsertAutomorphismGroup(B, dpa, bks[done]);
      Gens cat:= a;
      PGens := sub<Sym(NumberOfProjectives(A))|PGens, b>;
      Append(~DB,B);
      Append(~db,bks[done]);
      done := done-1;
   end if;
end for;

	return sub<GL(Dimension(A), BaseRing(A)) | Gens >,  PGens;

end intrinsic;

                                     




