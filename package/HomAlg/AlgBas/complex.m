freeze;

/***************************************************************************
				Creation
****************************************************************************/

intrinsic Complex(L::List, d::RngIntElt: Check := true) -> ModCpx
{Create the complex given by the list L of maps and such that the last term has
degree d};
    for i := 1 to #L do
	if Type(L[i]) eq Map then
	    L[i] := MapToMatrix(L[i]);
	end if;
    end for;
    return InternalComplex(L, d: Check := Check);
end intrinsic;

intrinsic Splice(C::ModCpx,D::ModCpx,f::ModMatRngElt) -> ModCpx
{The splice of the complex C with the complex D along the map f from
the last term of C to the first term of D. the degree of the last
term of the splice is the same as the degree of the last term of
the complex D.}

   a,b := Degrees(C);
   c,d := Degrees(D);
   require BoundaryMap(C,b+1)*f eq 0 and f*BoundaryMap(D,c) eq 0:
    "Composition of boundary maps is not zero";
   L := BoundaryMaps(C) cat [* f *] cat BoundaryMaps(D);
   E := Complex(L,d);
return E;

end intrinsic;

/***************************************************************************
				Homology
****************************************************************************/

intrinsic HomologyOfChainComplex(C::ModCpx) -> []
{The sequence of homology groups of the complex C}

    if assigned C`HomologyOfChainComplex then
    return C`HomologyOfChainComplex;
    end if;
    h, l := Degrees(C);
    //H := [ car<PowerStructure(ModAlgBas),PowerStructure(Map)> | ];
    H := [**];
    for i := h - 1 to l + 1 by -1 do
	ker := Kernel(BoundaryMap(C, i));
	im := Image(BoundaryMap(C, i + 1));
	h,m := quo<ker | im>;
    Append(~H, <h,m>);
    end for;
    C`HomologyOfChainComplex := H;
    return H;

end intrinsic;


intrinsic Homology(C::ModCpx) -> []
{The sequence of homology groups of the complex C}

    if assigned C`HomologyOfChainComplex then
	U := C`HomologyOfChainComplex;
    else 
	U := HomologyOfChainComplex(C);
	C`HomologyOfChainComplex := U;
    end if;
    H := [U[i][1]:i in [1 .. #U]];
    M := [U[i][2]:i in [1 .. #U]];

    return H, M;

end intrinsic;

intrinsic Homology(C::ModCpx, n::RngIntElt) -> ModAlgBas
{The homology group in degree n of the complex C as an A-module,
together with the associated epimorphism}
    h, l := Degrees(C);
    requirerange n, l + 1, h - 1;
    return quo<Kernel(BoundaryMap(C, n)) | Image(BoundaryMap(C, n + 1))>;
end intrinsic;

intrinsic DimensionOfHomology(C::ModCpx, n::RngIntElt) -> []
{The dimension of the n-th homology group of the complex C}
    h, l := Degrees(C);
    requirerange n, l + 1, h - 1;
    return Dimension(Homology(C, n));
end intrinsic;

intrinsic DimensionsOfHomology(C::ModCpx) -> []
{The sequence of the dimensions of the homology groups of the complex C}
    return [Dimension(M): M in Homology(C)];
end intrinsic;

/***************************************************************************
				    Sub
****************************************************************************/

intrinsic Subcomplex(C::ModCpx, S::[ModAlgBas]) -> ModCpx
{The subcomplex of C generated by S and the inclusion of S in C. S is a 
sequence of submodules of the terms of C}
    L := BoundaryMaps(C);
    l := #L + 1;
    require #S eq l: "List argument should contain", l, "submodules";
 
    // Check compat?
    _, d := Degrees(C);
    for i := 1 to #S - 1 do
        require S[i] subset Domain(L[i]):
            "List element", i, "is not a submodule";
    end for;

    require S[#S] subset Codomain(L[#S - 1]):
        "List element", #S, "is not a submodule";
    F := [* Morphism(S[1], Domain(L[1])) *];
    for i := 2 to #S do
        //S[i] := S[i] + S[i - 1] * L[i - 1];
        D := Domain(L[i - 1]);
        LC := Codomain(L[i - 1]);
        S[i] := S[i] + sub<LC | RowSpace(Morphism(S[i - 1], D) * L[i - 1]) >;
        F[i] := Morphism(S[i], LC);
    end for;
 
    for i := 1 to #L do
        X := Solution(
            Morphism(S[i + 1], Codomain(L[i])),
            Morphism(S[i], Domain(L[i])) * L[i]
        );
        X := RMatrixSpace(S[i], S[i + 1]) ! X;
        L[i] := X;
    end for;
 
    D := Complex(L, d);
    M := ChainMap(F, D, C, 0);
    return D, M;
end intrinsic;
 
intrinsic Subcomplex(C::ModCpx,L::List) -> ModCpx,MapChn
{The subcomplex generated by L. The list L may be either a list of
sequences of element of the terms of C or a list of submodules 
of the terms of C. There must be one element of L for each term
of C. The function returns both the subcomplex and the inclusion
of the subcomplex into C.}

m,n := Degrees(C);
D,mu := Subcomplex(C,[sub<Term(C,m-j+1)|L[j]>:j in [1 .. m-n+1]]);
return D,mu;

end intrinsic;

intrinsic RandomSubcomplex(C::ModCpx, S::SeqEnum) -> ModCpx, MapChn
{Given a chain complex C in degrees a to a-t+1 and a sequence S = 
[s_1 .. s_t], the function creates the minimal chain comples whose
term in degree a-i+1 is a subcomplex generated by s_i random elements 
of the term in degree a-i+1 of C. The function also returns the 
chain map that is the inclusion of subcomplex into C.} 

   subb := [* *];
   a,b := Degrees(C);
   for i := 1 to a-b+1 do
   subb[i] := sub<Term(C,a-i+1)|[Random(Term(C,a-i+1)): j in [1 .. S[i]]]>;
   end for;
   D, phi := sub<C|subb>;

   return D,phi;

end intrinsic;


/***************************************************************************
				    Quo
****************************************************************************/

//intrinsic QuotientComplex(C::ModCpx, S::[ModAlgBas]) -> ModCpx
intrinsic QuotientComplex(C::ModCpx, D::ModCpx) -> ModCpx
{The quotient complex Q of C by D and the projection of C onto Q}
//"C:", C; TES(C);
    L := BoundaryMaps(C);
    // check S subcomplex?
    l := #L + 1;
    //require #S eq l: "List argument should contain", l, "submodules";

    // Check compat?
    max, min := Degrees(C);

    S := [Term(C, i): i in [max .. min by -1]];
    T := [Term(D, i): i in [max .. min by -1]];
    assert #S eq #L + 1;

    /* S[i] --L[i]--> S[i + 1] */

    Q := [];
    F := [ PowerStructure(Map) | ];
    for i := 1 to #S do
	Q[i], F[i] := quo<S[i] | T[i]>;
    end for;

    LL := [* *];
    for i := 1 to #L do
//"bqi:", Basis(Q[i]);
//"@@:", Basis(Q[i]) @@F[i];
//"p:", Parent(Basis(Q[i]) @@F[i]);
//"next:", [x * L[i]: x in Basis(Q[i]) @@ F[i]];
	q := [F[i + 1](y): y in [x * L[i]: x in [z@@F[i]: z in Basis(Q[i])]]];
	//LL[i] := Hom(Q[i], Q[i + 1]) ! q;
	LL[i] := RMatrixSpace(Q[i], Q[i + 1]) ! &cat[Eltseq(f): f in q];
    end for;

    D := Complex(LL, min);

    F := [* *];
    for i := 1 to #S do
	F[i] := Morphism(S[i], Q[i]);
    end for;

    M := ChainMap(F, C, D, 0);

    return D, M;
end intrinsic;

intrinsic QuotientComplex(C::ModCpx, S::[ModAlgBas]) -> ModCpx
{The quotient complex of C by the sequence S of submodules}
    return QuotientComplex(C, Subcomplex(C, S));
end intrinsic;

intrinsic QuotientComplex(C::ModCpx,L::List) -> ModCpx,MapChn
{The quotient of C by the subcomplex generated by L. The list L may 
be either a list of sequences of element of the terms of C or a list 
of submodules of the terms of C. There must be one element of L 
for each term of C. The function returns both the quotient complex 
and the quotient map.}

S := Subcomplex(C,L);
D,mu := QuotientComplex(C,S);
return D,mu;

end intrinsic;


/***************************************************************************
				    Direct sum
****************************************************************************/

intrinsic DirectSum(C::ModCpx, D::ModCpx) -> ModCpx
{The direct sum of C and D}

    Cmax, Cmin := Degrees(C);
    Dmax, Dmin := Degrees(D);

    min := Min(Cmin, Dmin);
    max := Min(Cmax, Dmax);

    z := sub<Term(C, Cmax)|>;
    S := [];
    for i := max to min by -1 do
	if i in [Cmin .. Cmax] then
	    c := Term(C, i);
	else
	    c := z;
	end if;
	if i in [Dmin .. Dmax] then
	    d := Term(D, i);
	else
	    d := z;
	end if;
	Append(~S, DirectSum(c, d));
	//S[i] := DirectSum(c, d);
    end for;

    get_S := func<i | S[max + 1 - i]>;

    LC := BoundaryMaps(C);
    LD := BoundaryMaps(D);

    L := [* *];
    for i := max - 1 to min by -1 do
	if i notin [Cmin .. Cmax - 1] then
	    f := BoundaryMap(D, i + 1);
	elif i notin [Dmin .. Dmax - 1] then
	    f := BoundaryMap(C, i + 1);
	else
	    c := BoundaryMap(C, i + 1);
	    d := BoundaryMap(D, i + 1);
	    f := DiagonalJoin(c, d);
	end if;
	f := RMatrixSpace(get_S(i + 1), get_S(i)) ! Eltseq(f);
	Append(~L, f);
    end for;

    return Complex(L, min);
end intrinsic;

/*************************************************************************
			     Manipulations
 *************************************************************************/


intrinsic ShiftToDegreeZero(f::MapChn) -> MapChn
{Takes a chain map in any degree and writes it as a chain map in degree
   zero in which both the domain and codomain have lowest degree zero.}

   a,b := Degrees(Domain(f));
   c,d := Degrees(Codomain(f));
   C := Shift(Domain(f),-b);
   D := Shift(Codomain(f),-d);
   g := ChainMap(ModuleMaps(f),C,D,0);

return g;

end intrinsic;

/*************************************************************************
                                 duals
**************************************************************************/

intrinsic Dual(C::ModCpx) -> ModCpx
{The dual of the complex C as a complex over the opposite algebra of 
the algebra of C. The last term of the dual complex is in degree 0.}

   a,b := Degrees(C);
   require ISA(Type(Term(C, b)), ModRng): "Type of terms must be ModRng";

   dd := [*  *];
   mlst := [Dual(Term(C,b+i-1)):i in [1 .. a-b+1]];
   for i := 1 to a-b do
   dd[i] := RMatrixSpace(mlst[i],mlst[i+1])!Dual(BoundaryMap(C,b+i));
   end for;
   D := Complex(dd,0);
   return D;

end intrinsic;



intrinsic Dual(C::ModCpx,n::RngIntElt) -> ModCpx
{The dual of the complex C as a complex over the opposite algebra of 
the algebra of C. The last term of the dual complex is in degree n.}

   a,b := Degrees(C);
   dd := [*  *];
   mlst := [Dual(Term(C,b+i-1)):i in [1 .. a-b+1]];
   for i := 1 to a-b do
   dd[i] := RMatrixSpace(mlst[i],mlst[i+1])!Dual(BoundaryMap(C,b+i));
   end for;
   D := Complex(dd,n);
   return D;

end intrinsic;

/**************************************************************************
                           Zero Extensions
***************************************************************************/

intrinsic LeftZeroExtension(C::ModCpx) -> ModCpx
{Given a complex C of modules over a basic algebra, return the complex
of length one greater that is obtained by adjoining the zero map from the 
zero module to the term of highest degree in the complex.}

   a,b := Degrees(C);
   zz, phi := sub<Term(C,a)|>;
   D := Splice(Complex(MapToMatrix(phi),0),C);
   return D;

end intrinsic;

intrinsic LeftZeroExtension(C::ModCpx,n::RngIntElt) -> ModCpx {Returns
the complex obtained from C by apending n terms of zero modules on the
left end of C.}

   requirege n,-1; 
   if n eq 0 then return C;
   end if;
   E := C;
   for i := 1 to n do
   E := LeftZeroExtension(E); 
   end for;

return E;

end intrinsic;

intrinsic RightZeroExtension(C::ModCpx) -> ModCpx
{Given a complex C of modules over a basic algebra, return the complex
of length one greater that is obtained by adjoining the zero map to the 
zero module from the term of lowest degree in the complex.}

   a,b := Degrees(C);
   zz, phi := quo<Term(C,b)|Term(C,b)>;
   D := Splice(C,Complex(MapToMatrix(phi),b-1));
   return D;

end intrinsic;

intrinsic RightZeroExtension(C::ModCpx,n::RngIntElt) -> ModCpx {Returns
the complex obtained from C by apending n terms of zero modules on the
right end of C.}

   requirege n,-1; 
   if n eq 0 then return C;
   end if;
   E := C;
   for i := 1 to n do
   E := RightZeroExtension(E); 
   end for;

return E;

end intrinsic;

intrinsic ZeroExtension(C::ModCpx) -> ModCpx
{Given a complex C of modules over a basic algebra, return the complex
of length two greater that is obtained by adjoining the zero map to the 
zero module from the term of lowest degree in the complex and also 
appending the zero map from the zero module to the term of highest degree 
in the complex.}

   D := LeftZeroExtension(RightZeroExtension(C));
   return D;

end intrinsic;

intrinsic EqualizeDegrees(S::SeqEnum) -> SeqEnum
{Given a sequence of complexes of modules over the same algebra,  the 
function returns the sequence of complexes obtained by taking Zero extensions
of the elements of S, if necessary until all of the elements of the sequence
have the same degrees.}

BD := [];
ED := [];
for i := 1 to #S do
a,b := Degrees(S[i]);
BD[i] := a;
ED[i] := b;
end for;
m := Maximum(BD);
n := Minimum(ED);
T := [];
for i := 1 to #S do
T[i] := LeftZeroExtension(RightZeroExtension(S[i],ED[i]-n),m-BD[i]);
end for;

return T;

end intrinsic;


intrinsic EqualizeDegrees(C::ModCpx,D::ModCpx,n::RngIntElt) -> ModCpx,ModCpx
{Given a complex C in degrees from a to b and a complex D in degrees c to d,
the function returns the two complexes in degrees max(a,c+n) to min(b,d+n)
and from max(a-n,c) to min(b-n,d) obtained from C and D by zero extensions
when necessary.};

E := EqualizeDegrees([C,Shift(D,n)]);
return E[1],Shift(E[2],-n);

end intrinsic;
   
intrinsic EqualizeDegrees(C::ModCpx,D::ModCpx) -> ModCpx,ModCpx
{Given complexes C and D over the same algebra, the function returns 
the complexes obtained by taking Zero extensions of C and D, if necessary 
so that both complexes have the same degrees.}

E := EqualizeDegrees([C,D]);
return E[1],E[2];

end intrinsic;

/***************************************************************************
			     ExactExtension
***************************************************************************/

intrinsic LeftExactExtension(C::ModCpx) -> ModCpx
{Given a complex C of modules over a basic algebra, return the complex
of length one greater that is obtained by adding the inclusion map from 
the homology to the term of highest degree in the complex to the left
end of the complex.}

   a,b := Degrees(C);
   zz, phi := Kernel(BoundaryMap(C,a-1));
   D := Splice(Complex(MapToMatrix(phi),a),C);
   return D;

end intrinsic;


intrinsic RightExactExtension(C::ModCpx) -> ModCpx
{Given a complex C of modules over a basic algebra, return the complex
of length one greater that is obtained by adding the quotient map to the 
homology module from the term of lowest degree in the complex on the 
right end of the complex.}

   a,b := Degrees(C);
   zz, phi := Cokernel(BoundaryMap(C,b));
   D := Splice(C,Complex(MapToMatrix(phi),b-1));
   return D;

end intrinsic;

intrinsic ExactExtension(C::ModCpx) -> ModCpx
{Given a complex C of modules over a basic algebra, return the complex
of length two greater that is obtained by adding the inclusion from the 
homology to the term of highest degree in the complex and also appending 
the quotient map from the homology to the term of highest degree 
in the complex.}

   D := LeftExactExtension(RightExactExtension(C));
   return D;

end intrinsic;

/***************************************************************************
			   Contractons
***************************************************************************/

intrinsic Preprune(C::ModCpx,n::RngIntElt) -> ModCpx
{Returns the complex C with n terms removed from the left end.}

   DD := [* *];
   a,b := Degrees(C);
   requirerange n,0,a-b-2;
   for i := 1 to a-b-n do
   DD[i] := BoundaryMap(C,a-n-i+1);
   end for;
   D := Complex(DD,b);

return D;

end intrinsic;

intrinsic Prune(C::ModCpx, n::RngIntElt) -> ModCpx
{Returns the complex C with n terms removed from the right end.}

   DD := [* *];
   a,b := Degrees(C);
   requirerange n,0,a-b-2;
   for i := 1 to a-b-n do
   DD[i] := BoundaryMap(C,a-i+1);
   end for;
   D := Complex(DD,b+n);

return D;

end intrinsic;

/****************************************************************************
				   Access
*****************************************************************************/

intrinsic Terms(C::ModCpx) -> SeqEnum
{The sequence of the terms of the complex.}

   a, b := Degrees(C);
   X := [Term(C,a-i+1):i in [1 .. a-b+1]];
   return X;

end intrinsic;

/*
intrinsic BoundaryMaps(C::ModCpx) -> List
{The list of the boundary maps in the complex C.}

   L:= [*  *];
   a,b := Degrees(C);
   for i := a to b+1 by -1 do
   Append(~L,BoundaryMap(C,i));
   end for;
   return L;

end intrinsic;
*/

/***************************************************************************
			Exactness					    
****************************************************************************/

intrinsic IsShortExactSequence(C::ModCpx) -> BoolElt,RngIntElt
{True if the complex consists of a short exact sequence along 
	       with other terms}
flag := false;
a,b := Degrees(C);
ndeg := [i:i in [1 .. a-b+1]|Dimension(Term(C,a+1-i)) ne 0];
if #ndeg eq 0 then
flag := true;
elif #ndeg eq 2 and ndeg[2]-ndeg[1] eq 1 then
aa := BoundaryMap(C,ndeg[1]);
if Rank(aa) eq Nrows(aa) and Rank(aa) eq Ncols(aa) then
flag := true;
end if;
elif #ndeg eq 3 and ndeg[3]-ndeg[1] le 2 and IsExact(ZeroExtension(C)) then
flag := true;
end if;
return flag;

end intrinsic;



