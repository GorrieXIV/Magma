freeze;

intrinsic QuoConstr(A::AlgBas, S::ModTupFld) -> AlgBas, ModMatFldElt
{Returns the quotient algebra of A by the ideal S, which is a subspace
of the vector space of A.}

k := BaseRing(A);
nproj := NumberOfProjectives(A);
ng := #Generators(A);
NI := NonIdempotentGenerators(A);
m := #NI;
NEWP := [* *];
np := DimensionsOfProjectiveModules(A);
B := Basis(S);
P, inj, prj := DirectSum([VectorSpace(BaseRing(A),np[i]): i in [1 .. #np]]);
NA := [ ];
                 // these are the new matrix algebras
lst := [];
                // this is the list of the surviving generators.

                // first we should get list of surviving idempotents.
elimlst := [i: i in [1 .. nproj]| Vector(Generators(A)[i]) in S];
gai := GeneratorAssociatedIdempotents(A);
elimlst2 := elimlst cat [i: i in [nproj+1 .. ng]|
           gai[i][1] in elimlst or gai[i][2] in elimlst];
keeplst := [i: i in [1 .. nproj]| not i in elimlst];
keeplst2 := [i: i in [1 .. ng]|not i in elimlst2];
for i  in keeplst do
   Pi := VectorSpace(BaseRing(A), np[i]);
   BBi := [prj[i](P!Vector(x)):x in B];
   PPi := ProjectiveModule(A,i);
   NPi,gamma := quo<PPi|[PPi!x:x in BBi]>;
   Append(~NEWP, <NPi,gamma>);
   nlst := [];
   M := JacobsonRadical(NPi);

        // we make a list of nonidempotent generators that are necessary.
        // the answer is none if the Dimension of M is zero.
   if Dimension(M) ne  0 then
      N := JacobsonRadical(M);
      Q, phi := quo<M|N>;
      BB := [phi(NPi.1*x):x in NI];
      for i := 1 to #BB do
         if #nlst eq 0 then
            mmm := [BB[i]];
         else
            mmm := [BB[x]:x in nlst] cat [BB[i]];
         end if;
         X := KMatrixSpace(BaseRing(A), #nlst+1, Dimension(Q))!mmm;
         if Rank(X) eq #nlst+1 then
            Append(~nlst, i);
         end if;
      end for;
   end if;
   lst := lst cat nlst;
end for;
ndim := Dimension(A)-Dimension(S);
theta := KMatrixSpace(BaseRing(A), Dimension(A),ndim)!0;
rcount := 1;
ccount := 1;

                // here we are making the homomorphism to the new algebra

//for i := 1 to  #keeplst do
//   InsertBlock(~theta,MapToMatrix(NEWP[i][2]),rcount,ccount);
//   rcount +:= np[i];
//   ccount +:= Dimension(NEWP[i][1]);
//end for;

blank := 0;
for i := 1 to  nproj do
   if i in elimlst then
      blank +:= 1;
      rcount +:= np[i];
   else 
      InsertBlock(~theta,MapToMatrix(NEWP[i-blank][2]),rcount,ccount);
      rcount +:= np[i];
      ccount +:= Dimension(NEWP[i-blank][1]);
   end if;
end for;



                // now we must make the algebra

Mat := KMatrixSpace(BaseRing(A), ndim,ndim)!0;
IMat := Mat;
NA := [];
mrct:= 1;
for i := 1 to #keeplst do
   P := NEWP[i][1];
   M := JacobsonRadical(JacobsonRadical(P));
   ld := [j:j in lst|P.1*NI[j] ne P!0];
   base := [P.1] cat [P.1*NI[j]: j in ld];
   sd := 1;
   pt := [<1,i>] cat [<1,#keeplst+Index(lst,j)>: j in ld];
   while Dimension(M) gt 0 do
      M := JacobsonRadical(M);
      nsd := #base;
      Q, phi := quo<P|M>;
      nld := Dimension(Q);
      for t := 1 to #lst do
         for s := sd+1 to nsd do
            if Rank(KMatrixSpace(BaseRing(A), #base+1, Dimension(Q))!
          ([Vector(phi(x)):x in base] cat [Vector(phi(base[s]*NI[lst[t]]))]))
                                        eq (#base +1) then
               Append(~base, base[s]*NI[lst[t]]);
               Append(~pt, <s,#keeplst+t>);
               if #base eq nld then
                  break t;
               end if;
            end if;
         end for;
      end for;
      sd := nsd;
   end while;
   U := KMatrixSpace(BaseRing(A),#base,#base)![Vector(x): x in base];
   V := U^(-1);
   al := ActionGenerators(P);
   matlst := [U*al[i]*V: i in keeplst] cat
                                [U*al[nproj+x]*V: x in lst];
   Append(~NA, <MatrixAlgebra<BaseRing(A),Dimension(P)|matlst>, pt>);
   InsertBlock(~Mat,U,mrct,mrct);
   InsertBlock(~IMat,V,mrct,mrct);
   mrct +:= Dimension(P);
end for;
B := BasicAlgebra(NA);

     return B, hom<A -> B|theta*IMat>;

end intrinsic;

////////////////////////////////////////////////////////////////////////

MakeIdeal := function(A, S)
// Returns the subspace of the vector space of the algebra A that is the
// ideal of the A generated by the given sequence of elements.}

genlst := S;
V := VectorSpace(A);
np := NumberOfProjectives(A);
IG := IdempotentGenerators(A);
NG := NonIdempotentGenerators(A);
if np gt 1 then
   M := sub<V|[Vector(u*(A!Vector(x))):x in genlst,u in IG] cat
        [Vector((A!Vector(x))*u):x in genlst,u in IG]>;
else
   M := sub<V|[Vector(x):x in genlst]>;
end if;
dim := Dimension(M);
flag := true;
while flag do
   M := sub<V|Basis(M) cat [Vector(u*A!x):x in Basis(M),u in NG] cat
                     [Vector(A!x*u):x in Basis(M),u in NG]>;
   if Dimension(M) eq dim then
      flag := false;
   else
      dim := Dimension(M);
   end if;
end while;

        return M;

end function;

////////////////////////////////////////////////////////////////////////

intrinsic IdealConstr(A::AlgBas, S::SeqEnum[AlgBasElt]) -> ModTupFld
{Returns the subspace of the vector space of the algebra A that is the
ideal of the A generated by the given sequence of elements.}

        return MakeIdeal(A,S);

end intrinsic;

///////////////////////////////////////////////////////////////////////

intrinsic IdealConstr(A::AlgBasGrpP, S::SeqEnum[AlgBasElt]) -> ModTupFld
{Returns the subspace of the vector space of the algebra A that is the
ideal of the A generated by the given sequence of elements.}

        return MakeIdeal(A,S);

end intrinsic;

////////////////////////////////////////////////////////////////////

MakeMatrixOnSubalgebra := function(A, BV, m, xi, ix);
// A is the algebra, V is the basis of the subalgebra, m is
// the basis element that the function finds the matrix of, xi is
// the basis matrix of V meaning the inclusion matrix of V into A,
// and ix is the right inverse matrix of xi.

RR := [A!x: x in BV];
dd := #BV;
mm := A!m;
X := KMatrixSpace(BaseRing(A), dd, dd)!0;
for j := 1 to dd do
   X[j] := Vector(RR[j]*mm)*ix;
end for;

        return X;

end function;

////////////////////////////////////////////////////////////////////

intrinsic SubalgebraFromBasis(A:: AlgBas, V::SeqEnum) -> AlgBas, Map
{Given a basic algebra A and the basis V of a subspace of A, the function
returns the basic algebra which is the subalgebra spanned by the subspace
and the inclusion matrix of the homomomorphism embedding the subalgebra
into A. Note that the space V might not contain the identity element of
A and in that case the identity element is added to returned subalgebra.}

k := BaseRing(A);
d := Dimension(A);
dd := #V;
UU := VectorSpace(k,d);
VV := sub<UU|[Vector(x):x in V]>;

       // This next is to insure that the subalgebra has an
       // identity, and to identify the idempotents in the
        // subalgebra. The spinning operation only guarantees
       // that it is close under multiplication and addition.

if not Vector(A!1) in VV then
   VV := sub<UU|VV, Vector(MinimalIdentity(A,[A!x:x in Basis(VV)]))>;
end if;
dop := DimensionsOfProjectiveModules(A);
if #dop eq 1 then
   loc := [1];
else
   loc := [1] cat [1+ &+[dop[j]:j in [1 ..i]]:i in [1 .. #dop-1]];
end if;

      // this is the locations of the idempotent generators. Now
      // we make the projection map onto the space of idempotents.

PR := KMatrixSpace(k,d,#dop)!0;
for i := 1 to #dop do
   PR[loc[i]][i] := 1;
end for;
VLL := sub<VectorSpace(k,#dop)|[(UU!x)*PR:x in Basis(VV)]>;
if #dop eq 1 then 
   idems := [A!1];
else
   LL := Basis(VLL);
   BV:= BasisMatrix(VV);
   elst := [x@@(BV*PR):x in LL];
   idems := [A!(x*BV): x in elst];
   for i:= 1 to #idems do
      x := idems[i];
      if not x^2 eq x then
         flag := true;
         p := Characteristic(k);
         while flag do
            x := x^p;
            if x^2 eq x then
               flag := false;
               idems[i] := x;
            end if;
         end while;
      end if;
   end for;
end if;
klst := Basis(Kernel(PR) meet VV);
if #dop eq 1 then 
   Blst := [[Vector(A!1)] cat klst];
else 
   Blst := [[Vector(y)] cat Basis(sub<VV|[Vector(y*(A!x)):x in klst]>):
                       y in idems];
end if;

        // Note that the terms of Blst are bases for the projective
        // modules for the subalgebra.
bb := #Blst;
bbl := [#x: x in Blst];
XI := [* KMatrixSpace(k,bbl[j],d)!Blst[j] : j in [1 .. bb] *];
IX := [* RightInverseMatrix(x): x in XI *];
MATLL := [ [* MakeMatrixOnSubalgebra(A,Blst[j],idems[i],XI[j],IX[j]):
      j in [1 .. bb] *]: i in [1 .. bb]];
ll1 := [[i:i in [1 .. d]|Blst[j][1][i] ne 0][1]: j in [1 ..bb]];
ll2 := [[[i-ll1[j]: i in [1 .. d]|x[i] ne 0][1]: x in Blst[j]]:
            j in [1 .. bb]];
ordd := [];
for j := 1 to d do 
   for u := 1 to #ll2 do
      for v := 1 to #ll2[u] do
         if ll2[u][v] eq j then
            Append(~ordd, <u,v>);
         end if;
      end for;
   end for;
end for;
nigens := [];
VLL := [VectorSpace(k,x):x in bbl];
WLL := [* sub<vv|>: vv in VLL *];
for xxo in ordd do
   u := xxo[1]; v := xxo[2];
   if not Basis(VLL[u])[v] in WLL[u] then
      Append(~nigens, xxo);
      Append(~MATLL, [* MakeMatrixOnSubalgebra(A,Blst[j],Blst[u][v],
                 XI[j],IX[j]): j in [1 .. bb] *]);
      for j :=1 to bb do
         X :=  WLL[j] + RowSpace(MATLL[#MATLL][j]);
      end for;
   end if;
end for;
num := #MATLL;
if num gt #idems then
 for j := 1 to bb do
   nigj := [x: x in nigens|x[1] eq j];
   F := FreeAlgebra(k,num-#idems);
   MM := AModule(F,[MatrixAlgebra(k,bbl[j])!MATLL[i][j]:
                  i in [#idems+1 .. num]]);
   J1 := sub<MM|&+[RowSpace(MATLL[i][j]): i in [#idems+1 .. num]]>;
   if Dimension(J1) ne 0 then 
      J2 := sub<J1|&+[RowSpace(Action(J1).i): i in [1 .. num-#idems]]>;
   else 
      J2 := J1;
   end if;
   if bbl[j] - Dimension(J2) lt #nigj +1 then
   
                        // this means that the generators that we have
                        // are not a minimal set.

      Q, phi := quo<MM|J2>;
      W := sub<Q|>;
      rmlst := [];
      for t := 1 to #nigj do
         if phi(Basis(MM)[nigj[t][2]]) in W then
            Append(~rmlst, Index(nigens,nigj[t]));
         else
            W := sub<Q|W, phi(Basis(MM)[nigj[t][2]])>;
         end if;
      end for;
      MATLL := [* MATLL[i]: i in [1 .. #MATLL]|not i-bb in rmlst *];
      nigens := [nigens[i]: i in [1 .. #nigens]|not i in rmlst];
   end if;
   J1 := sub<MM|&+[RowSpace(MATLL[i][j]): i in [#idems+1 .. #MATLL]]>;
   if Dimension(J1) ne 0 then 
      J2 := sub<J1|&+[RowSpace(Action(J1).i): i in [1 .. #MATLL-#idems]]>;
   else
      J2 := J1;
   end if;
   num := #MATLL;
 end for;
end if;
        // now we have the generators and the action of these generators
        // on the projective modules of the subalgebra. Next we must
        // compute the path trees and make the basic algebra of the
        // subalgebra. 
PT := [[<1,i>] : i in [1 .. #idems]];
if num eq #idems then 
   INC := KMatrixSpace(k,#idems,Dimension(A))![Vector(x):x in idems];
   ALGL := [<MatrixAlgebra<k,1|[MATLL[j][i]:j in [1 .. #idems]]>,PT[i]>:
         i in [ 1 .. #idems]];
   B := BasicAlgebra(ALGL);
else
 for i := 1 to #PT do
   PT[i] cat:= [<1, #idems+Index(nigens, x)>:x in nigens| x[1] eq i];
 end for;
 BCmats :=  [*  *];
 num := #MATLL;
 for j := 1 to bb do
   nigj := [x: x in nigens|x[1] eq j];
   vecs := [Vector(MATLL[bb+Index(nigens,x)][j][1]): x in nigj];
   BB := [Vector(MATLL[j][j][1])] cat vecs;
   F := FreeAlgebra(k,num-#idems);
   MM := AModule(F,[MatrixAlgebra(k,bbl[j])!MATLL[i][j]:
                        i in [#idems+1 .. num]]);
   J1 := sub<MM|&+[RowSpace(MATLL[i][j]): i in [#idems+1 .. num]]>;
   if Dimension(J1) ne 0 then 
      J2 := sub<J1|&+[RowSpace(Action(J1).i): i in [1 .. num-#idems]]>;
   else 
      J2 := J1;
   end if;
   J := J2;
   while Dimension(J) ne 0 do
      J := sub<J|&+[RowSpace(Action(J).i): i in [1 .. num-#idems]]>;
      dddd := Dimension(MM)-#BB-Dimension(J);
      nvecs := [];
      Q, phi := quo<MM|J>;
      W := sub<Q|>;
      wll := [];
      for i := 1 to #nigens do
         for t := 1 to #vecs do
            ss := vecs[t]*MATLL[bb+i][j];
            if not phi(ss) in W then
               Append(~nvecs, ss);
               Append(~PT[j], <#BB-#vecs+t,bb+i>);
               Append(~wll, phi(ss));
               W := sub<Q|wll>;
               if Dimension(W) eq dddd then
                  break i;
               end if;
            end if;
         end for;
      end for;
      vecs := nvecs;
      BB cat:=  vecs;
   end while;
        // now we have the path tree for projective # j. We need
        // the imbedding matrix.

   Append(~BCmats, KMatrixSpace(k,bbl[j],bbl[j])!BB);
 end for;
 BCinv := [* x^-1 : x in BCmats *];
 NXI := [* BCmats[i]*XI[i]: i in [1 .. bb] *];
 ALGL := [];
 for i := 1 to bb do
   MM := MatrixAlgebra<k,bbl[i]|
                      [BCmats[i]*MATLL[j][i]*BCinv[i]:j in [1 .. #MATLL]]>;
   Append(~ALGL,<MM,PT[i]>);
 end for;
 B := BasicAlgebra(ALGL);
 INC := KMatrixSpace(k,Dimension(B),d)!0;
 rcc := 1;
 for i := 1 to bb do
   InsertBlock(~INC, NXI[i], rcc,1);
   rcc +:= Nrows(NXI[i]);
 end for;
end if;

                return B, hom<B -> A|INC>;

end intrinsic;

/////////////////////////////////////////////////////////////

SpinAlgebra := function(A, ll);
// Finds the subalgebra of A that is generated by the elements of the
// subset ll. 

flag := true;
k := BaseRing(A);
d := Dimension(A);
V := VectorSpace(k,d);
W := sub<V|[Vector(x):x in ll]>;
if Dimension(W) eq d then
        return [A!x:x in Basis(W)];
end if;
B := [A!x:x in Basis(W)];
while flag do
   U := Basis(W); 
   WW := sub<V|U cat [Vector((A!x)*y): x in U, y in B]>;
   if Dimension(WW) eq Dimension(W) then
      flag := false;
   else
      W := WW;
   end if;
end while;

        return [A!x:x in Basis(W)];

end function;
//////////////////////////////////////////////////////////////////

intrinsic SubConstr(A:: AlgBas ,S::SeqEnum) -> AlgBas, Map
{Returns the subalgebra generated by the elements of the suquence,
together with the inclusion map of the subalgebra into A.}

XX := SpinAlgebra(A,S);
U, phi := SubalgebraFromBasis(A,XX);

return U, phi;

end intrinsic;


