freeze;

// Jon F. Carlson, June 2012

////////////////////////////////////////////////////////////////////

KMtrx := function(X);

        return KMatrixSpace(BaseRing(Parent(X)), Nrows(X), Ncols(X))!X;

end function;

////////////////////////////////////////////////////////////////////

intrinsic RandomIdealGeneratedBy(A::AlgBas,n::RngIntElt) -> ModTupFld
{Returns the ideal generated by n randomly selected elements in the
Jacobson radical of the basic algebra A.}

P := RightRegularModule(A);
np := NumberOfProjectives(A);
rrr := [Random([1..3]): i in [1 ..n]];
JP := JacobsonRadical(P);
JJP := JacobsonRadical(JP);
JJJP := JacobsonRadical(JJP);
genlst := [];
for i := 1 to n do
   if rrr[i] eq 1 then
      Append(~genlst,P!Random(JP));
   elif rrr[i] eq 2 then
      Append(~genlst,P!Random(JJP));
   else
      Append(~genlst,P!Random(JJJP));
   end if;
end for;
genlst2 := [A!Vector(x): x in genlst];

        return ideal<A|genlst>;

end intrinsic;

/////////////////////////////////////////////////////////////////////

IndHom := function(mat, phi, xi)
//{Returns a map f such that phi*f = mat*xi in the case that mat
//maps the kernel of phi into the kernel of psi. }

phi1 := KMtrx(phi);
k := CoefficientRing(mat);
n := Nrows(mat);
V := VectorSpace(k,n);
W := VectorSpace(k,Ncols(mat));
WW := [((x@@phi1)*mat)*xi: x in 
           Basis(Codomain(phi1))];
MM := KMatrixSpace(k,Ncols(phi),Ncols(xi))!WW;

        return MM;

end function;

////////////////////////////////////////////////////////////////////

intrinsic InducedHomomorphism(mat::Mtrx, phi::Mtrx,
        xi::Mtrx) -> ModMatFldElt
{Returns a map f such that phi*f = mat*xi in the case that mat
maps the kernel of phi into the kernel of psi. }

        return IndHom(mat,phi,xi);

end intrinsic;

///////////////////////////////////////////////////////////////////

RadicalPower := function(M,j);
// Returns Rad^j(M)

N := M;
if j eq 0 then
   return N;
else
   for i := 1 to j do
      N := JacobsonRadical(N);
   end for;
end if;

                return N;

end function;

////////////////////////////////////////////////////////////////////

intrinsic TruncatedAlgebra(A::AlgBas, n::RngIntElt) -> AlgBas, Map
{Returns the quotient of the algebra by the n-th power of the radical
of A. Returns also the quotient map. }

RX := MinimalGeneratorForm(A);
C := RX`Algebra;
AU := [];
for i := 1 to NumberOfProjectives(C) do
   P := ProjectiveModule(C,i);
   R := RadicalPower(P,n);
   if Dimension(R) eq 0 then
      Append(~AU,<Action(P),PathTree(C,i)>);
   else
      PP := quo<P | R>;
      Append(~AU, <MatrixAlgebra<BaseRing(C),Dimension(PP)|
                          ActionGenerators(PP)>,
                          [PathTree(C,i)[x]:x in [1 .. Dimension(PP)]]>);
   end if;
end for;
B := BasicAlgebra(AU);
mat := KMatrixSpace(BaseRing(A), Dimension(C), Dimension(B))!0;
rn := DimensionsOfProjectiveModules(C);
cn := DimensionsOfProjectiveModules(B);
ri := [0] cat [&+[rn[j]:j in [1 .. i]]:i in [1 .. #rn]];
ci := [0] cat [&+[cn[j]:j in [1 .. i]]:i in [1 .. #cn]];
for i := 1 to NumberOfProjectives(C) do
   InsertBlock(~mat, KIdentityMatrix(BaseRing(A),cn[i]),ri[i]+1, ci[i]+1);
end for;

	amat := hom<C -> B |mat>;
        return B, RX`InverseHomomorphism*amat;

end intrinsic;

///////////////////////////////////////////////////////////////////

intrinsic RightInverseMatrix(inc :: ModMatFldElt) -> ModMatFldElt
{Given the inclusion map of a subspace into a vector space, the
 function returns a matrix pr with the property that inc*pr is
 the identity map on the subspace.}

E,T := EchelonForm(inc);
pr := KMatrixSpace(BaseRing(Parent(inc)), Ncols(inc),Nrows(inc))!0;
for i := 1 to Nrows(inc) do
   for j := 1 to Ncols(inc) do
      if E[i,j] ne 0 then
         pr[j,i] := 1;
         break j;
      end if;
   end for;
end for;

        return pr*T;

end intrinsic;

///////////////////////////////////////////////////////////////////

intrinsic Centre(A:: AlgBas) -> AlgBas, Map
{Returns the center of the basic algebra as a basic algebra
and the inclusion homomorphism.}

k := BaseRing(A);
d := Dimension(A);
M := KMatrixSpace(k, d, d)!0;
V := VectorSpace(k, d);
VV := V;
for x in Generators(A) do
N := M;
for j := 1 to d do
N[j] := Vector(A.j*x-x*A.j);
end for;
VV := VV meet NullSpace(N);
end for;
R := [A!x:x in Basis(VV)];
C, phi := sub<A|R>;

        return C,   phi;

end intrinsic;

//////////////////////////////////////////////////////////////////////

intrinsic Centraliser(A:: AlgBas, S:: SeqEnum) -> AlgBas, Map
{Returns the centraliser in the basic algebra A of the elements in the
sequence S, along with the homomorphism embedding the centraliser into A.}

k := BaseRing(A);
d := Dimension(A);
M := KMatrixSpace(k, d, d)!0;
V := VectorSpace(k, d);
VV := V;
for x in S do
   N := M;
   for j := 1 to d do
      N[j] := Vector(A.j*x-x*A.j);
   end for;
   VV := VV meet NullSpace(N);
end for;
R := [A!x:x in Basis(VV)];
C, phi := sub<A|R>;

        return C,   phi;

end intrinsic;

///////////////////////////////////////////////////////////////////
/*
intrinsic Centralizer(A:: AlgBas, S:: SeqEnum) -> AlgBas, Map
{Returns the centralizer in the basic algebra A of the elements in the
sequence S, along with the homomorphism embedding the centralizer into A.}

C, phi := Centraliser(A,S);

        return C, phi;

end intrinsic;
*/
/////////////////////////////////////////////////////////////////////

intrinsic IsCentral(A::AlgBas,x::AlgBasElt) -> BoolElt
{True if the element x is in the center of the basic algebra  A.}

return &and[x*y eq y*x: y in Generators(A)];

end intrinsic;

/////////////////////////////////////////////////////////////////////

intrinsic Restriction(M::ModAlgBas, B:: AlgBas, xi::ModMatFldElt)
        -> ModAlgBas
{B is a subalgebra of the algebra A, over which the module M is defined.
The map xi is the matrix of the map of B into A. The function returns the
restriction of M to a B-module.}

A := Algebra(M);
ACT := Action(M);
dop := DimensionsOfProjectiveModules(A);
start := 0;
MA := [];
for i := 1 to #dop do
   for j := 1 to dop[i] do
      x := PathTree(A,i)[j];
      if x[1] eq 1 then
         Append(~MA,ACT.x[2]);
      else
         Append(~MA,MA[start+x[1]]*ACT.x[2]);
      end if;
   end for;
   start +:= dop[i];
end for;
NMA := [];
for i := 1 to #Generators(B) do
   xx := Vector(Generators(B)[i])*xi;
   NMA[i] := &+[xx[j]*MA[j]:j in [1 .. Dimension(A)]];
end for;
NA := AModule(B, NMA);

        return NA;

end intrinsic;


/////////////////////////////////////////////////////////////////////

intrinsic Restriction(M::ModAlgBas, B:: AlgBas, xi::Map)
        -> ModAlgBas
{B is a subalgebra of the algebra A, over which the module M is defined.
The map xi is the map of the embedding of B into A. The function returns the
restriction of M to a B-module.}

	return Restriction(M, B, Matrix(xi));

end intrinsic;

//////////////////////////////////////////////////////////////////////

intrinsic ChangeAlgebras(M::ModAlgBas, B:: AlgBas, xi::ModMatFldElt)
        -> ModAlgBas
{Given a module M over an algebra A and an algebra homomorphism xi of 
B into A, the function returns the module M as a B-module.}

        return Restriction(M, B, xi);

end intrinsic;

///////////////////////////////////////////////////////////////////////

intrinsic ChangeAlgebras(M::ModAlgBas, B:: AlgBas, xi::Map)
        -> ModAlgBas
{Given a module M over an algebra A and an algebra homomorphism xi of 
B into A, the function returns the module M as a B-module.}

        return Restriction(M, B, Matrix(xi));

end intrinsic;



//////////////////////////////////////////////////////////////////

intrinsic IsCommutative(A::AlgBas) -> BoolElt
{true if the algebra A is commutative.}

       return &and[x*y eq y*x: x in Generators(A), y in Generators(A)];

end intrinsic;

