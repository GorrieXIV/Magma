freeze;

// Jon F. Carlson, June 2012

SocleFiltrationByProjective := function(A,i);
// A is a basic algebra. The function returns a bases of the elements
// of the socle filtration.

k := BaseRing(A);
P := ProjectiveModule(A,i);
m := Dimension(P);
S := Socle(P);
sc := [[P!x: x in Basis(S)]];
flag := true;
Q := P;
SS := S;
while flag do
   if SS eq Q then
      flag := false;
   else
      QQ, sigma := quo<Q|SS>;
      SS := Socle(QQ);
      if Dimension(Q) eq Dimension(P) then
         phi := sigma;
      else
        phi := phi*sigma;
      end if;
      ss := [x@@phi:x in Basis(SS)];
      Append(~sc, ss);
      Q := QQ;
   end if;
end while;
B := &cat sc;
dims := [#x:x in sc];

        return KMatrixSpace(k,m,m)!B, dims;

end function;

///////////////////////////////////////////////////////////////////

intrinsic MinimalGeneratorForm(A::AlgBas) ->  Rec
{Returns a record consisting of an isomorphic basic algebra having 
the property that it is generated by a minimal number of element 
and the Projective modules are filtered by radical layers, the 
matrices of the isomorphism to and from the original algebra, 
the dimensions of the radical layers and the dimensions of the 
filtered layers.}

if assigned A`MinimalGeneratorForm then 
	return A`MinimalGeneratorForm;
end if;
k := BaseRing(A);
n := NumberOfProjectives(A);
NI := NonIdempotentGenerators(A);
m := #NI;
lst := [* *];
lst2 := [];
fildim := [];
dimproj := DimensionsOfProjectiveModules(A);
PP, inj, prj := DirectSum([VectorSpace(k,x):x in dimproj]);
for t := 1 to n do
   nlst := [];
   P := ProjectiveModule(A,t);
   SF, sfdim := SocleFiltrationByProjective(A,t);
   M := JacobsonRadical(P);
   mu := Morphism(M,P);
   N := JacobsonRadical(M);
   fild := [];
   Q, phi := quo<P|N>;
   for idind := 1 to n do // This is the idempotent index
      fildd := []; 
           // this is going to tell us the socle dimensions of 
           // e_tAe_{idind}
      V := sub<Q|>;
      index := sfdim[1];
      BB := [];
      for u := 1 to #sfdim-1 do
         U := sub<Q|[phi(P!SF[i])*ActionGenerators(Q)[idind]: 
                     i in [1 .. index]]>;
         if U ne V then
            BB cat:= [((ExtendBasis(V,U)[j])@@phi):
                    j in [Dimension(V)+1 .. Dimension(U)]];
            Append(~fildd, Dimension(U)-Dimension(V));
            V := U;
         end if;
         index +:= sfdim[u+1];
      end for;
      Append(~lst,Reverse(BB));
      lst2 cat:= Reverse([A!inj[t](Vector(x)): x in BB]);
      if #fildd eq 0 then 
         fild[idind] := [0];
      else  
         fild[idind] := Reverse(fildd);
      end if;
   end for;
   fildim[t] := fild;
end for;
	// lst2 is the list of the new nonidempotent generators.
	// now we must create the new projective modules and the pathtrees
NA := [];
Mat := KMatrixSpace(BaseRing(A),Dimension(A),Dimension(A))!0;
IMat := Mat;
mrct:= 1;
mcct := 1;
nigct := 0;
raddim := [];
for i := 1 to n do
   P := ProjectiveModule(A,i);
   M := JacobsonRadical(JacobsonRadical(P));
   rd1 := [Dimension(P), Dimension(P)-1, Dimension(M)];
   fd1 := [Dimension(P), Dimension(P)-1];
   base := [P.1] cat &cat [lst[(i-1)*n+j]: j in [1 .. n]];
   sd := 1;
   pt := [<1,i>] cat [<1,n+nigct+j>: j in [1 .. #base -1]];
   nigct +:= #base-1;
   while Dimension(M) gt 0 do
      M := JacobsonRadical(M);
      if Dimension(M) gt 0 then
         Append(~rd1, Dimension(M));
      end if;
      nsd := #base;
      Q, phi := quo<P|M>;
      nld := Dimension(Q);
      for t := 1 to #lst2 do
         for s := sd+1 to nsd do
            xxx := base[s]*lst2[t];
            if Rank(KMatrixSpace(k, #base+1, Dimension(Q))!
          ([Vector(phi(x)):x in base] cat [Vector(phi(xxx))]))
                                        eq (#base +1) then
               Append(~base, xxx);
               Append(~pt, <s,n+t>);
               if #base eq nld then
                  break t;
               end if;
            end if;
         end for;
      end for;
      sd := nsd;
   end while;
   U := KMatrixSpace(k,#base,#base)![Vector(x): x in base];
   V := U^(-1);
   al := ActionGenerators(P);
   matlst := [U*al[i]*V: i in [1 .. n]] cat
                                [U*RepresentationMatrix(P,x)*V: x in lst2];
   Append(~NA, <MatrixAlgebra<BaseRing(A),Dimension(P)|matlst>, pt>);
   InsertBlock(~Mat,U,mrct,mrct);
   InsertBlock(~IMat,V,mrct,mrct);
   Append(~raddim,rd1);
   mrct +:= Dimension(P);
end for;
B := BasicAlgebra(NA);
rf := recformat<Algebra:AlgBas, Homomorphism:Map, 
	InverseHomomorphism:Map, RadicalDimensions:SeqEnum,
	FilterDimensions:SeqEnum>;
stdfm := rec<rf|Algebra:= B, Homomorphism:= hom<B -> A|Mat>, 
	InverseHomomorphism := hom<A -> B|IMat>, RadicalDimensions := raddim,
	FilterDimensions := fildim>;
A`MinimalGeneratorForm := stdfm;
C := stdfm`Algebra;
Idd := IdentityMatrix(k, Dimension(A));
stdfm2 := rec<rf|Algebra:= C, Homomorphism:= hom<C -> C|Idd>,
        InverseHomomorphism := hom<C -> C|Idd>, RadicalDimensions := raddim,
        FilterDimensions := fildim>;
C`MinimalGeneratorForm := stdfm2;

	return stdfm, C;

end intrinsic;

///////////////////////////////////////////////////////////////////////

intrinsic MinimalGeneratorFormAlgebra(A: AlgBas) -> AlgBas
{Returns an isomorphic algebra having minimal generator form.}

if assigned A`MinimalGeneratorForm then
   X :=  A`MinimalGeneratorForm;
else 
   X := MinimalGeneratorForm(A);
end if;
 
	return X`Algebra;

end intrinsic; 

///////////////////////////////////////////////////////////////////////

function AssociatedGradedAlgebraData(A) 
// Returns the basic algebra that is isomorphic to the associated
// graded algebra of A, along with the graded cap isomoprhism.

if assigned A`AssociatedGradedAlgebra then
   return  A`AssociatedGradedAlgebra, A`GradedFactorIsomorphism;
end if;
MGF := MinimalGeneratorForm(A);
B := MGF`Algebra;
ff := Matrix(MGF`InverseHomomorphism);
rdims := MGF`RadicalDimensions;
BA := [];
np := NumberOfProjectives(B);
for i := 1 to np do
   rd := rdims[i] cat [0];
   MA := MatrixAlgebra(BaseRing(A),rd[1]);
   Act := Action(ProjectiveModule(B,i));
   if #rd in [2,3] then 
      BA[i] := <Act, PathTree(B,i)>;
   else 
      stops := &cat[[rd[1]-rd[i+2]+1: j in [1.. rd[i]-rd[i+1]]]:
               i in [1 .. #rd-2]];
      GEN := [MA!Act.i:i in [1 .. np]];
      for j := np+1 to Ngens(B) do  // the nonidempotent generator matrix
         S := Act.j;
         for s := 1 to #stops do  //   the row of the matrix
            for t := stops[s] to rd[1] do
               S[s,t] := 0;
            end for;
         end for;
         Append(~GEN, S);
      end for;
      BA[i] := <MatrixAlgebra<BaseRing(B),rd[1]|GEN>,PathTree(B,i)>;
   end if;
end for;
Mfg := MinimalGeneratorForm(BasicAlgebra(BA));
B := Mfg`Algebra;
gg := Matrix(Mfg`Homomorphism);
M := RightRegularModule(A);
J := JacobsonRadical(JacobsonRadical(M));
Q, phi := quo<M|J>; 
M2 := RightRegularModule(B);
J2 := JacobsonRadical(JacobsonRadical(M2));
Q2, theta := quo<M2|J2>;
mat := InducedHomomorphism(ff*gg, Matrix(phi), Matrix(theta));
A`GradedFactorIsomorphism := mat;
A`AssociatedGradedAlgebra := B;
B`AssociatedGradedAlgebra := B;
B`GradedFactorIsomorphism := IdentityMatrix(BaseRing(A), Nrows(mat));

	return B, mat;

end function;

///////////////////////////////////////////////////////////

intrinsic AssociatedGradedAlgebra(A::AlgBas) -> AlgBas
{Returns the basic algebra in minimal generator form that 
is isomorphic to the associated graded algebra of A.}

if assigned A`AssociatedGradedAlgebra then
   return  A`AssociatedGradedAlgebra;
end if;
C, mm := AssociatedGradedAlgebraData(A);

	return C;

end intrinsic;
   
///////////////////////////////////////////////////////////

intrinsic GradedFactorIsomorphism(A::AlgBas) -> AlgBas
{Returns the isomorphism from A/Rad^2(A) to X/Rad^2(X) where X
is the associated graded algebra of A.}

if assigned A`GradedFactorIsomorphism then
   return  A`GradedFactorIsomorphism;
end if;
C, mm := AssociatedGradedAlgebraData(A);

        return mm;

end intrinsic;

///////////////////////////////////////////////////////////////////////

intrinsic GradedCapHomomorphism(A::AlgBas) -> ModMatFldElt
{Returns the matrix of the map from A/Rad(A) to X/Rad(X) where 
X is the associated graded algebra of A. }

MFG := MinimalGeneratorForm(A);
rdims := MFG`RadicalDimensions;
dpm := DimensionsOfProjectiveModules(A);
np := NumberOfProjectives(A);
phi := Matrix(MFG`Homomorphism);
dpm := DimensionsOfProjectiveModules(A);
tdims := [];
sdims1 := [1];
sdims2 := [1];
for i := 1 to #dpm do
   tdims[i] := dpm[i] - rdims[i][3];
   sdims1[i+1] := sdims1[i] + dpm[i];
   sdims2[i+1] := sdims2[i] + tdims[i];
end for;
MMM := KMatrixSpace(BaseRing(A), &+tdims, &+tdims)!0;
for i := 1 to #dpm do
   InsertBlock(~MMM, Submatrix(phi, sdims1[i], sdims1[i],tdims[i], tdims[i]),
                sdims2[i], sdims2[i]);
end for;

	return MMM;

end intrinsic;

///////////////////////////////////////////////////////////////////////

intrinsic GradedCapHomomorphism(A::AlgBas, B::AlgBas, mu:ModMatFldElt) ->
		ModMatFldElt
{Given an algebra homomorphism mu: A -> B, returns the induced homomorphism
A/Rad^2(A) -> B/Rad^2(B), where Rad^2 is the second power of the Jacobson
Radical.}

MFGa := MinimalGeneratorForm(A);
rdimsa := MFGa`RadicalDimensions;
dpma := DimensionsOfProjectiveModules(A);
npa := NumberOfProjectives(A);
dpma := DimensionsOfProjectiveModules(A);

MFGb := MinimalGeneratorForm(B);
rdimsb := MFGb`RadicalDimensions;
dpmb := DimensionsOfProjectiveModules(B);
npb := NumberOfProjectives(B);
dpmb := DimensionsOfProjectiveModules(B);

tdimsa := [];
sdims1a := [1];
sdims2a := [1];
for i := 1 to #dpma do
   tdimsa[i] := dpma[i] - rdimsa[i][3];
   sdims1a[i+1] := sdims1a[i] + dpma[i];
   sdims2a[i+1] := sdims2a[i] + tdimsa[i];
end for;

tdimsb := [];
sdims1b := [1];
sdims2b := [1];
for i := 1 to #dpmb do
   tdimsb[i] := dpmb[i] - rdimsb[i][3];
   sdims1b[i+1] := sdims1b[i] + dpmb[i];
   sdims2b[i+1] := sdims2b[i] + tdimsb[i];
end for;

MMM := KMatrixSpace(BaseRing(A), &+tdimsa, &+tdimsb)!0;
for i := 1 to #dpma do
   for j := 1 to #dpmb do
      InsertBlock(~MMM, Submatrix(mu, sdims1a[i], 
                     sdims1b[j],tdimsa[i], tdimsb[j]),
                sdims2a[i], sdims2b[j]);
   end for;
end for;

	return MMM;

end intrinsic;
