freeze;

/*
AKS, Aug 2008.
*/

/*******************************************************************************
                            Matrix/vector things
*******************************************************************************/

intrinsic Matrix(Q::[ModMPolElt]) -> Mtrx
{The matrix whose rows are given by the elements of Q}
    M := Universe(Q);
    return Matrix(BaseRing(M), #Q, Degree(M), &cat[Eltseq(v): v in Q]);
end intrinsic;

intrinsic Vector(v::ModMPolElt) -> Mtrx
{The vector (dense matrix representation) corresponding to v};
    return Vector(Eltseq(v));
end intrinsic;

intrinsic UnitVector(M::ModMPol, i::RngIntElt) -> ModMPolElt
{Return Ambient(M)![0, ..., 0, 1, 0, ..., 0] where the 1 is in the
i-th position}
    requirerange i, 1, Degree(M);
    v := Ambient(M)!0;
    v[i] := 1;
    return v;
end intrinsic;

/*******************************************************************************
                            Basis operations
*******************************************************************************/

intrinsic IsHomogeneous(S::{[ModMPolElt]}) -> BoolElt
{Return whether all the polynomials in set/sequence S are homogeneous
w.r.t the grading of their parent.}
    return forall{f: f in S | IsHomogeneous(f)};
end intrinsic;

intrinsic MinimalBasis(S::{[ModMPolElt]}) -> []
{A minimal basis of the submodule generated by the set/sequence S.}

    return MinimalBasis(sub<Universe(S) | S>);
end intrinsic;
