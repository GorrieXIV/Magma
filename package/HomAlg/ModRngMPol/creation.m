freeze;

/*
AKS, Dec 2004.
*/

have_modules := func<I | IsField(BaseRing(I))>;

/*******************************************************************************
			    Module from ideal
*******************************************************************************/

function get_module_and_basis(B)
    I := Universe(B);
    R := Generic(I);
    if IsHomogeneous(B) and Type(I) in {RngMPol, RngMPolLoc} then
	F := GradedModule(R, [0]);
    else
	F := RModule(R, 1);
    end if;
    return F, [F | [f]: f in B];
end function;

function get_module_and_basis_I(I)
    return get_module_and_basis(SmallBasis(I));
end function;

intrinsic QuotientModule(I::GenMPol) -> ModMPol
{The reduced quotient module of R^1/I for ideal I};

    require have_modules(I): "Base ring must be a field";
    F, B := get_module_and_basis_I(I);
    return quo<F | B>;
end intrinsic;

intrinsic GradedModule(I::GenMPol) -> ModMPol
{The graded quotient module of R^1/I for ideal I}
    require IsHomogeneous(SmallBasis(I)): "Small basis of I is not homogeneous";
    return QuotientModule(I);
end intrinsic;

intrinsic Submodule(I::GenMPol) -> ModMPol
{The reduced submodule of R^1 generated by the ideal I}
    require have_modules(I): "Base ring must be a field";
    F, B := get_module_and_basis_I(I);
    return sub<F | B>;
end intrinsic;

/*******************************************************************************
			    Module from setq	
*******************************************************************************/

intrinsic QuotientModule(S::Setq[GenMPolElt]) -> ModMPol
{The reduced quotient module of R^1 divided by the ideal generated by S}
    require have_modules(Universe(S)): "Base ring must be a field";
    F, B := get_module_and_basis(S);
    return quo<F | B>;
end intrinsic;

intrinsic Submodule(S::Setq[GenMPolElt]) -> ModMPol
{The reduced submodule of R^1 generated by the ideal generated by S}
    require have_modules(Universe(S)): "Base ring must be a field";
    F, B := get_module_and_basis(S);
    return sub<F | B>;
end intrinsic;
