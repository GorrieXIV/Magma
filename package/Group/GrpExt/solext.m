freeze;
 
import "degred.m":  DegreeReductionH; 
intrinsic ExtensionsOfSolubleGroup
         (H :: GrpPerm, G :: GrpPerm) -> SeqEnum
{All extensions (up to isomorphism) of soluble group H by group G}
  
  local L, extensions, newextensions, candidates, gp, fac, nGgens, nHgens,
        oldnHgens, HQ, HQS, phi, F, gptoF, rels, Hrels, w, hw, N, centquot,
        Nmoddegs, cord;
  if not IsSoluble(H) then
     error "First argument must be a soluble group";
  end if;

  L := ElementaryAbelianSeries(H);
  if #L eq 1 then
    return [FPGroup(G:StrongGenerators:=false)];
  end if;

  vprint GrpExt,1: "LEVEL:",1;
  fac := Factorisation(Index(H,L[2]));
  vprint GrpExt,1: "  Layer size",fac;
  extensions :=
          ExtensionsOfElementaryAbelianGroup(fac[1][1],fac[1][2],G);
  vprint GrpExt,1: #extensions,"EXTENSIONS";
  
  if #L eq 2 then
    return extensions;
  end if;

  nGgens := Ngens(G);
  nHgens := fac[1][2];
  /* At any given stage, then extensions have  nGgens+nHgens generators, the
   * first nGgens coming from G and the remainder from H.
   */
  cord := #G; //current order of quotient
  for level in [2..#L-1] do
    vprint GrpExt,1: "LEVEL:",level;
    cord *:= fac[1][1]^fac[1][2];
    Nmoddegs := Sort([Dimension(m) :
                     m in CompositionFactors(GModule(H,L[level],L[level+1]))]);
    //degrees of constituents of L/[level]/L[level+1] as H-module
    fac := Factorisation(Index(L[level],L[level+1]));
    vprint GrpExt,1: "  Layer size",fac;
    oldnHgens := nHgens;
    nHgens +:= fac[1][2];
    // form HQ = H/L[level+1].
    if level eq #L-1 then
      HQ := H;
      HQS := L[level];
    else
      phi, HQ := CosetAction(H,L[level+1]);
      HQS := phi(L[level]);
    end if;
    centquot := HQS subset Centre(HQ);
    newextensions:=[];
    for ext in extensions do
      gp := CosetImage(ext,sub<ext|>);
      AssertAttribute(gp,"Order",cord);
      RandomSchreier(gp);
      //use regular reptn, for now - perhaps try to improve on this later?
      gp := DegreeReductionH(gp);
      vprint GrpExt,1: "  Next extension. Degree:",Degree(gp);
      gp := sub< Sym(Degree(gp)) | [gp.i : i in [1..Ngens(gp)]] >;
      N := sub<gp | [gp.i : i in [nGgens+1..nGgens+oldnHgens]] >;
      proj := hom< gp-> G | [G.i : i in [1..nGgens]] cat
                            [Id(G) : i in [nGgens+1..nGgens+oldnHgens]] >;
      // set up the next layer as an N-module
      candidates := ExtensionsOfElementaryAbelianGroup
                   (fac[1][1],fac[1][2],gp,<ext,N,Nmoddegs,centquot,G,proj>);
      // if HQ is abelian, then N acts trivially on the modules.

      for cand in candidates do
      /* see if the subgroup generated by the last nHgens generators is
       * isomorphic to HQ. If so, we want it!
       * Our presentation of cand should include a presentation of this
       * subgroup.
       */
         vprint GrpExt,2: "    Next Cand:";
         F := FreeGroup(nHgens); 
         gptoF := hom< cand->F | [Id(F) : i in [1..nGgens]] cat
                               [F.(i-nGgens) : i in [nGgens+1..Ngens(cand)]] >;
         rels := Relations(cand);
         Hrels := [];
         for rel in rels do
           w := ElementToSequence(LHS(rel)*RHS(rel)^-1);
           hw := true;
           for g in w do
             if Abs(g) le nGgens then
                      // word contains a G-generator so we don't want it.
               hw := false;
               break;
             end if;
           end for;
           if hw then
             Append(~Hrels,gptoF(LHS(rel)*RHS(rel)^-1));
           end if;
         end for;
         HQcand := quo< F | Hrels >;
         HQcand := CosetImage(HQcand,sub<HQcand|>);
           //again use regular perm. rep.
         // if IsIsomorphic(HQ,HQcand) then
         //   Append(~newextensions,cand);
         // end if;

         if #Factorisation(#HQ) eq 1 then
           if IsIsomorphic(PCGroup(HQ),PCGroup(HQcand)) then
             Append(~newextensions,cand);
           end if;
         elif IsIsomorphic(HQ,HQcand) then
           Append(~newextensions,cand);
         end if;

      end for;
    end for;
    extensions := newextensions;
    vprint GrpExt,1: #extensions,"EXTENSIONS";
  end for;

  return extensions;
end intrinsic;
