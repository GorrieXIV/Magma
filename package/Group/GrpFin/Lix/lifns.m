freeze;

forward LowIndexSubgroupsH, ExtendLowIndexSubgroupsH;
import "extend1sub.m":ExtendOneSubgroupH;
import "../../GrpMat/LMG/radquot.m" : GetRadquotPermGp;
import "../../GrpPerm/max/extend1submodn.m" :  ExtendOneSubgroupModN;

LowIndexSubgroupsRecursive := function(G,maxind :
                                           Presentation:=false, Print:=0)
/* Should only be called on TF-group with composition factors not in database.
 */
  local maxsi, si, stabpt, stabsubs;

  maxsi := 1;
  stabpt := 1;
  for o in {Representative(o): o in Orbits(G)} do
    si := Index(G,Stabiliser(G,o));
    if si gt maxsi then
      maxsi := si;
      stabpt := o;
    end if;
  end for;

  if Print gt 0 then
    print
       "Composition factor not in database. Trying stabilizer of point",stabpt;
  end if;

  stabsubs := LowIndexSubgroupsH(Stabiliser(G,stabpt),maxind: Print:=Print);

  if Print gt 0 then
    print "Found",#stabsubs,"subgroups of stabiliser";
  end if;

  return ExtendLowIndexSubgroupsH(G,stabpt,maxind:
                   Presentation:=Presentation, Print:=Print, ss:=stabsubs);

end function;


forward MustCover, LISubsModN;
LowIndexSubgroupsH := function(G,maxind:
                            Presentation:=false, Print:=0, trynormsub:=false)
/* Subgroup records are returned.
 * We do it first for the radical quotient, and then use lifting.
 * If Presentation is true, then presentations are computed.
 * if trynormsub is true then we look at the socle factors of the radical
 * quotient and check whether any of them have no subgps of index at most
 * maxind
 */ 
  local lisubs, lisubsl, H, Hind, ind, new, calcpres, ct, L, Q, pQ, oQ, S, M,
        MM, mm, s, Res, f, phi, nms, RF, SF, normnos, k, N, cancontinue, done,
         radprimes;

  RF := recformat<order, length, subgroup, presentation, index>;
  L:=ElementaryAbelianSeries(G);
  if Print ge 1 then
     print "Elementary abelian series of length:",#L-1;
     print "Layer sizes:", [Index(L[i],L[i+1]): i in [1..#L-1]];
  end if;
  radprimes := { t[1] : t in FactoredOrder(L[1]) };

  /* First get subgroups of radical quotient */
  
  Q, pQ := RadicalQuotient(G);
  if trynormsub and not Presentation then
    //cannot compute presentations when we work mod normal subgroup
    SF := SocleFactors(Q);
    normnos := [ i :  i in [1..#SF] | MustCover(SF[i],maxind,radprimes) ];
    if #normnos gt 0 then
      //we can work modulo N^\infty, where N is inverse image of
      //covered socle factors
      N := sub< Q | [ SF[i] : i in normnos] > @@ pQ;
      while not IsPerfect(N) do N := DerivedGroup(N); end while;
      if Print ge 1 then
        "Working modulo normal subgroup generated by large simple groups";
      end if;
      return LISubsModN(G,N,maxind : Print:=Print);
    end if;
  end if;
  oQ := #Q;
  calcpres := #L eq 1 select Presentation else true;

  done := false;
  if L[1] eq G then // group is soluble
    lisubs := Subgroups(Q:Presentation:=calcpres);
    done := true;
  elif oQ le 100000 then
    M := Subgroups(Q : Presentation:=calcpres, IndexLimit := maxind);
    assert forall{m : m in M | (oQ div m`order) le maxind};
    lisubs := [m : m in M | (oQ div m`order) le maxind];
    Sort(~lisubs,func<x,y|y`order-x`order>);
    done := true;
  elif trynormsub then //perhaps we can ignore subgps not in database
    SF := SocleFactors(Q);
    normnos := [ i :  i in [1..#SF] | not MustCover(SF[i],maxind,radprimes) ];
    cancontinue := forall{i: i in normnos | HasComputableSubgroups(SF[i])};
  else cancontinue := HasComputableSubgroups(Q);
  end if;
  
  if not done and cancontinue then 
    M := MaximalSubgroupsH(Q,sub<Q|>:maxind:=maxind,radprimes:=radprimes,
                                     Presentation:=calcpres, Print:=Print);
    lisubs := [m : m in M | (oQ div m`order) le maxind];
    /* Need to append Q itself */
    mm := rec <RF | subgroup:=Q, length:=1, order := #Q >;
    Append(~lisubs,mm);
    Sort(~lisubs,func<x,y|y`order-x`order>);
    ct := 2;
    while ct le #lisubs do
      H := lisubs[ct]`subgroup;
      if Print gt 1 then
        print ct, "Index:", Index(Q,H);
      end if;
      if 2*Index(Q,H) gt maxind then
        break;
      end if;
      M := MaximalSubgroupsH(H,sub<H|>: maxind:=maxind,radprimes:=radprimes,
                                          Presentation:=calcpres, Print:=Print);
      for i in [1..#M] do
        S := M[i]`subgroup;
        ind := Index(Q,S);
        if ind le maxind then
          new :=true;
          for j in [ct+1..#lisubs] do
            K := lisubs[j]`subgroup;
            if IsConjugate(Q,S,K) then
              new:=false;
              break;
            end if;
          end for;
          if new then
            M[i]`length := Index(Q,Normaliser(Q,S));
            Append(~lisubs,M[i]);
            if Print gt 1 then
              print "  New: index",ind;
            end if;
            if ind lt Index(Q,lisubs[#lisubs-1]`subgroup) then
               Sort(~lisubs,func<x,y|y`order-x`order>);
            end if;
          end if;
        end if;
      end for;
      ct := ct+1;
    end while;
  elif not done then lisubs := LowIndexSubgroupsRecursive(Q,maxind:
                                        Print:=Print, Presentation:=calcpres);
  end if;

  //Presentation option of Maximal Subgroups is not always working!
  if calcpres then
    for i in [1..#lisubs] do
      if not assigned lisubs[i]`presentation then
        f,phi := FPGroupStrong(lisubs[i]`subgroup);
        lisubs[i]`presentation := f;
        lisubs[i]`subgroup := sub<Q | [phi(f.i) : i in [1..Ngens(f)] ]>;
      end if;
    end for;
  end if;

  lisubsl := [];
  for i in [1..#lisubs] do
    newrec := rec< RF | >;
    newrec`order := lisubs[i]`order;
    newrec`length := lisubs[i]`length;
    if calcpres then
      newrec`presentation := lisubs[i]`presentation;
    end if;
    S := lisubs[i]`subgroup;
    newrec`subgroup :=
                      sub< G | [(S.i) @@ pQ : i in [1..Ngens(S)] ] >; 
    newrec`index := Index(G, sub<G | newrec`subgroup, L[1] > );
    Append(~lisubsl, newrec);
  end for;
  lisubs := lisubsl;

  lisubsfinal := [];
  for i in [1..#L-1] do
    calcpres := i eq #L-1 select Presentation else true;
    lisubsl := [];
    if Print ge 1 then
      print "Extending through layer size ",#L[i]/#L[i+1];
      print #lisubs,"subgroups";
      print "orders:", [subrec`order : subrec in lisubs];
    end if;
    ct:=0;
    for subrec in lisubs do
      ct +:= 1;
      if Print gt 1 then
        print "Lifting subgroup number",ct,"of",#lisubs,"of order",
                subrec`order;
      end if;
      lisubse :=
        ExtendOneSubgroupH(G,L[i],L[i+1],subrec,maxind,calcpres:Print:=Print);
      for subrece in lisubse do
        cps := subrece;
        if cps`index gt maxind div 2 then
          cps`subgroup := sub< G | subrece`subgroup, L[i+1] >; 
          cps`order := #G div cps`index;
          Append(~lisubsfinal, cps);
        else
          Append(~lisubsl, subrece);
        end if;
      end for;
    end for;
    lisubs := lisubsl;
  end for;

  lisubs := lisubsfinal cat lisubsl;
  Sort(~lisubs,func<x,y|y`order-x`order>);
  for i in [1..#lisubs] do
    AssertAttribute(lisubs[i]`subgroup,"Order",lisubs[i]`order);
  end for;

  return lisubs;
end function;

CheckInt := function(G,K,stabpt,g)
/* K should be a subgroup of Stabiliser(G,stabpt), where G is a transitive
 * permutation group, and g an element of G. We want to test whether
 * K = Stabiliser(<K,g>,stabpt). This function does some quick tests and
 * returns false if it finds that this is not the case, and true
 * if it fails to come to a conclusion.
 */
 local L, O, o, gg;
 o := Order(g);
 if o eq 1 then
   return true;
 end if;
 L := sub<G|K,g>;
 O := Orbit(L,stabpt);
 for i in [1..10] do
   gg := g^Random([1..o-1])*Random(K)*g^Random([1..o-1])*Random(K);
         //g^Random([1..o-1])*Random(K);
   _,h := IsConjugate(L,stabpt,stabpt^gg);
   if not gg*h^-1 in K then
      return false;
   end if;
 end for;
 return true;
end function;

ExtendLowIndexSubgroupsH := function(G,stabpt,maxind:
           Print:=0, Presentation:=false, ss:=[], all:=false, attempt:=false)
/* For the case when G is too large to apply MaximalSubgroups directly,
 * but H = Stabiliser(G,stabpt) for some stabpt is not too large, then apply
 * LowIndexSubgroupsH first to H, and then see which subgroups * extend to G.
 * If the sequence ss is nonempty then it is used as the list of subgroups of
 * the stabiliser
 */
  local H, lisubsH, lisubs, orbreps, g, h, new, L, LS, ind, ca, ci, ext, ct, N,
        RF, subct, lisubsHnew, NG, F, phi, gct;
  H := Stabiliser(G,stabpt);
  if #ss ne 0 then
    lisubsH := ss;
  else
    lisubsH := LowIndexSubgroupsH(H,maxind:Print:=Print);
    if attempt then
       // Can we exclude subgroups conjugate under the action of G?
      lisubsHnew:=[];
      for s in lisubsH do
        new:=true;
        for t in lisubsHnew do
          if IsConjugate(G,s`subgroup,t`subgroup) then
            new:=false;
            break;
          end if;
        end for;
        if new then Append(~lisubsHnew,s); end if;
      end for;
      lisubsH := lisubsHnew;
    end if;
  end if;
  RF := Format(lisubsH[1]);
  lisubs := [rec<RF|subgroup:=G, order:=#G,length:=1>];

  if Print gt 1 then
    print #lisubsH, "SUBGROUPS TO EXTEND!";
  end if;

  subct:=0;
  for LF in lisubsH do
    L := LF`subgroup;
    subct+:=1;
    if Print gt 1 then
      print subct, "Stab sub index", #H div LF`order;
    end if;
    ca, ci := CosetAction(H,L);
    ind := Index(G,L);
    if all or ind le maxind then
        new :=true;
        for K in lisubs do
          if IsConjugate(G,L,K`subgroup) then
            new:=false;
            break;
          end if;
        end for;
        if new then
           Append(~lisubs,
             rec<RF|subgroup:=L, order:=#L,length:=Index(G,Normaliser(G,L))> );
           if Print gt 1 then
             print "  New: index",ind;
           end if;
           if ind lt Index(G,lisubs[#lisubs-1]`subgroup) then
              Sort(~lisubs,func<x,y|y`order-x`order>);
           end if;
        end if;
    end if;
    ext := [];
      // this will be the list of proper subgroups of G with stabiliser L
/* Theory of algorithm below:
    We are looking at subgroups <L,g> for g in G - we try to
    restrict the g that we need to consider.
    (i) Since <L,g> = <L,gl> for any l in L, choose one g for each
        orbit of L, such that 1^g = x for x orbit rep. of L.
        For each such g in (i), we need to consider hg for h in H, and
        we try to restrict the h that we need consider.
    (ii) Clearly we can restrict to right coset reps. of L in H.
   (iii) Better - for any l in (H meet gLg^-1), <L, hlg> = <L, hg>,
         so we can use orbit reps. of (H meet gLg^-1) in the right
         coset action of H on the cosets of L.
*/
    orbreps := [Representative(o) : o in Orbits(L) | o ne {stabpt} ];
    // restrict to stabpt^G
    orbreps := [o: o in orbreps | o in Orbit(G,stabpt)];
    gct := 0;
    for o in orbreps do
      // restriction (i) above
      _, g := IsConjugate(G,stabpt,o);
      LS := Stabiliser(L,o); // = L meet g^-1 H g
      Lorbreps := [Representative(lo) : lo in Orbits(ca(LS^(g^-1))) ];
      // LS^(g^-1)) = (H meet gLg^-1) - see (iii) above.

      for lo in Lorbreps do
        _, h := IsConjugate(ci,1,lo);
        h := h@@ca;
        N := sub< G | L, h*g >;
        gct +:= 1;
        if CheckInt(G,L,stabpt,h*g) and Stabiliser(N,stabpt) eq L then
          ind := Index(G,N);
          if Print gt 1 then
            print "  Extends to index in G:",ind;
          end if;
          if not N in ext then
            Append(~ext,N);
          end if;
        end if;
      end for;
    end for;
    if Print gt 1 then
      print "Tried",gct,"elements to adjoin to K";
    end if;

    if Print gt 1 then
      print #ext,"extensions for this subgroup of the stabiliser";
    end if;
    /* now see if any pair of groups in ext generates a larger group */
    ct := 2;
    while ct le #ext do
      for ct2 in [1..ct-1] do
        N := sub< G | ext[ct], ext[ct2] >;
        if CheckInt(G,ext[ct],stabpt,Random(ext[ct2])) and
                                               Stabiliser(N,stabpt) eq L then
          ind := Index(G,N);
          if Print gt 1 then
            print " Larger extension of index in G:",ind;
          end if;
          if not N in ext then
            Append(~ext,N);
          end if;
        end if;
      end for;
      ct := ct+1;
    end while;

    /* Now see which extensions are new subgroups of G */
    for N in ext do
      ind := Index(G,N);
      if all or ind le maxind then
        new :=true;
        for K in lisubs do
          if IsConjugate(G,N,K`subgroup) then
            new:=false;
            break;
          end if;
        end for;
        if new then
          Append(~lisubs,
             rec<RF|subgroup:=N, order:=#N,length:=Index(G,Normaliser(G,N))> );
          if Print gt 1 then
            print "  New: index",ind;
          end if;
          if ind lt Index(G,lisubs[#lisubs-1]`subgroup) then
            Sort(~lisubs,func<x,y|y`order-x`order>);
          end if;
        end if;
      end if;
    end for;

  end for; //loop over subgroups of H

  if Presentation then
    //simply have to compute them!
    if Print gt 1 then
      print "Calculating presentations";
    end if;
    for i in [1..#lisubs] do
      N := lisubs[i]`subgroup;
      if #N le 5000 then
        F,phi := FPGroup(N);
      else
        F,phi := FPGroupStrong(N);
        lisubs[i]`subgroup := sub<G | [phi(F.i) : i in [1..Ngens(F)] ]>;
      end if;
      lisubs[i]`presentation := F;
    end for;
  end if; 

  return lisubs;
end function;

LISubsModN := function(G,N,maxind : Print:=0)
/* Find subgroups of permutation or matrix group G that contain normal
 * subgp N of index up to maxind
 */
  local RF, Q, pQ, R, QN, NtoQ, QmodN, GtoQmodN, M, mm, f, phi, s, pres,
        prestosub, mods, relim, MM, Res, ss, L, subs, ans, t, u, lisubs,
        lisubsl,lisubsfinal,lisubse, subrece, S, T, NR, LG;
  RF := recformat<order, length, subgroup, index, presentation, modifiers>;
  //The modifiers are elements of N outside of radical with which we multiply
  //relators to get values in radical.

  Q, pQ, R := RadicalQuotient(G);
  QN := pQ(N);
  NtoQ := hom< N->Q | [ pQ(N.i) : i in [1..Ngens(N)]] >;
  //we need a perm rep of Q/QN.
  QmodN, GtoQmodN := GetRadquotPermGp(G,N);
  if Print gt 1 then
    "  Found perm rep of degree", Degree(QmodN);
  end if;
  //find maximal elementary abelian series above N
  if Type(G) eq GrpPerm then
    L := ElementaryAbelianSeries(G, N meet R);
  else //function does not exist for type GrpMat
    NR := N meet R;
    LG := ElementaryAbelianSeries(G);
    L := [ NR ];
    for i in [#LG-1 .. 1 by -1] do
      s := sub< G | LG[i], NR >;
      if s ne L[#L] then Append(~L,s); end if;
    end for;
    L := Reverse(L);
  end if;
  lisubs :=
         LowIndexSubgroupsH(QmodN, maxind :Print:=Print,Presentation:=true);
  if Print gt 1 then
    "  ", #lisubs, "subgroups of radical mod N";
  end if;
  Sort(~lisubs,func<x,y|y`order-x`order>);
  lisubsl := [];
  lisubsfinal := [];
  if Print gt 2 then
    "    Calculating modifiers";
  end if;
  for i in [1..#lisubs] do
    newrec := rec< RF | >;
    newrec`order := lisubs[i]`order;
    newrec`length := lisubs[i]`length;
    S := lisubs[i]`subgroup;
    //if Ngens(S) eq 0 then S := sub< S | S.0 >; end if;
    newrec`subgroup :=
                 sub< G | [(S.i) @@ GtoQmodN : i in [1..Ngens(S)] ] >;
    T := sub<G | newrec`subgroup, L[1] >;
    for g in Generators(N) do if not g in T then
      T := sub< G | T, g >;
    end if; end for;
    newrec`index := Index(G, T );
    if 2*newrec`index gt maxind or #L eq 1 then  
      newrec`subgroup := T;
      newrec`order := #G div newrec`index;
      Append(~lisubsfinal, newrec);
    else
      newrec`presentation := lisubs[i]`presentation;
      // now calculate modifiers
      pres := newrec`presentation;
      S := newrec`subgroup;
      prestosub := Ngens(S) eq 0 select hom< pres->S | [Id(S)] >
      else hom< pres->S | [S.i : i in [1..Ngens(S)]] >;
      mods := [];
      for rel in Relations(pres) do
        relim := (LHS(rel) * RHS(rel)^-1) @ prestosub @ pQ;
        assert relim in QN;
        Append(~mods, (relim^-1) @@ NtoQ);
      end for;
      newrec`modifiers := mods;
      Append(~lisubsl, newrec);
    end if;
  end for;
  lisubs := lisubsl;

  for i in [1..#L-1] do
    if Print ge 1 then
      print "Lifting through layer",i,"of size",a,"^",b where
       a:=c[1][1] where b:=c[1][2] where c:= Factorisation(Index(L[i],L[i+1]));
    end if;
    calcpres := i lt #L-1;
    lisubsl := [];
    ct := 0;
    for subrec in lisubs do
      ct +:= 1;
      if Print gt 1 then
        print "    Lifting subgroup number",ct,"of",#lisubs,"of order",
                subrec`order;
      end if;
      lisubse := ExtendOneSubgroupModN(
                 G,N,pQ,NtoQ,L[i],L[i+1],subrec,maxind,calcpres:Print:=Print);
      if Print gt 1 then
        print "    That subgroup number produced",#lisubse,"lifts.";
      end if;
      for subrece in lisubse do
        cps := subrece;
        if cps`index gt maxind div 2 then
          cps`subgroup := sub< G | subrece`subgroup, L[i+1] >;
          for g in Generators(N) do if not g in cps`subgroup then
            cps`subgroup := sub< G | cps`subgroup, g >;
          end if; end for;
          cps`order := #G div cps`index;
          if assigned cps`presentation then delete cps`presentation; end if;
          if assigned cps`modifiers then delete cps`modifiers; end if;
          Append(~lisubsfinal, cps);
        else
          Append(~lisubsl, subrece);
        end if;
      end for;
    end for;
    lisubs := lisubsl;
  end for;

  for subrece in lisubsl do
    cps := subrece;
    cps`subgroup := sub< G | subrece`subgroup, N >;
    cps`order := #G div cps`index;
    if assigned cps`presentation then delete cps`presentation; end if;
    if assigned cps`modifiers then delete cps`modifiers; end if;
    Append(~lisubsfinal, cps);
  end for;
  Sort(~lisubsfinal,func<x,y|y`order-x`order>);
  return lisubsfinal;
end function;

SimpleGroupMinimalDegree := function(tup)
//tup is a tuple as returned by SimpleGroupName
//return the minimal degree of a faithful permutation representation
  local s, q, r, d;
  s:=tup[1]; r:=tup[2]; q:=tup[3];
  if s cmpeq "A" then //linear
    d:=r+1;
    if d eq 2 and q eq 5 then return 5; end if;
    if d eq 2 and q eq 7 then return 7; end if;
    if d eq 2 and q eq 9 then return 6; end if;
    if d eq 2 and q eq 11 then return 11; end if;
    if d eq 4 and q eq 2 then return 8; end if;
    return (q^d - 1) div (q - 1);
  end if;
  if s cmpeq "2A" then //unitary
    d:=r+1;
    if d eq 3 and q eq 5 then return 50; end if;
    if d eq 3 then return q^3+1; end if;
    if d eq 4 then return (q^3+1)*(q+1); end if;
    if IsEven(d) and d ge 6 and q eq 2 then
      return 2^(d-1)*(2^d-1) div 3;
    end if;
    return (q^d-(-1)^d)*(q^(d-1)-(-1)^(d-1)) div (q^2-1);
  end if;
  if s cmpeq "C" then //symplectic
    if q eq 3 and r eq 2 then return 27; end if;
   if q eq 2 then return 2^(r-1)*(2^r-1); end if;
   return (q^(2*r)-1) div (q-1);
  end if;
  if s cmpeq "B" then //orthogonal odd degree
    if q eq 3 then return 3^r*(3^r-1) div 2; end if;
    return (q^(2*r)-1) div (q-1);
  end if;
  if s cmpeq "D" then //orthogonal plus, even degree
    if q eq 2 or q eq 3 then return q^(r-1)*(q^r-1) div (q-1); end if;
    return (q^r-1)*(q^(r-1)+1) div (q-1);
  end if;
  if s cmpeq "2D" then //orthogonal minus, even degree
    return (q^r+1)*(q^(r-1)-1) div (q-1);
  end if;
  if s cmpeq "2B" then //Sz
    assert IsEven(q);
    return q^2+1;
  end if;
  if s cmpeq "G" then //G2
    if q eq 3 then return 351; end if;
    if q eq 4 then return 416; end if;
    return (q^6-1) div (q-1);
  end if;
  if s cmpeq "2G" then //Small Ree
    assert q mod 3 eq 0;
    return q^3+1;
  end if;
  if s cmpeq "3D" then //twisted D4
    assert r eq 4;
    return (q^8+q^4+1)*(q+1);
  end if;
  if s cmpeq "F" then //F4
    assert r eq 4;
    return (q^12-1)*(q^4+1) div (q-1);
  end if;
  if s cmpeq "2F" then //Big Ree
    assert IsEven(q);
    assert r eq 4;
    if q eq 2 then return 1600; end if;
    return (q^6+1)*(q^3+1)*(q+1);
  end if;
  if s cmpeq "E" then //E6,E7,E8
    assert r in {6,7,8};
    if r eq 6 then return (q^9-1)*(q^8+q^4+1) div (q-1); end if;
    if r eq 7 then return (q^14-1)*(q^9+1)*(q^5+1) div (q-1); end if;
    return (q^30-1)*(q^12+1)*(q^10+1)*(q^6+1) div q-1;
  end if;
  if s cmpeq "2E" then //2E6
    assert r eq 6;
    return (q^12-1)*(q^6-q^3+1)*(q^4+1) div q-1;
  end if;
  if s cmpeq 17 then //A_n
    return r;
  end if;
  if s eq 18 then //sporadic
    return
      case < q |
        "M11" : 11,
        "M12" : 12,
        "M22" : 22,
        "M23" : 23,
        "M24" : 24,
         "J1" : 266,
         "HS" : 100,
         "J2" : 100,
        "McL" : 275,
        "Suz" : 1782,
         "J3" : 6156,
        "Co1" : 98280,
        "Co2" : 2300,
        "Co3" : 276,
         "He" : 2058,
       "Fi22" : 3510,
       "Fi23" : 31671,
       "Fi24" : 0,
         "Ly" : 8835156,
         "Ru" : 4060,
         "ON" : 122760,
         "Th" : 0,
         "HN" : 1140000,
         "BM" : 0,
          "M" : 0,
         "J4" : 0,
     default  :  0  >;
  end if;
end function;

MustCover := function(S,maxind,primes)
/* This returns true if, whenever the simple group S is a composition factor
 * of G then any subgroup of G of index at most maxind must contain the
 * perfect residual of the inverse image of S in G.
 * This could be improved by using information about minimal dimensions
 * of modules for simple groups.
 */
  //SimpleGroupName sometimes fails, so try it several times
  ct:=0;
  repeat ct+:=1;
    flag,sn := SimpleGroupName(S);
  until flag or ct eq 10;
  mindeg := SimpleGroupMinimalDegree(sn[1]);
  if mindeg le maxind then
    return false;
  end if;
  for p in primes do
    //check whether S could act on a small module - unlikely!
    k:=2;
    repeat
      if #GL(k,p) mod #S eq 0 then
        "Possible complementary subgroup",k,p;
        return false;
      end if;
      k+:=1;
    until p^k gt maxind;
  end for;
  return true;
end function;
