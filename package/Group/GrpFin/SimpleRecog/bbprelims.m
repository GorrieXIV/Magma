freeze;

/*
   Uses internal Magma functions to set up a homomorphism
   between the group generated by <gens1> and the group
   generated by <gens2>. 

   Use with caution: It is intended only for "sporadic" treatments
*/
BruteForceHomomorphism := function (A, B)
     assert Ngens (A) eq Ngens (B);
return hom < A -> B | [ B.i : i in [1..Ngens (B)] ] >;
end function;


//////////////////////////////////////////////////////////

MyInsertBlock := function (X, d, rowcols)
     k := #rowcols;
assert (d ge k);
assert (k eq Nrows (X));
     Y := Identity (MatrixAlgebra (BaseRing (Parent (X)), d));
     for i in [1..k] do
         for j in [1..k] do
	    Y[rowcols[i]][rowcols[j]] := X[i][j];
         end for;
     end for;
return Y;
end function;
/////////////////////////////////////////////////////////

/*
   Input:
     (1) A basis B for GF(p^e) over GF(p)
     (2) An element x in GF(p^e)
   Output:
     An integer sequence expressing <x> as a linear
     combination of the elements in B
*/
MyEltseq := function (B, x)
     E := Parent (x);
assert Degree (E) eq #B;
     F := PrimeField (E);
     V, f := VectorSpace (E, F);
     W := VectorSpaceWithBasis ( [ B[i] @ f : i in [1..Degree (E)] ] );
     coords := Coordinates (W, x @ f);
assert &+[ coords[i] * B[i] : i in [1..Degree (E)] ] eq x;
return [ Integers ()!(coords[i]) : i in [1..Degree (E)] ];
end function;


MyCoordinates := function (B, F, x)
     E := Parent (x);
     V, f := VectorSpace (E, F);
     W := VectorSpaceWithBasis ( [ B[i] @ f : i in [1..#B] ] );
     coords := Coordinates (W, x @ f);
assert &+[ coords[i] * B[i] : i in [1..#B] ] eq x;
return coords;
end function;


PreservesBilinearForm := function (M, x)
return M eq x * M * Transpose (x);
end function;


PreservesSesquilinearForm := function (M, x)
     l := Degree (BaseRing (Parent (x)));
     if l mod 2 eq 1 then
         return false;
     else
         k := l div 2;
         return M eq x * M * Transpose (FrobeniusImage (x, k));
     end if;
end function;


/*
   given a nondegenerate hermitian 2-space whose natural basis
   is assumed to be an orthonormal basis, return a transition
   matrix that transforms the form to a hyperbolic pair
*/

HyperbolicTransition := function (V)

     assert Dimension (V) eq 2;

     k := BaseRing (V);
     n := Degree (k);
     assert n mod 2 eq 0;

     q := Characteristic (k)^(n div 2);
     r := PrimitiveElement (k);
     u := V.1;
     w := V.2;

     if Characteristic (k) mod 2 eq 1 then
         a := r^((q-1) div 2);
         b := r^(q-1) * a;
     else
         a := r^(q-1);
         b := Frobenius (a, n div 2);
     end if;

     e := 1/(1 + a * Frobenius (b, n div 2)) * (u + a * w);
     f := u + b * w;

     T := MatrixAlgebra (k, 2)!Matrix ([e, f]);
     
     M := MatrixAlgebra (k, 2)![1,0,0,1];
     N := MatrixAlgebra (k, 2)![0,1,1,0];
     
     assert T * M * Transpose (FrobeniusImage (T, n div 2)) eq N;

return T;
end function;


/*
   Given a list <Q> of vectors in <V> forming a basis for <V>
   as a vector space over its prime field, return a sequence
   of integers which, when viewed as elements of the prime
   field, express <u> as a linear combination of elements of <Q>
*/ 


MyCoefficients := function (Q, u)
     VK := Parent (u);
     K := BaseRing (VK);
     e := Degree (K);
     k := PrimeField (K);
     n := #Q;
assert (n mod e eq 0);
     d := n div e;
assert Degree (VK) eq d;
     Vk, phi := KSpace (VK, k);
     M := Matrix ([ Q[i] @ phi : i in [1..n] ]);
assert Rank (M) eq n;
     N := M^-1;
     coeffs := (u @ phi) * N;
assert (u eq &+ [coeffs[i] * Q[i] : i in [1..n] ]);
return [ Integers ()!coeffs[i] : i in [1..n] ];
end function;

/////////////////////////////////////////////////////////////


/*
   Input:
     (1) A group <X>
     (2) <rho>, a (purported) homomorphism X -> Y
   Output: <flag> indicating whether or not <rho> is as claimed.
*/
MyIsHomomorphism := function (X, rho)
     isit := true;
     proc := RandomProcess (X);
     for i in [1..5] do
         u := Random (proc);
         v := Random (proc);
         uu := u @ rho;
         vv := v @ rho;
         flag := (u * v) @ rho eq uu * vv;
         if (not flag) then
             return false;
         end if;
     end for;
return true;
end function;

MyIsHomomorphismModScalars := function (X, rho)
     isit := true;
     proc := RandomProcess (X);
     for i in [1..5] do
         u := Random (proc);
         v := Random (proc);
         uu := u @ rho;
         vv := v @ rho;
         flag := IsScalar (((u * v) @ rho) * (uu * vv)^-1);
         if (not flag) then
             return false;
         end if;
     end for;
return true;
end function;

///////////////////////////////////////////////////////////

OrderModCentre := function (g, G, divs)
     o := Order (g);
     gdivs := { Gcd (d, o) : d in divs | Gcd (d, o) gt 1 };
     for d in gdivs do
         n := o div d;
         h := g^n;
         if forall { i : i in [1..Ngens (G)] | 
                         (h, G.i) eq Identity (G) } then
	    o := n;
         end if;
     end for;
return o;
end function;
///////////////////////////////////////////////////////////


///////// field extensions and Hermitian forms ////////////

/*
   There are obviously more sensible ways to do these.
   The input is:
      (1) A finite field F = GF (q)
      (2) An extension field E = GF (q^f)
      (3) An element x of F
   The outputs are:
      A nonzero element z of E such that Tr(z) = x, 
         where Tr denotes the trace map of E over F; and
      An element z of E such that Nm(z) = x,
         where Nm denotes the norm map of E over F.
*/
ElementHavingPrescribedTrace := function (F, E, x)
     f := Degree (E) div Degree (F);
     q := #F;
     Tr := hom < E -> F | e :-> &+ [ e^(q^i) : i in [0..f-1] ] >;
assert exists (z){ e : e in E | (Tr (e) eq x) and (e ne 0) };
return z;
end function;


ElementHavingPrescribedNorm := function (F, E, x)
     f := Degree (E) div Degree (F); 
     q := #F;
     Nm := hom < E -> F | e :-> &* [ e^(q^i) : i in [0..f-1] ] >;
assert exists (z){ e : e in E | Nm (e) eq x };
return z;
end function;


IsHermitianForm := function (M)
     E := BaseRing (Parent (M));
     e := Degree (E);
assert (e mod 2 eq 0);
     f := e div 2;
return (Transpose (M) eq FrobeniusImage (M, f)) and
       (Nrows (M) eq Rank (M));
end function;


/////////// useful functions for computing with SL(2,q) ///////

/*
   The following function may be useful beyond SU(3,q) code.
   The input is:
      (1) A construtively recognised SL(2,q) subgroup L
      (2) A map L -> SL(2,q)
      (3) Its inverse SL(2,q) -> L
      (4) x in N_G(L) where G is a natural overgroup of L
   The output is:
      An element l of L that acts on the set of transvection groups
      of L exactly as x does. Note that x induces an element of
      PGL(2,q) on that set, so it is possible that no such l exists.
      If it does, however, then evidently xl^-1 is in C_G(L)
*/
PGL2ActionOnTransvectionGroups := function (L, phi, tau, x : PSLAction := true)
     H := Parent (L.1 @ phi);
     MA := MatrixAlgebra (BaseRing (H), 2);
     H_Transvections := [ H![1,0,1,1], H![1,1,0,1], H![2,1,-1,0]];
     L_Transvections := [ u @ tau : u in H_Transvections ];
     L_Images := [ v^x : v in L_Transvections ];
     H_Images := [ w @ phi : w in L_Images ];
     points := [ Nullspace (MA!w - Identity (MA)).1 : w in H_Images ];
     mat := Matrix (points);
     sol := Basis (Nullspace (mat))[1];
     sol := [ sol[i] : i in [1,2,3] ];
     if (PSLAction) then
         alpha := sol[2] / (sol[1] * (points[1][1] * points[2][2] -
                                          points[1][2] * points[2][1]));
         r := PrimitiveElement (BaseRing (H));
         q := #BaseRing (H);
         n := Log (r, alpha);
         if (n mod 2 eq 1) then
            if q mod 2 eq 1 then
               return false, _;
            else 
               l := (q + n - 1) div 2;
            end if;
         else 
            l := n div 2;
         end if;
         points := [ r^l * v : v in points ];
     end if;
     h := Matrix ([sol[1] / sol[2] * points[1], points[2]]);
     h := Generic (H)!h;
     if (PSLAction) then
assert Determinant (h) eq 1;
         return true, h, h @ tau;
     else
         // match up the order of <h> with the order of <x>
         mu := PrimitiveElement (BaseRing (H));
         assert exists (i) { j : j in [0..#BaseRing (H)-1] |
               Order (Generic (H)![mu^j,0,0,mu^j] * h) eq Order (x) };
         return true, Generic (H)![mu^i,0,0,mu^i] * h, _;
     end if;
end function;



/*
   The following function is also likely to be useful.
   The input is:
      (1) A constructively recognised SL(2,q) subgroup L
      (2) A map L -> SL(2,q)
      (3) Its inverse SL(2,q) -> L
      (4) a transvection u of L
      (5) a transvection w of L not commuting with u
   The output is:
      An element h of L of order q-1 normalising the 
      transvection groups containing u and w.
*/
SL2NormalisingToralElement := function (L, phi, tau, u, w)
     uu := u @ phi;
     ww := w @ phi;
     H := Generic (Parent (uu));
     F := BaseRing (H);
     r := PrimitiveElement (F);
     MA := MatrixAlgebra (F, 2);
     centres := [ Nullspace (MA!uu - Identity (MA)).1,
		  Nullspace (MA!ww - Identity (MA)).1 ];
     conj := H!Matrix (centres);
     hh := conj^-1 * H![r,0,0,1/r] * conj;
     h := hh @ tau;
assert ( (u, u^h) eq Identity (L) and (w, w^h) eq Identity (L) );
return h;
end function;


// look into this more: should be a faster way of constructing 
// a normalising toral element
/*
   Input:
     (1) Transvection group T
     (2) Two distinct (nonidentity) transvections x and y
         belonging to some transvection group S opposite T
   Return: An element of the group generated by S and T of
           order q-1 normalising S and T
*/
interchanges_transvection_groups := function (x, y, l)
return IsIdentity ((x^l, y)) and IsIdentity ((y^l, x));
end function;

SL2NormalisingToralElementFast := function (T, x, y)
     assert exists (u){ t : t in T | 
        interchanges_transvection_groups (T[2], x, t * x * t) };
     assert exists (v){ t : t in T | 
        interchanges_transvection_groups (T[2], x, t * y * t) };
return u * v;
end function;

////////////////////////////////////////////////////////////////


/*
   The following function is a nonconstructive test for
   isomorphism with SL(2,q) x SL(2,q).
   The input is:
     (1) A black box group H
     (2) A prime power q
   The output is:
     A flag indicating whether or not H is 
     (probably) isomorphic to SL(2,q) x SL(2,q)
*/
IsSL2xSL2 := function (H, q)

     procH := RandomProcess (H);

     limit := 12 * Floor (Log (2, q));     
     obad := q^2 + 1;
     ogood := q^2 - 1;
     i := 1;
     found := false;
     while (i lt limit) do
         h := Random (procH);
         o := Order (h);
         if (o eq ogood) then
            found := true;
            x := h^(q-1);
            if forall { i : i in [1..Ngens (H)] |
                            (H.i, x) eq Identity (H) } then
               return false;
            end if;
         end if;
         if (o eq obad) then
            return false;
         end if;
         i +:= 1;
     end while;

return found;
end function;
//////////////////////////////////////////////////////


/*
   The following function obtains a factorisation of
   the input group as a direct product of two SL(2,q)s.
   The input is:
     (1) A black box group H that is probably
         isomorphic to SL(2,q) x SL(2,q)
     (2) A prime power q
   The output is:
     (1) A flag
     (2) An SL(2,q)-subgroup L1 of H 
     (3) words expressing L1.i in terms of H.j
     (4) An SL(2,q)-subgroup L2 of H
     (5) words expressing L2.i in terms of H.j
   such that H = L1 x L2
*/

FactorizeSL2xSL2 := function (H, q)

     procH := RandomProcessWithWords (H);

     p := Factorisation (q)[1][1];    
     if (q eq 3) then
         pows := [4];
         limit := 100;
     else
         pows := [ 2*p , q-1 , q+1 ];
         limit := 50 * Floor (Log (2, q));
     end if;

     // first search for elements that exhibit the desired factors  
     elts := [];
     words := [];
     count := 0;
     while (#elts lt 8) and (count lt limit) do
         count +:= 1;
         h, w := Random (procH);
         o := Order (h);
         for n in pows do
	    if (o mod n eq 0) then
               a := h^n;
               wa := w^n;
               if (not a eq Identity (H)) and 
                  (not forall { i : i in [1..Ngens (H)] | 
                              (H.i, a) eq Identity (H) }) then
                  Append (~elts, a);
                  Append (~words, wa);
               end if;
            end if;
         end for;
     end while;

     // find the two factors
     gens1 := [ elts[1] ];
     wL1 := [ words[1] ];
     gens2 := [];
     wL2 := [];
     for i in [2..#elts] do
         flag1 := forall { j : j in [1..#gens1] | 
                               (gens1[j], elts[i]) eq Identity (H) };
         flag2 := forall { j : j in [1..#gens2] | 
                               (gens2[j], elts[i]) eq Identity (H) };
         if (flag1) then
            if (not flag2) or (#gens2 eq 0) then
               Append (~gens2, elts[i]);
               Append (~wL2, words[i]);
            end if;
         elif (flag2) then
	    if (not flag1) then
	       Append (~gens1, elts[i]);
               Append (~wL1, words[i]);
            end if;
         else     
    	    return false, _, _, _, _;
         end if;
     end for;

     if (#gens1 lt 2) or (#gens2 lt 2) then
         return false, _, _, _, _;
     end if;

     L1 := sub < Generic (H) | gens1 >;
     L2 := sub < Generic (H) | gens2 >;

return true, L1, wL1, L2, wL2;
end function;

////////////////////////////////////////////////////////////////

FactorizeSL2xSL2Alt := function (H, q)

     // assumes q is at least 4

     procH := RandomProcessWithWords (H);
     
     o := (q^2 - 1) / Gcd (2, q - 1);
     i := 0;
     found := false;
     repeat
        i +:= 1;
        h, w := Random (procH);
     until (Order (h) eq o) or (i gt 10 * Floor (Log (2, q))); 
     X1 := [ h^(q-1) ];
     wX1 := [ w^(q-1) ];
     X2 := [ h^(q+1) ];
     wX2 := [ w^(q+1) ];
     
     O := #SL (2, q);
     facs := Factorisation (O);
     pows := [ O div (x[1] ^ x[2]) : x in facs ];
     
     i := 0;
     while (#X1 lt 4 or #X2 lt 4) and 
           (i lt 50 * Floor (Log (2, q))) do
          i +:= 1;
          y, w := Random (procH);
          for t in [1..#pows] do
              yt := y ^ pows[t];
              wt := w ^ pows[t];
              flag1 := forall { x : x in X1 | 
                                    (yt, x) eq Identity (H) };
              flag2 := forall { x : x in X2 | 
                                    (yt, x) eq Identity (H) };
              if (flag1 and not flag2) then
                  if (not yt in X2) then
                      Append (~X2, yt);
                      Append (~wX2, wt);
                  end if;
              elif (not flag1 and flag2) then
                  if (not yt in X1) then
                      Append (~X1, yt);
                      Append (~wX1, wt);
                  end if;
              end if;
          end for;
     end while;

     if (#X1 lt 4) or (#X2 lt 4) then
         return false, _, _, _, _;
     end if;

     L1 := sub < Generic (H) | X1 >;
     L2 := sub < Generic (H) | X2 >;

return true, L1, wX1, L2, wX2;
end function;
