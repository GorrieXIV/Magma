%Latest version prepared by DFH February 20, 2014

%\documentclass[12pt,twoside,a4paper,reqno,psamsfonts]{amsart}
\documentclass[12pt,twoside,reqno,psamsfonts]{amsproc}
\usepackage[latin1]{inputenc} % svenska tecken skall tolkas
\usepackage{amscd}
\usepackage{amsopn}
\usepackage{amstext}
\usepackage{amsxtra}
\usepackage{amssymb}
\usepackage{upref}
\usepackage{url}
\usepackage{bm} % for \boldsymbol
%\usepackage{draftcopy}
\usepackage{graphicx}
\usepackage{setspace}
\usepackage{xspace}
%\usepackage{stmaryrd}
%\usepackage{lineno}

\setlength{\marginparwidth}{75pt}
\newcommand{\comment}[1]{\marginpar{\begin{center}\scriptsize{#1}\end{center}}}

\renewcommand{\thefootnote}{}

\frenchspacing


%% page layout
\addtolength{\textwidth}{2.2cm}
\addtolength{\oddsidemargin}{-1.1cm}
\addtolength{\evensidemargin}{-1.1cm}
\addtolength{\topmargin}{0cm}
\addtolength{\textheight}{1.4cm}

\newcommand{\repgp}{{represented group}\xspace}
\newcommand{\uppergp}{{upper group}\xspace}
\newcommand{\nullsubgp}{{null subgroup}\xspace}
\newcommand{\Nullsubgp}{{Null subgroup}\xspace}
%\numberwithin{section}{chapter}
\numberwithin{equation}{section}
\numberwithin{figure}{section}
%\numberwithin{algorithm}{chapter}

\newcounter{algorithm}
%\numberwithin{algorithm}{section}
%\renewcommand{\thealgorithm}{\arabic{section}.\arabic{algorithm}}

\theoremstyle{plain}
\newtheorem{thm}{Theorem}[section]
\newtheorem{lem}[thm]{Lemma}
\newtheorem{cl}[thm]{Corollary}
\newtheorem{pr}[thm]{Proposition}
\newtheorem{axiom}[thm]{Axiom}
\newtheorem{conj}[thm]{Conjecture}
\newtheorem{prob}[thm]{Problem}

\theoremstyle{definition}
\newtheorem{deff}[thm]{Definition}

\theoremstyle{remark}
\newtheorem{note}[thm]{Note}
\newtheorem{rem}[thm]{Remark}

%\renewcommand{\thetheorem}{Theorem~\arabic{chapter}.\arabic{theorem}}
%\renewcommand{\thepr}{Proposition~\arabic{chapter}.\arabic{pr}}
%\renewcommand{\thedeff}{Definition~\arabic{chapter}.\arabic{deff}}
\providecommand{\abs}[1]{\left\lvert #1 \right\rvert}
\providecommand{\norm}[1]{\left\lVert #1 \right\rVert}
\providecommand{\ceil}[1]{\left\lceil #1 \right\rceil}
\providecommand{\floor}[1]{\lfloor #1 \rfloor}
\providecommand{\set}[1]{\left\lbrace #1 \right\rbrace}
\providecommand{\gen}[1]{\left\langle #1 \right\rangle}
\providecommand{\Sym}[1]{\operatorname{Sym}( #1 )}
\providecommand{\Alt}[1]{\operatorname{Alt}( #1 )}
\renewcommand{\Pr}[1]{\operatorname{Pr}[ #1 ]}
%\renewcommand{\char}[1]{\operatorname{char}[ #1 ]}

\newcommand{\field}[1]{\mathbb{#1}}
\newcommand{\vect}[1]{\boldsymbol{\mathrm{#1}}}
\newcommand{\N}{\field{N}}
\newcommand{\Z}{\field{Z}}
\newcommand{\R}{\field{R}}
\newcommand{\Q}{\field{Q}}
\newcommand{\OO}{\field{O}}
\newcommand{\K}{\field{K}}
\newcommand{\A}{\field{A}}
\newcommand{\F}{\field{F}}
\newcommand{\PS}{\field{P}}
\newcommand{\GAP}{\textsf{GAP}}
\newcommand{\SMASH}{\textsc{Smash}}
\newcommand{\MAGMA}{\textsc{Magma}}
\newcommand{\Magma}{\textsc{Magma}}
\newcommand{\Meataxe}{\textsc{MeatAxe}}

%\usepackage{latexsym, amssymb, amsmath, xspace}
\newcommand{\bO}{{\mathbf O}}
\newcommand{\bZ}{{\mathbf Z}}
\newcommand{\bC}{{\mathbf C}}
\newcommand{\bN}{{\mathbf N}}
\newcommand{\bF}{{\mathbf F}}
\newcommand{\soc}{\mathrm{soc}}
\newcommand{\Om}{\Omega}
\newcommand{\POm}{\mathrm{P}\Omega}
% for Cayley graphs
\newcommand{\C}{\mathcal{C}}
\newcommand{\LL}{\mathcal{L}}
\newcommand{\TT}{\mathcal{S}}
\newcommand{\cS}{\mathcal{S}}
\newcommand{\OV}{\mathcal{O}}

\DeclareMathOperator{\lcm}{lcm}
\DeclareMathOperator{\sgd}{sgd}
\DeclareMathOperator{\mgm}{mgm}
\DeclareMathOperator{\sgn}{sgn}
\DeclareMathOperator{\GL}{GL}
\DeclareMathOperator{\PGL}{PGL}
\DeclareMathOperator{\GF}{GF}
\DeclareMathOperator{\IM}{Im}
\DeclareMathOperator{\RE}{Re}
\DeclareMathOperator{\I}{Id}
%\DeclareMathOperator{\OR}{O}
\DeclareMathOperator{\SL}{SL}
\DeclareMathOperator{\GO}{GO}
\DeclareMathOperator{\SO}{SO}
\DeclareMathOperator{\Sz}{Sz}
\DeclareMathOperator{\Sp}{Sp}
\DeclareMathOperator{\SU}{SU}
\DeclareMathOperator{\PSU}{PSU}
\DeclareMathOperator{\chr}{char}
\DeclareMathOperator{\Aut}{Aut}
\DeclareMathOperator{\Out}{Out}
\DeclareMathOperator{\Inn}{Inn}
\DeclareMathOperator{\Syl}{Syl}
\DeclareMathOperator{\PSL}{PSL}
\DeclareMathOperator{\PSp}{PSp}
\DeclareMathOperator{\PPSL}{(P)SL}
\DeclareMathOperator{\diag}{diag}
\DeclareMathOperator{\Tr}{Tr}
\DeclareMathOperator{\SLP}{SLP}
\DeclareMathOperator{\G2}{{^2}G_2}
\DeclareMathOperator{\LargeRee}{{^2}F_4}
\DeclareMathOperator{\Ree}{Ree}
\DeclareMathOperator{\Gal}{Gal}
\DeclareMathOperator{\Norm}{N}
\DeclareMathOperator{\Cent}{C}
\DeclareMathOperator{\Zent}{Z}
\DeclareMathOperator{\EndR}{End}
\DeclareMathOperator{\Hom}{Hom}
\DeclareMathOperator{\Ker}{Ker}
\DeclareMathOperator{\cln}{{:}}
\DeclareMathOperator{\O2}{O_2}
\DeclareMathOperator{\Op}{O_p}
\DeclareMathOperator{\RP}{\bf{RP}}
\DeclareMathOperator{\NP}{\bf{NP}}
\DeclareMathOperator{\PP}{\bf{P}}
\DeclareMathOperator{\coRP}{\bf{co-RP}}
\DeclareMathOperator{\ZPP}{\bf{ZPP}}
\DeclareMathOperator{\Imm}{Im}
\DeclareMathOperator{\Mat}{Mat}
\DeclareMathOperator{\Dih}{D}

\newcommand{\OR}[1]{\operatorname{O} \bigl( #1 \bigr)}
%\newcommand{\cln}{\operatorname{O} ( #1 )}

\title{A practical model for computation with matrix groups}

\author{Henrik B\"a\"arnhielm}
\address{Department of Mathematics \\ University of Auckland \\ Auckland \\ New Zealand}
\urladdr{http://www.math.auckland.ac.nz/\textasciitilde henrik/}
\email{henrik@math.auckland.ac.nz}

\author{Derek Holt}
\address{Mathematics Institute \\ University of Warwick \\ Coventry, CV4 7AL \\ United Kingdom}
\urladdr{http://www.warwick.ac.uk/staff/D.F.Holt}
\email{D.F.Holt@warwick.ac.uk}

\author{C.R. Leedham-Green}
\address{School of Mathematical Sciences \\ Queen Mary, University of London \\ Mile End Road \\ London \\ United Kingdom}
\urladdr{http://www.maths.qmul.ac.uk/\textasciitilde crlg/}
\email{c.r.leedham-green@qmul.ac.uk}

\author{E.A.\ O'Brien}
\address{Department of Mathematics \\ University of Auckland \\ Auckland \\ New Zealand}
\urladdr{http://www.math.auckland.ac.nz/\textasciitilde obrien/}
\email{obrien@math.auckland.ac.nz}


\begin{document}
%\setpagewiselinenumbers
%\linenumbers

\begin{abstract}
We describe an algorithm to compute a composition tree
for a matrix group defined over a finite field, and 
show how to use the associated structure 
to carry out computations with such groups,
such as finding composition and chief series, the soluble radical, 
and Sylow subgroups.
\end{abstract}

\maketitle

\footnote{
Last revised \today.
We thank Peter Brooksbank and Max Neunh\"offer for helpful comments,
and Colva Roney-Dougal for helpful discussions. 
B\"a\"arnhielm was funded by a University of Auckland
Postdoctoral Fellowship.
All authors were partially supported by the Marsden Fund of New
Zealand  \emph{via} grant UOA1015.}

\section{Introduction}
In this article we describe in detail algorithms for computing with large 
matrix groups defined over finite fields, and their implementation in
$\MAGMA$ \cite{Magma}. 
The motivation comes from the \emph{matrix group recognition
project} \cite{crlg01}: its aim is
to understand the structure of $G = \langle Y \rangle \leqslant \GL(d, \F_q)$. 
Our algorithms construct a composition series, and facilitate membership 
testing and writing of elements of $G$ as words 
in $Y$. Further functionality includes, for example,
the computation of chief series, the centre, the soluble radical, and
Sylow subgroups. 

Comparable questions can already be answered readily for 
permutation groups of large degree.
These algorithms rely on ``base and strong generator" (BSGS) methods
\cite[Chapter 4]{hcgt}. 
It is now possible to study the structure of permutation groups with
moderately small bases having degrees up to about ten million.
Variations of these techniques have only limited applicability
to matrix groups.

A \emph{composition tree} for a finite group is a data structure for
\comment{DFH: added sentence}
storing a composition series, which will be defined in
Section \ref{sec:outline} and, in greater detail, in
Section \ref{section:algorithm}.
The basic strategy for computing a composition tree of a matrix group,
based on a combination of a constructive version of 
Aschbacher's theorem \cite{aschbacher84} and constructive recognition
algorithms for finite simple groups, 
was proposed by Leedham-Green \cite{crlg01}, and a prototype was 
implemented in {\sc Magma} by Leedham-Green and O'Brien in 2000.
Various developments and refinements of the strategy 
were introduced in \cite{MR2289128, MR2258009, OBrien11}.
In particular, a variation of the composition tree construction
\comment{DFH: rewrote this sentence slightly}
is described by Neunh\"offer \& Seress in \cite{MR2289128};
the resulting implementations in {\GAP} \cite{GAP}
are available as part of the {\tt recog} package \cite{recogbase,recog}. 

Similar methods can also be applied to permutation groups, and
are useful for the study of large base groups where BSGS
techniques are less effective.
In \cite{MR2289128}, 
a uniform  data structure for both matrix and permutation groups 
is presented; we adopted this proposal.   

%described in \cite{crlg01, MR2258009, OBrien11};
%some new ideas were introduced in ~\cite{

In summary, our objectives are four-fold.
\begin{enumerate}
\item Construct a composition tree for a 
group $G$ that is a subgroup of either $\GL(d, \F_q)$ or of $\Sym{n}$.
\item Using the composition tree, construct a composition series for $G$. 
\item Adjust the generators of the subgroups in the composition series
to obtain a new composition series
that refines a particular characteristic series of $G$.
We refer to this step as {\em rearranging} the composition series.
\item Provide the infrastructure needed by  
the \emph{Soluble Radical Model} of \cite[Chapter 10]{hcgt}
to answer other structural questions about $G$.
\end{enumerate}

Of these four tasks the first has required most effort.  It may be
divided into three subtasks: making Aschbacher's theorem 
constructive; constructive recognition for simple groups;
and combining these to complete the task.  We are now, after some
20 years of continuous development, at the point where, in
practice, we can construct a composition tree for
a matrix group defined in dimension up to 100 and over a large field in
a reasonable length of time.  

It is not our purpose here to describe
the large body of work, by many authors, that enables
us to make Aschbacher's theorem constructive, and to process simple groups.
This work is described elsewhere; we give references.  Our concern here
is with the {\it strategic concepts} and {\it technical details}
needed to combine these algorithms into a package that both
constructs a composition tree, and, by
carrying out our other objectives, can be used to analyse the structure
of the groups in question.  This superstructure
has been developed by us over the past ten years, and is described in
sufficient detail to guide others who may wish to implement these ideas.  

We barely touch on questions of complexity;  the critical complexity issues
arise with the algorithms for Aschbacher's theorem and simple groups.  
It is generally accepted that the ability to compute integer factorisations and
\comment{DFH: expanded this sentence.}
discrete logarithms is indispensable for the structural analysis of matrix
groups over finite fields but, even given the availability of oracles for
these purposes, serious obstructions remain to be overcome before we have a
provably polynomial-time algorithm for computing a composition tree.
We contrast this with the striking theoretical results obtained in
the black-box context \cite{BBS} and reported in Section 
\ref{section:charsubs}.

Sections~\ref{section:algorithm}--\ref{section:leaf_algorithm} 
describe the construction of the composition tree.
Sections~\ref{section:autident}--\ref{section:rearrange}
describe the rearranging algorithm, which requires us to solve an
identification problem for automorphisms of classical groups that may
be of independent interest.
In Section \ref{section:furthercomp} we explain
how the resulting data structure 
is exploited by the Soluble Radical Model
to carry out various structural computations 
in $G$ such as finding its centre and its Sylow
subgroups.  

Our implementations of the resulting algorithms are 
available in $\MAGMA$ %\cite{Magma},
as the \texttt{CompositionTree} package,
and form part of its standard machinery 
for computing with matrix groups. 
Section \ref{implementation} discusses aspects
of our implementations and their performance. 

The algorithms of \cite{MR2429998, statherthesis} construct
directly a chief series of $G$ that refines
the characteristic series of $G$ defined in Section~\ref{section:charsubs}.
We first construct a composition series.
The algorithm to adjust the generators of the terms in
the composition series is straightforward,
and uses the composition tree as a ``black box" with a well-defined
interface, without relying on detailed knowledge of its construction.
A disadvantage compared with \cite{MR2429998} is that certain 
groups require many adjustments. 

%A variation of the composition tree construction is 
%under development by Neunh\"offer \& Seress \cite{MR2289128}  
%in {\GAP} \cite{GAP}; the resulting implementations are available at 
%\cite{recogbase,recog}. In \cite{MR2289128}, they proposed
%a uniform  data structure for both matrix and permutation groups; 
%we adopted this proposal.   

Algorithms for computing with 
linear groups defined over infinite fields often compute,
as a preliminary step, an image over a finite field.
Our algorithms, in particular those that produce a presentation for the image,
are immediately applicable; see, for example, \cite{Tits,RecogInfinite}.

\section{Background and notation}
All groups in this paper are assumed to be finite.
For background on aspects of the matrix group recognition
project,  we refer the reader
to \cite{crlg01, MR2258009, OBrien11}. 

As outlined in \cite[Chapter 6]{seress03},
an extensive library of highly efficient algorithms exists 
for small base permutation groups. 
Finite polycyclic groups are usually represented 
by PC-presentations; practical algorithms for their study 
appear in \cite[Chapter 8]{hcgt}.
High-quality implementations of both classes of algorithms
are available in both {\sf GAP} and 
{\sc Magma}; we assume their availability,
and refer the interested reader to these sources for details. 
We refer to these as {\it standard machinery}.

Many existing algorithms to compute structural information
about $G\leqslant \GL(d, \F_q)$ -- for example, its composition factors
or conjugacy classes -- rely on the availability of a BSGS for $G$; 
see \cite{hcgt} for a discussion.
We refer to these as {\it BSGS machinery}.

We assume that efficient algorithms are available to  
solve many basic problems for matrices.
These include finding orders (\cite{crlg95} and 
\cite{MR2258009});
computing characteristic and minimal polynomials (\cite{NP08}
and \cite[\S 7.3]{hcgt});
and computing large powers (\cite[\S 3.1.1]{hcgt} and \cite{cr-odd}).

A {\it straight-line program} (SLP) 
is a compactly stored word in 
a set of group generators and their inverses; 
for a formal definition, see for example~\cite[\S 3.1.3]{hcgt}.
While the length of a word in a given generating set constructed in $n$
multiplications and inversions can increase exponentially with $n$,
the length of the corresponding SLP is {\it linear}
in $n$.  Babai \& Szemer{\'e}di \cite{BabaiSzemeredi84}
prove that every element of a finite
group $G$ has an SLP of length $\OR{\log^2|G|}$
in every generating set.

A \emph{rewriting} algorithm for a finite group $G$ solves the 
{\it constructive membership problem}:
given $u \in U \geqslant G = \gen{Y}$, decide whether or not 
$u \in G$, and if so express $u$ as an SLP in $Y$. 
Here $U$ is the {\it universal group} containing $G$; 
\comment{DFH: small edit}
i.e. $\GL(d, \F_q)$ or $\Sym{n}$ when $G$ is  a matrix group or permutation
group, respectively.

A \emph{constructive recognition algorithm} for a (quasi)simple group $G$ 
solves the following problem: construct an isomorphism $\varphi$ from $G$ to a
\emph{standard copy} of $G$ (see Section~\ref{subsection:standard})
such that $\varphi(g)$ can be computed efficiently for every $g \in G$.
Such an isomorphism is said to be \emph{effective}. 
We also demand that $\varphi^{-1}$ is effective.

The concept of a {\it black-box group} was introduced in
\cite{BabaiSzemeredi84}. In this model,
group elements are represented by bit-strings
of uniform length; the only group operations
permissible are multiplication, inversion, and checking
for equality with the identity element.
Permutation groups
and matrix groups defined over finite fields
are covered by this model.

Seress \cite[p.\ 17]{seress03} defines
a {\it black-box algorithm} as one that does not
use specific features of the group representation,
nor particulars of how group operations
are performed; it uses only the operations
permissible in a black-box group.  A common assumption
is that {\it oracles} are available to perform certain tasks --
usually problems not known to be solvable in polynomial time. 
An example is an oracle to determine the order 
of an element in a black-box group.  Number-theoretic oracles 
include a {\it discrete log oracle}: for a given non-zero
$\mu \in \F_q$ and a fixed primitive element $\omega$ of $\F_q$,
it returns the unique integer $k$ in the
range $1\leqslant k < q$ for which $\mu = \omega^k$.
Another is {\it integer factorisation}, 
usually of numbers of the form $q^i - 1$.
The most efficient algorithms for both number-theoretic oracles 
run in sub-exponential time (see \cite[Chapter 4]{IS}). 

Babai \cite{Babai91} presents a black-box Monte Carlo
algorithm to construct nearly uniformly distributed
random elements of a finite group $G$ in polynomial time.
An alternative is the {\it product replacement algorithm} 
\cite{lg95, Pak00}.  We assume that a random element and its 
SLP in the generators of $G$ are simultaneously constructed.
Both algorithms satisfy this assumption.

The {\it central order} of $g\in G$ is the 
smallest power of $g$ that lies in the centre of $G$.
The cyclic group of order $e$ is denoted by $\Cent_e$. 

\section{Outline of the algorithms}\label{sec:outline}
A composition tree of a group $G$ is a data structure 
\comment{DFH: added more detail to definition}
-- namely, a full binary tree -- to store its composition factors, or factors
of a subnormal series that can be readily refined to a composition series. 
Each node of the tree has an associated group, and $G$ itself is the
group of the root node.
For the associated group $H$ of each non-leaf node, there is an
%exact sequence
%\[ 0 \to H_0 \stackrel{\theta_0}{\rightarrow} H
%\stackrel{\theta_1}{\rightarrow} H_1 \rightarrow 1,\]
epimorphism $\theta:H \to H_1$ and a monomorphism $\theta_0:H_0 \to H$
with $\Imm \theta_0 = \ker \theta$,
where $H_0$ and $H_1$ are respectively the groups associated with the left
child and the right child of the node.

The tree is constructed recursively. 
The data structure facilitates rewriting in $G$.
In particular, the ability to perform rewriting in a section of $G$ 
is available once a composition tree has
been constructed for this section. 
This ability is essential to the recursion, and depends on the
availability of rewriting algorithms for the finite simple groups, a
dependency often satisfied. 

\subsection{Composition tree construction}
Here is an outline of the algorithm to construct a composition tree
of a group $G$ with a given generating set.
\begin{enumerate}
\item Either: 
\comment{DFH: reworded and rearranged this}
\begin{enumerate}
\item [(i)] construct an effective epimorphism
$\theta : G \to G_1$, for some group $G_1$; or 
\item[(ii)] deduce that $G$ is cyclic, elementary abelian, 
or ``close" to being non-abelian simple.  
Now $G$ becomes a {\it leaf} in the tree.
\end{enumerate}
\noindent
In Case (i), $\theta$ must be a {\it reduction}; that is, $G_1$
should be ``smaller" than $G$ in some respect -- 
for example, its degree or field of definition.
Assume henceforth that Case (i) applies. 
\item Recursively construct a composition tree for $G_1$ using the images
of the generators of $G$ under $\theta$.
\item Construct generators for $G_0 := \Ker \theta $.
\item Recursively construct a composition tree for $G_0$.
\item Combine the composition trees for $G_1$ and $G_0$ into a tree for $G$.
\end{enumerate}

If $G \leqslant \GL(d, \F_q)$, then we exploit Aschbacher's 
theorem \cite{aschbacher84} in Step (1).
This requires algorithms to decide whether $G$ lies in a
certain Aschbacher class, and to construct the corresponding $\theta$.
Other homomorphisms, such as the determinant map, may also be used.

If $G \leqslant \Sym{n}$, then we could exploit the 
O'Nan-Scott theorem \cite[Chapter 10]{hcgt} in Step (1).
However, as outlined in \cite[Chapter 6]{seress03},
an extensive library of highly efficient algorithms exists which 
only require a BSGS.
For a small base permutation group one can easily find a BSGS.
Thus our goal is more limited: we apply certain reductions to
large base groups and then use the existing % permutation group 
algorithms to complete the investigation.

The group associated with a leaf need not be simple.
It may be cyclic or elementary abelian,
a simple or soluble primitive permutation group, or an absolutely 
irreducible matrix group that is simple modulo its centre.
Our decisions on what groups may be treated as leaves are 
partly dictated by complexity considerations, 
and partly based on the quality of algorithms
available to process a leaf. For example, we observe no practical
advantage from refining a cyclic group to 
its composition factors.

\subsection{The composition series}
\label{subsection:rearrange_interface}
The composition tree suffices if we are interested only in 
rewriting and membership testing in $G$, but for any further structural
calculations we require a composition series.
\comment{DFH: rearranged and expanded slightly}
To construct such a series, we need to find composition series of the groups
associated with the leaves of the tree.
When the group associated with a node is insoluble but not simple,
this may require additional work.  To carry this out efficiently,
we need constructive recognition algorithms for
the non-abelian composition factors of $G$.

We use the tree and associated constructive recognition
algorithms to construct the following.
\begin{itemize}
\item A composition series $\gen{1} = G_0 < G_1 < \dotsm < G_m = G$,
and, for each $k$, a subset $X_k$ of $G_k$ that 
generates $G_k$ modulo $G_{k-1}$.

\item For each $k > 0$, an effective epimorphism $\tau_k : G_k \to S_k$,
  where $S_k$ is the standard copy of $G_k / G_{k - 1}$,
  and $\Ker \tau_k  = G_{k - 1}$.
\item For each $k > 0$, a rewriting algorithm for $S_k$.

\item For each $k > 0$, an effective map $\phi_k:S_k \to G_k$ with
$\phi_k \circ \tau_k = {\rm Id}_{S_k}$.
\end{itemize}

If $G$ is not a leaf, then it is straightforward to construct
this data for $G$ from the corresponding data for its image and kernel. 
Hence the task reduces to constructing such data for the leaves of the
composition tree for $G$. 

\subsection{Rearranging the composition series}
\label{section:charsubs}
Recall, for example from  \cite[\S 10.1]{hcgt}, 
that a finite group $G$ has a characteristic series of subgroups
$$1 \leqslant L \leqslant M \leqslant  K \leqslant G$$
where $L$ is the soluble radical (the 
largest normal soluble subgroup) of $G$.
Let $M/L := \soc(G/L)$ be the socle of $G/L$
(the group generated by its minimal normal subgroups).
Since $M/L$ has no soluble minimal normal subgroups,
it is the direct product
of the minimal normal subgroups $M_1/L$, $M_2/L, \ldots, M_r/L$ of $G/L$.
Each $M_i/L$ is the direct product of
isomorphic finite non-abelian simple groups 
$S_{ij}$ for $1 \leqslant j \leqslant k_i$.
%and, for fixed $i$, the $S_{ij}$ are permuted transitively under
%the conjugation action of $G/L$ (and hence of $G$) on $M_i/L$.

Let $\Delta = \{ S_{ij} \mid 1 \leqslant j \leqslant i_k, 1 \leqslant i \leqslant r \}$.
Conjugation by elements of $G$ defines an action $\psi:G \to
\Sym{\Delta}$ and the $r$ orbits of this action are 
$\{\,S_{ij}\mid 1 \leqslant j \leqslant k_i\,\}$. 
Let  $K := \ker(\psi)$. Since $M/L$ is a direct product of non-abelian
simple groups, $\Zent(M/L) = 1$, and hence $C_{G/L}(M/L) = 1$:
otherwise $C_{G/L}(M/L)$ would contain minimal normal subgroups
of $G/L$ disjoint from $M/L$. Thus conjugation by elements of $G$ 
induces a
monomorphism $\alpha:G/L \to \Aut(M/L)$, and $\alpha(K)$ is contained
in the subgroup of $\Aut(M/L)$ that fixes all of the $S_{ij}$. Hence
$\alpha(K)$ is contained in the direct product of the groups
$\Aut(S_{ij})$, and $\alpha(K)/\alpha(M)$ is contained in the
direct product of the groups $\Out(S_{ij})$.
Since the outer automorphism group
of every non-abelian finite simple group is soluble, 
$K/M \cong \alpha(K)/\alpha(M)$ is soluble.
Observe that $G/K$ is isomorphic to a subgroup of
$\Sym{\Delta}$.

Babai \& Beals \cite{babaibeals99} initiated
and pioneered the {\em black-box approach}
to the study of matrix groups: focusing on the 
abstract structure of $G \leqslant \GL(d, q)$, it seeks to construct
precisely this characteristic series for $G$. 
In 2009, as a culmination of 25 years of work,
Babai, Beals \& Seress \cite{BBS} proved that,
subject to the existence of a discrete
log oracle and the ability to factorise integers
of the form $q^i - 1$ for $1 \leqslant i \leqslant d$,
there exist black-box polynomial-time Las Vegas algorithms
to construct this series for a large class of matrix groups.

A chief series for $G$ that refines this characteristic series is particularly
useful for carrying out structural computations in $G$, such as
calculating its automorphism group, or its conjugacy classes of elements or
subgroups. For details of such algorithms, see~\cite[Chapter 10]{hcgt}. 
While their implementations have used BSGS machinery to date, 
the algorithms are essentially black-box. 

As a first step towards such a chief series, we construct
a composition series that refines the characteristic series.
We proceed up the composition series of $G$ and, for each $G_k$, we do the
following.
If possible, we replace each $x_k \in X_k$ by an element
$x_kg$ with $g \in G_{k-1}$, such that $x_kg \in L$, or (if this is not
possible) $x_kg \in M$, or (if this is not possible) $x_kg \in K$.
This does not change $G_k$, it only modifies $X_k$.
After these changes, by taking the sets $X_k$
in a different order, with those lying in $L$ coming first, followed by
those lying in $M$, then those lying in $K$, and finally those not in $K$, we
obtain a new composition series of $G$ that passes through $L$, $M$, and $K$.
We refer to this process as {\it rearranging} the series.

The algorithm to perform this task is described in Section
\ref{section:rearrange}.

\section{Standard copies, generators, presentations, rewriting}
We now discuss various technical issues that
play a role in the algorithms.

\subsection{A group pair}
A quotient of a group by a cyclic central
subgroup may occur as a node group in a composition tree. We define a
{\em group pair} to be a tuple $(G,N)$, where $G$ and $N$ are
subgroups of some common overgroup $U$, and $G$ centralises $N$. 
We call $G$ and
$N$ respectively the {\em \uppergp} and the {\em \nullsubgp} of the pair,
and the quotient group $GN/N \cong G/(G \cap N)$ is the {\em \repgp} of the
pair. For notational purposes, it is convenient to regard a group $G$ as being
a group pair with \uppergp $G$ and trivial \nullsubgp.

We define a morphism $\theta:(G,N) \rightarrow (G_1,N_1)$ between
group pairs to be a map $\theta :GN \rightarrow G_1N_1$ (note that we
use $\theta$ for this map too) with
$\theta(N) \leqslant N_1$,
such that $\theta$ induces a group homomorphism
$\phi:GN/N \rightarrow G_1N_1/N_1$.
While $\theta:GN \to G_1N_1$ is {\it not} required to be a homomorphism,
we nevertheless use $\Ker \theta$ to denote
$\{ g \in GN \mid \theta(g) = 1 \}$.
We call $\theta$ a monomorphism, epimorphism or isomorphism of group
pairs if $\phi$ is (as a group homomorphism).
Group pair morphisms $\theta_0:(G_0,N_0) \rightarrow (G,N)$ and
$\theta:(G,N) \rightarrow (G_1,N_1)$ form an {\em exact sequence}
if $\Imm\phi_0 = \Ker \phi $, which is true if and only
if $\Imm(\theta_0) N = \{g \in GN \mid \theta(g) \in N_1 \}$.

We assign a group pair $(G,N)$ to each node of a composition tree for $G$,
\comment{DFH:added final paragraph}
and the group associated with the node is the represented group of the pair.
If the node is not a leaf, then we define an associated exact sequence
$\theta_0:(G_0,N_0) \rightarrow (G,N)$ and
$\theta:(G,N) \rightarrow (G_1,N_1)$, where  $(G_0,N_0)$ and $(G_1,N_1)$
are the pairs assigned to the left-and right-habd child nodes. This induces
the required exact sequence on the corresponding represented groups.

\subsection{Standard copies}\label{subsection:standard}
For each finite simple or quasisimple group $S$, 
we designate one {\it standard copy}. 
To compute in another copy $H$ of $S$, we first
construct effective isomorphisms between this copy and the
standard copy, carry out the desired computations in the standard
copy, and then use the isomorphisms to transfer the results back to $H$.

The standard copy of $S$ 
has a designated set of {\em standard generators}.
One important component of a constructive recognition algorithm is to find
generators $X$ in an arbitrary representation $H$ of $S$ that correspond to the
standard generators under an isomorphism, and to express the elements of $X$
as SLPs in the input generators of $H$.  
A second is the ability to write elements of $H$ as SLPs in $X$.
These enable the construction of effective isomorphisms
between $H$ and $S$ in both directions.

The standard copy of $\Alt{n}$ is
on $n$ points; its standard generators are $(1,2,3)$ and either of 
$(3,\ldots, n)$ or $(1, 2)(3,\ldots, n)$ according to the parity of $n$.

The standard copy of a quasisimple classical group $G$ is 
its natural representation;  if $A$ is a central subgroup of $G$, then 
the standard copy of $G/A$ is represented by 
the pair $(G,A)$.

Wilson \cite{Wilson96} introduced 
standard generators for the sporadic groups and their covering groups: these  
are defined on the {\sc Atlas} web site \cite{atlas_www}.

The standard copy of each of the remaining simple and quasisimple groups 
$S$ is chosen to be either (the image of) the smallest degree
permutation representation of $S$, or a group pair defined by a small degree
matrix representation over a finite field. 

\subsection{Verification and presentations for simple groups}
\label{sec:presentations}
Our algorithm to construct a composition tree has a {\em verification}
option, which guarantees the correctness of its output.
\comment{DFH: Added first paragraph}
Without this, there is a small probability
(which, as we shall see in Proposition \ref{onlythm} below, can be made
arbitrarily small by the user) that the group is larger than it appears.
This option will be described in Subsection \ref{section:kernel_generation}.
It requires the computation of presentations of
the node groups which, as we shall see in Subsection \ref{subsec:presnonleaf},
reduces to finding presentations of the leaf groups.

For small and for soluble leaf groups, these can be computed using standard
machinery. As we shall explain in Subsection \ref{subsec:generators},
for larger insoluble groups, the problem reduces to the construction of
presentations for the finite simple groups on their standard generators.
Hence a goal of both theoretical and practical interest is to obtain
``short" presentations for the finite simple
groups on {\it specific} generating sets. 

Informally, the length of a presentation is the number
of generators plus the sum of the lengths of the relators;
see \cite{MR2393425} for one definition. 
Key to this work are short presentations for $\Alt{n}$ and $\Sym{n}$.
Independently Bray {\it et al.\ }\cite{alt_sym_short_pres}
and Guralnick {\it et al.\ }\cite{MR2393425}
proved that $\Alt{n}$ and $\Sym{n}$ have presentations with a bounded number
of generators and relations, and length $\OR{\log n}$.

In a major extension, Guralnick {\it et al.\ }\cite{MR2393425} proved that
every non-abelian finite simple group of rank $n$ over $\F_q$,
with the possible exception of $^2G_2(q)$,
has a presentation with a bounded number of generators
and relations and total length $\OR{\log n + \log q}$.
In all cases, the lengths are optimal, up to multiplication by a fixed constant.

There remains the task of
writing down explicit short presentations for the finite simple groups
on their standard generators.  Leedham-Green \& O'Brien \cite{pres}
do this for the classical groups.  Bray \& B{\"a}{\"a}rnhielm 
\cite{sz_blackbox} provide a presentation 
for ${\rm Sz}(q)$ on its standard generators.
Presentations on Steinberg generators 
for the exceptional groups appear in \cite{Babaietal97}.
Presentations on standard generators for 
sporadic groups are available at \cite{atlas_www}.

\subsection{Generating sets}
\label{subsec:generators}
An \uppergp $G$ stored in a node of a composition tree has 
an ordered list of {\em input generators}
that generate $G$. For the root node, they are supplied by the user. 
If the node is a right child under a group pair morphism $\theta$, 
then its input generators are the images of the input 
generators of $G$ under $\theta$.

The group $G$ has a second list of \emph{nice generators}.
This idea was introduced by Neunh\"offer \& Seress~\cite{MR2289128}.
In a non-leaf node with reduction epimorphism $\theta$ and kernel monomorphism
$\theta_0$, its nice generators are the images under $\theta_0$ of the nice
generators of
the kernel node together with inverse images under $\theta$ of the nice
generators of the image node. 
If $G$ is a leaf and its non-abelian composition factor
has standard copy $S$, 
then the nice generators of $G$ are inverse images in $G$ of 
the standard generators 
of $S$ together with a generator of $\Zent(G)$.

We maintain the two lists for a number of reasons.
A critical reason is that we can use the theoretical results 
described in Section~\ref{sec:presentations}
to write down a presentation for a leaf node on its nice generators;
such is not feasible for an arbitrary generating set. 
This results in shorter presentations at all nodes
than would be possible, in general, for an arbitrary generating set.
Another is that we can more easily design rewriting algorithms 
that write an element of a leaf group in terms of its nice generators.
We store SLPs that define the nice generators as words in the input
generators, so words in the nice generators can be rewritten in terms
of the input generators as required. As we show below, this facility 
allows us to rewrite a presentation on the nice generators to one 
on the input generators.

\subsection{Presentations and rewriting for non-leaf nodes}
\label{subsec:presnonleaf}
Assume that presentations and rewriting algorithms are known for
the child node groups $G_0N_0/N_0$ and $G_1N_1/N_1$ on their nice
generators; we now describe how to provide them for $GN/N$. In the following
descriptions, we ignore the {\nullsubgp}s and work just with
$G_0$, $G_1$ and $G$. The {\nullsubgp}s introduce further technical
complications; we defer discussing these until 
Section~\ref{section:scalars}.
To simplify notation, we also identify $G_0$ with its isomorphic
image under $\theta_0$.

\subsubsection{Presentations} 
\label{pres}
The algorithm to write down a presentation of $G$, using the fact that it
is an extension of $G_0$ by $G_1$, is standard; see
for example \cite[Proposition 2.55]{hcgt} or \cite[\S 10.2]{joh90}. 
Let $\{\, X_0 \mid R_0\, \}$ and
$\{\, X_1 \mid R_1\, \}$ be presentations of $G_0$ and $G_1$.

For each $x\in X_1$, choose $x' \in G$ with $\theta(x') = x$.
Let $X_1' := \{\, x' \mid x \in X_1\,\}$ and $X := X_1' \cup X_0$.
For a given word $w$ in $X_1$, we define a word $w'$ in $X_1'$  by
replacing each generator $x$ in $w$ by the corresponding $x' \in X_1'$; and
since each $r \in R_1$ evaluates to $1_{G_1}$ it follows that $r'$ evaluates to
an element of $G_0$.  Let $w_r$ be a word in $X_0$ that evaluates
to the same element, and let $R_1'=\{r'w^{-1}_r\mid r\in R_1\}$.
For each $x_0\in X_0$ and $x\in X'$ we have $x^{-1}x_0x\in G_0$;
so there is a word $w_{xx_0}$ in $X_0$ that evaluates to this element.
Let $S=\{x^{-1}x_0xw_{xx_0}^{-1}\mid x\in X'_1,x_0\in X_0\}$.
Now, if $R:=R_0\cup R'_1\cup S$, then $\{X\mid R\}$ is a presentation of $G$.

We use this theory with $X_0$ and $X_1$ being the sets of nice
generators of $G_0$ and $G_1$ respectively, and define $X := X_1' \cup X_0$
to be the set of nice generators of $G$. We use our rewriting algorithm
in $G_0$ to calculate the words $w_r$ and $w_{xx_0}$.

To rewrite this presentation on the input generators of $G$, 
we use the following result; see for example
\cite[\S 4.4, Remark 7]{joh90}.
If $G = \langle X \rangle$, then two words in $X$ are 
{\em $G$-equivalent} if they represent the same element of $G$.

\begin{pr}\label{changegens}
Let $\{ X \mid R \}$ be a presentation of a group $G$.
Let $Y$ be another generating set of $G$, and let $Y_\rho$ and $X_\rho$ be
functions, which respectively rewrite words in $X$ to $G$-equivalent words
in $Y$ and words in $Y$ to $G$-equivalent words in $X$.
Let $S = \{ Y_\rho(r)\mid r \in R \} \cup
\{ Y_\rho(X_\rho(y))y^{-1} \mid y \in Y \}$.
Then $\{ Y \mid S \}$ is a presentation of $G$.
\end{pr}

\subsubsection{Rewriting}\label{rewriting} 
The construction of the rewriting algorithm for $G$ on its nice generators
from those of $G_0$ and $G_1$ is straightforward.
For $g \in G$, we rewrite $\theta(g) \in G_1$ as a word $w$ in $X_1$
and define the corresponding word $w'$ in $X_1'$ as described above.
We evaluate $w'$ to obtain $h$ in $G$, so $gh^{-1} \in G_0$, and write
$gh^{-1}$ as a word $w_0$ in $X_0$.  Now $g$ is written as the
word $w_0w$ in $X$.

We label as $\rho$ 
the function that assigns the element $gw^{-1}$ of $G_0$ to $g \in G$. 

\section{The composition tree algorithm}
\label{section:algorithm}
Recall that a composition tree for a group is stored as a full binary tree. 
Each node describes the \repgp of a group pair $(G,N)$,
and has various data attached to it.
Its right child, with associated group pair $(G_1,N_1)$,
represents the image of $(G,N)$ under a group pair morphism
$\theta$, which arises from a reduction. 
Its left child, with associated group pair 
$(G_0,N_0)$, represents the kernel
of $\theta$. More precisely,
there is a group pair morphism $\theta_0$ from the left child to
$(G,N)$ such that $\theta_0$ and $\theta$ form an exact sequence.
It is often -- but not always -- true that $\theta_0$ is simply 
an inclusion map.
This flexibility allows us to store the kernel in a different
representation, which may be more efficient. For instance, if $\theta$
arises from a tensor decomposition of a matrix group, then we store
both the image and the kernel as matrix groups of smaller dimension.
We allow the represented group of the kernel or image to be trivial, provided
that $\theta$ represents some kind of simplification, such as in the degree of
the matrix group or in the field size.

For the group pair $(G,N)$ associated with the node, the \nullsubgp $N$ is
always cyclic and centralised by $G$.
If $G$ is a permutation group or elementary
abelian, then $N$ is trivial. If $G$ is a matrix group then $N$ 
consists of scalar matrices. It may also be non-trivial when $G$ is a cyclic
group.  More details about the null subgroups, and their definitions 
for the various reductions, are given in
Section \ref{section:scalars}. 
The \nullsubgp of the root node is trivial by default, but it may be assigned
by the user subject to these constraints.

\subsection{Data structures for a node}\label{section:datastructures}
We list the important data components stored in a node with
associated group pair $(G,N)$.  Some of these components are available 
only when the construction of the composition tree rooted at that node is complete.
\begin{enumerate}
\item The input generators of $G$.
\item A generator for the \nullsubgp $N$.
\item An instance of the product replacement algorithm for $G$ on its input
generators, for generating random elements of $G$. 
\item A list of reduction algorithms that can be used to find a
  reduction homomorphism for $G$, in order of priority.
  This priority may vary according to the reduction used 
  to construct $G$. 
\item The nice generators of $G$.
\item A list of SLPs of the nice generators in the input generators.
\item A rewriting algorithm that expresses $g \in GN$ as an
SLP in its nice generators that evaluates to an element in $gN$.
\item A list of {\it mandarins}. These are random elements used to test the
correctness of the subtree rooted at the node --
see Section~\ref{section:general}.
\item A list of SLPs of relators for a presentation of $G$ on its 
nice generators.
\item A list of lists of SLPs of elements in the nice generators 
of $G$ whose images (in the appropriate sections) generate each 
composition factor. 
\item The data associated with the composition series
described in Section \ref{subsection:rearrange_interface}.
\end{enumerate}

If the node is not a leaf, then there is a reduction epimorphism
$\theta$ to its right child and a monomorphism $\theta_0$ from its left child.
The following additional data is stored.
\begin{enumerate}
\item The reduction epimorphism $\theta$.
\item A list of SLPs of the images under $\theta_0$ of the input 
generators of the left child in the input generators of the node.
\end{enumerate}

If the node is a leaf, then the following additional data is stored.
\begin{enumerate}
\item The isomorphism type of $G$ if it is abelian. 

\item If $G$ is quasisimple, then an effective 
epimorphism $\alpha : G \to S$ to the standard
copy of the non-abelian composition factor of $G$, and 
effective inverse $\beta$.
\end{enumerate}

\subsection{The basic algorithm}\label{section:general}
We now describe in more detail the composition tree algorithm. 
We apply this initially to the input group $G \leqslant \GL(d,\F_q)$ 
or $G \leqslant \Sym{n}$,
but during the application of the algorithm 
it is applied recursively to the other node groups. 
We discuss the reductions as they apply to $G$,
and defer until Section~\ref{section:scalars} the details of 
how we process
the \nullsubgp and define the {\nullsubgp}s of the node's children.

Before describing the algorithm, we discuss the important
\comment{DFH: I have rewritten the two paragraphs on mandarins}
role played by the mandarins in establishing the correctness
of the construction.
When we start to process a node, the associated
group has a generating set and a set of mandarins. 
In the root node, the mandarins are random elements of the input group. 
For every node, the expectation is that the mandarins all lie in the 
associated group. For leaf nodes we test this immediately after
processing the node. For non-leaf nodes, the succesful construction of the
subtree rooted at this node enables us to write the mandarins as SLPs in the
nice generating set, which implies their containment in the group. 
A failure of a mandarin to lie in the group implies that something has gone
wrong with our construction of the tree, and this provokes a {\em crisis}.
Our method of correcting the mistake is described in Section
\ref{section:crisis-management} below.

We explain now how we construct the mandarins of the child nodes
of a non-leaf node.
The mandarins of the group $G_1$ of the right child are defined to be
the images of those of $G$ under the reduction epimorphism $\theta:G \to G_1$.
If one of these images cannot be computed for some reason
(for example, if $G_1$ is reducible and the mandarin does not fix the fixed
submodule of $G_1$), then the mandarin does not lie in $G_1$,
and a crisis is provoked.
If no problem is detected during the construction of the
subtree rooted at $G_1$, then the mandarins of $G_1$ lie in $G_1$.
The mandarins of the group $G_0$ of the left child are then obtained by
applying the function $\rho$, defined in Section \ref{rewriting},
to the mandarins of $G$.

In summary, the algorithm to construct the composition tree
for the input group $G$ is the following.
\begin{enumerate}
\item Attempt to construct a reduction morphism $\theta : G \to G_1$. 
\comment{DFH: I have made some changes to this summary.}
See Sections \ref{section:perm_reductions} and 
\ref{section:matrix_reductions} for details.

\item If no reduction is found, then the node is marked as a leaf.
\begin{enumerate}
\item Process the leaf as described in
Section \ref{section:leaf_algorithm}. This includes identifying any nonabelian
composition factor of the leaf group and, where possible, applying an
appropriate contructive recognition algorithm.
\item If verification is required, then construct a presentation of the leaf
group on its nice generators.
%If the relations of the known presentation of the simple composition factor
%are not satisfied, then a crisis is provoked.
\item Test the mandarins of the node for membership in the group.  
If this fails, then a {\it crisis} is provoked. Otherwise, halt.
\end{enumerate}

\item Set up the data structure for the right child of the node, and
try to define the mandarins for this child as discussed above.
If this fails, then a crisis is provoked.
Otherwise recursively construct a composition tree for the right child.

\item Construct a putative generating set for $\Ker \theta $, define 
the group $G_0$
of the left node and the isomorphism $\theta_0:G_0 \rightarrow \Ker \theta $.
See Section \ref{section:kernel_generation} for details.
Construct the mandarins for this child, as discussed above.

\item Recursively construct a composition tree for $G_0$. 
If we construct this subtree without provoking a crisis, then we have
established that the mandarins associated with $G_0$ lie in $G_0$.
It then follows from the definition of the mandarins of the
child nodes that the mandarins of $G$ lie in $G$.

\item Set up the nice generators and the rewriting algorithm for $G$ as
described in Section~\ref{subsec:generators}.
\comment{DFH: I moved this check on the input generators from the verification
paragraph to here, because it is always carried out.}
Apply the rewriting algorithm to the input generators of $G$ to check that
they lie in the group generated by the nice generators. If not, then a
crisis is provoked.

\item
If verification is required, then attempt to construct a presentation of $G$
on its nice generators from presentations of its children. 
If we construct the presentation, then we have
verified that the composition tree for $G$ is correct.
If the attempt to construct a presentation fails a crisis is provoked.
\end{enumerate} 

\begin{pr}\label{onlythm}
If the above algorithm completes successfully without using verification,
and if the number of mandarins at each node is $M$, 
then the probability of an
incorrect result being returned is at most $1 - (1- 2^{-M})^\ell$,
where $\ell$ is the number of left child nodes in the resulting tree.
\end{pr}
\begin{proof}
The only source of possible error is when the left child of a node
\comment{DFH: This assumes that the constructive recognition algorithms
never return a false positive.}
is created, and the generating set for this node is inadequate.
If this is the case, then the deficiency will be detected unless the
generating set generates a group that contains the mandarins.
If the generating set generates a subgroup of index $k$, then
the probability that the mandarins all lie in this subgroup is
$1/k^M$ since the construction of the generating set is independent
of the mandarins.  Since $k\ge 2$ the result follows.
\end{proof}

\subsection{Kernel generation}
\label{section:kernel_generation}

A critical task is the construction of a generating set for $\Ker\theta$
in Step (4) of the main algorithm.
The reductions described in Sections \ref{semilinear} and 
\ref{pgroup} provide these generating sets directly, but the others 
do not. We now describe two general methods to 
construct $\Ker\theta$: the {\em random element} method introduced 
in \cite{crlg01}, and the {\em presentation} method
introduced in~\cite{MR2289128}.

If there are non-trivial {\nullsubgp}s, then we must construct
the kernel of $\phi:GN/N \to G_1N_1/N_1$ rather than of $\theta$, but
for the moment we ignore this problem and describe the computation
of the kernel of $\theta:G \to G_1$. The presence of {\nullsubgp}s
introduces some technical complications that we discuss
in Section \ref{section:scalars}. 
To simplify notation, we identify $G_0$ with $\Ker \theta$,
whereas in reality $\Ker \theta$ is the isomorphic image of $G_0$ under
$\theta_0$. In all our reductions, images and inverse images under
$\theta_0$ are easily computed. 

\subsubsection{The random element method}\label{subsubsec:randommethod}
This has two ingredients.  
The first is the construction of a set of random elements of $G_0$; this set, 
which may be augmented from time to time, will be the
putative input generating set $Y_0$ of $G_0$.  
It can only be carried out when a composition tree for $G_1$
has been constructed.
The second, {\em verification}, decides
definitively whether $Y_0$ is adequate.
It requires that we 
can construct a presentation for $G_1$ on its nice generators.
In the absence of verification we have a Monte Carlo algorithm, with
a bound to the probability of failure given by Theorem \ref{onlythm}.

%(In practice, we can opt to construct
%a composition tree for the input group without verification, and
%retrospectively verify the complete tree.)

\vspace*{0.1cm} \noindent{\tt Constructing random elements of $G_0$.}
Given a rewriting algorithm for $G_1$, we define the function
$\rho:G\to G_0$ of Section~\ref{subsec:generators}.
Observe that $\rho(g)$ depends only on $\theta(g)$: namely, on the coset of
$\Ker \theta$ that contains $g$, and not on the value of $g$ within this
coset.  Thus if $U=\set{g_1,\dotsc,g_k}$ is
a set of (nearly uniformly distributed independent) random elements 
of $G$, then $\rho(U)$ and 
$\theta(U)$ are such sets for $G_0$ and $G_1$ respectively.

We use $\rho$ to construct a putative generating 
set $Y_0$ of random elements of $G_0$.
Various theoretical upper bounds to the size of $Y_0$ required
to generate $G_0$ with high probability are known.
Let $d(G)$ be the minimal size of a generating set
of a finite group $G$.
If $G \leqslant \Sym{n}$, then $d(G) \leqslant n/2$ for $n>3$ by~\cite{CST89}.
If $G \leqslant \GL(d,\F_q)$, then $d(G) \leqslant 3d/2$ if $G$ is completely
reducible, and $d(G/O_p(G)) \leqslant 3d/2$ in general; these bounds 
are sharp \cite{KR91}. Improved bounds for completely reducible
groups over specific fields appear in~\cite{matgp_gens}: 
also if $G$ is a subnormal subgroup of a primitive group,
then $d(G) \leqslant  2 \log_2 d$. % ~\cite{matgp_gens}.
Observe that $|O_p(G)| \leqslant q^{d(d-1)/2}$, and there
are $p$-groups $G< \GL(d,\F_q)$ with $d(G) = ed^2/4$ where $q=p^e$, so
$d(G) = \OR{d^2\log q}$ in general; again this is best possible. 
Every finite group $G$ is generated with high probability by 
$d(G) + \OR{\log\log |G|}$ random elements of $G$; see, for example,~\cite{L02}.
Thus, to ensure that with provably high probability $Y_0$
generates $\Ker \theta$, the required value of $\abs{Y_0}$ 
is $\OR{d^2 \log q}$ in general, $\OR{d}$ if $O_p(G)=1$,
or $\OR{\log d}$ if $G_0$ is a subnormal subgroup of a primitive
group (a condition that holds for many nodes).

As we show in Section \ref{meataxe}, if the input group
$G \leqslant \GL(d, \F_q)$, then $O_p(G)$ is always the group of the
left child of the root node;  so it 
and its descendants may need $\OR{d^2\log q}$ generators. 
On the other hand, the right child of the input group and its descendants
almost always have $O_p(G)=1$, and so need at most $3d/2$
generators. (The only possible exception is the right child of
an extraspecial normaliser reduction.)
If we know that $G_0$ is primitive, then we can use the $\OR{\log d}$ bound.

Our experience suggests that using large numbers of kernel
generators is detrimental to the performance of the algorithm,
and it is preferable to impose an absolute
upper bound on the initial value
of $\abs{Y_0}$.  We use different bounds in the three cases:
when $O_p(G)=1$, when $G_0$ is primitive, and otherwise.
If $Y_0$ does not generate $G_0$, then we double its size.
Our implementation allows flexibility in the initial
choice of $\abs{Y_0}$.

\vspace*{0.1cm} \noindent{\tt Verification.}
If the procedure to verify that $\langle Y_0 \rangle = G_0$
%has three steps.
%We first use the rewriting algorithm for $G$ on its nice generators to test
%whether the input generators $Y$ of $G$ 
%lie in the subgroup generated by its nice generators $X$.
%If so, then we have proved that $G$ is generated by its nice
%generators. If not, then verification fails.
%We execute this step even if we are not performing complete verification
%using a presentation.
%The rest of the verification process is carried out (if at all)
is to be carried out, then this is done
at the same time as constructing the presentation for $G$ from those of
$G_0$ and $G_1$, as described in Section \ref{pres}.
In the notation of that section, when we rewrite  
the elements $x^{-1}x_0x$ as words in $X_0$, we are at the same time
checking that these words lie in $\langle X_0 \rangle$.
If so, then we have proved that $\langle X_0 \rangle \triangleleft G$.
If not, then verification fails.

If $\{X_1 | R_1 \}$ is the presentation of $G_1$, and
$X_1'$ is the set of nice generators of $G$ corresponding
to $X_1$, then verification is completed by checking that
every $r\in R$, when evaluated on $X_1'$, gives an element
of $\langle X_0 \rangle $.

\subsubsection{The presentation method}
This can be used if a presentation of $G_1$ is known.
Let $R_1'$ be the set of inverse images in $G$ of the relators $R_1$,
as described in Section~\ref{pres}, so 
$G_0 = \gen{ R_1' }^G$. 
We use the Monte Carlo algorithm of \cite{MR1235795} to construct this
normal closure.  An upper bound to the number of generators needed
to generate the normal closure is a function of the 
length, $l_G$, of the longest subgroup chain in $G$.
If $G \leqslant \GL(d, \F_q)$ then $l_G = \OR{d^2 \log q}$~\cite{ST91}. 
If $G \leqslant \Sym{n}$ then $l_G \leqslant 3n/2$~\cite{CST89}.

\subsubsection{A comparison of the methods}
Both methods construct random elements of the kernel.  The random method
relies on the use of the product replacement algorithm to construct random 
elements of $G$, and the function $\rho$ to convert these into
random elements of $G_0$.  
The presentation method requires a set of normal generators $R_1'$ 
for $G_0$, as a subgroup of $G$, arising from a presentation 
for $G_1$ on $Y_1$.  It initialises $Y_0$ to $R_1'$, 
and augments $Y_0$ by adding 
random normal subproducts \cite{MR1235795} 
of $\langle Y_0\rangle$ in $\langle Y\rangle$.  
While the resulting set generates $G_0$ with a provable probability, 
the elements of $R_1'$ are not uniformly distributed in $G_0$, 
and so we may require a large generating set to construct $G_0$.
Using the random method, we initialise $Y_0$ to contain 
some initial number of random elements of $G_0$
and add more as required; 
we expect that the resulting generating set for $Y_0$ is smaller. 
Verification using the presentation method is 
somewhat easier: since $R_1'$ is already contained in $Y_0$,
there is no need to check this during verification.

We consider briefly the cost of the two methods.
For the random element method, the cost of the construction of 
a random element, and the length of the 
SLP required to construct it, is dominated by the corresponding cost of 
the rewriting algorithm in $G_1$.
For the presentation method, one first produces a
presentation for $G_1$ on $Y_1$.
Each relator expressing 
an element of $Y_1$ as an SLP in the nice generators is 
an instance of rewriting in $G_1$. Of course, this rewriting 
is also done with the
random element method if verification is required.

Our experience suggests that the random element method performs
better than the presentation method provided that appropriate 
choices are made for the initial values of $\abs{Y_0}$.

\subsection{Crisis management}
\label{section:crisis-management}

In practice, we use smaller bounds for the sizes of the 
generating sets than those demanded by theory. 
Hence both methods may fail to find the full kernel. This has
consequences for the design of the composition tree algorithm.
As part of the construction of the composition
tree rooted at the kernel, we test the mandarins for membership in the kernel, 
which entails testing mandarins for membership of nodes that
are descendants of the kernel.
If a membership test for a mandarin fails, 
then some left child on the path from this node to the root was
not calculated correctly; it need not be the 
node where the membership test fails.
If this failure occurs, then it is a \emph{crisis},
and we must discard a part of the tree and recompute it.
If there are several kernel computations on the path from the node
to the root, then we do not know which of them is incorrect. We
therefore introduce the notion of a \emph{safe} node defined as follows.
\begin{itemize}
\item The root node is safe.
\item A right child is safe if and only if its parent is safe.
\item A left child is never safe unless it is calculated using some
  method guaranteed to construct the full kernel, in which case it is safe if and only if its parent is safe.
\end{itemize}
If a crisis occurs during rewriting in a node, we 
backtrack along the path from the node to the root, until we reach a
safe node. We discard the left subtree of this safe node, 
retaining only the known generators of its left child. We add more
generators to this kernel and try again.

\section{Reductions for permutation groups}
\label{section:perm_reductions}
This and the following section are devoted to Step (1) of the main composition
\comment{DFH: added paragraph}
tree algorithm summarised in Subsection \ref{section:general}.
The individual algorithms that attempt to construct the various types of
reduction morphisms are described elsewhere. Here, we just describe
what they do, and how they fit into our the structure of our main program.

We provide reductions from general permutation
groups to small base groups, which can be then be studied 
using standard machinery. These reductions were introduced  
in \cite{MR2289128}.  

\subsection{Intransitivity}
If $G \leqslant \Sym{n}$ is intransitive, then it
induces an action on an orbit $\mathcal{O}$. 
We use standard machinery 
to construct $\theta : G \to \Sym{\mathcal{O}}$. 

\subsection{Imprimitivity}
A transitive subgroup of $\Sym{n}$ is
imprimitive if it preserves a non-trivial partition of
$\Omega = \set{1, \dotsc, n}$. We use standard machinery 
to set up the associated reduction. 

\subsection{Handling the giants}
We use the Monte Carlo algorithm described in  
\cite[\S 10.2]{seress03} 
to determine whether $G$ is $\Alt{n}$ or $\Sym{n}$.
If so, it is processed as described in Section~\ref{section:c9_reduction}.

\subsection{Large base primitive groups}
The algorithm of \cite{jellyfish} determines if a primitive
subgroup $G$ of $\Sym{n}$ is a
subgroup of a wreath product of $\Sym{m}$ and $\Sym{r}$ in product
action on $k$-element subsets of $\set{1, \dotsc, m}$, containing
$\Alt{m}^r$. If so, the algorithm constructs a monomorphism $\theta : G \to
\Sym{mr}$ whose faithful image is imprimitive with $r$ blocks of size $m$. 

\vspace*{0.1cm}
If none of these reductions applies, then $G$ is a small base group.
The leaves of the composition tree for a permutation group are 
either simple or soluble. 

\section{Reductions for matrix groups}
\label{section:matrix_reductions}

The reductions that arise from our constructive
version of Aschbacher's theorem are described in
\cite{crlg01, MR2258009}. 
Here we summarise both these and others. 
The order in which they are described is the default order 
in which they are applied; in particular situations 
they may be applied in a different order.
For the most part, we defer discussion of the complications introduced by
{\nullsubgp}s until Section~\ref{section:scalars}.

Neunh\"offer \cite{Neunhoffer09}
reformulated the categories introduced by 
Aschbacher \cite{aschbacher84} 
to facilitate easier membership problems;
he and Seress use these reformulations in their
GAP implementation~\cite{MR2289128}.

\subsection{Unipotent reductions}
$G \leqslant \GL(d, \F_q)$ is unipotent if and only if every $g
\in G$ has order a power of $p$, the characteristic of $\F_q$. 
Moreover, $G$ is unipotent if and
only if every composition factor of the $\F_qG$-module has dimension
$1$ and $G$ acts trivially on every factor.

We first employ a fast negative test:
if any generator of $G$ has order 
not a power of $p$, then $G$ is not unipotent. Otherwise 
we use the {\Meataxe} \cite{Parker84, meataxe, better_meataxe}
to decompose the 
$\F_qG$-module and test if its composition factors satisfy the criteria.

If $G$ is unipotent, then the {\Meataxe} provides a change-of-basis
matrix $c$ such that $G^c$ is lower unitriangular. 
The projection of $G^c$ onto its first non-zero subdiagonal is a homomorphism.
The image of this reduction is elementary abelian and is treated as a leaf.
It has trivial \nullsubgp and is stored as a PC-group.

\subsection{Submodule reductions}
\label{meataxe}
Let $V$ be
the natural $\F_qG$-module of $G \leqslant \GL(d, \F_q)$. First we find the
indecomposable summands of $V$, so $V \cong V_1 \oplus \dotsb \oplus
V_k$. Next we find a composition series of each $V_i$.
This also provides a change-of-basis matrix $c_i \in \GL(V_i)$ that
exhibits this series. We use the change-of-basis matrix
$c = \bigoplus_{i = 1}^k c_i$ (diagonal join)
to exhibit both the direct sum decomposition of $V$ and the 
composition series of each $V_i$.
The corresponding composition series of $V$ is
\begin{equation*}
0 = V_{1, 0} < V_{1, 1} < \dotsb < V_{1, n_1} < V_1 \oplus V_{2, 1} < 
\dotsb < V_1 \oplus V_2 < \dotsb < V.
\end{equation*}

Now $G^c$ is both block lower triangular, corresponding to the
composition factors of $V$, and block diagonal, corresponding to the
direct summands of $V$. We obtain a homomorphism by projecting onto
the diagonal blocks corresponding to the composition factors. The
kernel of this homomorphism is ${O}_p(G)$. 
If the input group $G$ is not unipotent, then this is the first reduction
in the composition tree, so the 
composition tree has the property that ${O}_p(G)$ is the first
kernel. Thus the composition factors arising from
${O}_p(G)$ are at the bottom of the composition series
determined by the tree; so we avoid later
rearranging of the (potentially large number of) composition factors
of ${O}_p(G)$. Furthermore, all node groups  arising to the right
of the root node of the tree (almost always) have trivial $p$-core
and so have generating sets of cardinality $\OR{d}$.

The group $G_1$ of the right child is now contained in $\GL(V_1) \times
\dotsm \times \GL(V_k)$, embedded in $\GL(d, \F_q)$. From this node we
obtain a homomorphism onto the first non-trivial summand
block. The right child of this reduction is contained in $\GL(V_1)$.
From this node we obtain a homomorphism $\theta_{1,1}$ to
$\GL(V_{1,1})$, and then a homomorphism $\theta_{1,2}$ from $\Ker \theta_{1,1}$
to $\GL(V_{1,2}/V_{1,1})$, and so on. 
Continuing in this way, we obtain reductions to the groups acting on
the composition factors of $V$. 

Of course, we could also obtain a homomorphisms from $G_1$
onto its restriction to a composition factor of $V$.
%directly to groups acting on the factors of $V$. 
If $V$ has  $n$ composition factors,
then the number of kernel computations is $n-1$ in either case.
One argument for proceeding through summands is that it leads to a
reduction of dimension. If we
map directly to factors, then the first kernel would be embedded in
$\GL(V / V_{1,1})$. If we first map to a summand, then $\Ker
\theta_{1,1}$ is embedded in $\GL(V_1 / V_{1, 1})$ which may have much
smaller dimension. Since matrix multiplication
has cubic complexity in the dimension, this is desirable.
%Also the resulting composition tree 
%exhibits more of the structure of $G$.

\subsection{Absolute reducibility}
Groups that act irreducibly but not absolutely irreducibly are in 
the \emph{semilinear} Aschbacher class. We consider
these separately from the general semilinear case, since we have a faster
reduction, an isomorphism, in this special case. 
An irreducible group $G \leqslant \GL(d, \F_q)$ is
not absolutely irreducible if it is reducible when embedded 
into $\GL(d, \F_{q^e})$
for some $e > 1$. The smallest $e$ such that the constituents of
the embedding into $\GL(d, \F_{q^e})$ are absolutely irreducible determines the
\emph{splitting field} $\F_{q^e}$ for $G$. Now $G$ has a faithful
representation $\theta : G \to \GL(d/e, \F_{q^e})$.
Holt and Rees \cite{meataxe} describe an extension of the {\sc MeatAxe}
that constructs~$\theta$.  

\subsection{Semilinearity}
\label{semilinear}

If $G \leqslant \GL(d, \F_q)$ acts absolutely irreducibly and semilinearly, 
then there exists $K \triangleleft G$
% \leqslant \GL(d, \F_q)$ 
that acts irreducibly but not absolutely irreducibly, and so has a splitting
field $\F_{q^e}$. Moreover, there is a non-scalar $C \in \Zent(K)$
such that for every $g \in G$ there exists $i_g \in \{1, \ldots, e \}$
where $Cg = gC^{q^{i_g}}$. 

The {\SMASH} algorithm of \cite{MR1407872} provides $e$ and $C$, 
and so we obtain a homomorphism $\theta:G \to \Cent_e$ with non-absolutely
irreducible kernel, given by $g \mapsto i_g$.

For this reduction, we obtain generators for the
kernel $G_0$ as follows.
Let $G = \langle x_1, \dotsc, x_m \rangle$ and 
let the image $G_1 = \langle y_1, \dotsc, y_m \rangle \leqslant \Cent_e$.
\begin{enumerate}
\item
Use the extended Euclidean
algorithm to obtain $n = \gcd(y_1, \dotsc, y_m, e)$ and an
expression $n = a_0 e + \sum_{i = 1}^m a_i y_i$ with $a_i \in \Z$.
\item Let $x = \prod_{i = 1}^m x_i^{a_i}$ and $h_i = x_i x^{-y_i/n}$ for
$i = 1, \dotsc, m$. Then $\theta(x) = n$, so each $h_i \in G_0$.
Let $k_0 = x^{e / n}$. Then $k_0 \in G_0$, and 
$\set{k_0,h_1, \dotsc, h_m}$ is a normal generating set for $G_0$.
%\item Let $k_0 = x^{\abs{I} / n}$ and $k_{i, j} = h_i^{x^j}$ for $i = 1, \dotsc, m$ and $j = 0, \dotsc, e-1$. 
\item Hence $G_0 = \gen{\set{k_0} \cup \set{h_i^{x^j} : 1 \leqslant i \leqslant m,
0 \leqslant j \leqslant e-1}}$.
\end{enumerate}

\subsection{Imprimitivity}
$G \leqslant \GL(d, \F_q)$ is imprimitive if it permutes a
non-trivial direct sum decomposition 
of $V = \F_q^d$. Hence $V \cong
V_1 \oplus \dotsm \oplus V_k$, where all $V_i$ have the same dimension.
The algorithm of \cite{primitivityalg} constructs the 
homomorphism $G \to \Sym{k}$. 

The kernel $G_0$ consists of those elements that preserve the 
decomposition of $V$, and hence it is reducible.
The algorithm provides a change-of-basis 
matrix that exhibits the block diagonal structure of $G_0$.
When we process $G_0$, we first apply the submodule reductions.

\subsection{Extraspecial and symplectic normalisers}
\label{pgroup}
$G \leqslant \GL(d, \F_q)$ is in this Aschbacher class if it
normalises an $r$-group $R$ of order $r^{2m + 1}$ or $2^{2m + 2}$,
where $r$ is prime, $r^m = d$ and $r | q - 1$. If $r > 2$ then $R$
is extraspecial; if $r = 2$ then $R$ is either extraspecial or of
symplectic type (a central product of an extraspecial
$2$-group and a cyclic group of order $4$).

If $m = 1$ then the algorithm of \cite{MR2142090} constructs this homomorphism
$G \to \Sp(2, \F_r)$. If $m > 1$ then the algorithm of \cite{MR2257997}
constructs a homomorphism $G \to \GL(2n, \F_r)$ or $G \to \Sym{r^n}$,
where $1 \leqslant n \leqslant m$.
(The latter is an action on blocks of imprimitivity.)
The algorithms also construct generators of the kernel of the homomorphism.

\subsection{Smaller fields modulo scalars}
\label{smallerfield} 
$G \leqslant \GL(d, \F_q)$ 
is in this Aschbacher class if 
there exists $c \in \GL(d, \F_q)$ such that 
$H \leqslant \GL(d, \F_s) Z$ with $H^c=G$,
where $Z = \Zent(\GL(d, \F_q))$ and $\F_s < \F_q$.
We use the polynomial-time Las Vegas algorithm 
of \cite{smallerfield} to
compute the change-of-basis matrix $c$.
If $H \leqslant \GL(d, \F_s)$, then this conjugation
is an isomorphism $\theta:G \to H$, in which case $H$ becomes the group
of the right child node, whereas the group of the left child node is trivial.

Otherwise each $g \in G$ satisfies $g= h^c \lambda_g$
with $h \in H$ and $\lambda_g$ scalar. This factorisation is
not unique: % only up to multiplication by scalar matrices in $\GL(d, \F_s)$,
% since 
we can replace $h^c$ and $\lambda_g$ by $h^c\lambda_s$ and
$\lambda_s^{-1}\lambda_g$ respectively
for any scalar matrix $\lambda_s \in \GL(d, \F_s)$. 
We define the \uppergp $G_1$ of the image to be the subgroup of $Z$
generated by the elements $\lambda_g$ for each generator
$g$ of $G$, and the \nullsubgp $N_1$ of the image to 
be the subgroup of $Z$ generated
by the \nullsubgp $N$ of the node and $\Zent(\GL(d, \F_s))$. These are
stored as cyclic groups. While the map $\theta:GN \rightarrow G_1N_1$
defined by $g \mapsto \lambda_g$ for $g \in G$ and $n \mapsto n$ for $n \in N$
is not a homomorphism (or even well-defined), it
induces a homomorphism from $GN$ to $G_1N_1/N_1$.
%the \repgp of the image.
The \uppergp of the left child is a subgroup of
$HN \cap \GL(d, \F_s)$, with $\theta_0: h \mapsto h^c$,
and its \nullsubgp is $N \cap \GL(d, \F_s)$. 

It is this reduction and that 
of Section \ref{tensor-product} that obliges us to introduce the \nullsubgp. 
Further details are presented in Section~\ref{section:scalars}.

The algorithm of \cite{smallerfield} requires that 
$G'$, the derived group of $G$, acts absolutely irreducibly.
Carlson, Neunh\"offer \& Roney-Dougal \cite{CNRD}
present a polynomial-time Las Vegas algorithm to
find a non-trivial reduction of an irreducible matrix group $G$ that
has at least one of the following properties: 
\begin{enumerate}
\item $G$ acts semilinearly;
\item $G$ can be written modulo scalars over a smaller field;
\item $G'$ does not act absolutely irreducibly. 
\end{enumerate}
In particular, the algorithm either (i) finds a reduction of $G$
of type semilinearity, imprimitivity, smaller field modulo scalars, or
tensor product; or (ii) constructs a non-trivial homomorphism from
$G$ to $\F_q^\times$.

\subsection{Tensor products}
\label{tensor-product}
$G \leqslant \GL(d, \F_q)$ lies in this Aschbacher class if
its natural module % $V$ has the structure of a tensor product
$V \cong U \otimes W$ and $G$ respects this decomposition. It
follows that $G$ is isomorphic to a subgroup of
$H_0 \circ H_1$ where $H_0 \leqslant \GL(U)$ and $H_1 \leqslant \GL(W)$. 

We use the algorithm of \cite{tensorprodalg} to obtain a 
change-of-basis matrix
$c \in \GL(d, \F_q)$ such that $G^c$ is an explicit Kronecker product.
For $g \in G$, it is now straightforward to compute 
$g_0 \in \GL(U)$ and $g_1 \in \GL(W)$ with $g=g_0 \otimes g_1$. 
This factorisation is not unique: % only up to scalars, since 
we can replace
$g_0, g_1$ by $\lambda g_0,\lambda^{-1} g_1$ respectively
for any scalar matrix $\lambda \in \GL(d, \F_q)$.
We therefore define the full group of scalars in $\GL(W)$ to be the \nullsubgp
$N_1$ of $G_1$ and define $\theta:g \mapsto g_1$. 
While $\theta$ is not necessarily a
homomorphism, it induces a homomorphism from $G$ to $\PGL(W)$. 

\subsection{Tensor induction}
$G \leqslant \GL(d, \F_q)$ is tensor induced if its
natural module % $V$ has the structure of a tensor product 
$V \cong U_1 \otimes U_2 \otimes \dotsm \otimes U_k$, where all $U_i$ have the
same dimension and are permuted by $G$. 
We use the algorithm of \cite{MR1925006} to compute the homomorphism
$G \to \Sym{k}$.

The kernel $G_0$ consists of those elements that preserve the tensor
decomposition of $V$.  When we process $G_0$, we first apply 
the tensor product reduction. 

\subsection{Nearly simple reductions}\label{subsec:ns}
\comment{DFH: I moved the first sentence from the naming the simple factor
section to here, where it makes more sense.}
We use the algorithms of \cite{MR1625479, MR1717416}
to test if $G$ normalises a classical group in its natural representation. 
If not, then we assume that $G$ is in class $\cS$; this consists of other
absolutely irreducible matrix groups that are almost simple modulo scalars and
not defined modulo scalars over a smaller field.
In either case $G$ is {\em nearly simple}:
it has structure $Z.S.E$ where $Z=\Zent(G)$ is the scalar
subgroup of $G$, and $S$ is a non-abelian simple group, 
and $S.E \leqslant \Aut(S)$.

We apply additional reductions to $G$.
The first three are homomorphisms $\theta$ 
to cyclic groups, and will be considered below. 
If $G$ normalises a classical group in its natural
representation, then these three reductions construct $Z.S$.
If $G$ is in class $\cS$, then a fourth is required.
In either case, we treat $Z.S$ as a leaf.

\subsubsection{Determinant}
The determinant map for $G \leqslant \GL(d, \F_q)$ is $g \mapsto \det(g)
\in \F_q^{\times}$, so the image is a cyclic group. 
Converting $\det(g) \in \F_q^{\times}$ to
a power of a generator of $\Imm(\theta)$ requires an invocation of
a discrete log algorithm in $\F_q$.

\subsubsection{Form action}
If $G \leqslant \GL(d, \F_q)$ normalises a classical group $H$ which is
not $\SL(d, \F_q)$, then $H$ preserves a non-degenerate
bilinear form $F$. Hence 
$h F \bar{h}^T = F$ for every $h \in H$, where $\bar{h} = h$ unless $H$ is
a unitary group, in which case $\bar{h} = h^{\sqrt{q}}$ (recall $q$ is a square
in this case). Elements of $G$ preserve $F$ up to a scalar, so
for each $g \in G$ there exists $\lambda_g \in \F_q^{\times}$ such
that $g F \bar{g}^T = \lambda_g F$. Hence we obtain a homomorphism 
$g \mapsto \lambda_g$, with cyclic image. 
Again, converting $\lambda_g$ to a power of a generator of $\Imm(\theta)$
requires the use of the discrete log algorithm in $\F_q$.
To determine whether $G$ preserves a classical form modulo scalars,
we use the {\Meataxe} \cite[\S 7.5.4]{hcgt}.

\subsubsection{Spinor norm}
If $G \leqslant \GL(d, \F_q)$ is an orthogonal group, then the determinant
and form action reductions ensure that
$G \leqslant \SO^{\epsilon}(d, \F_q)$.
But $\SO^{\epsilon}(d, \F_q)$ is not perfect, and we obtain a homomorphism
$G \to \Cent_2$ where $g \in G$ maps to its spinor norm. The kernel of this
map is $\Omega^{\epsilon}(d, \F_q)$ which is simple modulo scalars for
$d \ge 6$.
To calculate spinor norms, we use the algorithms of \cite{spinornorms}.

\subsubsection{Naming the non-abelian composition factor}
\label{subsection:naming}
We assume for the remainder of this section that $G$ is in class $\cS$.
The next step is to identify the isomorphism
\comment{DFH: I moved this section here from Section 9, because it needs to be
applied at this point.}
type of its non-abelian composition factor.
We first calculate the \emph{stable derivative} $D := G^{(\infty)}$ of $G$,
by repeatedly computing commutators, taking normal closures
and testing for perfectness~\cite[\S 2]{MR2258009}.
Since $G/Z$ is almost simple, 
its third derived group is $D$. % [REF -- Steinberg 1960, Kleidman].

Since $G < \SL(d, \F_q)$ and $\Zent(D)$ is the scalar subgroup of $D$,
we have $\abs{\Zent(G)} \le \gcd(d, q - 1)$, and we use this
upper bound to calculate $\abs{\Zent(G)}$ using the Monte Carlo algorithm of
\cite[Theorem 4.15]{MR1829470}.

The procedure to name $S$ has four steps.
\begin{enumerate}
\item 
Decide from
$\abs{\Zent (D)}$ and the (central) orders of a sample of elements 
whether $D$ could be isomorphic to either $\Alt{n}$ or $2{.}\Alt{n}$
for some $n$. If so, attempt to verify the identification by
applying (an extension of) the constructive recognition algorithm
of \cite{MR1743388} to $D$. 

\item Investigate the (central) orders of a sample of elements to decide
  if $D$ could be isomorphic to a specific sporadic group, 
  or a covering group.
  If so, attempt to verify the identification by using the 
  black-box algorithms of \cite{atlas_www}
  to construct its (central) standard generators.

\item We may now assume that $S$ is a group of Lie type.
Find the characteristic of $S$ using the algorithm 
of \cite{blackbox_char}. (An alternative algorithm for 
absolutely irreducible matrix groups appears in \cite{KS09}.)

\item Find the name and defining field of $S$ using
the algorithm of \cite{general_recognition} 
(this assumes that the characteristic is known).
\end{enumerate}
%The algorithms used are black-box; in particular,
%the resulting procedure can also be applied to 
%a permutation group.

\comment{DFH: added final paragraph.} 
If the naming procedure fails for some reason, then we attempt no further
reductions on this node, and use BSGS machinery;
see Subsection \ref {subsec:identfail} for further details.

\subsubsection{Coset action}
\label{subsection:coset_action}
The final reduction is
a mapping to a (small degree) permutation group. 
After applying the previous three reductions, we obtain a nearly simple group
with structure $Z'.S.E'$, where $Z'$ and $E'$ are subgroups
of the original $Z$ and $E$. We revert to the notation $G := Z.S.E$ for
this group.  The determinant reduction ensures that
$\abs{Z}$ divides $\gcd(d, q - 1)$.

We now construct a homomorphism from
$G$ to a permutation group isomorphic to $E$.
We use the method described in \cite{MR2429998}.
Observe $D$ is simple modulo scalars, and the scalars 
in $D$ are restricted to those in the Schur multiplier of $S$.
Let $G_0 := \langle Z, D \rangle$.  We construct the permutation action 
of $G$ on the cosets of $G_0$; 
the image of this reduction is isomorphic to $E$. 
We test two cosets for equality using the rule
$G_0 x_1 = G_0 x_2$ if and only if $x_1 x_2^{-1} \in G_0$.
We use the algorithm of \cite{MR1925006} to decide 
membership in a normal subgroup.

%Before applying this reduction, we identify the isomorphism type of $S$ 
%(see Section \ref{subsection:naming}).
Since we have identified the isomorphism type of $S$,
we can use our knowledge of $\Aut(S)$ to obtain an upper bound to $|E|$
-- this provides a useful termination condition for the coset reduction. 
If $S$ is an alternating or sporadic group, then $|E| \leqslant 2$.
Otherwise $S$ is a known group of Lie type. 
If $S$ is in defining characteristic $p$, then 
$\abs{G : D} \leqslant dg \log_p q$ where $d$ and $g$ are listed
in~\cite[Table 5, p. xvi]{atlas}. 
Since $\abs{G : D} \geqslant \abs{E}$ this provides a useful 
upper bound to $|E|$.
(We thank Frank L\"ubeck for discussion on this point.) 

\section{The \nullsubgp}
\label{section:scalars}
This section concerns the technicalities involved in hadling the null subgroups
\comment{DFH: added this paragraph}
of nodes, and is probably only of interest to readers who are interested in
implementing the algorithm. In the \GAP\ implementations \cite{recogbase,recog},
these problems are simplified by requiring that the null subgroup is either
trivial or the full group of scalars. The advantages of our approach approach
are increased generality, and potentially fewer discrete log calculations.

In Section~\ref{section:matrix_reductions}
we discuss the types of reduction epimorphisms $\theta$ and kernel
monomorphisms $\theta_0$ computed for the non-leaf nodes
representing matrix groups.  There we usually ignore the
fact that the group represented by the node is not just a matrix
group, but is the quotient $GN/N$ for a group pair $(G,N)$.
Recall that, if $(G_0,N_0)$ and $(G_1,N_1)$ are the group pairs of the left
and right children of the node, then we need to define maps $\theta_0:G_0N_0
\rightarrow GN$ and $\theta:GN \to G_1N_1$, with $\theta_0(N_0) \leqslant
N$ and $ \theta(N) \leqslant N_1$, that induce
a monomorphism $\phi_0 : G_0N_0/N_0 \to GN/N$ and an epimorphism
$\phi:GN/N \to G_1N_1/N_1$ such that $\Ker \phi = \Imm \phi_0$ or,
equivalently, $\Imm(\theta_0)N = \{g \in GN \mid \theta(g) \in N_1 \} =
\theta^{-1}(N_1)$.

Let $\theta$ be a reduction map defined on a node, and
let $X$ and $X_1$ be the nice generators of $G$ and of $G_1$, 
so $X_1 = \{  \theta(x) : x \in X\} \setminus \{1\}$.
In Section~\ref{subsec:generators} we define the 
map $\rho:G \to \ker \theta$ by $\rho(g) = g w^{-1}$, where $w$ is the
result of writing $\theta(g)$ as an SLP in $X_1$ and evaluating that
SLP in $X$.

To carry out the required computations involving the \nullsubgp, we need to
extend two of our existing techniques:
\begin{enumerate}
\item[(i)] Our rewriting algorithm at a node must be capable of writing 
$x \in GN$ as an SLP in $X$ that evaluates to an element of $xN$. 
\item[(ii)]
We need to extend $\rho$ to a function $\rho :GN \to \theta^{-1}(N_1)$.
%with the property that $\theta( \rho (x) ) \in N_1$ for all $x \in GN$.
\end{enumerate}

Assume that we can solve (i) in the image node.
To achieve (ii), we apply our rewriting algorithm in 
$G_1N_1$ to $\theta(x)$ for $x \in GN$,
and define $\rho(x) = xw^{-1}$, where $w$ is
the result of evaluating the SLP for $\theta(x)$ 
%the resulting SLP evaluated 
in $X$. 

If we can solve (i) in the leaf nodes, then we use the method
described in Section~\ref{rewriting}, together with the extended
definition of $\rho$, to solve (i) in non-leaf nodes.
% EOB change -- moved from last para 
Only nodes that represent cyclic or matrix groups may
have non-trivial {\nullsubgp}s.
We explain how to solve (i) in cyclic leaf nodes in
Section~\ref{subsec:cyclicnodes}, and in non-abelian leaf nodes
in Section~\ref{section:leaf_algorithm}.

For some of the reductions, we must ensure that
$\theta_0(G_0) \leqslant \Ker \theta$, otherwise the algorithm may go into
an infinite loop.
To achieve this, we need to find inverse images $\tau(n_1)$ in $N$
of $n_1 \in N_1$ and define
$\theta(G_0) := \{ \rho(x)\, \tau(\theta(\rho(x^{-1}))) \mid x \in GN \}$.

%Only nodes that represent cyclic or matrix groups may
%have non-trivial {\nullsubgp}s.

\subsection{{\Nullsubgp}s of cyclic group nodes}\label{subsec:cyclicnodes}
Nodes with cyclic groups are leaves so there are no further reductions.
We use a single nice generator for the cyclic \uppergp $G$ of
the node.
As explained above, we need the ability to rewrite $x \in GN$ as an SLP
in the nice generators of $G$ that evaluates to an element of $N$.
To achieve this, we first find $n \in N$
with $xn \in G$; we then write $xn$ as a power of the nice generator of $G$.

As we show below, cyclic node groups with non-trivial {\nullsubgp}s
occur only as subgroups of $\F_q^{\times}$, so 
both $\abs{G}$ and $\abs{N}$ divide $q-1$.  
% We assume that the prime factorisation of $q-1$ is known.
We apply the following proposition (used
again in Section \ref{nullmatgpred})
with $C=G$ and $D=N$ to find the required
$n \in N$ with $xn \in G$,
and so avoid a discrete log calculation in $N$.
 
\begin{pr}
\label{pr:scalar_patch}
Let $C$ and $D$ be subgroups of $\Cent_m$ and let $x \in CD$. Given a list of the primes
dividing $m$, in polynomial time we can find $z \in D$ such that $xz \in C$.
$($We assume that all elements, including single generators of $C$ and $D$,
are given as powers of a generator of $\Cent_m$.$)$
\end{pr}
\begin{proof}
Let
\[
\abs{C} = \prod_{i = 1}^n p_i^{a_i},\quad
\abs{x} = \prod_{i = 1}^n p_i^{b_i},\quad
\abs{D} = \prod_{i = 1}^n p_i^{c_i}
\]
where each $p_i$ is prime, $a_i, b_i, c_i \geqslant 0$, $a_i +
c_i > 0$ and $b_i \leqslant \max(a_i, c_i)$.
From knowledge of the primes dividing these orders and the fact that
the exponents $a_i,b_i,c_i$ are polynomially bounded, we can compute
$a_i,b_i,c_i$ in polynomial time.
Let $q_i = \abs{x} /
p_i^{b_i}$ for $i = 1, \dotsc, n$, and observe that $\gcd(q_1, \dotsc,
q_n) = 1$. Using the extended Euclidean algorithm, we 
find integers $m_i$ such that $1 = \sum_{i = 1}^n m_i q_i$.

Let $z_i = x^{m_i q_i}$ for $i = 1, \dotsc, n$. Then
  \[ \prod_{i = 1}^n z_i = \prod_{i = 1}^n x^{m_i q_i} =
  x^{\sum_{i = 1}^n m_i q_i} = x, \]
and $\abs{x^{q_i}} = p_i^{b_i}$.
Since $z_i = (x^{q_i})^{m_i}$ and $p_i \not| m_i$, we have $\abs{z_i} =
p_i^{b_i}$.

Now define
$ z := (\prod_{b_i > a_i} z_i)^{-1} $ and observe that if $b_i > a_i$
then $b_i \leqslant c_i$. This implies that $\abs{z}$ divides $\abs{D}$ and hence
$z \in D$.  Finally, $\abs{x z} = \prod_{b_i \leqslant a_i} z_i$, and since
$\abs{z_i} = p_i^{b_i}$ it follows that $x z \in C$.
\end{proof}
%\vspace{-1.1cm}

\subsection{Null subgroups for matrix group reductions}
\label{nullmatgpred}
We now describe how the {\nullsubgp}s % $N_0$ and $N_1$ 
are defined for the various reductions, 
and discuss ensuing complications in the definitions of
$\theta_0$ and $\theta$.  For reductions of type
{\tt TensorProduct} and {\tt SmallerFieldModScalars}, we introduce a
non-trivial \nullsubgp $N_1$ into the image node, even if $N$
is trivial, so we cannot avoid the use of {\nullsubgp}s.

In Table \ref{tbl:scalar_propagation}, we record how 
the {\nullsubgp}s $N_0$ and $N_1$ of the kernel and image nodes are defined for 
each of the reductions applied to $G \leqslant \GL(d,\F_q)$.
The notation used there is the following.
The {\nullsubgp} of a matrix group node always consists of scalar matrices.
An entry $\lambda$ in the table denotes an element of $\F_q$  such that 
the corresponding {\nullsubgp} is $\gen{\lambda I_d}$, 
so $N_0=\gen{\lambda_0 I_{d_0}}$ and $N_1 = \gen{\lambda_1 I_{d_1}}$.
If $G_1$ is a cyclic group, it is convenient (for notational purposes) 
to identify $G_1$ and $N_1$
with subgroups of $\F_q^\times$ and define $\lambda_1$ to be a
generator of $N_1$.
For the {\tt FormAction} reduction, $t = 2$ except in the unitary case, 
when $t = \sqrt{q} + 1$. 
The symbol $\omega_q$ denotes a primitive element of $\F_q$.
The smaller field in the
{\tt SmallerField} and {\tt SmallerFieldModScalars} reductions is
$\F_s < \F_q$, so $\abs{ \omega_s}  = s-1$ and $\abs{\omega_q} =q-1$.

\begin{table}[h]
\begin{tabular}{l|c|c}
Reduction & $\lambda_0$ & $\lambda_1$ \\
\hline
Unipotent & $1$ & $1$ \\
Submodule Reduction & $1$ & $\lambda$ \\
Absolute Reducibility & $1$ & $\lambda$ \\
Semilinearity & $\lambda$ & $1$ \\
Imprimitivity & $\lambda$ & $1$ \\
Extraspecial Normaliser & $\lambda$ & $1$ \\
Smaller Field & $1$ & $\lambda^{\abs{\lambda} / 
\gcd(\abs{\lambda}, \abs{\omega_s}})$ \\
Smaller Field Mod Scalars & 
$\lambda^{\abs{\lambda} / \gcd(\abs{\lambda}, \abs{\omega_s})}$ & 
                            $\omega_q^{\abs{\omega_q} / \lcm(\abs{\lambda}, \abs{\omega_s})}$  \\
Tensor Product & $\lambda$ & $\omega_q$  \\
Tensor Induction & $\lambda$ & $1$ \\
Determinant & $\lambda^{\abs{\lambda} / \gcd(\abs{\lambda}, d)}$ & $\lambda^d$  \\ 
Form Action & $\lambda^{\abs{\lambda} / \gcd(\abs{\lambda}, t)}$ & $\lambda^t$  \\ 
Spinor Norm & $\lambda$ or $\lambda^2$ & $\theta(\lambda I_d) = \pm{1}$  \\
%Spinor Norm & $\lambda^{\lambda_I+1}$ & $\theta(\lambda I_d)$ $(\in \set{0, 1})$  \\
Coset Action & $\lambda$ & $1$ 
\end{tabular}
\caption{Definitions of {\nullsubgp}s for children of a node}
\label{tbl:scalar_propagation}
\end{table}

%\vspace*{-0.93cm} 
We now discuss each reduction in greater detail,
listing the more straightforward cases first.

\noindent{\tt Unipotent.}
If $G$ is unipotent, then $G \cap N=1$, 
so $GN/N \cong G$ and the \nullsubgp can
%effectively 
be ignored.  We put $N_0=N_1=1$.

\vspace*{0.1cm} \noindent{\tt AbsoluteReducibility.}
Here $\theta$ is an isomorphism, so both $G_0$ and $N_0$ are trivial. 
We put $N_1=N$.

\vspace*{0.1cm} \noindent{\tt SmallerField.}
Again $\theta$ is an isomorphism, so both  $G_0$ and $N_0$ are trivial.
We define $N_1$ to be the intersection of $N$ with $\GL(d,\F_s)$.

\vspace{0.1cm} \noindent{\tt Imprimitivity}, {\tt Semilinearity}, 
{\tt TensorInduction}, {\tt ExtraspecialNormaliser} and {\tt CosetAction}.
In each case, $\theta$ is a homomorphism with $N < \Ker\, \theta$,
so we set $N_1=1$ and $N_0=N$, 
define $G_0 := \{ \rho(g) \mid g \in G \}$,
 and $\theta_0$ is  the identity map.

\vspace*{0.1cm} \noindent{\tt TensorProduct}.
Recall from Section~\ref{tensor-product} that
$G$ respects a decomposition $V \cong U \otimes W$.
Let $d=d_0d_1$, where $d_0 = \dim(U)$ and $d_1 = \dim(W)$.
The projection $\theta:GN \to \GL(d_1,\F_q)$
is not generally a homomorphism (it is not even well-defined),
but it induces a homomorphism
$\phi:GN \to \PGL(d_1,\F_q)$ with $N < \Ker \phi$. We define $N_1$ to 
be the full scalar subgroup of $\GL(d_1,\F_q)$.
Every element of  $\Ker \phi$ can be written uniquely as $g_0 \otimes I_{d_1}$
with $g_0 \in \GL(d_0,\F_q)$.
We define $G_0$ to be the subgroup of $\GL(d_0,\F_q)$ generated by the elements
$g_0$ arising in this way from a generating set of $\Ker \phi$.
Recall that $N = \langle \lambda I_d \rangle$. 
We define $N_0 := \langle \lambda I_{d_0} \rangle$,
so $N = N_0 \otimes I_{d_1}$.
The map $\theta_0:G_0N_0 \to GN$ is defined by $\theta(x) = x \otimes I_{d_1}$.
The inverse of $\theta_0$ is computed by writing elements in
$\Ker \phi$ as $x \otimes I_{d_1}$.

\vspace*{0.1cm} \noindent{\tt SubmoduleReduction}.
Here $\theta: GN \to \GL(d_1,\F_q)$ is a homomorphism that restricts to
a monomorphism on $N$, and we define $N_1 := \theta(N) =  \langle 
\lambda I_{d_1} \rangle$
and $N_0=1$. The elements $\rho(x)$ with $x \in GN$ satisfy
$\theta(\rho(x)) = \mu_x  I_{d_1} \in N_1$ for some $\mu_x \in \F_q$,
We define $G_0 := \{ \rho(x) \mu_x^{-1} \mid x \in GN \}$
(so $G_0 < \Ker \theta $), and $\theta_0$ is the identity map.

\vspace*{0.1cm} \noindent{\tt Determinant} and {\tt FormAction}.
In both cases $\theta:GN \to \F_q^{\times}$ is a homomorphism and we
define $N_1 = \theta(N)$ and $N_0 =  \Ker \theta|_N$.
If $x \in GN$ then $\theta(\rho(x)) = \mu_x \in N_1$.
As explained earlier, we must ensure that $G_0 \leqslant \Ker \theta$
(where $\theta_0$ is the identity map in these reductions),
so we need to find $\nu_x \in N$ with $\theta(\nu_x I_d) = \mu_x$.
We define $G_0 := \{ \rho(x) \nu_x^{-1} \mid x \in GN \}$.

For {\tt Determinant} reductions, $\theta(\nu_x I_d) = \nu_x^d$, so
we need to find $\nu_x$ with $\nu_x^d = \mu_x$. We 
find the roots in $\F_q$ of the polynomial $x^d - \mu_x$ in polynomial
time~\cite[Theorem 8.12]{Geddesetal92}.
For each such root, $\nu_x I_d \in N$ if and only if $\abs{\nu_x}$ divides
$\abs{N}$, so we use this test to find $\nu_x$.

Now consider {\tt FormAction} reductions. In the non-unitary case
$\theta(\nu_x I_d) = \nu_x^2$, and we proceed as in the determinant case.
The unitary case is more difficult. Recall that the \emph{norm} of
$\F_q$ over $\F_{\sqrt{q}}$ is a homomorphism 
$\Norm : \F_q^{\times} \to \F_{\sqrt{q}}^{\times}$ 
defined by $\omega_q \mapsto \omega_q^{\sqrt{q} + 1}$.
In this case $\theta(\nu_x I_d)  = \Norm(\nu_x)$, so we must find
$\nu_x \in \F_{q}^{\times}$ such that $\Norm(\nu_x) = \mu_x$. This is a norm
equation, which we solve using \cite[Proposition 2.2]{spinornorms} 
to obtain a solution $\nu_0$. Again, we need a solution $\nu_x$ such that
$\nu_x I_d \in N = \langle \lambda I_d \rangle$.
Each solution has the form $\nu_0 \nu_1$ with $\Norm(\nu_1) = 1$.
But $\Norm(\nu_1) = \nu_1^{\sqrt{q} + 1}= 1$ if and only if $\nu_1$ is in
the subgroup of $\F_{q}^{\times}$ of order $\sqrt{q} + 1$, so we can
find $\nu_1$ with $\nu_0 \nu_1 \in \langle \lambda \rangle$ by
Proposition~\ref{pr:scalar_patch}.

\vspace*{0.1cm} \noindent{\tt SpinorNorm}.
This is similar to the previous two reductions, but since $\Imm\theta$
has order 1 or 2 in this case, it is straightforward to write down
generators of $\Ker \theta$ directly (as we do 
in Section~\ref{semilinear} for semilinear reductions).

\vspace*{0.1cm} \noindent{\tt SmallerFieldModScalars}.
Recall from Section~\ref{smallerfield} that
$H \leqslant \GL(d, \F_s) Z$ with $H^c=G$,
where $Z = \Zent(\GL(d, \F_q))$ and $\F_s < \F_q$,
and $\theta(x) = \lambda_x$, where $x= h^c \lambda_x$ and $x \in GN$. 
While $\theta:GN \to \F_q^{\times}$ is not generally a
homomorphism (it is not even well-defined),
it induces a homomorphism
$\overline{\theta}:GN \to \F_q^{\times}/\F_s^{\times}$.
We define $N_1 = \langle \F_s^{\times}, \theta(N) \rangle$ and
$N_0 = N \cap \Ker \overline{\theta}=  N \cap \GL(d,\F_s)$.

We need $G_0$ to be a subgroup of $\GL(d,\F_s)$. Define $\theta_0$
by $\theta_0(h) = h^c \in GN \cap \Ker \overline{\theta}$.
To define generators of $G_0$, we must find random elements of
$GN \cap \Ker \overline{\theta}$ and then conjugate them by $c^{-1}$.
If $x \in GN$, then $\theta(\rho(x)) =\mu_x \in N_1$.
If $\nu_x$ satisfies $\nu_x \mu_x^{-1} \in F_s^{\times}$,
then $\rho(x) \nu_x^{-1} \in GN \cap \Ker \overline{\theta}$, as required.
We can find $\nu_x$ using Proposition~\ref{pr:scalar_patch}.

\section{Processing the leaves}
\label{section:leaf_algorithm}
To compute a composition tree for
\comment{DFH: expanded this paragraph slightly}
$G \leqslant \GL(d, \F_q)$ or $G \leqslant \Sym{n}$, it remains to
present Steps (2) (a) and (b) of the main
algorithm summarised in Subsection \ref{section:general}, which we do in
this section.
For the various types of leaf groups,
we employ algorithms to construct nice generators, to solve the rewriting
problem, and (possibly) compute a presentation for the represented groups of
each leaf in the composition tree of $G$.
The individual algorithms are described elsewhere.
Here, we just explain what they do, and how we use them.
We also describe how to compute composition series of the leaf groups
which, as we saw in Subsection \ref{subsection:rearrange_interface}, is
necessary if we want to carry out further structural computations on the
input group $G$.

As usual, we denote the \uppergp of a leaf node by $G$
and its \nullsubgp by $N$. Recall that the rewriting algorithm must
write $g \in GN$ as an SLP in the nice generators of $G$ that
evaluates to an element of $gN$, and the presentation must be on the nice
generators of $G$ and define $GN/N$.

\comment{DFH: moved section on naming composition factor to Subsection
\ref{subsec:ns}, where it is applied}

\subsection{Cyclic groups}
A single generator of a cyclic group is chosen as its nice generator.
A presentation is straightforward: a single relation is
required.  The \repgp $H:=GN / N$ 
has presentation $\{x \mid x^{\abs{H}}\}$.
The composition factors are straightforward to obtain using
standard machinery.  Proposition \ref{pr:scalar_patch}
provides the rewriting algorithm. 

\subsection{Elementary abelian groups}
These arise from unipotent reductions and we store them as PC-groups.
We designate the group's PC-generators as its nice generators,
the standard collection process as the rewriting algorithm,
and use the corresponding PC-presentation. 
(Recall that $N=1$ in this case.)
The composition factors are straightforward to obtain using 
standard machinery.

\subsection{Permutation groups}
These leaves are simple or soluble primitive permutation groups.  
If $G\cong \Alt{n}$, then we use (an extension of)
the black-box algorithm of \cite{MR1743388} to solve
the constructive recognition and rewriting problems.

Otherwise, depending on the isomorphism type of $G$,
we either use BSGS machinery or one of the 
black-box algorithms discussed in Section~\ref{subsection:crr}.  
If a presentation is not known, then it 
is constructed using the algorithm of Cannon \cite{Cannon73}.

\subsection{Classical groups in their natural representation}
\label{classical-gps}
Since $GN$ is in the kernel of the determinant, form action and spinor norm
maps, it is quasisimple and so $N < G$.
The leaf groups lie in the families $\SL(d, \F_q)$,
$\Sp(d, \F_q)$, $\SU(d, \F_q)$ and $\Omega^{\epsilon}(d, \F_q)$ 
for $\epsilon \in \{ \pm, \circ \}$. % Since $GN$ is quasisimple, $N < G$.

The standard copy $S$ of the simple group $G/\Zent(G)$ is represented by 
the pair $(H,\Zent(H))$ where $H^c = G$ for some $c \in \GL(d,\F_q)$,
and $c$ is readily computed as the change-of-basis matrix that
transforms the form fixed by $H$ to that fixed by $G$.
The set of nice generators of $G$ is $X^c$, where $X$ is the
set of standard generators of $H$.
The algorithms of \cite{cr-odd} and \cite{dlo}
are used to construct the nice generators of $G$ as SLPs in 
its input generators. 
The algorithms of \cite{costi_phd} solve the rewriting problem for $H$ on $X$.
A presentation on the standard generators is available from \cite{pres}.

The composition factors consist of the simple group together with those
of $\Zent(G)$ modulo $N$. Since $G$ is a quasisimple classical group in 
its natural representation, we can write down an explicit scalar matrix
that generates $\Zent(G)$. We obtain
this matrix as an SLP in the standard generators using \cite{costi_phd}.
We construct a PC-presentation for the centre, 
compute the quotient by its \nullsubgp, and then use standard 
machinery to obtain its composition factors.

\subsection{Groups in class $\cS$}
\label{section:c9_reduction}

If $G \leqslant \GL(d, \F_q)$ is a leaf group in class $\cS$,
then $G = Z.S$, where $S$ is a finite simple group
and $Z=\Zent(G)$ is the (cyclic) scalar subgroup of $G$. 
The extension $Z.S$ may not be perfect,
so $Z$ need not lie in the Schur multiplier of $S$.
Since the determinant reduction has been applied, 
$GN \leqslant \SL(d, \F_q)$, so both $\abs{Z}$ and $\abs{N}$ 
divide $\gcd(d, q - 1)$.

\subsubsection{Calculating the centre}
\label{subsection:c9_centre}

To obtain a generating set for $Z$, we use the 
Monte Carlo algorithm of \cite[Theorem
4.15]{MR1829470} and the upper bound $\gcd(d, q - 1)$ to its order. 
We then obtain a single generator 
$u$ of $Z$ as an SLP in the generators of $G$. 

\subsubsection{Constructive recognition and rewriting}
\label{subsection:crr}
Recall that we have named $S$ using the algorithm 
of Subsection \ref{subsection:naming}.
If a constructive recognition algorithm is available for $S$,
then the leaf algorithm provides an effective homomorphism
$\alpha : GN \to H$ with kernel $ZN$, where $H$ is the standard copy of $S$.
Let $Y$ be the set of input generators of $G$.
By definition of a constructive recognition algorithm,
$H$ has a designated set $\overline{X}$ of standard generators,
and there are algorithms to find these generators as SLPs in $\alpha(Y)$,
and to rewrite elements in $H$ as SLPs in $\overline{X}$.
These algorithms enable the construction of an effective inverse map
$\beta: H \to G$ that satisfies $\beta(\alpha(g)) \in gZN$ for all $g \in GN$.
We define the nice generators $X$ of $G$ to be the images under $\beta$ of the
standard generators $\overline{X}$ of $H$, together with the generator $u$ for
$Z$ constructed in Section~\ref{subsection:c9_centre}.

This provides the required algorithm that rewrites 
$x \in GN$ to an SLP in $X$ that evaluates to an element of $xN$ as follows.
For $x \in GN$, we compute $z := x \beta(\alpha(x^{-1})) \in Z N$.
We obtain an SLP in $X$ for $\beta(\alpha(x^{-1}))$ by taking the
image under $\beta$ of an SLP in $\overline{X}$ for $\alpha(x^{-1})$,
so it remains to obtain an SLP in $X$ for some element of $xN$.
Using Proposition~\ref{pr:scalar_patch}, we find $n \in N$
with $zn \in Z$, and then we complete the rewriting process by
expressing $zn$ as an SLP in $u$.
Since $|u| \leqslant \gcd(d, q - 1)$, this is easy.

If a presentation for $S$ on its standard generators is available then, by
applying the map $\beta$, we obtain a presentation
$\set{\mathcal{X} \mid \mathcal{R}}$
for the isomorphic group $G/Z$ on its generating set
$\set{xZ \mid x \in X \setminus \{u\} }$.
We then obtain a presentation for the \repgp $GN/N$ on $X$ as follows.
Each relator $r \in \mathcal{R}$ is regarded as a word in $X$,
and evaluates in $G$ to $u_r \in Z N$.
After multiplying by a suitable
element of $N$ (using Proposition~\ref{pr:scalar_patch}),
we express each $u_r$ as an SLP $w_r$ in $u$, as above.
The relators for the presentation of $GN/N$ are then 
%$$\set{r_i w_i^{-1}
%  : 1 \leqslant i \leqslant m} \cup \set{[x_i, u] : 1 \leqslant i \leqslant n} 
%\cup \set{u^{\abs{u} / \gcd(\abs{u}, \abs{N})}}.$$
$$\set{r w_r^{-1}
  : r \in \mathcal{R}} \cup \set{[x, u] : x \in X} 
\cup \set{u^{\abs{u} / \gcd(\abs{u}, \abs{N})}}.$$

To obtain composition factors for a group in class $\cS$ is easy, since 
we know its centre. We then proceed as in Section \ref{classical-gps}.

We now list
the constructive recognition algorithms available for the various types
of simple groups.  Some are also applied to permutation group leaves.

\vspace*{0.15cm} \noindent{\it Alternating groups.}
We use the algorithm of \cite{MR1743388}.  
(In fact we have already done this in verifying our identification of $S$.) 

\vspace*{0.15cm} \noindent{\it Sporadic groups.}
We have already found standard generators of $S$ during the naming procedure.
As a rewriting algorithm, we use either the ``reduction"
algorithm of \cite{ryba_trick} or BSGS machinery. 
If we use the latter, then, 
as described in \cite[\S 7.6]{MR2258009}, we choose a base 
targeted to the given representation of $S$.
This allows us to define the maps $\alpha$ and $\beta$.

\vspace*{0.15cm} \noindent{\it Classical groups in defining characteristic.}
If $S \cong \PSL(2, q)$, then we use the algorithm of \cite{psl_recognition}. 

If $S \cong \PSL(3, q)$, then we use the algorithm of \cite{MR2356848}
to obtain the maps $\alpha$ and $\beta$. This algorithm applies to
$GN$ only if $ZN$ is contained in the Schur multiplier of
$S$. Instead, we apply it to the stable derivative $D$ of $GN$, which
we computed earlier, so obtaining $\overline{X}$ as SLPs in the
generators of $D$, and hence also in $Y$. This allows us to define the
nice generators as above. Note that the domain of $\alpha$ is 
$D$, not $GN$. This poses no problem, since for rewriting in $GN$ we
use the algorithm of \cite{costi_phd} which only requires $GN$ and
$X$ as input.

If $S \cong \PSL(n, q)$ where $n \geqslant 4$ and $d \leqslant n^2$, then 
we use the algorithms of \cite{small_deg_reps} to identify the isomorphism,
and the rewriting algorithms of \cite{costi_phd}.

Otherwise, 
we use the constructive recognition algorithms of \cite{BDLO}
and the rewriting algorithms of \cite{costi_phd}. 

\vspace*{0.1cm} \noindent{\it Black-box algorithms for classical groups.}
We use the algorithms of \cite{BDLO}
to obtain the maps $\alpha$ and $\beta$, and 
the black-box rewriting algorithm 
of Ambrose {\it et al.}\ \cite{blackrewrite}.

Other available black-box algorithms include those 
of \cite{MR1804385} for $\PSL(d, q)$;
\cite{MR2422320} for $\PSp(d, q)$; 
\cite{Brooksbank03} for $\PSU(d, q)$; 
and \cite{MR2228648} for $\Omega^\epsilon(d, q)$. 

%Kantor \& Seress  \cite{MR1804385} developed
%a black-box algorithm for $\PSL(d, q)$; it 
%was implemented in {\sc Magma} by Brooksbank.  
%The algorithm of \cite{MR2356848} is black-box.  
%If $S \cong \PSL(d, q)$ for $d > 3$, 
%then we use the algorithm of \cite{MR1804385}. 
%We obtain the nice generators
%as SLPs in the input generators as above. To rewrite
%in $GN$, we use BSGS machinery or \cite{ryba_trick}.
%Since the homomorphism to $\PSL(d, q)$ is from $D$, not $GN$, we
%cannot use it to map elements of $GN$ to the natural representation.
%Instead we first obtain nice generators using 
%the map from the standard copy; rewrite on these using BSGS 
%or \cite{ryba_trick}; then map to standard copy by rewriting 
%on nice generators; and evaluating on standard generators. 
%[EOB -- This needs more clarification but probably best
% to wait for further developments at implementation level.] 

%If $S \cong \PSp(d, q)$ and $q$ is odd, then 
%we use the algorithms of \cite{MR2422320}.
%If $S \cong \PSU(d, q)$, then we use the algorithms 
%of \cite{Brooksbank03}. These work as for $\PSL(d, q)$. 

%A black-box rewriting algorithm to write an element of a 
%classical group as an SLP in its standard generators
%is under development by Ambrose {\it et al.}\ \cite{blackrewrite}.

\vspace*{0.1cm} \noindent{\it Exceptional groups.}
The algorithms of \cite{baarnhielm05, baarnhielm_phd, small_ree_recog, 
sz_blackbox} constructively recognise the Suzuki and Ree groups. 
The Schur multiplier of $^2B_2(q)$ is $2^2$ for
$q=8$ and trivial otherwise.
The representations of $^2B_2(q)$ in (defining) characteristic
$2$ have dimension $4^n$ for some $n \geqslant 1$; since 
$\abs{Z}$ divides $\gcd(4^n, 2^k - 1)$, we deduce that $Z = 1$. 
In odd characteristic, 
the black-box recognition algorithm for $^2B_2(q)$ 
handles the case when $\abs{Z} =2$ and $Z \leqslant [G,G]$. 

The algorithms for $^2F_4(q)$
constructively recognise only the smallest representation of 
dimension $26$, with defining field of
size $q = 2^{2m + 1}$ for some $m > 0$. 
Since $\gcd(26,2^{2m + 1}-1)=1$, we deduce that $Z=1$. 
(By exploiting condensation, we can also work effectively 
with the 246-dimensional representation.) 

The algorithms for $^2G_2(q)$ constructively
recognise representations in defining characteristic with 
field size $q = 3^{2m + 1}$ for some $m > 0$.
Such representations have dimension $7^n 3^{3k}$ where
$n \geqslant 0$, $k \geqslant 0$ and $n + k > 0$.
Since $\gcd(21,3^{2m + 1}-1)=1$, 
we deduce that $Z=1$.

Kantor \& Magaard \cite{KM} present
black-box Las Vegas algorithms to recognise constructively
the exceptional simple groups of Lie type and rank at least 2,
other than ${}^2F_4(q)$, defined over a field of known size.

\vspace*{0.1cm} \noindent{\it Default methods.}
If no constructive recognition algorithm is available for the isomorphism
\comment{DFH: rearranged and rewote some of this paragraph}
type of the simple composition factor of $G$, then we can use
the black-box algorithm of \cite{ryba_trick}, which reduces the constructive 
membership problem to three instances of the same problem for
involution centralisers in $G$.
Let $Y$ be the set of standard generators of $GZ/Z$
represented by the group pair $(G,Z)$.
For membership testing,
we apply \cite{ryba_trick} to $G Z$; membership testing in the
involution centralisers is done using recursive applications of
\texttt{CompositionTree}. We obtain an SLP for the element in
$Y \cup \set{\lambda}$ where $N = \gen{\lambda}$,
and rewrite this to an SLP in $Y$ by setting $\lambda = 1$.  

As we observed in Subsection \ref{subsection:rearrange_interface},
we need a constructive recognition algorithm to efficiently compute a
composition series of $G$ for use in further structural calcualtions and so,
in its absence, we are obliged to resort to BSGS machinery. A presentation is
found using the algorithm of \cite{Cannon73}.

\subsection{Identification failure}\label{subsec:identfail}
It is possible that one of the membership algorithms for Aschbacher 
\comment{DFH: I made this into a new subsection, since we are no longer
in class $\cS$.}
classes fails to deduce that a group $G$ lies in this class.
Fortunately, this happens very rarely, if at all, in practice, but
if it does, then the procedure to name the nonabelian simple factor $S$
described in Subsection \ref{subsection:naming} is likely to fail. If the naming
procedure does return a name for $S$, then the constructive recognition
algorithm for $S$ will fail.

If either the naming procedure or the constructive recognition algorithm
fails for the above or for some other reason (these algorithms are all
probabilistic),
\comment{DFH: I have evaded the question of whether constructive
recognition could return a false positive!}
then we compute a BSGS of $GN$ using the random Schreier-Sims
algorithm \cite[\S 4.4.5]{hcgt}, 
and (optionally) verify it using the Todd-Coxeter-Schreier-Sims
algorithm \cite[\S 6.2.2]{hcgt}. 
This allows constructive membership testing
in $G$. As above, we rewrite an
SLP for an element to obtain it in $Y$. 
The {\it strong generators} of $G$ are chosen as its nice generators, 
and a presentation is obtained on these. 
Composition factors are found using BSGS machinery.

\section{Identifying automorphisms of finite simple groups}
\label{section:autident}

As explained in Section~\ref{subsection:rearrange_interface},
{\tt CompositionTree} has the option of computing a composition
series $1=G_0 \lhd G_1 \lhd G_2 \lhd \cdots \lhd G_m=G$, 
where $S_k$ is the standard copy of $G_k / G_{k - 1}$.
To apply the rearrangement algorithm to this series, 
we need to decide whether an automorphism of $S_k$ that 
normalises $A \leqslant {\rm Aut}(S_k)$
lies in $A$.  If so, then we must identify it as an element of $A$.
More precisely, we solve the following problem.
\begin{prob}\label{aut-problem}
Assume, for some $k$, that $g_1,g_2,\ldots,g_t \in G$ normalise $G_k$
and $G_{k-1}$.  For $1 \leqslant i \leqslant t$,
let $\alpha_i$ be the automorphism of $S_k$ induced by conjugation by
$g_i$; namely, $\alpha_i:x \mapsto \tau_k(g_i^{-1}\phi_k(x)g_i)$. 

Let $A_i = \langle \Inn(S_k), \alpha_1,\ldots,\alpha_i \rangle \leqslant \Aut(S_k)$
for $1 \leqslant i \leqslant t$ where $A_0 = \Inn(S_k)$. 
For $0 \leqslant i<t$, assume that
$A_i \lhd A_{i+1}$ and $A_{i+1}/A_i$ has prime order.

Let $g \in N_G(G_k) \cap N_G(G_{k-1})$ be such that the 
automorphism $\alpha$
of $S_k$ induced by $g$ is guaranteed to normalise $A_t$ and either to lie in
$A_t$ or to generate a subgroup $A_{t+1} := \langle A_t,\alpha \rangle$ such
that $A_{t+1}/A_t$ has prime order. 

Decide whether $\alpha \in A_t$.
If so, then compute $x \in S_k$ and integers $e_i$
such that $\alpha = c_x\alpha_1^{e_1}\alpha_2^{e_2}\cdots \alpha_t^{e_t}$,
where $c_x \in \Inn(S_k)$ is conjugation by $x$. If $\alpha \not\in A_t$,
then set $g_{t+1}:=g$ and $\alpha_{t+1}:=\alpha$. 
\end{prob}

We describe an efficient algorithm to solve Problem \ref{aut-problem}
when $S_k$ is a classical group in its natural representation.
For all other $S_k$, we currently solve this problem using standard
automorphism group algorithms \cite[Chapter 10]{hcgt}.

\subsection{Classical groups in their natural representation}
\label{natural}
To ease exposition, we postpone discussion of the 
triality automorphism of $\Om^+(8,\F_q)$ to Section \ref{triality}.
The notation used is local to this section, and may not
be consistent with that used in the remainder of the paper.

\subsubsection{Automorphism groups of classical groups}
Let $\Omega=S_k$ be one of $\PSL(d,q)$ ($d \ge 2$), $\PSp(d,q)$ ($d \ge 4$),
$\PSU(d, \sqrt{q})$ ($d \ge 3$), or $\POm^{\epsilon}(d,q)$ ($d \ge 7$).
Here $\Omega$ is represented by the group pair
$(\widetilde{\Omega},\Zent(\widetilde{\Omega}))$ with
$\widetilde{\Omega} = \SL(d,\F_q)$, $\Sp(d,\F_q)$, $\SU(d,\F_q)$, or
$\Om^{\epsilon}(d,\F_q)$, in its natural representation as a subgroup
of $\GL(d,\F_{q})$. 
If $\Omega \ne \PSL(d,q)$, then
let $F$ be the bilinear, sesquilinear or quadratic
form preserved by $\widetilde{\Omega}$, and used to define
$\widetilde{\Omega}$.
%where, for the orthogonal groups,
%we use the quadratic form in characteristic 2 and the bilinear form otherwise.

Denote $\Aut(\Omega)$ by $A$.
Following \cite[Chapter 2]{kleidmanliebeck90}, observe that  
$A$ has a chain of normal subgroups
$$1 < \Omega \cong \Inn(\Omega) \leqslant S \leqslant I \leqslant \Delta \leqslant \Gamma \leqslant A,$$ 
which are defined as follows.
\begin{enumerate}
\item[(i)] $S=\Inn(\Omega)$ except when $\Omega = \POm^{\epsilon}(d,q)$,
in which case $S$ is the group of automorphisms induced by elements of
$\SO^{\epsilon}(d,\F_q)$.
\item[(ii)] $I$ consists of automorphisms induced by all elements of
$\GL(d,\F_q)$ when $\Omega = \PSL(d,q)$, and by the elements 
%of $\GL(d,\F_{q^u})$ that preserve $F$ in the other cases.
of $\GL(d,\F_{q})$ that preserve $F$ in the other cases.
\item[(iii)] $\Delta = I$ when $\Omega = \PSL(d,q)$, and consists
of automorphisms induced by elements of $\GL(d,\F_{q})$ that
preserve $F$ modulo scalars in the other cases. Equivalently, $\Delta$
consists of automorphisms induced by the elements of the
normaliser of $\widetilde{\Omega}$ in $\GL(d,\F_{q})$.
\item[(iv)] $\Gamma$ is the subgroup of $A$ generated by $\Delta$ and  the
field automorphisms.
\item[(v)] $A$ is generated by $\Gamma$ and a graph automorphism  of
order 2 when $\Omega = \PSL(d,q)$ with $d \ge 3$, or $\Omega=\PSp(4,2^n)$.
Otherwise $A=\Gamma$.
\end{enumerate}
%The elements of $\Delta$ are induced by
%conjugation by elements of $\GL(d,\F_{q^u})$.
Let $\mathcal{L} := (S/\Omega, I/S, \Delta/I, \Gamma/\Delta, A/\Gamma)$.
All members of $\mathcal{L}$ are cyclic
and three of them, $S/\Omega$, $\Delta/I$, and
$A/\Gamma$, have order at most 2.

\subsubsection{Data structures for the algorithm}
The algorithm to solve Problem~\ref{aut-problem} 
performs membership testing in
a subgroup $A_t = \langle \Inn(\Omega),\alpha_1,\ldots,\alpha_t \rangle$
of $A$, which is initialised to $A_0 = \Inn(\Omega)$, where the $\alpha_i$
are represented by $g_i \in G$ that induce $\alpha_i$ by conjugation.

For each cyclic quotient $X/Y \in \mathcal{L}$, we 
store the projection $(A_t \cap X)/(A_t \cap Y)$. 
If $\alpha_i \in X \setminus Y$, then we record this.
%For each $\alpha_i$, we record the quotient $X/Y \in \mathcal{L}$
%for which $\alpha_i \in X \setminus Y$.
For those $\alpha_i$ that lie in $\Delta$, we also store 
$x_i \in \GL(d,\F_{q})$ that induces $\alpha_i$ in its conjugation action
on $\widetilde{\Omega}$.

For those $X/Y$ that may have order greater than 2, namely
$I/S$ and $\Gamma/\Delta$, we store a cyclic group isomorphic to
$(A_t \cap X)/(A_t \cap Y)$ together with the elements of this cyclic
group that correspond to those $\alpha_i \in X \setminus Y$.
This enables us to write a new automorphism $\alpha \in X$ with
$\alpha Y \in (A_t \cap X)Y$ as a word in these $\alpha_i$ that evaluates
to an element of $\alpha Y$.
It is trivial to do this when $|X/Y| \leqslant 2$.

To perform membership testing of $\alpha \in A$ in $A_t$,
we consider the five quotients $X/Y$ in reverse order.
For each non-trivial quotient,
we test membership of $\alpha$ in $(A_t \cap X)Y$.
Assume for the moment that we can do this.

If $\alpha \in (A_t \cap X)Y$,  then 
we multiply $\alpha$ by suitable elements of $A_t \cap X$ to get
$\alpha \in Y$ (more precisely, we modify the
$g\in G$ that induces $\alpha$),
and then proceed to the next quotient $X/Y$. If this process
succeeds for each $X/Y$, then the modified $\alpha$ lies in $\Inn(\Omega)$,
and hence $\alpha \in A_t$.
We also need to identify $x \in \Omega$ where $\alpha$ is 
induced by conjugation
by $x$ but, as we see below, $x$ is 
already calculated during the
membership testing in the quotients $X/Y$.

If $\alpha \not\in (A_t \cap X)Y$ for one of $X/Y$, 
then we define $g_{t+1}:=g$, $\alpha_{t+1}:=\alpha$ and
$A_{t+1} := \langle A_t,\alpha \rangle$. We also record that
$\alpha \in X \setminus Y$. If $X/Y$ is $\Gamma/\Delta$ or $I/S$, then we
modify the stored cyclic group that represents this quotient to
make it isomorphic to $(A_{t+1} \cap X)/(A_{t+1} \cap Y)$. Since we 
assume that $\langle A_t,\alpha \rangle/A_t$ is either trivial or has
prime order, at most one of the intersections $A_t \cap X$ changes.

\subsubsection{Lifting automorphisms from $\Omega$ to $\widetilde{\Omega}$}
It remains to describe how to perform membership testing of automorphisms
$\alpha$ in $(A_t \cap X)Y$ in the quotients $X/Y \in \mathcal{L}$.
Before doing this, we discuss an additional technicality.

The automorphism  $\alpha$ of $\Omega$ is defined by %given to us as 
$g \in G$ that induces $\alpha$ in its conjugation action on $G_k/G_{k-1}$.
The maps $\tau_k$ and $\phi_k$ enable us to calculate the image of
elements of $\Omega = S_k$ under $\alpha$. In all cases under
consideration, $\alpha$ lifts uniquely to an automorphism $\tilde{\alpha}$
of $\widetilde{\Omega}$. (This is not true for the triality
automorphism of $\Omega^+(8,\F_q)$ when $q$ is odd.)
For the membership tests to work, we must be able to calculate the images
of a set of generators of $\widetilde{\Omega}$ under $\tilde{\alpha}$, and
we need a collection of random elements of $\widetilde{\Omega}$ on which
we can calculate the action of $\tilde{\alpha}$.

To achieve this, we proceed as follows. Since $\Omega = \widetilde{\Omega}/Z$
is a central quotient of
$\widetilde{\Omega}$, for every $x,y \in \widetilde{\Omega}$, 
we have $\tilde{\alpha}([x,y]) = [a,b]$ for all
inverse images $a,b$ of $\alpha(xZ),\alpha(yZ)$ in $\widetilde{\Omega}$.
Hence we can calculate the action of $\tilde{\alpha}$ on commutators.
Since $\widetilde{\Omega}$ is perfect, it is generated by
commutators, so we choose a set of random commutators that
generate $\widetilde{\Omega}$; that these generate can be verified using
the Monte Carlo algorithm of~\cite{MR1625479}.  
Since we know the action of $\tilde{\alpha}$ on a generating set, 
we can compute
random elements of $\widetilde{\Omega}$ as SLPs in these generators and
then calculate their images under $\tilde{\alpha}$.

\subsubsection{The membership tests}
We now describe the membership tests for $\alpha$ in each
of the five quotients $X/Y \in \mathcal{L}$.

\vspace{0.1cm}\noindent{\tt Membership testing in 
$A/\Gamma$ and $\Gamma/\Delta$.}
These tests use characteristic polynomials.
Fix $x \in \widetilde{\Omega}$, and suppose that
the characteristic polynomial of $x$ is
$$X^d + c_{d-1}X^{d-1} + \cdots + c_1 X + c_0.$$
\begin{enumerate}
\item[(i)] If $\tilde{\phi}$ is the field automorphism of 
$\widetilde{\Omega}$
%induced by $\phi \in \Aut(K)$, where $K = \F_{q^u}$,
induced by $\phi \in \Aut(K)$, where $K = \F_{q}$,
then $\tilde{\phi}(x)$ has characteristic polynomial
$X^d + \phi(c_{d-1})X^{d-1} + \cdots \phi(c_1) X + \phi(c_0)$.
\item[(ii)] If $\gamma$ is the graph automorphism of
$\SL(d,\F_q)$ ($d \ge 3$) induced by the inverse-transpose map, then
$\gamma(x)$ has characteristic polynomial
$X^d + c_1X^{d-1}/c_0 + \cdots + c_{d-1}X/c_0 + 1/c_0.$  
\end{enumerate}
We call $x \in \widetilde{\Omega}$ {\em full} if the coefficients
of its characteristic polynomial generate $K$.
%A large proportion of elements  of $\widetilde{\Omega}$ are full,
%as shown in \cite[Theorem 3.2]{smallerfield}  
%for elements of the group algebra $K[\widetilde{\Omega}]$.
%in~\cite[Theorem 3.2]{smallerfield}.
Assume for the moment that $\widetilde{\Omega} \not= \Sp(4,\F_{2^e})$ for some
$e$.  By finding a small number of full $x \in \widetilde{\Omega}$
and calculating the characteristic
polynomials of both $x$ and $\tilde{\alpha}(x)$, the two properties listed above
enable us quickly to decide whether $\tilde{\alpha} \in \Gamma$;
if so, we use the isomorphism between $\Gamma/\Delta$ and $\Aut(K)$ to identify
the coset of $\Delta$ in which it lies.
Hence we can perform membership testing
in $A/\Gamma$ and in $\Gamma/\Delta$.

Now consider $\widetilde{\Omega} = \Sp(4,\F_{2^e})$.
If, after calculating
the characteristic polynomials of both $x$ and $\tilde{\alpha}(x)$ for a
small number of full elements $x$, we fail to identify $\alpha$ as an element
of $\Gamma$, then we conclude that $\alpha \in A \setminus \Gamma$. 
If we conclude that $\alpha \in \Gamma$, then there is a 
small probability that we are wrong; in that case, the module isomorphism test
described below will fail, and we again conclude that 
$\alpha \in A \setminus \Gamma$.

\vspace{0.1cm}\noindent{\tt Identifying a conjugating element.}
We have now decided whether $\alpha \in \Delta$.
If so, then $\tilde{\alpha}$
is induced by conjugation by some $x \in \GL(d,\F_{q})$. 
We perform a module isomorphism test between
the natural module $V$ for $\widetilde{\Omega}$ and the module $V^{\alpha}$
defined by applying $\alpha$ to the action matrices of $V$, and 
obtain $x$ as the matrix describing the explicit isomorphism.
This test can be carried out efficiently using 
{\sc Meataxe} methods \cite[\S 7.5.3]{hcgt}.
Since $\widetilde{\Omega}$ is absolutely irreducible, 
$x$ is determined up to multiplication by a scalar.

\vspace{0.1cm}\noindent{\tt Membership testing in $\Delta/I$.}
If $\Omega = \PSL(d,q)$, then $I=\Delta$. 
Otherwise $x$ preserves the form $F$ modulo scalars:
it transforms $F$ to $\lambda F$ for some $\lambda \in K$.
If the result of the membership test is positive, then we ensure that
the (possibly modified) element $x$ fixes $F$.

If $\Omega = \PSU(d, \sqrt{q})$, $\PSp(d,q)$ ($q$ even) or $\POm^{\pm}(d,q)$
($d$ odd or $q$ even), then $\Delta = I$, so % we certainly have
$\alpha \in I$, but we still need to multiply $x$ by a scalar to make it
fix $F$. If $\Omega = \PSU(d, \sqrt{q})$,  then
$\lambda$ must lie in the subfield of $K$ of order
$q$, and we solve a norm equation to find $\mu \in K$ with
$\mu^{1+q}=\lambda$; now $\mu^{-1}x$ preserves $F$, and we replace $x$ by
$\mu^{-1}x$. In the other cases, $\lambda$ must be a square in $K$,
and we find a square root $\mu$ of $\lambda$ in $F$ and replace
$x$ by $\mu^{-1}x$.

It remains to consider the cases $\Omega = \PSp(d,q)$ or $\POm^{\pm}(d,q)$ for
even $d$ and odd $q$, when $|\Delta/I| = 2$. We first test whether $\lambda$ has
a square root $\mu \in K$. If so, then $\alpha \in I$, and we replace $x$ by
$\mu^{-1}x$ to make $x$ preserve $F$.
If $\lambda$ is a non-square in $K$, then $\alpha \in \Delta \setminus I$.
If there is already an automorphism $\alpha_i \in A_t$ ($i \leqslant t$) with
$\alpha_i \in \Delta \setminus I$, then we replace $\alpha$ by
$\alpha \alpha_i$ (or rather $g$ by $gg_i$) and $x$ by $xx_i$, where
$x_i$ is the stored element of $\GL(d,\F_{q})$ associated with $\alpha_i$.
We then multiply $x$ by a scalar to make it preserve $F$.
If $\lambda$ is a non-square in $K$ and there is no existing
$\alpha_i \in A_t$ with $\alpha_i \in \Delta \setminus I$,
then the result of the membership test is negative.

\vspace{0.1cm}\noindent{\tt Membership testing in $I/S$ and $S/\Omega$.}
Now $\alpha \in I$ and $x$ preserves $F$.
The determinant of $x$ determines the coset of $S$ in which $\alpha$
lies, so the membership test in $I/S$ is straightforward. If we find that
$\alpha \in A_tS$, then we multiply $\alpha$ by a suitable word in
the stored $\alpha_i$ and $x$ by the same word in the associated
$x_i$ to get $\alpha \in S$. We can then multiply $x$ by a scalar to get
$\det(x)=1$.

In the orthogonal case, the membership test in $S/\Omega$ is carried out
by calculating the spinor norm of $x$, using \cite{spinornorms}.

\smallskip
This concludes the description of the membership tests in the 
quotients $X/Y \in \mathcal{L}$.
As explained earlier, if the result of all of these tests is positive, then
the modified $\alpha$ lies in $\Inn(\Omega)$, and we have computed 
$x \in \widetilde{\Omega}$ where $\alpha$ is induced by 
conjugation by $x$.

\subsubsection{$\POm^+(8,q)$}\label{triality}
The general algorithm does not address the triality automorphism $\tau$
of $\Omega := \POm^{+}(8,q)$.  In that case, we let $A$ be the subgroup
$\Gamma$ of $\Aut(\Omega)$ as defined above for the other classical groups.
Then $\Aut(\Omega) = \langle A, \tau \rangle$ and $|\Aut(\Omega):A| = 3$.
If we encounter an automorphism $\alpha$ that is not in $A$, then we store it,
and view it as a coset representative of $A$ in $\Aut(\Omega)$.
We can test whether automorphisms lie in $A$ or in the same coset
as $\alpha$ and, if not, then we store a second automorphism representing
the other non-trivial coset.  This is similar to the method 
employed for the graph automorphism of $\PSp(4,2^e)$.

%\subsection{The general case}
%If $S_k$ is a classical group, then 
%the natural representation for $S_k$ is used. 
%For all other simple groups, we currently use standard 
%automorphism group algorithms \cite[Chapter 10]{hcgt} to 
%solve Problem \ref{aut-problem}. 

\section{The rearranging algorithm}\label{section:rearrange}
The method of identifying automorphisms of classical groups 
presented in Section~\ref{section:autident}
is one of the major components
of the rearranging algorithm which we now describe in detail.

As explained in Section~\ref{subsection:rearrange_interface},
{\tt CompositionTree} can compute a composition
series $1=G_0 \lhd G_1 \lhd G_2 \lhd \cdots \lhd G_m=G$ of $G$.
For $1 \leqslant k \leqslant m$, it also computes 
effective maps $\tau_k:G_k \to S_k$, $\phi_k:S_k \to G_k$,
where $S_k$ is the standard copy of the simple group $G_k / G_{k - 1}$,
and $\tau_k$ is an epimorphism with kernel $G_{k-1}$,
and, for $g \in S_k$, $\phi_k(g)$ is an element of $G_k$ with
$\tau_k\phi_k(g)=g$.

The non-abelian $S_k$ may be represented as permutation groups
or as absolutely irreducible matrix groups over finite fields.
In the latter case, $S_k$ may be represented by a group pair $(\tilde{S}_k,Z)$,
where the \nullsubgp $Z$ is the scalar subgroup of $\tilde{S}_k$. 

{\tt CompositionTree} returns generating sets $X_k$ of $S_k$ 
modulo $S_{k-1}$ that are
guaranteed not to contain the identity element, together with functions
$\psi_k$ that express elements of $S_k$ as SLPs in $X_k$.
If $S_k$ is cyclic, then $|X_k|=1$.
{\tt CompositionTree} also returns a function $\delta$ that 
rewrites elements of $G$ as SLPs in the nice generators of~$G$.

We start the rearranging process by using the maps $\phi_k$ to
compute and store sets $W_k$ of inverse images of the elements of $X_k$.
Since $1 \not\in X_k$, we have $g \not\in G_{k-1}$ for all $g \in W_k$.
We use $\delta$ to compute sets $\overline{W}_k$ of SLPs in the
nice generators of $G$ that represent the elements of $W_k$.

We define the {\it height} $h(g)$ of $g \in G$ to be the smallest $k$ such
that $g \in G_k$.  The maps $\tau_k$, $\phi_k$ and $\psi_k$ allow us to compute
both $h(g)$ and an SLP for $g$ in $\cup_{k=1}^{h(g)} W_k$.

The algorithm proceeds by considering each set $W_k$, for
$k=1,2,\ldots,m$ in turn and, when appropriate, replacing each
$g \in W_k$ by $gh$ for some suitable $h \in G_{k-1}$, while also making
the corresponding changes to the elements of $\overline{W}_k$. These
changes do not affect the property that $\tau_k$ maps $W_k$ to $X_k$.
After completing the process, 
each term of the characteristic series $1 \leqslant L \leqslant M \leqslant  K \leqslant G$
discussed in Section \ref{section:charsubs}
is generated by the union of some of the adjusted sets $W_k$.

More precisely, for $g \in W_k$, we first attempt to find $h \in G_{k-1}$
with $gh \in K$. If we succeed, then we replace $g$ by $gh$ and
attempt to find a new $h \in G_{k-1}$ with $gh \in M$. If that also succeeds,
then we attempt to find $h \in G_{k-1}$ with $gh \in L$.

It is straightforward to show that $G_kK=G_{k-1}K$ is equivalent to the
following condition: for each $g \in W_k$, there exists $h \in G_{k-1}$ with
$gh \in K$.  Since $G_{k-1}K$ is a
normal subgroup of $G_kK$ and $G_k/G_{k-1}$ is simple, $G_k \cap G_{k-1}K$
must equal either $G_k$ or $G_{k-1}$.
Since we assume that $g \not\in G_{k-1}$ for all $g \in W_k$,
the elements $h$ exist either for all $g \in W_k$ or for none of them.
Hence, to decide this question, we need only consider one $g \in W_k$.
Of course, if $h$ exists, then we must compute such
for every $g \in W_k$.

Since the result of a positive outcome of these tests is to replace the
elements of $W_k$ by elements that lie in $K$, $M$, or $L$, we 
frequently refer (with considerable abuse of language)
to these processes as testing the composition
factors for membership of $K$, $M$ and $L$.

After their completion, $K$ is generated by those $W_k$ for which we
successfully replaced the $g \in W_k$ by $gh \in K$,
and similarly for $M$ and $L$.  Thus we can 
rearrange the composition series so that it passes through $L$, $M$ and $K$.

If we test a non-abelian composition factor $G_k/G_{k-1}$ for membership of $M$,
then, since $K/M$ is soluble, we know {\it a priori} that the answer must be
positive. In this situation, we replace the $g \in W_k$ by elements
$gh$ that generate one of the simple direct factors of $M/L$. 

\subsection{Auxiliary data required}\label{auxil}
Before explaining how we test for the existence of suitable
$h$ with $gh \in K$, $M$ or $L$,
we describe some extra data maintained during the
rearranging process.

When we consider the composition factor $G_k/G_{k-1}$, the
(adjusted) generators $W_j$ of some of the non-abelian factors $G_j/G_{j-1}$
with $j<k$ that we have already considered may generate simple factors of $M/L$.
Let these factors (if any) be indexed by $j_1,j_2,\ldots,j_r$, where
$0 \leqslant r < k$ and $j_1<j_2< \cdots < j_r < k$, and let
$\Delta = \{j_1,j_2,\ldots,j_r\}$.

Let $P \leqslant \Sym{\Delta}$ be generated by the
conjugation action of the generators $W_i$ of those factors $G_i/G_{i-1}$ with
$i<k$ that do not lie in $K$ on the simple factors $\langle W_j \rangle L/L$ of
$M/L$ with $j \in \Delta$. We keep track of the correspondence
between the generators of $P$ and the corresponding elements 
of the $W_i$.

Initially, $r=0$ and $P$ is the trivial group acting on the empty
set $\Delta$. The factor $G_k/G_{k-1}$ under consideration may be a
new simple factor of $M/L$, in which case we adjoin $k$ to $\Delta$.
This new factor is fixed under conjugation  by
the elements of $W_i$ for all $i<k$ in the induced permutation action of $G$
on the complete set of simple factors of $M/L$.
Thus the only change needed to $P$ when we adjoin
$k$ to $\Delta$ is to extend the definition of its generators by making them
fix the new point~$k$.

On completion of the algorithm, $\Delta$ can be identified with the set
of all simple factors of $M/L$ (also named $\Delta$
in Section~\ref{section:charsubs}), and $P = \Imm\phi$,
where $\phi:G\to \Sym{\Delta}$ is the homomorphism with kernel $K$.

During the course of the algorithm, we carry out
membership testing in $P$, and rewrite elements as words
in its generators, using standard permutation group algorithms.

For each $j \in \Delta$, we maintain a subgroup $A_j$ of
$\Aut(S_j)$.  It is generated by
automorphisms induced by conjugation by the generators $W_i$ of certain
composition factors $G_i/G_{i-1}$ that lie in $K$ but not in $M$. As with 
$P$, we keep track of the correspondence between the generators of $A_j$
and the corresponding sets $W_i$.
More precisely, immediately before we consider the composition factor
$G_k/G_{k-1}$, $A_j$ is the group of automorphisms of $S_j$ induced by
those elements of $G_{k-1} \cap K$ that centralise all of the simple factors
$\langle W_{j'} \rangle L$ of $M/L$ with $j < j' \in \Delta$. 

When $G_j/G_{j-1}$ is first identified as a direct factor of $M/L$,
we initialise $A_j$ to $\Inn(S_j)$.
Suppose that the factor $G_k/G_{k-1}$ with $k>j$ under consideration
turns out to lie in $K$ but not in $M$.  Since $G_k/G_{k-1}$ must be cyclic,
$W_k = \{g\}$ for some $g$.  As we 
explain in more detail in Section~\ref{subsection:test2},
we now adjust $g$ such that, for some specific $j \in \Delta$,
it centralises all factors $\langle W_{j'} \rangle L$ with
$j < j' \in \Delta$, but the automorphism $\alpha$  of $S_j$ induced
by conjugation by $g$ does not lie in $A_j$. We then append $\alpha$ to $A_j$.
The computations required in $A_j$
are described in Section~\ref{section:autident}.

As was the case with $P$, this setup is not disturbed by
later composition factors  $G_k/G_{k-1}$ that are simple factors of
$M/L$. The elements in earlier factors that induce the generators of
the groups $A_j$ automatically induce the identity automorphism on
all such later factors.

\subsection{The rearrangement algorithm in detail}
Observe that non-abelian composition factors cannot belong to $K/M$,
and abelian composition factors cannot belong to $M/L$.
We first list the three main steps of the algorithm and then describe them in
greater detail.

\medskip \noindent
Initialise $\Delta$ to $\{\}$ and $P$ to $\Sym{\Delta}$.

\medskip \noindent
For $k =1,2,\ldots,m$, do the following, with $W_k = \{g_1,g_2,\ldots,g_s\}$,
or $W_k = \{g\}$ if $S_k$ is cyclic.
\begin{enumerate}
\item[(i)] Decide whether there exist 
$h_i \in G_{k-1}$ $(1 \leqslant i \leqslant s)$ with $g_ih_i \in K$.
If so, replace $g_i$ by $g_ih_i$. If not, then adjoin the permutations of
$\Delta$ induced by conjugation by the elements of $W_k$ as new generators
of $P$, and proceed to the next value of $k$. 

\item[(ii)] If $S_k$ is cyclic, then
decide whether there exists $h \in G_{k-1}$  with $gh \in L$.
If so, replace $g$ by $gh$. If not, then there exists $h \in G_{k-1}$ with the
following property: there exists $j \in \Delta$ such that $gh$ centralises
$\langle W_{j'} \rangle L/L$
for all $j'\in \Delta$ with $j'>j$, but the automorphism $\alpha$ of
$S_j$ induced by $gh$ does not lie in $A_j$.
Replace $g$ by $gh$ and adjoin $\alpha$ to the set of generators of $A_j$.

\item[(iii)]
If $S_k$ is insoluble, then find 
$h_i \in G_{k-1}$ such that, for $1 \leqslant i \leqslant s$, each $g_ih_i$ centralises
each factor $G_j/G_{j-1}$ with $j \in \Delta$, and replace
each $g_i$ by $g_ih_i$. (The adjusted elements $g_i$ generate a new 
simple factor of $M/L$.)
Adjoin $k$ to $\Delta$ and initialise $A_k$ to $\Inn(S_k)$.
\end{enumerate}

\subsubsection{Does $G_k/G_{k-1}$ lie in $K$?}\label{subsection:test1}
If $r\leqslant 1$, then there is nothing to do in Step (i), since $G_k/G_{k-1}$
must already lie in $M$. Suppose that $r>1$.
We consider the first generator $g_1$ in $W_k$, and calculate its permutation
action $\sigma_1$ on $\Delta = \{j_1,j_2,\ldots,j_r\}$.
To do this, we let $x_i$ be the first generator in $W_{j_i}$ for
$1 \leqslant i \leqslant r$, and calculate $x_i' := x_i^{g_1}$ and its height
$h_i := h(x_i')$.
Since $x_i$ and hence also $x_i'$ lie in $M$, each composition factor
$G_{h_i}/G_{h_i-1}$ must lie in $M$. If $S_{h_i}$ is non-abelian then, since
conjugation by $g_1$ permutes the simple factors of $M/L$, 
it follows that $h_i \in  \Delta$ and $h_i$ is the 
required image $j_i^{\sigma_1}$
that we are attempting to
calculate. If $S_{h_i}$  is cyclic, then $G_{h_i}/G_{h_i-1}$ must lie
in $L$. In that case, we replace $x_i'$ by $x_i' \phi(\tau(x_i'))^{-1}$, which
reduces the height of $x_i'$ without changing $x_i'L$, and try again.
Eventually, $x_i'$ must lie in a non-abelian composition factor, which enables
us to compute the required image $j_i^{\sigma_1}$. 

Thus we compute $\sigma_1$, and it is easily seen that the composition factor
$G_k/G_{k-1}$ lies in $K$ if and only if $\sigma_1 \in P$, which we can test.
Irrespective of the result of this test, we then proceed to 
calculate $\sigma_i$ for $2 \leqslant i \leqslant j_r$. As explained above, 
$\sigma_1 \in P$ if and only if $\sigma_i \in P$ for all $i$.
If so, then we rewrite each $\sigma_i$ as a word in the generators of $P_i$.
Since these generators correspond to elements of $W_i$ for $i<k$, we 
then multiply $g_i$ (for $1 \leqslant i \leqslant t$) by the inverse of the
corresponding elements of $G_i$ to yield elements $g_ih_i$ that induce the
identity permutation on $\Delta$, and hence lie in $K$, as required.

If $\sigma_i \not\in P$, then we 
define $P^* := \langle P, \sigma_i \rangle$.
Since $G_k/G_{k-1}$ is simple, $P^*/P$ 
is simple and isomorphic to $G_k/G_{k-1}$. 
We now replace $P$ by $P^*$.
When the algorithm completes, we know a composition series for $P$. 

\subsubsection{Does cyclic $G_k/G_{k-1}$ lie in $L$?}\label{subsection:test2}
Suppose that $G_k/G_{k-1}$ is cyclic and lies in $K$, so we must 
test it for membership of $M$. Since $M/L$ has no abelian composition
factors, this is equivalent to membership of $L$. Since $G_k/G_{k-1}$ is
cyclic, $W_k = \{g\}$ for some $g$.

Since $g$ is in $K$, it normalises each simple factor
$\langle W_j \rangle L/L$ of $M/L$ with $j \in \Delta$.  For each such $j$,
let $\alpha_j$ be the automorphism of $S_j$ induced by conjugation by $g$;
that is,  $x^{\alpha_j} = \tau(g^{-1}\phi(x)g)$ for $x \in S_j$.

We proceed as follows. We consider $\langle W_j \rangle L/L$
in turn for $j = j_r,j_{r-1},\ldots,j_1$.  We first
use the methods described in Section~\ref {section:autident} to test whether
$\alpha_j \in A_j$ and, if so, express $\alpha_j$ as a product of an inner
automorphism of $S_j$ and a word in the generators of $\Aut(S_j)$ that have
been adjoined to $A_j$ when considering earlier composition factors of $G$.

If $\alpha_j \in A_j$, then we use the calculated word to find
$h \in G_{k-1}$ such that the automorphism induced by $gh$ centralises
$\langle W_j \rangle L/L$. We then replace $g$ by $gh$, recalculate the
$\alpha_{j'}$ for $j' \in \Delta$ with $j' < j$, and proceed to the
next value of $j$.

If $\alpha_j \in A_j$ for all
$j \in \Delta$, then the automorphism $\alpha$ induced by conjugation by the new
element $g$ centralises $M/L$, so $g \in L$, and we have achieved our objective.

On the other hand, if $\alpha_j \not\in A_j$ for some $j$, 
then we adjoin $\alpha_j$
as a new generator of $A_j$ and proceed to the next value of $k$.

The reason that we consider the factors $\langle W_j \rangle L/L$ in reverse
order is that the property that the elements $g$ that induce the automorphisms
that generate $A_j$ centralise all factors $\langle W_{j'} \rangle L/L$ 
with $j'>j$ is not affected by new factors of $M/L$ discovered later.

As we observed for $P$, if $A^* = \langle A_j, \alpha_j\rangle$,
then $A_j^*/A_j \cong G_k/G_{k-1}$, which is cyclic of prime order.
The algorithm described in Section~\ref{section:autident} assumes 
that this property holds.

%Analogously to the property of $P$ observed in the final paragraph of
%Section~\ref{subsection:test1},  
%when we replace $A_j$ by the group $A^*_j$ generated by $A_j$ and 
%a new generator $\alpha_j$, then 
%$A_j^*/A_j \cong G_k/G_{k-1}$, which is cyclic of prime order.

\subsubsection{Processing insoluble $G_k/G_{k-1}$ in $K$.}\label{subsection:test3}
Finally, suppose that $G_k/G_{k-1}$ is insoluble and lies in $K$.
Since $K/M$ is soluble, $G_k/G_{k-1}$ must lie in $M$, and we wish to replace
the elements of $W_k$ by elements that generate a simple direct factor of $M/L$.

For $g_i \in W_k$ and $j \in \Delta$, let $\alpha_{ij}$ be the automorphism of
$S_j$ induced by conjugation by $g_i$.
As above, we consider the $j \in \Delta$ in decreasing order.
Since we know already that $G_k/G_{k-1}$ lies in $M$,
it is guaranteed that $\alpha_{ij} \in A_j$ at each step.
For each $j$ in turn, we replace $g_i$ by suitable $g_ih_i$ with
$h_i \in G_{k-1}$ such that $g_ih_i$ centralises $\langle W_j \rangle L/L$,
recalculate the $\alpha_{ij'}$ for $j' \in \Delta$ with $j'<j$, and
then proceed to the next $j$. 
After doing this for all $j \in \Delta$, the resulting elements of $W_j$
centralise all of the factors $\langle W_j \rangle L/L$, and hence
generate a simple direct factor of $M/L$ as required.

\section{Algorithms exploiting the Soluble Radical Model}\label{section:furthercomp}
After rearranging the composition series to pass through $L$, $M$ and $K$,
we compute representations of the soluble layers $L$ and $K/M$ as PC-groups,
together with effective maps that enable us to move  between
$L$ or $K/M$ and its PC-representation.
We do this also for the unipotent radical ${O}_p(G)$ of $G$ which,
from the design of {\tt CompositionTree}, is guaranteed to be at the bottom of
the composition series. Doing this is straightforward
using the available functions for rewriting elements of the simple factors
$S_k$ as SLPs in their generators. For each cyclic factor,
the SLPs are in a single generator.

We now briefly discuss examples of computations that can 
be carried out in $G \leqslant \GL(d,\F_q)$ by exploiting 
{\tt CompositionTree} and the Soluble Radical Model. 

\subsection{A chief series}
Computing a chief series that refines the characteristic
series can be subdivided into producing those factors that
lie in $G/K$, $K/M$, $M/L$ and $L$. 
Since $G/K$ is represented as a permutation group, 
we use standard permutation group machinery
to find a chief series.
For $M/L$ there is essentially nothing further to do: 
the chief factors within this layer correspond to the orbits of $P$.

This leaves the two soluble factors $K/M$ and $L$.
We use standard PC-group machinery to
find chains of characteristic subgroups of $K/M$ and $L$ with elementary
abelian layers, set up the layers as $\F_rG$-modules for the
appropriate primes $r$, and calculate composition series for these modules.
The terms in these series correspond to terms in a chief series of $G$.

\subsection{The centre}
First we compute
$\Zent(L)$ (which contains $\Zent(G)$) in the PC-representation of $L$. Next
we calculate the conjugation action of the generators of $G$ on $\Zent(L)$.
Now $\Zent(G)$ is the subgroup of $\Zent(L)$ fixed under this action.
We set up $\Zent(L)$ under the action of $G$ as a $\Z G$-module
and find the fixed subgroup via a matrix nullspace computation. 

\subsection{Sylow subgroups}\label{subsec:sylow} 
Let $r$ be a prime. Our method for computing a Sylow $r$-subgroup of $G$
assumes that we can find Sylow $r$-subgroups of the simple direct factors 
of $M/L$, and also that we can solve the conjugacy problem for two
such  Sylow $r$-subgroups.
For classical groups in their natural representation, 
algorithms (with $\MAGMA$
implementations) to solve both problems are described
in~\cite{stather07}. For other types of simple groups, 
we use BSGS machinery.

Here is a brief outline of our method of finding $R \in \Syl_p(G)$.
If $G=L$ then we use its PC-representation to find $R$, so assume not,
in which case $M/L$ is non-trivial.  First we find Sylow $r$-subgroups
$R_1$, $R_2$, $R_3$ and $R_4$ of $L$, $M/L$, $K/M$ and $G/K$.
We do this using the PC-representations for $L$ and for $K/M$,
the permutation representation of $G/K$, and the methods 
of~\cite{stather07}
for $M/L$. %If $R_2$ is trivial, then we find
%a Sylow 2-subgroup $T$ of $M/L$; since $T$ is non-trivial,
%this reduces the problem to a computation in a smaller group.
If $R_2$ is trivial, then we find a Sylow 2-subgroup $T$ of $M/L$;
as we see below, the fact that $T$ is non-trivial reduces 
the problem to a computation in a smaller group.

By solving the conjugacy problem
for Sylow $r$-subgroups of $K/M$, we find inverse images in $G$ of
the generators of $R_4$ which (modulo $M$) normalise $R_3$ and have order
a power of $r$. We combine these with generators of $R_3$ to produce
generators of a subgroup $R_5$ of $G/M$ which normalises $R_3$.

Similarly, by solving the conjugacy problem for Sylow $r$-subgroups of
$M/L$ (or for Sylow 2-subgroups if $R_2=1$), we find inverse
images in $G$ of the generators of $R_5$ which (modulo $L$) normalise $R_2$
(or $T$ if $R_2=1$) and have order a power of $r$. We combine these with
generators of $R_2$ to produce generators of a subgroup $R_6$ of $G/L$ which
normalises $R_2$ (or $T$ if $R_2=1$).

Finally, by solving the conjugacy problem for Sylow $r$-subgroups of
$L$, we find inverse images in $G$ of the generators of $R_6$ which
normalise $R_1$ and have order a power of $r$. We combine these with
generators of $R_1$ to produce generators of a subgroup $R$ of $G$ which
normalises $R_1$. Since $RL/L$ normalises $R_2$ or $T$, it is
a proper subgroup of $G$, and contains a Sylow $r$-subgroup of $G$.
We compute its order 
(either using {\tt CompositionTree} or BSGS machinery);
in practice, usually $R \in \Syl_r(G)$ but, if not, then we apply the 
algorithm recursively to $R$.

As we demonstrate in Example~\ref{invcent} below, 
a Sylow 2-subgroup can often be found as a subgroup of an appropriate
involution centraliser.

\subsection{Other algorithms} 
We have also implemented algorithms which exploit 
both {\tt CompositionTree} and the 
Soluble Radical Model to perform the following computations 
in $G \leqslant \GL(d, \F_q)$:  test for its nilpotency and solubility; 
determine its derived group; determine 
the normal closure in $G$ of a subgroup; 
determine the unipotent and soluble radicals and Fitting subgroup of $G$. 

In \cite{MR3056697}, algorithms are described that use a combination of
\comment{DFH: added paragraph}
BSGS methods and the \GAP\ {\tt recog} package to compute
centralisers and conjugacy classes in matrix groups, and we have
also implemented these using {\tt CompositionTree} in \MAGMA. 

\section{Implementation and performance}
\label{implementation}
We discuss aspects of our implementation
in \MAGMA\ of our algorithms and briefly discuss 
their performance on some examples.

\subsection{Implementation}

The {\tt CompositionTree} intrinsic in $\MAGMA$ has a large 
number of options. Most are technical, 
we describe just a few of the significant ones.
The kernel of a reduction 
can be constructed using the random element or presentation method. 
Short presentations for the classical groups
on standard generators are incorporated.
The user can verify the correctness of the tree using presentations
at each node during the construction of the tree. Alternatively,
the complete tree can be verified after its construction.
The initial number of kernel generators used in the random element method
of Section~\ref{subsubsec:randommethod} can significantly
affect the performance. It can be specified as a function,
depending on factors such as the degree, the field, and
the reduction type being used. The number of mandarins used can be
set by the user. 

Our general package for structural computations in matrix groups
\comment{DFH: expanded sentence slightly}
over finite fields decides initially whether to use 
{\tt CompositionTree} or BSGS machinery on a given group $G$.
To do so, it carries out irreducibility and imprimitivity
tests on $G$, as described in 
Section~\ref{section:matrix_reductions}, and then
makes a base change to reflect the submodule or block structure of the
associated module. This assists the search for a base
with short basic orbits. If the BSGS algorithm encounters
a basic orbit of length exceeding some (user-supplied) upper limit,
then we use {\tt CompositionTree}.
The resulting decision is not always optimal, and the user can force the
\comment{DFH: added sentence}
use of {\tt CompositionTree} by running it explicitly on $G$.

The package uses a large body of code, 
developed both as part of this work and independently. 
These contributions are noted in the online documentation. 

\subsection{Examples}
There are some situations in which the rearranging algorithm described
in Section~\ref{section:rearrange} does not perform well.
For example, we can construct soluble matrix groups of moderately small
degree and a large number of composition factors by starting with $\Sym{4}$
as a subgroup of $\GL(2,\F_p)$ for some prime $p$, and then repeatedly taking
wreath products with $\Sym{4}$.
Usually {\tt CompositionTree} produces a 
composition series that requires much 
rearranging to obtain a chief series.
%Since $\MAGMA$ automatically 
%computes PC-presentations that pass through a chief series (for the group
%type \texttt{GrpPC}), this results in poor performance.
The implementations of~\cite{MR2429998, statherthesis} perform better
on such examples.
Wreath products of small degree matrix groups with transitive
permutation groups of moderately high degree are also demanding. 
Such examples of degree up to about 50 can typically be processed easily 
using BSGS machinery (see Example 3 below).

We now discuss some illustrative examples. 
All computations were carried out on a Dell Latitude E6510 with
4GB of RAM using the implementation publicly available as
part of {\sc Magma} 2.17-11. Since most of the algorithms 
are randomised, individual timings may vary.
L\"ubeck \& M\"uller \cite{challenge}, Parker and Wilson have 
provided challenge problems.  Our machinery
can identify the composition factors of each challenge group.

\begin{enumerate}
\item 
One such challenge is the sporadic simple
group $J_4$ given as a 2-generator subgroup of $\GL(112,4)$.
{\tt CompositionTree} completed for this group in 50 seconds;
the first reduction writes the group over a smaller field.

\item 
A second challenge is an 
irreducible 4-generator subgroup of $\GL(168,61^2)$.
{\tt CompositionTree} completed for this group in 1100 seconds.
It is a tensor product of 12- and 14-dimensional groups. 
The composition factors,
obtained in 50 seconds, are
$\PSL(12,61^2)$, $\Omega^-(14,61)$, and cyclic groups of order 2 (six times),
3 (twice), 5 and 31. 
A chief series was computed in 270 seconds and 
an Sylow 3-subgroup in 165 seconds.
%It is possible to do further computations with
%this group, such as finding a chief series and Sylow subgroups, 
%but these are slower.

\item 
A third challenge is a 2-generator subgroup of
$\GL(84,7)$: an imprimitive wreath product of a
4-dimensional matrix representation of $\SL(2,7)$ with a permutation
representation of $\PSL(2,7)$ of degree 21.
{\tt CompositionTree} completed in 5 seconds, and the chief factors
were obtained in 45 seconds. This example illustrates well the 
cost of the rearrangement algorithm. 
By contrast, the BSGS machinery for the same tasks
completed in 10 seconds, following an initial 
change to a basis compatible with the 21 blocks.

\item 
One priority 
is to provide a wide range of functionality for carrying out
computations reasonably quickly in matrix groups of moderately small degree.
We have extensively tested maximal subgroups of classical groups,
which can be obtained using the $\MAGMA$ intrinsic {\tt ClassicalMaximals}.
For example, $\SU(12,5)$ has 26 classes of maximal subgroups
(up to conjugation in its automorphism group), of which eleven are reducible
(with unipotent radical of order dividing $5^{48}$);
six imprimitive (block sizes $6,6,4,3,2,1$); one semilinear;
two tensor products ($2 \times 6$ and $3 \times 4$); two defined over
proper subfields modulo scalars (orthogonal and symplectic groups over $\F_5$);
and three in the Aschbacher class $\cS$
(extensions of $\SL(2,23)$, $6.{\rm Suz}$ and $6. A_7$).
Chief series and all non-trivial Sylow $p$-subgroups were found
for all of these subgroups in a total of 1760 seconds.

\item \label{invcent}
As one example of a problem that arose naturally in some research work, we
were asked to find a Sylow 2-subgroup of the simple exceptional Lie
type group $G := F_4(3)$. 
%The \MAGMA\ command {\tt ChevalleyGroup("F",4,3)} returns
%the 24-dimensional representation of this group over $\F_3$.
The constructive membership problem for $G$ can be solved using
the technique described in \cite{ryba_trick},
and {\tt CompositionTree} successfully completed in 35 seconds,
so confirming that 
the order of its Sylow 2-subgroup is $2^{15}$. Since constructive
recognition is not yet available for $G$, we 
cannot find the Sylow subgroups directly.
Instead, we used our \MAGMA\ intrinsic {\tt CentraliserOfInvolution},
based on the Monte Carlo algorithm of~\cite{bray00}, to compute 
$C_G(t)$ for an involution $t \in G$.
We did this for random involutions $t$ until we found
$C_G(t)$ with order divisible by $2^{15}$. (This may occur with
$C_G(t) \cong 2. {\rm O}_9(3)$ or $2. {\rm O}^-_8(3)$.) It was now
a 1-second computation, using the method described in 
Section~\ref{subsec:sylow}, to find the
Sylow 2-subgroup of $G$ as a subgroup of $C_G(t)$. 
\end{enumerate}

\section{Future directions}
\label{future}

\subsection{Constructive recognition algorithms for exceptional groups} 
As noted in Section~\ref{section:leaf_algorithm}, we do not yet have
(implementations of) constructive recognition algorithms for 
the exceptional groups of Lie type and rank at least 2;
short presentation of these are also needed for the verification process.

\subsection{Aschbacher reductions}
Algorithms with better theoretical and practical performance
are desirable for certain of the reductions
based on Aschbacher's theorem. 
The existing algorithms sometimes have polynomial time complexity,
subject to certain conditions not 
always satisfied. While usually their implementations
run efficiently in practice, they sometimes fail (to complete). 

\subsection{Processing ${O}_p(G)$}
It seems likely that any
algorithm for processing ${O}_p(G)$ 
of a matrix group $G$ 
defined over a field $\F_q$ of characteristic $p$
has complexity 
$\OR{d^7\log_p^3 q}$ in field operations over $\F_p$.  
Constructing a generating set for ${O}_p(G)$ 
remains a bottleneck,  since its rank may be large.
It may be possible to improve our treatment 
of ${O}_p(G)$ by first constructing a
normal series for this group, where the corresponding factors consist of
rectangular blocks arising from a composition series for the natural module 
for $G$, and then applying representation theory to these
blocks to improve the way in which they are processed.

\subsection{Subgroups and factor groups}
Further developments will improve the functionality of the package.  For
example, subgroups, normal subgroups and quotient groups should be built into
the package.  If $H \leqslant G$ is defined by a generating set, and its
relationship with $G$ is to be ignored, then there is nothing to say.  But in
general this relationship should be respected.  In this case the
composition tree for $H$ could be constructed by refining the composition tree
for $G$.  The reorganisation of the composition tree for $G$ to refine a chief
series passing through the soluble radical and other characteristic subgroups
of $G$ would induce a rearranged composition tree for $H$ that would not, in
general, pass through the soluble radical or other characteristic subgroups of
$H$.  A normal subgroup $N$ of $G$ could be similarly processed.  Then $N$
would cover certain chief factors of $G$, and avoid others.  It would be
possible to use the resultant data structure to compute in $G/N$.  To combine
the twin goals of having, on the one hand, a computational model for a finite
group $G$ as being defined by a chief series that passes through the soluble
radical and other characteristic subgroups of $G$, and on the other hand
having a model that passes readily to subgroups and quotient groups, would
require complex data structures.  However, the fact that we have a platform
from which one can consider computing in quotients
of a matrix group may be of interest.

%\bibliographystyle{amsalpha}
\bibliographystyle{alpha}
\bibliography{mgrp}

\end{document}
