\magnification 1200
\def\q{\quad}
\def\GL{{\rm GL}}
\centerline{\bf Data types for composition tree 2.}
\medskip
\centerline{Data structure for group elements}
\medskip
There is a problem with MAGMA not allowing us to overwrite the group operations.
Until this is dealt with (or the code is organised to work round this problem) matrix group
elements will have to be encoded as single matrices.  All that is required, as far as
functionality is concerned, is that there should be readily computable inverse isomorphisms
between the universal group for the node and the corresponding matrix group.  This should be
completely trivial (once the universal groups has been determined).
For example an imprimitive group preserves blocks.  The corresponding universal group is
$\GL(r,q)\wr S_s$.  The data type represents an element of the group as a sequence of $s$
$r\times r$ matrices and a permutation, at least in theory.  In practice, if one has to use $rs\times rs$
matrices (at what cost I don't know), it is a triviality to write down the $r\times r$ matrices and the
permutation.

From the point of view of a specification of the code, I thus want a two-way computable isomorphism
between the actual data structure and my suggested data structure.
\medskip
Data structure for group elements in nodes of matrix type:
\medskip
General: Matrix;

SemiSimple: Sequence of matrices, partitioned into subsequences.

Unipotent-Compound:  Matrix, in block format, with certain blocks defined to be zero.

Unipotent-Single:  Rectangular matrices, composition is addition.

Irreducible:

\q Classical:  Matrix.

\q Larger Field:  Matrix and Galois automorphism.

\q Smaller Field:  Matrix and Scalar.

\q Imprimitivity:  Sequence of matrices and a pemutation.

\q Tensor Product:  Two matrices.

\q Tensor induced:  Sequence of matrices and a permutation.

\q Symplectic:  ?? and General.

\q C9.  Matrix.

Block  Sequence of matrices.

Subgroup.  See subgroup essay.
\medskip
Comments:  This should be reasonably clear.  With the symplectic case the left child
is a $p$-group for a different prime.  I suppose we should write it in terms of a power commutator
presentation to be able to use all the $p$-group code.  In the meantime we could opt out
(as we can with any node we have not perfected) and call the left child `general'.
\bye

