freeze;

/* do the projectivities generate a field? this is not a conclusive test; 
   we simply check that they commute and that we can find a generating
   element */

// import "../Smash/random.m": RandomElement;
import "../Smash/random.m": ElementOfOrder;
import "../Smash/misc.m": IsPowerOfPolynomial, EvaluateImage, FirstNonZeroEntry;
import "direct.m": ObtainDirectSumSpaces;

ProjectivitiesGenerateField := function (S, order)

   local G;

   for y in S do   
      if exists {x : x in S | x * y ne y * x} then 
         vprint Tensor: "Projectivities do not commute";
         return false, false;
      end if;
   end for;

   P := Parent (Rep (S));
   G := sub <GL(Degree (P), BaseRing (P)) | S>;
   g := ElementOfOrder (G, order, 100);

   if Type (g) eq BoolElt then 
      vprint Tensor: "Didn't find element of appropriate order";
      return false, false;
   end if;

   return true, g;

end function;

/* X is a matrix, return the non-zero blocks of size k in X */

BlocksOfMatrix := function (X, k)

   G := Parent (X);
   F := BaseRing (G);
   d := Degree (G);

   Nmr := d div k;
   A := MatrixAlgebra (F, d);
   Y := A!X;
   SmallA := MatrixAlgebra (F, k);
   Blocks := [];

   for i in [1..Nmr] do
      for j in [1..Nmr] do
         A := SmallA! ExtractBlock (Y, (i - 1) * k + 1, 
                                       (j - 1) * k + 1, k, k);
         if not IsScalar (A) then Include (~Blocks, A); end if;
      end for;
   end for;
 
   return Blocks;

end function;

/* rewrite basis for P wrt N */

ConstructNewFlat := function (N, P)

   Coeffs := [Eltseq (x) : x in Basis (N)];
   B := Basis (P);
   v := [&+[B[j] * Coeffs[i][j] : j in [1..#B]] : i in [1..#Coeffs]];
   F := BaseRing (N);
   return sub <VectorSpace (F, Degree (P)) | v>;
   
end function;

/* can we use the potential projectivity C to give us 
   a singular element? */

FoundSingularElement := function (C, DimU, P)

   /* compute its characteristic polynomial */
   f := CharacteristicPolynomial (C);

   /* is f the DimU power of some polynomial? */
   flag, factors := IsPowerOfPolynomial (f, DimU);
   if flag eq false then return true, true; end if;

   /* is f a power of an irreducible polynomial? */
   if #factors gt 1 then 
      /* compute generalised eigenspace of C */
      h := factors[1][1];
      N := NullSpace (EvaluateImage (h, C));
      return true, ConstructNewFlat (N, P);
   else 
      m := MinimalPolynomial (C);
      factors := Factorisation (m);
      if factors[1][2] gt 1 then 
         /* compute generalised eigenspace of C */
         h := factors[1][1];
         N := NullSpace (EvaluateImage (h, C));
         return true, ConstructNewFlat (N, P);
      else 
         return false, false;
      end if;
   end if;

end function;

/* Y collection of matrices written wrt geometric basis;
   P is a potential flat; we are searching for a point 
   of dimension DimU */
 
SetupBlocks := function (Y, P, DimU)

   Proj := {};
   Blocks := [];
   DimP := Dimension (P);

   /* look through DimP x DimP in matrix for each element of Y 
      for one with determinant 0 */

   for i in [1..#Y] do
      if IsScalar (Y[i]) then continue; end if;
      B := BlocksOfMatrix (Y[i], DimP);
      if exists (Result) {b : b in B | Determinant (b) eq 0} then 
         vprint Tensor: "Block A has nullspace"; 
         N := NullSpace (Result);
         return true, ConstructNewFlat (N, P);
      end if; 
      Append (~Blocks, B);
   end for;

   /* construct potential projectivities */ 
   for i in [1..#Blocks] do
      if #Blocks[i] eq 0 then vprint Tensor: "#Blocks from A is 0"; continue; end if;
      Ainv := Blocks[i][1]^-1;
      for j in [2..#Blocks[i]] do 
         C := Blocks[i][j] * Ainv;
         if not IsScalar (C) then 
            a, b := FoundSingularElement (C, DimU, P); 
            if a then return true, b; end if;
            Include (~Proj, C);
         end if;
      end for;
   end for;

   return false, Proj;

end function;

/* search for singular element in algebra generated by collection
   of projectivies CC */

SearchForSingularElement := function (C, P, DimU, NmrTries)

   local x, y, module;

   A := sub <Parent (Rep (C)) | C>;  // to get random elements 

   i := 0;
   repeat
      x := Random (A);
      y := Random (A);
      z := x + y;
      if not IsScalar (z) then 
         a, b := FoundSingularElement (z, DimU, P); 
         if a then return true, b; end if;
         Include (~C, z);
      end if;
      i +:= 1;
   until i eq NmrTries;

   return false, C;

end function;

/* try to find singular element in algebra of projectivities */

InvestigateMatrices := function (Y, P, DimU, NmrTries)

   DimP := Dimension (P);

   flag, C := SetupBlocks (Y, P, DimU);

   if flag then return flag, C; end if;

   if #C eq 0 then return false, false; end if;

   flag, C := SearchForSingularElement (C, P, DimU, NmrTries);

   return flag, C;

end function;

/* set up matrix whose rows are the vectors of the 
   bases for each subspace in Sum */

SetupMatrix := function (Sum)

   S := Sum[1];
   G := GL (Degree (S), BaseRing (S));

   A := &cat[&cat[Eltseq (x) : x in Basis (S)] : S in Sum];

   return G!A;

end function;

/* find minimal set of components of Sum whose direct sum contains P;
   U is the inclusion of P into V wrt the given basis for P and 
   for the basis of V obtained by concatentating the given
   bases for the direct summands */ 

IdentifySubset := function (A, P, Sum)

   Ainv := A^-1;

   U := [v * Ainv : v in Basis (P)];
   DegU := Degree (U[1]);
   k := #Sum;

   Dim := Dimension (Sum[1]);
   Indices := {};
   for i in [1..#U] do
      for j in [1..DegU] do
         if U[i][j] ne 0 then 
            Include (~Indices, (j - 1) div Dim + 1); 
            if #Indices eq k then return Indices, U; end if;
         end if;
      end for;
   end for;

   return Indices, U;

end function;

ComponentsOfSum:= function (P, Sum, index, M)

   V := VectorSpace (BaseRing (P), Degree (P));

   B := Basis (Sum[index]);
   return [V ! &+[M[i][j] * B[j] : j in [1..#B]] : 
                                   i in [1..Degree (Parent (M))]];

end function;

/* extract the (index)th matrix of dimension DimP x DimP from U */

BasisMatrix := function (P, U, index)

   DimP := Dimension (P);

   m := &cat[[U[i][j]: j in [(index - 1) * DimP + 1..index * DimP]]: 
                       i in [1..#U]];

   H := MatrixAlgebra (BaseRing (P), DimP);
   return H!m; 

end function;

/* construct the change of basis matrix and return it
   together with the generators of G wrt the new basis */

ConstructMatrices := function (G, P, Equated, A)
  
   k := #Equated;
   DimP := Dimension (P);

   F := BaseRing (G);
   K := GL (Degree (G), F);

   x := [];
   for i in [1..#Equated] do
      y := [];
      for j in [1..Degree (Equated[i])] do 
         y[j] := &+[Equated[i][j][k] * A[(i - 1) * DimP + k] : 
                          k in [1..Degree (Equated[i][j])]];
      end for;
      x cat:= y;
   end for;

   C := (K!(&cat[Eltseq (x[i]): i in [1..#x]]))^-1;

   /* write down the generators of G wrt to new basis */
   return [x^C: x in Generators (G)], C;

end function;

/* are the matrices composed of k x k blocks which differ
   only by scalars? if so, return the decomposition */

/*
intrinsic AreProportional(X::Setq, k::RngIntElt) -> BoolElt, <>
{Decide whether or not the collection of matrices X is composed of 
 k x k blocks which differ only by scalars; if so, return true and 
 the decomposition of each matrix, else false}

   require #X ne 0: "Argument 1 must be non-empty";

   G := Parent (Rep(X));
   F := BaseRing (G);
   d := Nrows (Rep(X));
  
   A := MatrixAlgebra (F, d);
   Nmr := d div k;

   SmallA := MatrixAlgebra (F, k);
   SmallB := MatrixAlgebra (F, Nmr);

   Z := Zero (SmallA);
   Factors := [];

   for x in X do

      y := A!x;
      first := true;
      Component := [];

      for i in [1..Nmr] do
        for j in [1..Nmr] do
           C := SmallA!ExtractBlock (y, (i - 1) * k + 1, (j - 1) * k + 1, k, k);

           if C ne Z and first then 
              B := C;
              First := C;
              entryB, index := FirstNonZeroEntry (B);
              first := false;
           end if;

           // is block C a multiple of block B? 

           if C ne Z then 
              entryC := Eltseq (C)[index];
              alpha := F!(entryC / entryB);
              if alpha * B ne C then return false, false; end if;
           else 
              alpha := F!0;
           end if;
           Append (~Component, alpha); 

         end for;
      end for;
      Second := SmallB!Component;

      entry, index := FirstNonZeroEntry(Second);
      assert entry eq 1;
      assert KroneckerProduct(Second, First) eq y;

      Append (~Factors, <Second, First>);
   end for;

   return true, Factors;

end intrinsic;
*/

intrinsic AreProportional(X::Setq, k::RngIntElt) -> BoolElt, <>
{Decide whether or not the collection of matrices X is composed of 
 k x k blocks which differ only by scalars; if so, return true and 
 the decomposition of each matrix, else false}

return DecomposeKronecker(X, k);
 end intrinsic;
 
intrinsic IsProportional(X::Mtrx, k::RngIntElt) -> BoolElt, <>
{Decide whether or not the matrix X is composed of k x k blocks which differ
 only by scalars; if so, return true and the decomposition, else false}
    i, d := AreProportional([X], k);
    if i then
	return true, d[1];
    else
	return false, false;
    end if;
end intrinsic;

/* construct the isomorphisms from one of the equated spaces   
   to each of the rest */

procedure FindIsom (G, ~P, I, U, Sum, ~E, ~Equated)

   F := BaseRing (G);
   PG := GL (Dimension (P), F);

   V := VectorSpace (F, Degree (P));

   StartDim := Dimension (P);

   Common := I meet E;

   if #Common ne 0 and #I ne #Common then

      fixed := Rep (Common);
      Mfixed := BasisMatrix (P, U, fixed); 

      /* is Mfixed a basis for Sum[fixed]? */
      Component := ComponentsOfSum (P, Sum, fixed, Mfixed);
      NewP := sub <V | Component>;

      if Dimension (NewP) lt StartDim then 
         P := NewP;
         return;
      end if;

      MfixedInv := (PG!Mfixed)^-1; 

      for i in I diff E do 

         M := BasisMatrix (P, U, i); 
         Component := ComponentsOfSum (P, Sum, i, M);
         NewP := sub <V | Component>;

         if Dimension (NewP) lt StartDim then 
            P := NewP;
            return;
         end if;

         /* compute the isomorphism matrix from space Mfixed to M */
         Isom := MfixedInv * (PG!M);
         Equated[i] := Equated[fixed] * Isom;
         Include (~E, i);

      end for; 
   end if;
     
end procedure;

/* S = Sum[1];
   S is a potential flat in a projective geometry of dimension DimU;
   find a point in the geometry or decide that S is not a flat */

procedure FindPoint (G, ~Sum, DimU, ~Status, ~CB: Exact := true)

   exact := Exact;

   Status := false; CB := "undefined"; 

   if Dimension (Sum[1]) mod DimU ne 0 then 
      return;
   end if;

   /* need to equate k spaces */
   k := #Sum;

   S := Sum[1];
   StartDim := Dimension (S);

   A := SetupMatrix (Sum);
  
   F := BaseRing (G);
   d := Degree (G);

   Idnn := Id (GL(StartDim, F));
   Equated := [Idnn : i in [1..k]];
   
   E := {1};

   R := RandomProcess (G);
   repeat 

      // g := RandomElement (G);
      g := Random (R);

      P := S^g;
      I, U := IdentifySubset (A, P, Sum);
      FindIsom (G, ~P, I, U, Sum, ~E, ~Equated);

      DimP := Dimension (P);

      if DimP mod DimU ne 0 then return; end if;

      if DimP lt StartDim then 
         Sum := [P];
         ObtainDirectSumSpaces (G, ~Sum, ~flag);
         // if flag eq false then Status := false; return; end if;
         if flag eq false then Status := "unknown"; return; end if;
         $$ (G, ~Sum, DimU, ~Status, ~CB);
         return;
      end if;

   until #E eq k;

   vprint Tensor: 
      "After setting up points in general position Dim = ", Dimension (P);

   Y, CB := ConstructMatrices (G, S, Equated, A);

   /* are the generators of G proportional? */
   if exact eq false then 
      Status := AreProportional (Y, DimP);
      vprintf Tensor: "Are matrices proportional for dim %o? %o\n", DimP, Status;
   else 
      /* are the generators of G proportional? */
      Status := AreProportional (Y, DimU);
      vprintf Tensor: "Are matrices proportional for dim %o? %o\n", DimU, Status;
      if Status eq false then 
         /* are the generators of G proportional? */
         Status := AreProportional (Y, d div DimU);
         vprintf Tensor: "Are matrices proportional for dim %o? %o\n", 
             d div DimU, Status;

      end if;
   end if;

   if Status eq false then CB := "undefined"; end if;

   if Status then 
      if (DimP eq DimU or DimP * DimU eq d) then 
         CB := <CB, DimP>; 
         return; 
      else 
         Status := "unknown";
      end if;
   elif (Dimension (P) eq DimU) then 
      return;
   end if;

   NmrTries := 100;

   Result, NewP := InvestigateMatrices (Y, S, DimU, NmrTries);
   if NewP cmpeq false then Status := "unknown"; return; end if;

   /* did we construct a possible new flat? */
   if Type (NewP) eq ModTupFld then 
      vprintf Tensor: 
         "Found a possible new flat of dimension %o\n", Dimension (NewP);
      if Dimension (NewP) mod DimU ne 0 then 
         Status := false;
         return;
      end if;
      S := NewP;  
      Sum := [S];
      ObtainDirectSumSpaces (G, ~Sum, ~flag);
      // if flag eq false then Status := false; return; end if;
      if flag eq false then Status := "unknown"; return; end if;
      $$ (G, ~Sum, DimU, ~Status, ~CB);
      return;
   elif Result eq false then 
      if ProjectivitiesGenerateField (NewP, #F^(DimP div DimU) - 1) then
         "** Unresolved case -- Probably found tensor \
decomposition over extension field";
          Status := "unknown";
          return; 
      else 
         error "** Projectivities do not generate field **";
      end if;
   end if;

end procedure;

/* S is a potential flat in a projective geometry of dimension DimU;
   find a point in the geometry or decide that S is not a flat */

// intrinsic GeneralFindPoint 
//    (G::GrpMat, ~S::., DimU::RngIntElt, ~Status::BoolElt, ~CB::. : 
//     Exact := true) 
// { This is a new intrinsic }

procedure GeneralFindPoint (G, ~S, DimU, ~Status, ~CB: Exact := true)
   Sum := [S]; exact := Exact;

   ObtainDirectSumSpaces (G, ~Sum, ~flag);
   if flag eq false then Status := false; return; end if;
   
   FindPoint (G, ~Sum, DimU, ~Status, ~CB: Exact := exact);

end procedure;
// end intrinsic;

/* Decide if S is a point; Status is set to true if 
   we verify S is a point */

procedure IsPoint (G, ~S, DimU, ~Status, ~CB)

   Status := false;

   Sum := [S];
   ObtainDirectSumSpaces (G, ~Sum, ~flag);
   if flag eq false then Status := false; return; end if;

   if Dimension (Sum[1]) mod DimU ne 0 then
      return;
   end if;

   /* need to equate k spaces */
   k := #Sum;

   S := Sum[1];
   StartDim := Dimension (S);

   A := SetupMatrix (Sum);
  
   F := BaseRing (G);

   Idnn := Id (GL(StartDim, F));
   Equated := [Idnn : i in [1..k]];

   E := {1};

   R := RandomProcess (G);
   repeat 

      // g := RandomElement (G);
      g := Random (R);

      P := S^g;
      I, U := IdentifySubset (A, P, Sum);

      FindIsom (G, ~P, I, U, Sum, ~E, ~Equated);
      DimP := Dimension (P);
      if DimP lt DimU then return; end if;

   until #E eq k;

   Y, CB := ConstructMatrices (G, S, Equated, A);

   /* are the generators of G of the correct shape? */
   Status := AreProportional (Y, DimU);
   vprint Tensor: "Are matrices proportional? ", Status;

end procedure;
