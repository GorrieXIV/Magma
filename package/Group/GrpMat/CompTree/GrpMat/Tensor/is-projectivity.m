freeze;

import "../Smash/misc.m": EvaluateImage;
// import "../Smash/random.m": RandomElement;
import "direct.m": ObtainDirectSumSpaces;
import "find-point.m": FindPoint;

/* is the characteristic polynomial a u-th power, for u in L? */

procedure ProcessElement (g, ~L, ~factors)

   f := CharacteristicPolynomial (g);
   factors := Factorisation (f);
   mults := {factors[i][2] : i in [1..#factors]};
   L := {u : u in L | forall {y : y in mults | y mod u eq 0}};

end procedure;

/* decide if the matrix C is a u-projectivity for some u in List;
   if Status is true, then CB is a tuple; first entry is the change 
   of basis matrix which exhibits the tensor decomposition, second
   is dimension of geometry -- unless we find a tensor decomposition 
   over a larger field */

procedure IsMatrixProjectivity (G, C, List, ~Status, ~CB: Exact := false)

   exact := Exact;

   CB := "undefined"; Status := false;

   /* if the matrix is scalar, do not test */
   if IsScalar (C) then 
      vprint Tensor: "Matrix is scalar";
      return; 
   end if;

   /* is List a single integer? */
   L := Type (List) eq RngIntElt select {List} else List;

   /* is the characteristic polynomial a u-th power, for u in L? */
   ProcessElement (C, ~L, ~factors);
   if L eq {} then return; end if;

   /* test a small number of elements in the F-algebra 
      generated by C and its G-conjugates */

   F := BaseRing (G);
   d := Degree (G);
   A := MatrixAlgebra (F, d);

   RF := recformat <g : AlgMatElt, factors : SeqEnum>;
   Record := [rec <RF | g := A!C, factors := factors>];

   NmrTries := 10;

   vprint Tensor: "Before looking at random elements of algebra, List is ", L;

   P := RandomProcess (G);
   K := 0;
   repeat 
      /* if so, we generate an element of the F-algebra and try again */
      g1 := Random (P); g2 := Random (P); 
      g := A!(C^g1) + A!(C^g2);

      /* is the characteristic polynomial a u-th power, for u in L? */
      ProcessElement (g, ~L, ~factors);
      if L eq {} then return; end if;
      r := rec <RF | g := g, factors := factors>;
      Append (~Record, r);

      K +:= 1;
   until K eq NmrTries;

   vprint Tensor: "After looking at random elements of algebra, List is ", L;

   /* if the characteristic polynomial f of some g is not a power of an 
      irreducible polynomial, then compute kernel of an irreducible 
      factor to give a potentional flat for FindPoint */
      
   for i in [1..#Record] do 
      factors := Record[i]`factors;
      if (#factors gt 1) then 
         g := Record[i]`g;
         h := factors[1][1];
         N := NullSpace (EvaluateImage (h, g));

         SumSpaces := [N];
         vprint Tensor: "Now call DirectSumSpaces";
         ObtainDirectSumSpaces (G, ~SumSpaces, ~flag);

         if flag eq false then Status := "unknown"; continue; end if;

         /* now send potential flat to FindPoint */
         for u in L do
            Spaces := SumSpaces;
            vprint Tensor: "Now call FindPoint for u = ", u;
            FindPoint (G, ~Spaces, u, ~Status, ~CB);
            vprint Tensor: "Status is ", Status;
            if Status cmpeq true then 
               if (CB[2]) in L or (exact eq false) then 
                  return; 
               end if;
            end if;
            // if Status cmpeq "unknown" then return; end if;
         end for;

         return;
      end if; /* #factors gt 1 */

   end for;

   vprint Tensor: "Have not found a suitable singular space";
   /* 
   if IsIrreducible (G) eq false then 
      printf "The matrix group is not irreducible";
   else  
      print "CONCLUSION: May have found tensor decomposition over larger field";
   end if;
   */

   Status := "unknown"; 

end procedure;

/* decide if the matrix C is a u-projectivity, for some u in L;
   if so, return true and also return the generators of 
   G written wrt a geometric basis for G  */

IsProjectivity := function (G, C, List)

   IsMatrixProjectivity (G, C, List, ~Status, ~CB);

   return Status, CB; 

end function;

/* decide whether any of the elements of prime order obtained from 
   the element g of order o is a projectivity in a u-projective 
   geometry for some u in L */

ProjectivityTest := function (G, g, o, ProjElts, NmrProjective, L: 
                              Exact := false)

   exact := Exact;

   CB := "undefined";
   Elts := ProjElts;
   primes := PrimeBasis (o);
   for p in primes do
      x := g^(o div p);
      if IsScalar (x) then continue; end if;
      if x in Elts then continue; else Append (~Elts, x); end if;
      vprint Tensor: "\nCall to IsMatrixProjectivity for p = ", p;
      IsMatrixProjectivity (G, x, L, ~Result, ~CB: Exact := exact);
      vprintf Tensor: 
         "Result of call to IsProjectivity for p = %o is %o\n", p, Result;
      if Result cmpeq true then
         vprint Tensor: "Found tensor product\n";
         return Result, CB, Elts;
      end if;
      if #Elts ge NmrProjective then break; end if;
   end for;

   return false, CB, Elts;

end function;
