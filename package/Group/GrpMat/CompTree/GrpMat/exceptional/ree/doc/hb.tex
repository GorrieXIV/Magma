%******************************************************************************
%
%    hb.tex      Magma Ree package handbook
%
%    File      : $HeadURL:: https://subversion.sfac.auckland.ac.nz/svn/prj_m#$:
%    Author    : Henrik Bäärnhielm 
%    Dev start : 2008-06-08
%
%    Version   : $Revision:: 10                                              $:
%    Date      : $Date:: 2008-04-11 16:31:41 +1200 (fre, 11 apr 2008)        $:
%    Last edit : $Author:: eobr007                                           $:
%
%    $Id:: design.tex 10 2008-04-11 04:31:41Z eobr007                        $:
%
%******************************************************************************

\documentclass[twoside,a4paper,reqno]{amsart}
%\usepackage[swedish,english]{babel} 
%\usepackage[latin1]{inputenc} % svenska tecken skall tolkas
\usepackage{graphicx}
%\usepackage{pictex}
\usepackage{amsmath}
\usepackage{amsfonts} % for \mathbb
\usepackage{amsthm}
\usepackage{amscd}
\usepackage{amsopn}
\usepackage{amstext}
\usepackage{amsxtra}
%\usepackage{stmaryrd}
\usepackage{amssymb}
%\usepackage{amsbsy}
\usepackage{textcase} % For correct case of swedish chars

\usepackage{bm} % for \boldsymbol
%\usepackage{draftcopy}
\frenchspacing

\numberwithin{equation}{section}
\numberwithin{figure}{section}
%\numberwithin{algorithm}{chapter}

\theoremstyle{plain}
\newtheorem{thm}{Theorem}[section]
\newtheorem{lem}[thm]{Lemma}
\newtheorem{cl}[thm]{Corollary}
\newtheorem{prop}[thm]{Proposition}
%\newtheorem{axiom}[theorem]{Axiom}
\newtheorem{conj}[thm]{Conjecture}

\theoremstyle{definition}
\newtheorem{deff}[thm]{Definition}

\theoremstyle{remark}
%\newtheorem{note}[theorem]{Note}
\newtheorem{rem}[thm]{Remark}

\newcounter{algorithm2e}
%\renewcommand{\thealgorithm2e}{\algorithmcfname~\arabic{section}.\arabic{algorithm2e}}

%\renewcommand{\thetheorem}{Theorem~\arabic{chapter}.\arabic{theorem}}
%\renewcommand{\thepr}{Proposition~\arabic{chapter}.\arabic{pr}}
%\renewcommand{\thedeff}{Definition~\arabic{chapter}.\arabic{deff}}
\providecommand{\abs}[1]{\left\lvert #1 \right\rvert}
\providecommand{\norm}[1]{\left\lVert #1 \right\rVert}
\providecommand{\ceil}[1]{\left\lceil #1 \right\rceil}
\providecommand{\floor}[1]{\lfloor #1 \rfloor}
\providecommand{\set}[1]{\left\lbrace #1 \right\rbrace}
\providecommand{\gen}[1]{\left\langle #1 \right\rangle}
%\providecommand{\ord}[1]{\operatorname{ord}( #1 )}
\providecommand{\Sym}[1]{\operatorname{Sym}( #1 )}
\renewcommand{\Pr}[1]{\operatorname{Pr}[ #1 ]}
%\renewcommand{\char}[1]{\operatorname{char}[ #1 ]}

\newcommand{\field}[1]{\mathbb{#1}}
\newcommand{\vect}[1]{\boldsymbol{\mathrm{#1}}}
\newcommand{\N}{\field{N}}
\newcommand{\Z}{\field{Z}}
\newcommand{\R}{\field{R}}
\newcommand{\Q}{\field{Q}}
\newcommand{\K}{\field{K}}
\newcommand{\A}{\field{A}}
\newcommand{\F}{\field{F}}
\newcommand{\PS}{\field{P}}
\newcommand{\GAP}{\textsf{GAP}}
\newcommand{\MAGMA}{\textsc{Magma}}

% for Cayley graphs
\newcommand{\C}{\mathcal{C}}
\newcommand{\OV}{\mathcal{O}}

\DeclareMathOperator{\sgd}{sgd}
\DeclareMathOperator{\mgm}{mgm}
\DeclareMathOperator{\sgn}{sgn}
\DeclareMathOperator{\GL}{GL}
\DeclareMathOperator{\GF}{GF}
\DeclareMathOperator{\IM}{Im}
\DeclareMathOperator{\RE}{Re}
\DeclareMathOperator{\I}{Id}
%\DeclareMathOperator{\OR}{O}
\DeclareMathOperator{\SL}{SL}
\DeclareMathOperator{\GO}{GO}
\DeclareMathOperator{\SO}{SO}
\DeclareMathOperator{\Sz}{Sz}
\DeclareMathOperator{\Sp}{Sp}
\DeclareMathOperator{\Ree}{Ree}
\DeclareMathOperator{\chr}{char}
\DeclareMathOperator{\Aut}{Aut}
\DeclareMathOperator{\Alt}{Alt}
\DeclareMathOperator{\PSL}{PSL}
\DeclareMathOperator{\diag}{diag}
\DeclareMathOperator{\Tr}{Tr}
\DeclareMathOperator{\SLP}{\mathtt{SLP}}
\DeclareMathOperator{\Norm}{N}
\DeclareMathOperator{\Cent}{C}
\DeclareMathOperator{\Zent}{Z}

\newcommand{\OR}[1]{\operatorname{O} ( #1 )}

\title{Handbook for \textsc{Magma} Ree package}
\author{Henrik B\"a\"arnhielm}
\address{School of Mathematical Sciences \\ Queen Mary, University of London \\ Mile End Road \\ London E1 4NS \\ United Kingdom}
\date{2007-04-22}
\urladdr{http://www.maths.qmul.ac.uk/\textasciitilde hb/}
\email{h.baarnhielm@qmul.ac.uk}

\begin{document}


\maketitle
%\end{frontmatter}

The \textsc{Magma} Ree package provides functionality for
constructive recognition and constructive membership testing of the small Ree
groups $\mathrm{{^2}G_2}(q) = \mathrm{Ree}(q)$, with $q = 3^{2m + 1}$ for some $m > 0$.

The main intrinsics of the package are \texttt{Ree(FldFin F)} which returns the standard copy of the small Ree group over the field $F$, \texttt{RecogniseRee(GrpMat G)}
which performs constructive recognition of $G \cong \mathrm{Ree}(q)$,
\texttt{ReeElementToWord(GrpMat G, GrpMatElt g)} which returns a
\texttt{GrpSLPElt} for $g$ in the generators of $G$, and
\texttt{ReeRecognition(GrpMat G)} which is a non-constructive test
for isomorphism between $G$ and $\mathrm{Ree}(q)$.
  
Sylow $p$-subgroups can be found using the \texttt{ReeSylow(GrpMat
  G, RngIntElt p)} intrinsic. To find conjugating elements between
Sylow $p$-subgroups, an intrinsic \texttt{ReeSylowConjugacy} is
provided. The latter is not available when $p$ is odd and divides $q^3 + 1$.

A list of representatives of the conjugacy classes of
maximal subgroups can be found using the
\texttt{ReeMaximalSubgroups(GrpMat G)} intrinsic, and the intrinsic
\texttt{ReeMaximalSubgroupsConjugacy} can be used to find
conjugating elements between maximal subgroups.

There are a few verbose flags used in the package.
\begin{itemize}
\item \texttt{ReeGeneral}, for the general routines.
\item \texttt{ReeStandard}, for the routines related to the standard copy.
\item \texttt{ReeConjugate}, for the routines related to conjugation.
\item \texttt{ReeTensor}, for the routines related to tensor decomposition.
\item \texttt{ReeMembership}, for the routines related to membership testing.
\item \texttt{ReeCrossChar}, for the routines related to cross-characteristic representations.
\item \texttt{ReeSylow}, for the routines related to Sylow subgroups.
\item \texttt{ReeTrick}, for the routines related to the stabiliser trick.
\item \texttt{ReeInvolution}, for the routines related to involution centralisers.
\item \texttt{ReeSymSquare}, for the routines related to symmetric square decomposition.
\item \texttt{ReeMaximals}, for the routines related to maximal subgroups.
\item \texttt{ReeElements}, for the routines related to element conjugacy.
\end{itemize}

All the flags can be set to values up to $10$, with higher values resulting in more output.

\section{Intrinsics}

\begin{verbatim}
Ree(F) : FldFin -> GrpMat
\end{verbatim}

The field $F$ must have size $q = 3^{2m + 1}$ for some $m > 0$. Returns $\mathrm{Ree}(q)$ on its standard generators.

\paragraph{}

\begin{verbatim}
RecogniseRee(G : parameters) : GrpMat -> BoolElt, Map, Map, Map, Map
\end{verbatim}
Parameters:
\begin{itemize}
\item[] \texttt{Verify}, \textsc{BoolElt}, \emph{Default : true}
\item[] \texttt{FieldSize}, \textsc{RngIntElt}
\end{itemize}

$G$ is absolutely irreducible and defined over minimal field.
Constructively recognise $G$ as a Ree group. If $G$ is isomorphic to $\mathrm{Ree}(q)$ where $q$ is the size of the defining field of $G$, then return:
\begin{enumerate}
\item Isomorphism from $G$ to $\mathrm{Ree}(q)$.
\item Isomorphism from $\mathrm{Ree}(q)$ to $G$.
\item Map from $G$ to the word group of $G$.
\item Map from the word group of $G$ to $G$.
\end{enumerate}
    
The isomorphisms are composed of maps that are defined by rules, so
\texttt{Function} can be used on each component, hence avoiding
unnecessary built-in membership testing.

The word group is the \texttt{GrpSLP} which is the parent of the
elements returned by \texttt{ReeElementToWord}. In general this is not
the same as \texttt{WordGroup(G)}, but is created from it using
\texttt{AddRedundantGenerators}.
    
If \texttt{Verify} is true, then it is checked that $G$ is isomorphic to
$\mathrm{Ree}(q)$, using \texttt{ReeRecognition}, otherwise this is not checked. In that case, \texttt{FieldSize} must be set to the correct value of $q$.

The algorithms for constructive recognition are those of \cite{hb_ree}.

\paragraph{}

\begin{verbatim}
ReeElementToWord(G, g) : GrpMat, GrpMatElt -> BoolElt, GrpSLPElt
\end{verbatim}

If $G$ has been constructively recognised as a Ree group,
and if $g$ is an element of $G$, then return \texttt{true} a \texttt{GrpSLPElt} from the word group of $G$ which evaluates to $g$, else return \texttt{false}.

This facilitates membership testing in $G$.

\paragraph{}

\begin{verbatim}
ReeRecognition(G) : GrpMat -> BoolElt, RngIntElt
\end{verbatim}
Determine (non-constructively) if $G$ is isomorphic to $\mathrm{Ree}(q)$. The corresponding $q$ is also returned.
    
If $G$ is over a field of characteristic not $3$ or has degree greater
than $7$, the Monte Carlo algorithm of \texttt{IdentifyLieType} is
used. If $G$ has degree $7$ and is over a field of characteristic
$3$, then a fast Las Vegas algorithm is used.

\paragraph{}

\begin{verbatim}
ReeIrreducibleRepresentation(F, twists : parameters) : 
FldFin, SeqEnum[RngIntElt] -> GrpMat
\end{verbatim}
Parameters:
\begin{itemize}
\item[] \texttt{CheckInput}, \textsc{BoolElt}, \emph{Default : true}
\end{itemize}

$F$ must have size $q = 3^{2m + 1}$ for some $m > 0$, and \emph{twists} should be a sequence of $n$ distinct pairs of integers $(i, j)$ where $i$ is $7$ or $27$ and $j$ in the range $[0 \ldots 2m]$.

Return an absolutely irreducible representation of $\mathrm{Ree}(q)$, a tensor product of twisted powers of the representation of dimension $7$ or $27$, where the twists are given by
the input sequence.

If \texttt{CheckInput} is true, then it is verified that $F$ and \emph{twists} satisfy the above requirements. Otherwise this is not checked.

\paragraph{}

\begin{verbatim}
ReeSylow(G, p) : GrpMat, RngIntElt -> GrpMat, SeqEnum
\end{verbatim}

If $G$ has been constructively recognised as a Ree group, and if
$p$ is a prime number, return a random Sylow $p$-subgroup $S$ of $G$.

Also returns a list of \texttt{GrpSLPElt} from the word group of $G$,
of the generators of $S$. If $p$ does not divide $\left\lvert G
\right\rvert$, then the trivial subgroup is returned.

\paragraph{}

\begin{verbatim}
ReeSylowConjugacy(G, R, S, p) : GrpMat, GrpMat, GrpMat, RngIntElt -> 
GrpMatElt, GrpSLPElt
\end{verbatim}

If $G$ has been constructively recognised as a Suzuki group, if $p$ is
a prime number and if $R$ and $S$ are Sylow $p$-subgroups of $G$, then
return an element $g$ of $G$ that conjugates $R$ to $S$. A
\texttt{GrpSLPElt} from the word group of $G$, that evaluates to $g$,
is also returned.

Currently, this is not implemented if $p$ is odd and divides $q^3 + 1$.

\paragraph{}

\begin{verbatim}
ReeMaximalSubgroups(G) : GrpMat -> SeqEnum, SeqEnum
\end{verbatim}

If $G$ has been constructively recognised as a Ree group,
find a list of representatives of the maximal subgroups of G.
    
Also returns lists of \texttt{GrpSLPElt} of the generators of the subgroups,
from the word group of $G$.

\paragraph{}

\begin{verbatim}
ReeMaximalSubgroupsConjugacy(G, R, S) : GrpMat, GrpMat, GrpMat -> GrpMatElt, GrpSLPElt
\end{verbatim}

If $G$ has been constructively recognised as a Ree group and if $R$
and $S$ are conjugate maximal subgroups of $G$, then return an element
$g$ of $G$ that conjugates $R$ to $S$. A \texttt{GrpSLPElt} from the
word group of $G$, that evaluates to $g$, is also returned.

Currently, this is not implemented if $R$ and $S$ are normalisers of
Sylow $p$-subgroups with $p$ odd and dividing $q^3 + 1$.

\paragraph{}

\begin{verbatim}
ReeConjugacyClasses(G) : GrpMat -> SeqEnum
\end{verbatim}

If $G$ has been constructively recognised as a Ree group, return a list of conjugacy classes, using the same format as the \texttt{ConjugacyClasses} intrinsic.

\section{Examples}

Example showing the basic features.
\begin{verbatim}
> // Let's try a conjugate of the the standard copy
> F := GF(3, 3);
> G := Ree(F);
> G ^:= Random(Generic(G));
> // perform non-constructive recognition
> flag, q := ReeRecognition(G);
> print flag, q eq #F;
true true
> // perform constructive recognition
> flag, iso, inv, g2slp, slp2g := RecognizeRee(G);
> print flag;
true
> // the explicit isomorphisms are defined by rules
> print iso, inv;
Mapping from: GrpMat: G to MatrixGroup(7, GF(3^3)) given by a rule [no inverse]
Mapping from: MatrixGroup(7, GF(3^3)) to GrpMat: G given by a rule [no inverse]
> // so we can use Function to avoid Magma built-in membership testing
> // we might not obtain the shortest possible SLP
> w := Function(g2slp)(G.1);
> print #w;
342
> // and the algorithm is probabilistic, so different executions will most
> // likely give different results
> ww := Function(g2slp)(G.1);
> print w eq ww;
false
> // the resulting SLPs are from another word group
> W := WordGroup(G);
> print NumberOfGenerators(Parent(w)), NumberOfGenerators(W);
7 3
> // but can be coerced into W
> flag, ww := IsCoercible(W, w);
> print flag;
true
> // so there are two ways to get the element back
> print slp2g(w) eq Evaluate(ww, UserGenerators(G));
true
> // an alternative is this intrinsic, which is better if the elements are not 
> // known to lie in the group
> flag, ww := ReeElementToWord(G, G.1);
> print flag, slp2g(w) eq slp2g(ww);
true true
> // let's try something just outside the group
> H := Omega(7, #F);
> flag, ww := ReeElementToWord(G, H.1);
> print flag;
false
> // in this case we will not get an SLP
> ww := Function(g2slp)(H.1);
> print ww;
false
\end{verbatim}

Example about Sylow subgroups.
\begin{verbatim}
> // let's try a small field
> m := 1;
> F := GF(3, 2 * m + 1);
> q := #F;
> print q;
27
> G := Ree(F);
> // let's try a conjugate
> G ^:= Random(Generic(G));
> // also move to another generating set
> G := DerivedGroupMonteCarlo(G);
> print NumberOfGenerators(G);
19
> // First we must recognise the group
> time flag, iso, inv, g2slp, slp2g := RecogniseRee(G);
Time: 2.000
> // what about creating Sylow subgroups?
> p := Random([x[1] : x in Factorization(q - 1) | x[1] gt 2]);
> print p;
13
> time R := ReeSylow(G, p);
Time: 0.020
> time S := ReeSylow(G, p);
Time: 0.010
> // that was easy, as is conjugating them
> time g, slp := ReeSylowConjugacy(G, R, S, p);
Time: 0.010
> time print R^g eq S;
true
Time: 0.000
> // in this case we also automatically get an SLP of the conjugating element
> print slp2g(slp) eq g;
true
> // those Sylow subgroups are cyclic, and we know the order
> print #R, NumberOfGenerators(R);
13 1
> // creating Sylow 3-subgroups is harder, since there are lots of generators
> time R := ReeSylow(G, 3);
Time: 0.000
> time S := ReeSylow(G, 3);
Time: 0.010
> print NumberOfGenerators(R), #R;
3 19683
> // but conjugation is easy
> time g, slp := ReeSylowConjugacy(G, R, S, 3);
Time: 0.000
> // verifying the conjugating element can be expensive
> time print R^g eq S;
true
Time: 0.870
> // Sylow 2-subgroups are small
> time R := ReeSylow(G, 2);
Time: 0.280
> print NumberOfGenerators(R), #R;
3 8
> // but slightly harder to conjugate
> time S := ReeSylow(G, 2);
Time: 0.200
> time g, slp := ReeSylowConjugacy(G, R, S, 2);
Time: 0.190
> time print R^g eq S;
true
Time: 0.000
\end{verbatim}

Example showing a larger field case.

\begin{verbatim}
> // let's try a larger field
> m := 15;
> F := GF(3, 2 * m + 1);
> q := #F;
> print q;
617673396283947
> G := Ree(F);
> // let's try a conjugate
> G ^:= Random(Generic(G));
> // also move to another generating set
> G := DerivedGroupMonteCarlo(G);
> print NumberOfGenerators(G);
19
> // non-constructive recognition is now a bit harder
> time ReeRecognition(G);
true 617673396283947
Time: 34.410
> // and is your machine up for this?
> time flag, iso, inv, g2slp, slp2g := RecogniseRee(G);
Time: 368.190
> // each call to constructive membership is then easy
> R := RandomProcess(G);
> g := Random(R);
> time w := Function(g2slp)(g);
Time: 2.080
> // evaluating SLPs always takes some time
> time print slp2g(w) eq g;
true
Time: 1.910
\end{verbatim}

Example about maximal subgroups.

\begin{verbatim}
> // let's try a small field
> m := 1;
> F := GF(3, 2 * m + 1);
> q := #F;
> print q;
27
> G := Ree(F);
> // let's try a conjugate
> G ^:= Random(Generic(G));
> // also move to another generating set
> G := DerivedGroupMonteCarlo(G);
> print NumberOfGenerators(G);
19
> // first we must recognise the group
> time flag, iso, inv, g2slp, slp2g := RecogniseRee(G);
Time: 1.870
> // try finding the maximal subgroups
> time l, slps := ReeMaximalSubgroups(G);
Time: 0.400
> // should have a parabolic, an involution centraliser, three Frobenius group\
s
> print #l;
5
> // we can conjugate all except Frobenius groups
> // but verifying the conjugating element can be expensive
> r := Random(G`RandomProcess);
> time g, slp := ReeMaximalSubgroupsConjugacy(G, l[1], l[1]^r);
Time: 0.040
> time print l[1]^g eq l[1]^r;
true
Time: 1.240
> time g, slp := ReeMaximalSubgroupsConjugacy(G, l[2], l[2]^r);
Time: 0.040
> print l[2]^g eq l[2]^r;
true
\end{verbatim}

\bibliographystyle{amsplain}
\bibliography{hb}

\end{document}
