freeze;
 
/* implementation of Niemeyer algorithm for normaliser of 
   extra-special group where degree is prime;
   implementation in Magma prepared by Eamonn O'Brien
   following GAP version prepared by Niemeyer */
   
import "functions.m": SetExtraSpecialFlag, SetExtraSpecialGroup,
                      SetExtraSpecialNormaliser,
                      SetExtraSpecialParameters,
                      ExtraSpecialFlag, SetExtraSpecialBasis;
fail := "unknown";

Factors := function (x)
   l := Factorisation (x);
   return &cat[[l[i][1]: j in [1..l[i][2]]]: i in [1..#l]];
end function;

NullspaceMat := function (b, lambda)
   P := Parent (b);
   F := BaseRing (P);
   d := Degree (P);
   MA := MatrixAlgebra (F, d);
   x := MA!b - lambda * Identity (MA);
   return Nullspace (x);
end function;

GeneratorsOfGroup := function (G);
   return [G.i: i in [1..Ngens (G)]];
end function;

/* is <a,b> extra special?
   test whether a and b satisfy the presentation 
   of an extra-special r-group of order r^3 and exponent r.  */

SatisfyExtraSpecialPres := function (a, b, r)

   z := (a, b);
   if z eq z^0 then return false; end if;
   if not IsScalar (z) then return false; end if;
   if z^r ne z^0 or a^r ne z^0 or b^r ne z^0 then return false; end if;
   return true;

end function;

/* compute a basis for V wrt R
   Computes a matrix B such that when conjugating the
   extra-special r-group <a,b> by B^-1 it is in standard form.  */

ComputeRBasis := function (rgrp)

   if Ngens(rgrp) ne 2 then
      "r-group must be generated by 2 elements";
      return false;
   end if;

   if assigned rgrp`ExtraSpecialBasis then 
      return rgrp`ExtraSpecialBasis; 
   end if;

   // the first is an eigenvector of rgrp.1 to eigenvalue 1
   v := NullspaceMat (GeneratorsOfGroup(rgrp)[1], 1);
   if Dimension (v) ne 1 then
      vprint Smash: "a does not have eigenvector to value 1";
      return false;
   end if;
   basis := [* v.1 *];

   for i in [2 .. Degree(rgrp)] do
      Append (~basis, basis[i-1]*GeneratorsOfGroup(rgrp)[2]);
   end for;

   rgrp`ExtraSpecialBasis := basis;
   return basis;
end function;

PositionInBasis := function (basis, v)

   if v eq 0 * v then return false; end if;
   for i in [1 .. #basis] do
      j := Depth (v);
      if basis[i][j] ne 0 then
	 a :=  v[j] / basis[i][j];
	 if v eq a * basis[i] then 
	    return [* i, a *];
         end if;
      end if;
   end for;

   return false;
end function;	 

/* does <h> lie in <rgrp>?
   test whether <h>  lies in <rgrp>.  We assume that 
   <rgrp> is generated by 2  elements a and b and is an extra-special
   r-group of order r^3 and exponent r.  If <h>  lies in <rgrp>, then 
   the function returns [m, n, u] such that h eq a^m b^n (a,b)^u.  */

RMembership := function (rgrp, basis, h)

   if Ngens(rgrp) gt 2 then
      "r-group must be generated by 2 elements";
      return false;
   end if;

   r := Degree (rgrp);
   a := rgrp.1; b := rgrp.2;
   z := (a, b);
	
   theta := z[1][1]^-1;

   w := basis[1]*h;
   n := PositionInBasis (basis, w);
   if n cmpeq false then return false; end if;
   u := Log (theta, n[2]);

   // now check whether v is mapped to theta^u v b^(n-1)
   if w ne theta^u * (basis[1]*b^(n[1]-1)) then 
      return false;
   end if;

   x := basis[1] * b * h * (b^(n[1]-1) * z^(-u))^-1;
	
   i := PositionInBasis (basis, x);
   if i cmpeq false then return false; end if;
   m := Log (theta, i[2]);
   if x ne theta^m * basis[1] * b then return false; end if;

   return [m mod r, n[1] - 1, -u mod r];

end function;

/* is <rgrp> normal in <grp>?
   return true if <rgrp> is normal in <grp> and false otherwise.  */

IsNormalRGroup := function (grp, rgrp)

   basis := ComputeRBasis (rgrp);
	
   for g in GeneratorsOfGroup (grp) do
      for h in GeneratorsOfGroup (rgrp) do
         if RMembership (rgrp, basis, h^g) cmpeq false then
	    return false;
	 end if;
      end for;
   end for;

   return true;
end function;

/* compute the image of g under the epimorphism of 
   the given group grp onto a subgroup of SL(2,r).  */

EpimorphicImage := function (rgrp, g)

   basis := ComputeRBasis (rgrp);
   F := GF (Degree (rgrp));

   im := [* *];
   im[1] := RMembership (rgrp, basis, rgrp.1^g);
   im[2] := RMembership (rgrp, basis, rgrp.2^g);
   if im[1] cmpeq false or im[2] cmpeq false then 
      vprint Smash: "element does not normalise r-group";
      return false;
   end if;
   return GL(2, F) ! &cat[[im[j][k]: k in [1..2]]: j in [1..2]];
end function;

/* determine images of generators of grp, which 
   contains extra-special r-group, to SL (2, r) */

EpimorphicImageInSL := function (grp, rgrp)

   li := [];
   for g in GeneratorsOfGroup(grp)do
      epi := EpimorphicImage(rgrp, g);
      if epi cmpeq false then
         return false;
      end if;
      Append (~li, epi);
   end for;
   return li;
end function;
	
IsCentralNorm := function (grp, z)
   for g in GeneratorsOfGroup(grp) do
      if g*z ne z*g then return false; end if;
   end for;
   return true;
end function;

IsElAb := function (grp)
   r := Degree (grp);
   gens := GeneratorsOfGroup (grp);
   for g in gens do
      if ProjectiveOrder(g) ne r and ProjectiveOrder(g) ne 1 then
         return false;
      end if;
      for h in gens do
         if not IsCentralNorm (grp, (g, h)) then return false; end if;
      end for;
   end for;
   return true;
end function;
	
InitConclusions := function()
   recRF := recformat <isNorm, hasEvenEl, EvenEl, Rm1El, hasDCom,   
                    DComEl, hasCom, isElAb, hasREl, hasRp1El, hasRm1El>;
   return rec<recRF | isNorm := "unknown", 
              hasEvenEl := "unknown", 
              DComEl    := false,
              EvenEl    := false,
              Rm1El     := false,
              hasDCom   := "unknown", 
              hasCom    := "unknown", 
              isElAb    := "unknown",
              hasREl    := "unknown", 
              hasRp1El  := "unknown", 
              hasRm1El  := "unknown" >;
end function;
       
StepI := function (grp, concl)
   r := Degree (grp);

   if concl`isNorm cmpeq false then
      vprint Smash: "group is not the normaliser of a symplectic type r-group";
      return false, concl, _;
   end if;

   /* do not need high-quality random elements */
   P := RandomProcess (grp: Scramble := 50);

   tup := [Random (P):  i in [1..4]];
   tupo := [ProjectiveOrder(tup[i]) : i in [1..#tup]];

   // test whether one of the elements has projective order
   // not dividing r^3(r^2-1)
   if [r^3*(r^2-1) mod tupo[i]: i in [1..4]] ne [0,0,0,0] then
      concl`isNorm := false;  // isnormal
      vprint Smash: "group is not the normaliser of a symplectic type r-group";
      return false, concl, P;
   end if;

   if concl`hasEvenEl cmpeq true then
      vprint Smash: "group has even order";
      return (concl`EvenEl, tup[3]), concl, P;
   end if;

   mod2 := [x mod 2: x in tupo];
   t := Position(mod2, 0);
   if t ne 0 then
      // we found an element of even order
      concl`EvenEl := tup[t]^(tupo[t] div 2);
      concl`hasEvenEl := true;       // even case
      vprint Smash: "group has even order";
      return (concl`EvenEl, tup[t mod 4 + 1]), concl, P;
   end if;

   t := [Gcd (i, r+1): i in tupo];
   for i in t do
      if i ne 1 and IsOdd(i) then
         // found an element of odd order dividing r+1
         vprint Smash: "group has elements of order dividing r+1";
         concl`hasRp1El := true;
      end if;
   end for;

   if concl`hasRp1El cmpeq true then
      return (tup[1], tup[2]), concl, P;
   end if;

   t := [Gcd (i, r-1): i in tupo];
   for i in t do
      if i ne 1 and IsOdd(i) then
         // found an element of odd order dividing r-1
         if concl`hasRm1El cmpeq "unknown" then
            vprint Smash: "group has elements of order dividing r-1";
         end if;
         concl`Rm1El    := tup[Position(t,i)];
	 concl`hasRm1El := true;
      end if;
   end for;

   g := ((tup[1], tup[2]), (tup[3], tup[4]));
   if concl`hasDCom cmpeq "unknown" and not IsCentralNorm (grp, g) then
      concl`hasDCom := true;
      concl`DComEl := g;
      vprint Smash: "group has non-central double commutators";
   end if;

   // if we have double commutator element and element of order r-1, 
   // we return double commutator element as non-central element
   if concl`hasDCom cmpeq true and concl`hasRm1El cmpeq true then 
      return concl`DComEl, concl, P;
   end if;

   if concl`hasDCom cmpeq "unknown" and concl`hasRm1El cmpeq true then
      return (tup[3], tup[4]), concl, P;
   end if;

   // G/(RZ(G)) might be cyclic of order r
   g :=  (tup[3], tup[4]);
   if not IsCentralNorm (grp, g) then 
      concl`hasCom := true;
      vprint Smash: "group might be cyclic of order r";
      return g, concl, P;
   end if;

   if concl`isElAb cmpeq "unknown" then 
      if IsElAb (grp) then
         concl`isElAb := true;
      else
         concl`isElAb := false;
      end if;
   end if;

   if concl`isElAb cmpeq false then
      return fail, concl, P;
   end if;
   vprint Smash: "group might be Z.R";

   g := tup[3];
   t := Factors (Order(g));
   for i in t do
      if i ne r then
         g := g^i;
      end if;
   end for;

   // now g is an r-element
   t := Order(g);
   // if the element has order r, return it
   if t eq r then return g, concl, P; end if;
	
   lam := g^r; 
   // this should lie in the centre
   if not IsCentralNorm(grp, lam) then return false, concl, P; end if;
   lam := lam[1][1];
   x := PolynomialRing (BaseRing(grp)) ! [0,1];
   lam := Coefficients (Factors (x^r - lam)[1])[1];
   return ScalarMatrix (r, lam)*g, concl, P;

end function;

StepII := function (grp, a, concl, P)

   r := Degree (grp);

   v := NullspaceMat (a, 1);
   if Dimension (v) ne 1 then
      vprint Smash: "a does not have eigenvector to value 1";
      return false;
   end if;
   v := v.1;

   if concl`hasEvenEl cmpeq true then
      for g in GeneratorsOfGroup(grp) do
         if not v*(a^g) eq v and (a,a^g) ne Identity(grp) and  
            IsCentralNorm (grp, (a,a^g)) then
            return a^g;
         end if;
      end for;    
      return (Random(P), concl`EvenEl);
   end if;

   if concl`hasDCom cmpeq "unknown" and 
      (concl`hasRp1El cmpeq true  or concl`hasRm1El cmpeq true) then 
      for g in GeneratorsOfGroup(grp) do
         if not v*(a^g) eq v and (a, a^g) ne Identity(grp) and  
            IsCentralNorm (grp, (a, a^g)) then
            return a^g;
         end if;
      end for;    
      return false;
   end if;

   if concl`hasDCom cmpeq true then
      if concl`Rm1El cmpeq false then return false; end if;
      f := (Random(P), Random(P));
      if ProjectiveOrder(f) ne r or
         (a,f) eq One(grp) or not IsCentralNorm (grp, (a,f)) then
         return false;
      end if;

      g := concl`Rm1El;

      theta := RootOfUnity (r, BaseRing(grp));
      w := NullspaceMat (a, theta);
      if Dimension (w) ne 1 then 
         "dimension of null space is not 1"; 
         return false; 
      end if;
      w := w.1;
      u := v*(a^g);
      i := Depth (u);
      if i eq 0 or v[1] eq 0*v[1] then return false; end if;
      nu := u[1]/v[1];
      u := w*(a^g);
      lam := Log (theta, u[1]/(w[1]*nu));
      if lam^3 mod r eq 1 then
         return f;
      else
         return f^g * f^(-lam^2);
      end if;
   end if;

   vprint Smash: "group might be Z.R";

   g := Random(P);
   t := Factors (Order(g));
   for i in t do
      if i ne r then g := g^i; end if;
   end for;
   // now g is an r-element
   t := Order(g);
   // if the element has order r, return it
   if t eq r then return g; end if;
	
   lam := g^r; 
   // this should lie in the centre
   if not IsCentralNorm (grp, lam) then return false; end if;
   lam := lam[1][1];
   x := PolynomialRing (BaseRing (grp)) ! [0,1];
   lam := Coefficients (Factors (x^r - lam)[1])[1];
   return ScalarMatrix (r, lam) *g;

end function;

StepIII := function (grp, rgrp)

   if Ngens (rgrp) ne 2 then return false; end if;
   a := rgrp.1;
   b := rgrp.2;
   z := (a, b);

   r := Degree(rgrp);
   if a^r ne Identity(rgrp) or b^r ne Identity(rgrp) or
      (a, b)^r ne Identity(rgrp) or (a,b) eq Identity(rgrp) or
      not IsScalar (z) then
      vprint Smash: "test group is not symplectic type r-group";
      return false;
   end if;
   vprint Smash: "found symplectic type extra-special r-group";

   basis := ComputeRBasis (rgrp);		
   vprint Smash: "computed basis for r-group";

   epi := EpimorphicImageInSL (grp, rgrp);
   if epi cmpeq false then
      vprint Smash: "group does not normalise r-group";
      return false;
   end if;
   return [* basis, epi *];

end function;
	
/* is grp normaliser of extra-special r-group? */
PrimeDegreeExtraspecialNormaliser := function (grp: epsilon := 1/100)

   if not Type(grp) eq GrpMat then
      "Input group must be a matrix group";
      return fail;
   end if;

   RF := recformat <rgrp, basis, image>; 
   F := BaseRing (grp);
   r := Degree (grp);
   N := 50;
   concl := InitConclusions();
   for i in [1 .. N] do
      a, concl, P := StepI (grp, concl);
      if a cmpeq false then return false; end if;
      if a cmpeq fail then continue; end if;
      b := StepII (grp, a, concl, P);
      if b cmpeq false then continue; end if;
      rgrp := sub<GL(r, F) | a, b >;
      if Ngens (rgrp) ne 2 then return false; end if;
      res := StepIII (grp, rgrp);
      if not (res cmpeq false) then 
         vprint Smash: "Extra-special basis found after N = ", i, "tries";
         basis := GL(r, F) ! &cat[Eltseq (x): x in res[1]];
	 return rec <RF | rgrp := rgrp, basis := basis, image := res[2]>;
      end if;
   end for;
   return fail;
end function;

RecogniseNormaliserExtraSpecial := function (G : epsilon := 1/100) 
   r := Degree (G);
   if r eq 2 or not IsPrime (r) then 
      error "Procedure is designed for odd prime degree cases";
   end if;

   result := PrimeDegreeExtraspecialNormaliser (G: epsilon := epsilon);
   if Type (result) eq BoolElt and result eq false then
      SetExtraSpecialFlag (G, false);
      return false;
   elif Type (result) eq Rec then 
      SetExtraSpecialFlag (G, true);
      R := result`rgrp;
      SetExtraSpecialGroup (G, R);
      SetExtraSpecialParameters (G, [Degree (R), 3]);
      SetExtraSpecialNormaliser (G, result`image);
      SetExtraSpecialBasis (G, result`basis^-1);
      return true;
   else
      return result;
   end if;
end function;

