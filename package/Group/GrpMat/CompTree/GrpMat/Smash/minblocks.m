freeze;

IsBlockSystem := function (B)

   if Type (B) ne Rec then return false; end if;
   return assigned B`BlockSystem;

end function;

NumberBlocks := function (B)

   if Type (B) eq RngIntElt then return B; end if;
   if IsBlockSystem (B) then 
      return B`NmrBlocks;
   else
      error "Argument is not a block system";
   end if;

end function;

/* filter vector v through echelonised basis W and update 
   coefficient matrix A  -- EOB: the arguments for the
   corresponding system function are not compatible */

procedure MyFilterVector (vv, ~W, ~A, one, ~result, ~vector)

   local depth, dim, a, c, v; 

/*
 FilterVector (vv, ~W, ~A,  ~result, ~vector);
 return;
*/
   v := vv;
   depth := Depth (v);
   a := 0 * v;
   dim := Degree (v);

   while depth ne 0 and IsDefined (W, depth) do
      c := W[depth][depth]^-1 * v[depth];
      v -:= c * W[depth];
      a -:= c * A[depth];
      depth := Depth (v);
   end while;

   if depth gt 0 and depth le dim then  
      W[depth] := v;
      a[depth] := one;
      A[depth] := a;
      result := true;
      vector := v;
   else
      result := false;
      vector := a;
   end if;

end procedure; 

/* find representative of vector i in BT */

BlockRep := function (i, BT)
   
   local j;

   if i ne 0 then 
      j := BT[i][#(BT[i])];
      if j lt 0 then return $$ (-j, BT); end if;
   end if;

   return i;

end function; 

/* set representative of vector i to be j in BT */

procedure SetRep (i, j, ~BT)

    BT[i][#(BT[i])] := -j;

end procedure; 
   
/* set image of vector i under generator j to  be in BT[k] */

procedure SetImage (i, j, k, ~BT)

    BT[i][j] := k;

end procedure; 

/* given column for generator i, what is column for generator i^-1? */

InverseColumn := function (i, NmrColumns)
   
   local NmrGens;

   NmrGens := NmrColumns div 2;
   return (i le NmrGens) select i + NmrGens else i - NmrGens;

end function; 

/* equate blocks c and d of block table BT and clean up all consequences */

procedure EquateBlocks (c1, d1, ~BT)

   c := c1;
   d := d1;
   if c eq d then return; end if;

   SetRep (d, c, ~BT);
   
   NmrColumns := #(BT[1]);

   for i in [1..NmrColumns - 1] do
      a := BlockRep (BT[d][i], BT);
      if a ne 0 then 
         index := InverseColumn (i, NmrColumns); 
         c := BlockRep (c, BT);
         x := BlockRep (BT[a][index], BT); 
         if x ne 0 then 
            EquateBlocks (c, x, ~BT);
            a := BlockRep (a, BT);
            c := BlockRep (c, BT); 
         end if;
         SetImage (a, index, c, ~BT);
         b := BlockRep (BT[c][i], BT);
         if b eq 0 then 
            SetImage (c, i, a, ~BT);
         elif a ne b then 
            EquateBlocks (a, b, ~BT);
         end if;
      end if;
   end for;

end procedure; 

/* count number of blocks in table BT */

CountBlocks := function (BT)

   local i, NmrColumns, NmrBlocks;

   NmrColumns := #(BT [1]);

   return #[i : i in [1..#BT] | BT[i][NmrColumns] gt 0];

end function; 

/* amalgamate those blocks of BT whose indices are listed in the 
   set S and update Bk */

procedure AmalgamateBlocks (S, ~Bk, ~BT)

   local i;

   for i in [2..#S] do
      EquateBlocks (BlockRep (S[1], BT), BlockRep (S[i], BT), ~BT);
   end for;

   for i in [1..#Bk] do
      Bk[i] := BlockRep (Bk[i], BT);
   end for;

end procedure; 

/* initialise block b of table BT to consist of 0 with last entry b */

procedure InitialiseBlock (b, Width, ~BT)

   local i;

   BT[b] := [0 : i in [1..Width - 1]];
   BT[b][Width] := b;

end procedure; 

/* find image of block i under generator j; here we use sequence 
   BS of subspaces of V generated by the blocks introduced; 
   before we call FilterVector, we check to see if the vector lies 
   in precisely one block; if so, we do not need to run FilterVector */

procedure BlockImage (M, matrices, i, j, ~basis, ~W, ~A, ~Bk, ~BT, ~Map, 
                      ~NextCoset, V, ~BS)

   NmrColumns := #(BT[1]);
   F := BaseRing (M);

   /* Bk[i] is the block containing the ith vector in basis */
   c := Bk[i];

   /* let b the image of block c under generator j  */
   b := BT[c][j];

   v := basis[i];
   w := v * matrices[j];

   /* try to avoid calls to FilterVector by first checking 
      whether w lies in one of the blocks */

   S := [];
   for n in [1..NextCoset - 1] do
     if w in BS[n] then
       flag := false;
       S := [n];
       break;
     end if;
   end for;

   if S eq [] then
      MyFilterVector (w, ~W, ~A, Identity (F), ~flag, ~x);
   end if;

   if flag ne true then 
      /* w lies in the space spanned by basis; set S to be the 
         minimum set of blocks whose direct sum contains w */

      if S eq [] then
        S := SetToSequence (Support (x));
        S := [Bk[Map[S[i]]] : i in [1..#S]];
      end if;

      /* if w lies in just one block and the image of c under j is undefined
         then define the image of c under j to be this block */

      bb := BT[S[1]][InverseColumn (j, NmrColumns)]; 
      if (#S eq 1 and b eq 0 and (bb eq 0 or bb eq c)) then
         SetImage (c, j, S[1], ~BT);
         SetImage (S[1], InverseColumn (j, NmrColumns), c, ~BT);
      else 
         if b ne 0 then
            Include (~S, b);
         end if;
         /* now amalgamate all of the blocks in S into one */
         if #S gt 1  or (bb ne 0 and bb ne c) then 
            /* DFH + EOB bug fix October 2002 */
            if #S gt 1 then AmalgamateBlocks (S, ~Bk, ~BT); end if;
            if bb ne 0 then AmalgamateBlocks ([bb,c], ~Bk, ~BT); end if;

           /* now re-define block-subspaces; note that BS must have 
              universe all subspaces of V; so don't
              redefine using BS := [ ... ] */

            for b in [1..NextCoset - 1] do
              BS[b] := sub<V | V!0 >;
            end for;

            for b in [1..#basis] do
              BS[Bk[b]] := BS[Bk[b]] + sub<V| basis[b] >;
            end for;
            /* DFH + EOB bug fix Feb 1998 */
            BlockImage (M, matrices, i, j, ~basis, ~W, ~A, ~Bk, ~BT, 
                   ~Map, ~NextCoset, V, ~BS);
         end if;
      end if;
   else
      /* w does not lie in the space spanned by basis; 
         add in new basis element; the image of c is undefined */
      if b eq 0 then 
         b := NextCoset;
         NextCoset := NextCoset + 1;
         BS[b] := sub<V | V!0 >;
         InitialiseBlock (b, #(BT[1]), ~BT);
         SetImage (c, j, b, ~BT);
         SetImage (b, InverseColumn (j, NmrColumns), c, ~BT);
      end if;
      /* increment length of basis */
      Len := #basis + 1;
      Map[Depth (x)] := Len;
      basis[Len] := w;
      Bk[Len] := b;
      BS[b] := BS[b] + sub<V|w>;
   end if;

end procedure; 

/* set up the elements of basis in array W where W[i] is a 
   vector of depth i -- there may be some gaps in W */

SetupBasis := function (basis)

   local i, depth, W;

   W := [];

   for i in [1..#basis] do
      depth := Depth (basis[i]);
      if depth eq 0 or IsDefined (W, depth) then
         return false;
      else
         W[depth] := basis[i];
      end if;
   end for;

   return W;

end function; 

/* set up permutation group representing action on blocks; also find 
   the block containing the input basis and the number of blocks */

SetupBlockPermGroup := function (d, F, BT, B, Bk)

   local LastColumn, BlockNumber, i, j, number, renumber, livenumber,
         BlockSystem, NmrBlocks, Block, Perms, PermGroup, row, last;

   LastColumn := #(BT[1]);
   renumber := []; livenumber := [];

   BlockNumber := 0;
   numbers := [];
   for i in [1..#BT] do
      number := BT[i][LastColumn];
      if number gt 0 then 
         BlockNumber := BlockNumber + 1;
	 numbers[i] := number;
         renumber[i] := BlockNumber;
         livenumber[BlockNumber] := i;
      end if;
   end for;

   NmrBlocks := #livenumber;

   /* set up the blocks */
   Blocks := [];
   V := VectorSpace (F, d);
   for j in numbers do 
      Block := [];
      for i in [1..#B] do
	  if Bk[i] eq j then       
	     Append (~Block, B[i]);
	  end if;
      end for;
      Append (~Blocks, sub < V | Block>);
   end for;
   assert &+Blocks eq V;
	    
   /* block containing the given collection of vectors  */
   BlockNumber := Bk[1]; 
   Block := [B[1]];
 
   for i in [2..#B] do
      if Bk[i] eq BlockNumber then 
         Append (~Block, B[i]);
      end if;
   end for;

   /* now write down the permutations  */
   Perms := [];
   last := (LastColumn - 1) div 2;
   for i in [1..last] do  
      Perms[i] := [];
      for j in [1..NmrBlocks] do
         row := livenumber[j];
         Perms[i][j] := renumber[BT[row][i]];
      end for;
      Perms[i] := Perms[i]; 
   end for;

   /* set up the permutation group  */
   // PermGroup := sub < SymmetricGroup (#Perms[1]) | Perms >;
   // vprint Smash: "PermGroup is ", PermGroup;

   /* now set up block system as record  */
   RF := recformat < NmrBlocks : RngIntElt, Block : SeqEnum, 
                     Blocks : SeqEnum, 
                     Perms : SeqEnum, BlockSystem : BoolElt>;

   BlockSystem := rec <RF | NmrBlocks := NmrBlocks, Block := Block, 
            Blocks := Blocks, Perms := Perms, BlockSystem := true>; 

   return BlockSystem;

end function; 

/* set up the permutation group  */

GroupActionOnBlocks := function (BlockSystem)

   if IsBlockSystem (BlockSystem) then 
      Degree := BlockSystem`NmrBlocks;
      Perms := BlockSystem`Perms;
      PermGroup := sub <SymmetricGroup (Degree) | Perms >;
      return PermGroup;
   else
      error "Input argument to GroupActionOnBlocks is not a block system";
   end if;

end function;

/* find smallest block containing the echelonised basis B under 
   the action of module M; 
   return number of blocks; the block containing the supplied basis B
   and the permutation group which describes the action on the blocks;  
   it is assumed that M is irreducible and that B is a basis */

MinBlocks := function (module, B)
   
   /* Bk[i] is the block containing the ith vector in basis

      W is the echelonised basis with vectors arranged according to depth

      A is coefficient matrix 

      BT[i][j] is the image of block i under the action of generator j 
      where the images under inverse of generator i is stored in 
      column i + NmrGens
   
      Map[i] = j says that element j of basis is stored as vector i of W 
               (that is, the depth of j is i)

      V is the underlying vector space.
      BS[i] is the subspace of V spanned by the i-th block */

   M := module;

   /* is M a group? if so, make it into a G-module */
   if Type (M) eq GrpMat then
      M := GModule (M);
   end if;

   F := BaseRing (M); 
   d := Dimension (M);

   V := VectorSpace (F, d);
   basis := [V!b : b in B];

   W := SetupBasis (basis);

   if (Type (W) eq BoolElt) then
      vprint Smash: "Supplied collection of vectors is not an echelonised basis";
      return false;
   end if;

   Map := [];
   for i in [1..#basis] do 
      Map[Depth (B[i])] := i; 
   end for;

   A := [];
   Bk := [];

   /* ensure BS has the universe of all subspaces of V 
      rather than just subspaces of a fixed dimension */
   BS := [sub <V | basis>, sub <V | V!0>];

   for i in [1..#W] do
      if IsDefined (W, i) then 
         A[i] := V.i;
      end if;
   end for;
     
   Bk := [1 : i in [1..#basis]];

   G := Group (M);
   NmrGens := Ngens (G);
   matrices := [G.i : i in [1..NmrGens]];

   /* length of row in block table is the number of generators * 2 + 1 */
   BT := [];
   InitialiseBlock (1, 2 * NmrGens + 1, ~BT);

   bound := d div 2;

   NextCoset := 2;
   for i in [1..d] do
      for j in [1..NmrGens] do
         BlockImage (M, matrices, i, j, ~basis, ~W, ~A, ~Bk, ~BT, 
                     ~Map, ~NextCoset, V, ~BS);
         if exists {B : B in BS | Dimension (B) gt bound} then 
            return 1; 
         end if;
      end for;
   end for;
         
   vprint Smash: "The number of blocks is ",  CountBlocks (BT);

   return SetupBlockPermGroup (d, F, BT, basis, Bk);

end function; 
