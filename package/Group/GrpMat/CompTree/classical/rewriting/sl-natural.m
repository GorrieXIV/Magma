// write A as SLP in standard generators for SL
SLWordInGen := function (G, A) 
   
   d := Degree (G);
   U := SLPGroup (4);
   if d eq 1 then return A, U!1; end if;
   W := SLPGroup (4);
   
   /* the code was originally written for different generating set. 
      This homomorphism maps the result to the new generating set. */
   q := #BaseRing (G);
   if d eq 3 then
      phi := hom<U -> W | W.4, W.3, W.1^-1, W.2>;
      phiNew := hom<W -> W | W.1, W.1^2 * W.2^(-1), W.3, W.4>;
   else 
      phi := hom<U -> W | W.4, W.3, W.1^-1, W.2^-1>;
   end if;
   
   F := BaseRing (G);
   w := PrimitiveElement (F);
   e := Degree (F);
   p := Characteristic (F);
   Z := IntegerRing ();
   M := KMatrixSpace (F, d, d);
   
   /* We wish to find the matrix whose top row is [1 w 0 .. 0], has 1s on the 
      leading diagonal and 0s everywhere else. We construct the subfield FF
      of F generated by w^2. This subfield has order greater than half of the
      order of F and hence is equal to F. By then coercing w into FF,
      magma will write w as a polynomial py in powers of the generator of FF.
      So w is written as a polynomial in w^2. t^(delta^-1) gives us the matrix
      with [1 w^2 0 .. 0] on the top row and t^(delta^-a) gives you the matrix
      with [1 w^2a 0 .. 0] on the top row. Hence, you can use py to find the
      powers of t^(delta^-1) needed to give the matrix with [1 w 0 .. 0] on
      the top row.  */
   
   FF := sub<F | w^2>;
   py := FF!F.1;
   py := Eltseq (py);
   py := [Z!y :y in py];
   
   /* py is now a polynomial in w^2 that is equal to w */
   O := &*[(U.2^U.1^-(i-1))^py[i]: i in [1..e]];

   S1 := U!1;
   S2 := U!1;
   
   /* this procedure is used to add row 1 to row j */
   
   RowOp := procedure (i, j, ~A, ~S, r)
      if r eq 1 then
         S := (U.2^(U.3*((U.4*U.3)^(j-i-1))*(U.4^(i-1))))^Z!Eltseq (A[j][i])[r]*S;
         AddRow (~A, -Eltseq (A[j][i])[r], i, j);
         // only works when i < j - which is the only direction we ever need 
      end if;
   
      if IsEven (r) then
         S := (((O^(U.1^-((r-2) div 2)))^(U.3* ((U.4*U.3)^(j-i-1))*
                (U.4^(i-1)))))^Z!Eltseq (A[j][i])[r] * S;
         AddRow (~A, -Eltseq (A[j][i])[r] * w^(r-1), i, j);
      end if;
   
      if IsOdd (r) then
         S := ((U.2^(U.1^-((r-1) div 2)))^(U.3* ((U.4*U.3)^(j-i-1))*
               (U.4^(i-1))))^Z!Eltseq (A[j][i])[r] * S;
         AddRow (~A, -Eltseq (A[j][i])[r] * w^(r-1), i, j);
      end if;
   end procedure;
   
   ColOp := procedure (i, j, ~A, ~S, r)
      if r eq 1 then
         S *:= (U.2^(((U.4*U.3)^(j-i-1))* (U.4^(i-1))))^-Z!Eltseq (A[i][j])[r];
         AddColumn (~A, -Eltseq (A[i][j])[r], i, j);
      end if;
   
      if IsEven (r) then
         S *:= ((O^(U.1^-((r-2) div 2)))^(((U.4*U.3)^(j-i-1))*
                (U.4^(i-1))))^-Z!Eltseq (A[i][j])[r];
         AddColumn (~A, -Eltseq (A[i][j])[r] * w^(r-1), i, j);
      end if;
   
      if IsOdd (r) then
         S *:= ((U.2^(U.1^-((r-1) div 2)))^(( (U.4*U.3)^(j-i-1))*
                (U.4^(i-1))))^-Z!Eltseq (A[i][j])[r];
         AddColumn (~A, -Eltseq (A[i][j])[r] * w^(r-1), i, j);
      end if;
   end procedure;
   
   /* A*(v^-1) puts the first column to the back, shuffles each column 
      left one and negates all the others; A*((v^-1)^k) where k is even, 
      puts the first k columns to the back and negates them whilst 
      shifting all the others to the left A*((v^-1)^k) where k is odd, 
      puts the first k columns to the back and negates all the OTHER 
      columns whilst shifting these others to the left */
   
   /* this procedure has the effect of conjugating by v^-1 */
   ConjByVInverse := procedure (~A, n)
      B := Transpose (A);
      C := ZeroMatrix (F, d, d);
      for i in [1..d-n] do
         C[i] := IsEven (n) select B[i+n] else -B[i+n];
      end for;
      for i in [1..n] do
         C[d-n+i] := IsEven (n) select -B[i] else B[i];
      end for;
   
      A := Transpose (C);
   
      C := ZeroMatrix (F, d, d);
      for i in [1..d-n] do
         C[i] := IsEven (n) select A[i+n] else -A[i+n];
      end for;
      for i in [1..n] do
         C[d-n+i] := IsEven (n) select -A[i] else A[i];
      end for;
   
      A := C;
   end procedure;
   
   /* A*v brings the last column to the front, shuffles each other row right
        one place whilst negating them
      A*((v^-1)^k) where k is even, brings the last k columns to the front
        and negates them whilst shifting all the others to the right
      A*((v^-1)^k) where k is odd, brings the last k columns to the front and
        negates all the OTHER columns whilst shifting these others to the right
      v^-1 * A brings the bottom row to the top, shuffles each other row down
        one place whilst negating them */
   
   ConjByV := procedure (~A, n)
   
      B := Transpose (A);
      C := ZeroMatrix (F, d, d);
      for i in [1..n] do
         C[i] := IsEven (n) select -B[d-n+i] else B[d-n+i];
      end for;
      for i in [1..d-n] do
         C[n+i] := IsEven (n) select B[i] else -B[i];
      end for;
   
      A := Transpose (C);
   
      C := ZeroMatrix (F, d, d);
      for i in [1..n] do
         C[i] := IsEven (n) select -A[d-n+i] else A[d-n+i];
      end for;
      for i in [1..d-n] do
         C[n+i] := IsEven (n) select A[i] else -A[i];
      end for;
   
      A := C;
   end procedure;
   
   A := M!A;
   
   for k in [0..d-2] do
   
      /* A := A^((v^-1)^k);
        moves the first, second, ..., kth column and row out of the way. */
      ConjByVInverse (~A, k);
      
      S1 := U.4^k * S1;
      S2 *:= (U.4^-1)^k;
      
      /* we now get a 1 in the top left hand corner of the matrix A */
      if A[1, 1] eq 0 then
         i := Depth (A[1]);
         /* A := A * (u*v^-1)^(i-2)* (u*v)^(i-2)*u; */
      
         /* swaps column 1 with column i whilst negating every column 
            between 1 and i exclusive. In the special case i = 2, the 
            negation is only applied to column 1. This will never move 
            any columns that have already been done because they will 
            always contain an 0 in the first row at this stage.  */
      
         A := SwapColumns (A, 1, i);
         if i ne 2 then
            for j in [2..i-1] do
               MultiplyColumn (~A, -1, j);
            end for;
         else
            MultiplyColumn (~A, -1, 2);
         end if;
         if IsEven (i) and i ne 2 then
            MultiplyColumn (~A, -1, i);
         end if;
         S2 *:= (U.3 * U.4^-1)^(i-2) * (U.3 * U.4)^(i-2) * U.3;
      end if;
         
      if A[1, 1] ne 1 then
         i := 2;
         if {A[i, 1] eq 0 : i in [2..d]} eq {true} then
            // A := A* (t^u); 
            /* this subtracts column 2 from column 1 and is necessary 
               if the column has zeroes in every position as otherwise 
               we will not be able to subsequently add a multiple of one row 
               to the top row in order to get a 1 in the [1, 1] position.  */
            AddColumn (~A, -1, 2, 1);
            S2 *:= U.2^U.3;
         end if;
         while A[i, 1] eq 0 do i +:= 1; end while; 

         /* we now subtract a suitable multiple (B) of the i-th row 
            to the first to get a 1 in the [1, 1] entry */
         B := (A[1, 1]-1) / A[i, 1];
         b := Eltseq (B);
         b := [Z!x: x in b];

         T := U.2^-1;
         T := (T^((U.4 * U.3)^(i-2)))^b[1];
         for r in [2..e] do
            if IsEven (r) then
               T *:= (((O^-1)^(U.1^-((r-2) div 2)))^(((U.4 * U.3)^(i-2))))^b[r];
            else
               T *:= (((U.2^-1)^(U.1^-((r-1) div 2)))^(((U.4 * U.3)^(i-2))))^b[r];
            end if;
         end for;
         AddRow (~A, -B, i, 1);
         S1 := T * S1;
      end if;
         
      for j in [2..d-k] do
         for r in [1.. e] do
            RowOp (1, j, ~A, ~S1, r);
         end for;
      end for;
      
      for j in [2..d-k] do
         for r in [1.. e] do
            ColOp (1, j, ~A, ~S2, r);
         end for;
      end for;
      
      /* A := A^(v^k); 
         moves the rows and columns back to their original position */
      ConjByV (~A, k);
      
      S1 := (U.4^-1)^k * S1;
      S2 *:= U.4^k;
      
   end for;
      
   word := S1^-1 * S2^-1;
   word := phi (word);
   
   if d eq 3 then
      return IsIdentity (A), phiNew (word);
   else
      return IsIdentity (A), word;
   end if;
end function;
   
/* Having completed the above, the A[d, d] entry should now be 1 too since 
   the matrix will now have 1s along the main diagonal, zeroes everywhere else
   and the matrix must have determinant 1.  */
