freeze;

import "selection.m": EntriesOfRootElement;
import "bbclassical.m": B, Evaluate2, BBType, BBField, BBStandardGenerators, 
  BBDimension, BBInverseGenerators;
import "elements.m": ConjugateClassicalStandardToMyBasis, 
  ConjugateClassicalStandardToElliot, U_, RootElements;

// The matrix of the standard orthogonal form of degree n and sign t over F -- 
// was an intrinsic 
MyOrthogonalForm := function ( t, n, F) 
  return IsOdd(Characteristic(F)) select
     SymmetricBilinearForm(t,n,F) else QuadraticForm(t,n,F);
end function;

/* 
   The following function recovers the smaller matrix from an element of 
   g of G that preserves <e1>+<e2,...> in the SL case and <e1>+<f1>+<e2,...>
   in the other cases.
  
   A scalar multiple of the matrix is recovered with the scalar being
   g[e1,e1]^-1.
*/


SmallerMatrix := function( G, g : Method := Method )

    F := BBField( G );
    dim := BBDimension( G );
    type := BBType( G );
        
    if ( dim eq 2 ) or <type,dim> eq <"SU",3> or 
       <type,dim,Method> eq <"SU",4,"BB">  then
        return Zero( MatrixAlgebra( F, 0 ));
    end if;
    
    /* 
      get the elements T_{f1,b} where b is an element of the basis
      In the case of SU this returns T_{f1,alpha f_i} where
      alpha = gamma^{(q+1)/2} (gamma is primitive root). 
      This will be rectified later.
    */
        
    roots := RootElements( G );

    mat := [];
    for r in roots do 
        vec := EntriesOfRootElement( G, r^g : Method := Method, 
                       GetWE1Entry := BBType( G ) eq "SU" and 
                       IsOdd( BBDimension( G ) ));
        Append( ~mat, vec );
    end for;

    mat := MatrixAlgebra( F, #mat )!mat;
                   
    /*
      now we fix the problem of having T_{f1,alpha f_i} instead of 
      T_{f1,f_i} in SU in odd char
    */             
                   
    if BBType( G ) eq "SU" and IsOdd( #F ) then
        
        F := BBField( G );
        dim := #roots;
        q := Round( Sqrt( #F ));
        for i in [ Ceiling( (dim+1)/2 )..dim - dim mod 2] do
            mat[i] := mat[i]*PrimitiveElement( F )^-Round((q+1)/2);
        end for;
    end if;
        
    return mat;
    
end function;

 /* 
   The following returns the generators of the SmallerSubgroup
   as words in the ClassicalStandardGenerators.
 */
    
GeneratorsOfSmallerSubgroup := function( type, dim, q )
     
     if type eq "SL" then 
        return [ B.1^B.2^-1, B.1^-1*B.2, B.3^B.2^-1, B.4^B.2^-1 ];
    elif type eq "Sp" then
        return [B.1^B.2,B.2*B.5,B.3^B.2,B.4^B.2,B.5^B.2,B.6 ];
    elif <type,dim,IsEven(q)> eq <"SU",4,true> then
        return [B.1^B.2^-1, One( B ), B.3^B.2^-1, B.4^B.2^-1,One( B ), 
                One( B ), One( B )];
    elif type eq "SU" and IsEven( dim ) then
        return [B.1^B.2,B.2*B.5,B.3^B.2,B.4^B.2,
                B.5^B.2,B.6,B.7];
    elif <type,dim,q> eq <"SU",5,4> then
        return [B.1^B.2,B.2*B.5,B.3^B.2,B.6^(B.7^B.2),
                One(B),B.6,B.7];
    elif type eq "SU" and IsOdd( dim ) then
        return [B.1^B.2,B.2*B.5,B.3^B.2,B.4^B.2,
                B.5^B.2,B.6,B.7];
    elif type eq "Omega+" then
        return [ B.1^B.8, B.2^B.8, B.3^B.8, B.4^B.8, B.5^B.8, B.6^B.8, 
                 One( B ), B.8*B.4^-1 ];
    elif type eq "Omega-" then 
        return [ B.1, B.2, B.3, B.4^B.5, B.5*B.4^-1 ]; 
    elif type eq "Omega" then
        return [ B.1, B.2, B.3, B.4*B.5^-1, B.5^B.4 ]; 
    end if;
end function;
    
/* 
  The orthogonal form preserved by the group generated by 
  ClassicalStandardGenerators is not always the same as the form whose
  Gram matrix is the output of OrthogonalForm. The following function
  returns the right Gram matrix.
*/
    
GramMatrixOfForm := function( type, dim, q )
    
    if type eq "SL" then 
        
        return Zero( MatrixAlgebra( GF( q ), dim ));
       
    elif type eq "Sp" then
        
        return StandardAlternatingForm( dim, q );
        
    elif type eq "SU" and IsEven( dim ) then
        
        return StandardHermitianForm( dim, Round( Sqrt( q )));
        
    elif type eq "SU" and IsOdd( dim ) then
        
        list :=  [1..dim div 2] cat [dim div 2 +2..dim] cat [ dim div 2 + 1 ];
        perm := PermutationMatrix( GF( q ), Sym( dim )!list );

        return perm*StandardHermitianForm( dim, Round( Sqrt( q )))*perm^-1;
    
    elif type eq "Omega+" then
        
        return case< IsEven( q ) | true: QuadraticForm( 1, dim, GF( q )),
               default : MyOrthogonalForm( 1, dim, GF( q ))>;
                
    elif type eq "Omega-" then
        
        stgens := ClassicalStandardGenerators( "Omega-", dim, q );
        stgroup := sub< GL( dim, q ) | stgens >;
        
        if IsEven( q ) then
            _, form := QuadraticForm( stgroup );
        else
            _, _, form := OrthogonalForm( stgroup );
        end if;
        
        conj := ConjugateClassicalStandardToMyBasis( "Omega-", dim, q );
        
        return conj^-1*form*conj;
        
    elif type eq "Omega" then
        
        el := Integers()!((q-1)/2 );
        formmat := Zero( MatrixAlgebra( GF( q ), dim ));
        formmat[dim,dim] := el;
        for i in [1..dim-1] do
            formmat[i,dim-i] := 1;
        end for;    
        
        return formmat;
    end if;
end function;

// ClassicalStandardForm returns the form preserved
// by ClassicalStandardGenerators.

ClassicalStandardForm := function( type, dim, q )

  conj := ConjugateClassicalStandardToMyBasis( type, dim, q );
  return conj*GramMatrixOfForm( type, dim, q )*conj^-1;

end function;
    
/* 
  The function SmallerMatrix returns a matrix of dimension dim-1 in SL 
  or dim-2 in the other cases that preserves the form induced on the 
  dim-1 or dim-2 dimensional space modulo scalar. This scalar is determined
  in the next function. It is necessary to determine this before
  this matrix can be fed into XXXWordInGen.
  
  We essentially calculate the value of the form on the 1st row of mat.
*/
  
    
ScalarOfForm := function( type, dim, q, mat )
  
    // no form is preserved by SL and so we return 1
    
    if type eq "SL" then
        return 1;
    end if;
    
    form := GramMatrixOfForm( type, dim-2, q );
    V := VectorSpace( GF( q ), dim-2 );
    
    q0 := case< type | "SU": Round( Sqrt( q )), default: q >;
  
    
    // find a vector v with form(v) ne 0
      repeat
        
        // choose two vectors; if Orthogonal in char 2 then v1 = v2
          
        v1 := Random( V ); 
        v2 := case< < type, IsEven( q )> | 
              <"Omega+",true>: v1, 
              <"Omega-",true>: v1,
              <"Omega",true>:  v1,
              default:  Random( V )>;
          
          // compute transpose v2. if SU then also apply Frobenius
          
          v2t := case< type | 
                 "SU": ColumnMatrix( [ x^q0 : x in Eltseq( v2 )]),
                 default:  ColumnMatrix( Eltseq( v2 )) >;
          
          sc1 := v1*form*v2t; 
          sc1 := sc1[1];
    until sc1 ne 0;
    
    v11 := v1*mat; v21 := v2*mat;
    v21t := case< type | 
            "SU": ColumnMatrix( [ x^q0 : x in Eltseq( v21 )]),
            default:  ColumnMatrix( Eltseq( v21 )) >;
        
    sc2 := v11*form*v21t; 
    sc2 := sc2[1];
    
    sc := sc2/sc1;
    
    if type eq "SU" then
        sc := Root( sc^-1, q0+1 );
    else
        if not IsSquare( sc ) then 
            return false;
        end if;
        
        sc := Sqrt( sc^-1 );
    end if;

    return sc;
 end function;
       
/* 
  The determinant of the output of SmallerMatrix will generally be different
  from 1. This is taken care of in the next function.
  */
     
MakeDeterminantOne := function( G, mat )
    
    // there is nothing to do in Omega+
      
    type := BBType( G );
    
    if type eq "Omega+" then
        return mat, One( B );
    elif type eq "Omega" and Determinant( mat ) ne 1 then
        return -1*mat, One( B );
    end if;
    
    F := BBField( G );
    dim := BBDimension( G );
    gamma := PrimitiveElement( F );
    q := case< type | "SU": Round( Sqrt( #F )), default: #F >;
                 
    /* 
      to make det( mat ) = 1, we multiply the element g that gave rise
      to mat with a power of gens[4].
      The exponent of this power is calculated now.           
     */             
                 
    det := Determinant( mat );
    base := case< type | "SU": gamma^-(q-1), default: gamma >;
    exp := Log( base, det );

    // we modify mat
    
    if type eq "SL" then
        
        mat[1] := mat[1]*det^-1;
        
    elif type eq "SU" and IsEven( dim ) then
        
        mat[1] := mat[1]*gamma^-exp;
        mat[dim-2] := mat[dim-2]*gamma^(q*exp);
        
    elif type eq "SU" and IsOdd( dim ) then

        mat[dim-2] := mat[dim-2]*gamma^((q-1)*exp);
        
    end if;
    
    return mat, B.4^exp;
    
end function;
    
/* 
  In orthogonal groups we also have to make sure that Spinor
  norm of SmallerMatrix is 0 before using the recursive step.
*/
      
MakeSpinorNormZero := function( G, mat )
    
    type := BBType( G );
    
    if not type in { "Omega", "Omega+", "Omega-" } then 
        return mat, One( B );
    end if;
    
    // first construct the Gram matrix of the form
      
    F := BBField( G ); dim := BBDimension( G );  
    q := #F;  
    
    sign := case< type | "Omega-": -1, default: 1 >;
    formmat := GramMatrixOfForm( type, dim-2, q );
    
    sp := SpinorNorm( GL( dim-2, F )!mat, formmat );
    
    if sp eq 0 then return mat, One( B ); end if;
    
    // if the Spinor norm is not zero then we change mat
      
    if type eq "Omega+" then
        
        mat[1] := mat[1]*PrimitiveElement( F );
        mat[dim-2] := mat[dim-2]*PrimitiveElement( F )^-1;
        return mat, B.4;
        
    elif type eq "Omega-" then
        
        D := ClassicalStandardGenerators( "Omega-", dim, #F )[3];
        i1 := dim-3 ; i2 := dim-2;             
        changemat := One( MatrixAlgebra( F, dim-2 ));
        changemat[i1,i1] := D[dim-1,dim-1];
        changemat[i1,i2] := D[dim-1,dim];
        changemat[i2,i1] := D[dim,dim-1];
        changemat[i2,i2] := D[dim,dim];
        mat := changemat*mat;
        
        return mat, B.11^B.2;
        
    elif type eq "Omega" then
        
        gamma := PrimitiveElement( GF( q ));
        mat[1] := gamma*mat[1];
        mat[dim-3] := gamma^-1*mat[dim-3];
        _, prog := U_( dim, q );
        return mat, prog;
        
    end if;
        
end function;
    
/* 
  We write SmallerMatrix as an SLP of the generators of G.
*/
  
SmallerMatrixToSLP := function( G, g, mat )    
    
    dim := BBDimension( G );
    type := BBType( G );
    
    if Dimension( Parent( mat )) le 1 or <type,dim> eq <"Omega-",4> then
        return One( B ), One( B ), One( G );
    end if;
    
    gens := BBStandardGenerators( G );
    D := gens[4];

    F := BBField( G ); q := #F;
      
    /* 
      the matrix mat only preserves the form modulo scalars. This
      is rectified next.
    */
      
    sc := ScalarOfForm( type, dim, q, mat );
    if Category( sc ) eq BoolElt then return false, false, false; end if;
    mat := sc*mat;

    /* 
      mat usually does not have det 1. This
      is rectified next.
    */
    
    mat, prd := MakeDeterminantOne( G, mat );
    
    // in the orthogonal cases, the spinor norm needs to be zero
      
    mat, prs := MakeSpinorNormZero( G, mat );
    
    if type eq "Omega+" and dim eq 4 then
        return B.4^Log( PrimitiveElement( GF( q )), mat[1,1] ), 
               prd*prs, Evaluate( prd*prs, BBStandardGenerators( G ));
    end if;
    
    dim1 := case< type | "SL": dim-1, default: dim-2 >;
    q0 := case< type | "SU": Round( Sqrt( q )), default: q >;
    mat := GL( dim1, q )!mat;
    stgens := ClassicalStandardGenerators( type, dim1, q0 );
    
    /* we conjugate mat expressed in terms of my basis to 
       ClassicalStandardGenerators */
      
    conj := ConjugateClassicalStandardToMyBasis( type, dim1, q )^-1;
    
    mat := mat^conj;
    stgroup := sub< GL( dim1, q ) | stgens >;

    flag, pr5 := ClassicalRewriteNatural( stgroup, type, mat^0, mat );
    assert flag;
    pr5 := Evaluate2( pr5, GeneratorsOfSmallerSubgroup( type, dim, q ));
    pr5 := Evaluate2( pr5, BBInverseGenerators( G ));
    
    return pr5, prd*prs, Evaluate( prd*prs, BBStandardGenerators( G ));
end function;
