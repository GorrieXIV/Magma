freeze;

import "misc.m": ExponentElement, PandPPrimePart, IsQ8;
import "fgrp.m": PowerProductFElt, FDot, CommFElt, PurifyFSub,
    CentraliserFGrp, FSubToGrp, IsAbelianFSub, ConjFElt, MultFElt,
    PowerFElt, CentreFSub, ExponentElementFSub;

/*
 * Find a non-central abelian f-subgroup of a non-abelian
 * nilpotent f-group.
 */
function NoncentralAbelianFGrp(F)
    vprint Finn: "NoncentralAbelian";
    
    is_central := func<x | forall{j : j in [1..F`ngens]|
                           x`elt * F`gens[j] eq F`gens[j] * x`elt}
                        >;
    vprintf Finn: "\t finding non-central generator... ";
    found := false;
    k := -1;
    for i in [1..F`ngens] do
        for j in [i+1..F`ngens] do
            if F`gens[i] * F`gens[j] ne F`gens[j] * F`gens[i] then
                found := true;
                k := <i,j>;
                break;
            end if;
        end for;
        if found then break; end if;
    end for;
    vprint Finn: "done";
    
    vprintf Finn: "\t is the non-trivial commutator non-central? ";
    c := CommFElt(FDot(F,k[1]),FDot(F,k[2]));
    if not is_central(c) then
        vprint Finn: "yes";
        a := c;
    else
        vprint Finn: "no";
        a := FDot(F,k[1]);
    end if;
    
    // at this point, `a' is non-central

   /* 
    * We build a normal generator and its (central) commutators at
    * the same time.
    */
    vprintf Finn: "\t looping: ";
    repeat
        vprintf Finn: "*";
        done := true;
        z := [];
        for j in [1..F`ngens] do
            b := CommFElt(a, FDot(F,j));
            if not is_central(b) then
                a := b;
                done := false;
                break;
            elif b`elt ne F`id then
                Append(~z, b);
            end if;
        end for;
    until done;
    vprintf Finn: "\n";
    return PurifyFSub(z cat [a]);
end function;

/*
 * CanEnlargeCyclicFSub
 *
 * INPUT:  finite nilpotent f-group F, an f-element `a' such that
 *         <a`elt> is normal in F
 * OUTPUT: `true' and an abelian normal super-f-subgroup of [a] or
 *         `false' if [a] is maximal abelian
 *
 * This function performs most of the centraliser-related computations
 * of `NoncyclicAbelian' in the paper.
 */
function CanEnlargeCyclicFSub(F, a)
    vprint Finn: "CanEnlargeCyclicFSub";

    C := CentraliserFGrp(F,a);
    grp_A := FSubToGrp([a]);
    
    if exists(c){c : c in C | c`elt notin grp_A} then
        vprint Finn: "\t A < C_G(A)";
        if IsAbelianFSub(C) then
            vprint Finn: "\t C_G(A) is abelian";
            return true, C;
        else
            vprint Finn: "\t C_G(A) is non-abelian";
            vprintf Finn: "\t looping: *";
            repeat
                comm := func<i | CommFElt(c, FDot(F,i))>;
                if exists(w){w : i in [1..F`ngens] | w`elt notin grp_A
                                 where w is comm(i)} then
                    c := w;
                    vprintf Finn: "*";
                else
                    vprintf Finn: "\n";
                    return true, [a, c];
                end if;
            until false;
        end if;
    else
        vprint Finn: "\t A = C_G(A)";
        return false, _;
    end if;
end function;

/*
 * CyclicDerivedSubgroupFGrp
 *
 * Let 1 != [G,G] <= <a> <= G. Return e such that <a^e> = [G,G]
 */
function CyclicDerivedSubgroupFGrp(F, a, order_a)
    vprint Finn: "CyclicDerivedSubgroupFGrp";
    vprint Finn: "\t order =", order_a;

    vprintf Finn: "\t creating list of group elements... ";
   /*
    * list_A := [ ((a`elt)^i) : i in [0..order_a-1] ];
    */
    elt := (a`elt)^0;
    list_A := [ elt ];
    for i in [1..order_a-1]  do
        elt *:= a`elt;
        Append(~list_A, elt);
    end for;
    vprint Finn: "done";
    
    dlog := func<x | Index(list_A,(x`elt)) - 1>;
    
    // a^(g_i) = a^(f[i])
    f := {dlog(ConjFElt(a, FDot(F,i))) : i in [1..F`ngens]};

    // (g_j,g_k) = a^h[j,k] (j < k)
    h := {dlog(MultFElt(MultFElt(FDot(F,-j),FDot(F,-k)),
                         MultFElt(FDot(F,j), FDot(F,k)))) 
           : k in [j+1..F`ngens], j in [1..F`ngens] };

    // [G,G] is generated by all a^(f[i]*h[j,k])
    return Gcd({x * y : x in f, y in h });
end function;

// Compute all the Sylow p-subgroups of a finite nilpotent f-sub.
// returns pairs <p, F_p>
function AllSylowSubgroupsFSub(gens)
    gens_orders := [Order(g`elt) : g in gens];
    
    S := &join{ Set(PrimeDivisors(o)) : o in gens_orders };
    
    res := [];
    while not IsEmpty(S) do
        p := Rep(S);
        Exclude(~S,p);
        
        syl  := [];
        hall := [];
        hall_orders := [];

        for i in [1..#gens] do
            pa, q := PandPPrimePart(gens_orders[i],p);
            Append(~syl,  PowerFElt(gens[i],q));
            Append(~hall, PowerFElt(gens[i],pa));
            Append(~hall_orders, gens_orders[i] div pa);
        end for;
        gens := hall;
        gens_orders := hall_orders;
        Append(~res, <p, PurifyFSub(syl)>);
    end while;
    return res;
end function;

/*
 * HasNoncyclicAbelian
 *
 * INPUT
 * an non-abelian finite nilpotent f-group F
 *
 * OUTPUT
 * true, a non-cyclic abelian normal subgroup, the 
 * false and a generator of a cyclic maximal subgroup;
 * the centraliser of the derived subgroup for ANC groups,
 * unless F_2 = Q_8
 * If DecideOnly = true, then all but the first return value
 * can be missing.
 *
 * TODO: simplify return values in the second case
 */
 
function HasNoncyclicAbelian(F : DecideOnly := false)
    vprint Finn: "HasNoncyclicAbelian";
    A := NoncentralAbelianFGrp(F);
    repeat
        grp_A := FSubToGrp(A);
        if not IsCyclic(grp_A) then break; end if;
        
        vprint Finn: "\t found cyclic abelian normal subgroup";

        a := ExponentElementFSub(A);
        r, A := CanEnlargeCyclicFSub(F,a);
        if r then continue; end if;

       /*
        * A = <a> is cyclic and maximal among abelian normal subgroups.
        * Now perform the second half of `NoncyclicAbelian' in the paper.
        */
        order_a := Order(a`elt);
        e := CyclicDerivedSubgroupFGrp(F,a,order_a);
        
       /*
        * H = C_G([G,G])
        */
        H := CentraliserFGrp(F,PowerFElt(a,e));
        syl := AllSylowSubgroupsFSub(H);
        
       /*
        * If G is a non-abelian ANC group, then H will be cyclic of
        * index 2, unless G2 = Q8. 
        */
        H2_is_Q8 := false;
        
       /*
        * `nice_syl' is either `false' or <q, Hq, grp_Hq> where
        * `grp_Hq' is non-abelian and not isomorphic to Q8
        */
        nice_syl := false;

        for S in syl do
            q, Hq := Explode(S);
            grp_Hq := FSubToGrp(Hq);
            
            if IsAbelian(grp_Hq) then
                if not IsCyclic(grp_Hq) then
                    vprintf Finn:
                        "\t H%o is abelian non-cyclic\n", q;
                    return true, Hq, _, _;
                else
                    vprintf Finn:
                        "\t H%o is cyclic\n", q;
                end if;
            elif (nice_syl cmpeq false) and ((q ne 2)
                    or (not IsQ8(grp_Hq))) then
               /*
                * We only use the randomised search if everything else
                * fails.
                */
                nice_syl := <q,Hq,grp_Hq>;
            else
                H2_is_Q8 := true;
            end if;
        end for;
        
       /*
        * We now use the randomised search, knowing that it will
        * terminate.
        */
        if nice_syl cmpne false then
            if DecideOnly then return true, _, _, _; end if;

            q, Hq, grp_Hq := Explode(nice_syl);
            
           /*
            * Compute Z(Hq)
            */
            Z, idx := CentreFSub(Hq);
            grp_Z := sub<grp_Hq | [z`elt : z in Z]>;
            
            vprintf Finn: "\t Z(H%o) is ", q;
            if not IsCyclic(grp_Z) then
                vprint Finn: "non-cyclic";
                return true, Z, _, _;
            end if;
            vprint Finn: "cyclic";

            z := ExponentElementFSub(Z);
            vprintf Finn: "\t Entering randomised search:\n\t\t ";
            repeat
                vprintf Finn: "@";
               /*
                * We could generate `pseudo-uniform' elements by
                * computing the primary decomposition of the (abelian!)
                * group Hq/Z(Hq). We just use the known generators and the
                * known order... this works well in practice.
                */
                h := PowerProductFElt(Hq, [Random(idx-1):i in [1..#Hq]]);
                A := [z,h];
                grp_A := sub<grp_Hq | h`elt, z`elt>;
            until not IsCyclic(grp_A);
            vprintf Finn: "\n";
            return true, A, _, _;
        else
            vprint Finn: "\t G is an ANC group";
        end if;
        return false, a, H, H2_is_Q8; 
    until false;
return true, A, _, _;
end function;
