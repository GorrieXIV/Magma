
/* construct tensor product of  matrix group G with P */

WreathExample := function (G, P: Rational := true)

Z := Integers ();
B := BaseRing (G);
n := Degree (P);
M := sub<GL(n, B) | [PermutationMatrix (Z, P.i): i in [1..Ngens (P)]]>;
d := Degree (G);
K := KroneckerProductOfLists ([M.i: i in [1..Ngens (M)]],
[G.i: i in [1..Ngens (G)]]);
K := sub < GL(#Rows (K[1]), B) | K>;

P := GL(Degree (K), Z);
S := SLPGroup (4);
X := RandomProcess (S);
w := Random (X);
x := Evaluate (w, [P.i: i in [1..4]]);
x := GL(Degree (K), B) ! x;
K := sub < Generic (K) | [K.i^x: i in [1..Ngens (K)]]>;
if Rational eq false then return K; end if;

Q := Rationals ();
PP := BaseRing (G);
M := MatrixRing (PP, d * n);
x := Identity (M);
x[1][d * n] :=PP.1/2; 
// x[1][d * n] := 1/2;
M := GL (d * n, PP);
x := M!x;
K := sub < GL(d * n, PP) | [K.i: i in [1..Ngens (K)]]>;
K := sub < GL(d * n, PP) | [x^-1 * K.i * x: i in [1..Ngens (K)]]>;
return K;
end function;

/* construct tensor product of primitive group (n, m)
   with group */

ReflectionExample := function (G, n, m: Rational := true)

Z := Integers ();
B := BaseRing (G);
P := PrimitiveGroup (n, m);
M := sub<GL(n, B) | [PermutationMatrix (Z, P.i): i in [1..Ngens (P)]]>;
d := Degree (G);
K := KroneckerProductOfLists ([M.i: i in [1..Ngens (M)]],
[G.i: i in [1..Ngens (G)]]);
K := sub < GL(#Rows (K[1]), B) | K>;

P := GL(Degree (K), Z);
S := SLPGroup (4);
X := RandomProcess (S);
w := Random (X);
x := Evaluate (w, [P.i: i in [1..4]]);
x := GL(Degree (K), B) ! x;
K := sub < Generic (K) | [K.i^x: i in [1..Ngens (K)]]>;
if Rational eq false then return K; end if;

Q := Rationals ();
PP := BaseRing (G);
M := MatrixRing (PP, d * n);
x := Identity (M);
x[1][d * n] := 1/2;
x[1][d * n - 1] :=PP.1/2; 
M := GL (d * n, PP);
x := M!x;
K := sub < GL(d * n, PP) | [K.i: i in [1..Ngens (K)]]>;
K := sub < GL(d * n, PP) | [x^-1 * K.i * x: i in [1..Ngens (K)]]>;
return K;
end function;

/* construct tensor product of primitive group (n, m)
   with RationalMatrix group (d, e);
   return random conjugate as subgroup of GL(d * n, Q) */

PrimitiveExample := function (d, e, n, m: Rational := true)

Z := Integers ();
P := PrimitiveGroup (n, m);
M := sub<GL(n, Z) | [PermutationMatrix (Z, P.i): i in [1..Ngens (P)]]>;
DB := RationalMatrixGroupDatabase();
G := Group(DB, d, e);
K := KroneckerProductOfLists ([M.i: i in [1..Ngens (M)]],
[G.i: i in [1..Ngens (G)]]);
K := sub < GL(#Rows (K[1]), Z) | K>;

P := GL(Degree (K), Z);
S := SLPGroup (4);
X := RandomProcess (S);
w := Random (X);
x := Evaluate (w, [P.i: i in [1..4]]);
K := sub < Generic (K) | [K.i^x: i in [1..Ngens (K)]]>;
if Rational eq false then return K; end if;

Q := Rationals ();
M := MatrixRing (Q, d * n);
x := Identity (M);
x[1][d * n] := 1/2;
M := GL (d * n, Q);
x := M!x;
K := sub < GL(d * n, Q) | [K.i: i in [1..Ngens (K)]]>;
K := sub < GL(d * n, Q) | [x^-1 * K.i * x: i in [1..Ngens (K)]]>;
return K;
end function;

MaximalRational := function (n)
   F := Rationals ();
   H := sub < GL (n, F) | ScalarMatrix (F, n, -1)>;
   G := WreathExample (H, Sym (n));
   return G;
end function;

CyclotomicExample := function (c, d, n)
   F := CyclotomicField (c);                  
   S := ScalarMatrix (F, d, F.1);
   H:=sub<GL(d, F) | S >;
   G := WreathExample (H, Sym (n));
   return G;
end function;

/* subgroup of GL(p^a, F) generated by MonomialSylow (F, p^a) 
   and diagonal matrix with entries from F */
VirtualG1 := function (F, p, a: Limit := 100)
   repeat 
   s := [F.1*Random ([1..Limit]): i in [1..p^a]];
   // s := ScalarMatrix (F, p^a, F.1);
   s := DiagonalMatrix (s);
   until Determinant (s) ne 0;
   S := MonomialSylow (F, p, a);
   G := sub<GL (p^a, F) | s, S>;
   return G;
end function;

/* wreath product of PrimitiveGroup (d, e) with VirtualG1 (F, p, a) */

VirtualG2 := function (d, e, F, p, a)
   DB := RationalMatrixGroupDatabase();
   H := Group(DB, d, e);
   H := sub < GL(d, F ) | [Eltseq (H.i): i in [1..Ngens (H)]]>;
   G1 := VirtualG1 (F, p, a);
   K := KroneckerProductOfLists ([H.i: i in [1..Ngens (H)]],
                                 [G1.i: i in [1..Ngens (G1)]]);
   G := sub < GL(#Rows (K[1]), F) | K>;
   return G;
end function;

// wreath product of matrix group G with Sylow (SL(n, p)) embedded in GL(n, F)

VirtualG3 := function (G, F, n, p)
   H := SL(n, p);
   H := ClassicalSylow (H, p);
   Z := Integers ();
   H := sub < GL(n, Z ) | [Eltseq (H.i): i in [1..Ngens (H)]]>;
   K := KroneckerProductOfLists ([G.i: i in [1..Ngens (G)]],
                                 [H.i: i in [1..Ngens (H)]]);
//   H := sub < GL(n, F ) | [Eltseq (H.i): i in [1..Ngens (H)]]>;
   G := sub < GL(#Rows (K[1]), F) | K>;
   return G;
end function;

/* 
for n in [3..20] do
   G := MaximalRational (n);
"Degree ", Degree (G);
   time f := IsFiniteMatrixGroup (G);
   time g := IsFinite (G);
   "=============================";
end for;
*/


/* 
for d in [4..10] do 
H := ShephardTodd (d);
for n in [4..12 by 1] do 
for k in PrimeBasis (n) do 
S := SylowSubgroup (Sym (n), k);
G := WreathExample (H, S);
"Degree ", Degree (G);
   time f := IsFiniteMatrixGroup (G);
   time g := IsFinite (G);
   "=============================";
end for;
end for;
end for;
*/

/* 
S := Subgroups (Sym (6));
for i in [2..#S] do 
  s := S[i]`subgroup;
for d in [4..10] do 
H := ShephardTodd (d);
G := WreathExample (H, s);
"Degree ", Degree (G);
   time f := IsFiniteMatrixGroup (G);
   time g := IsFinite (G);
   "=============================";
end for;
end for;
*/

/* 
for q in [2..17] do 
if IsPrime (q) then s := PSL(2, q); end if;
for d in [4..10] do 
H := ShephardTodd (d);
G := WreathExample (H, s);
"Degree ", Degree (G);
   time f := IsFiniteMatrixGroup (G);
   time g := IsFinite (G);
   "=============================";
end for;
end for;
*/


/*
for d in [4..36] do 
G := ShephardTodd (d);
for n in [3..7] do 
for m in [1..NumberOfPrimitiveGroups (n)] do 
   P := ReflectionExample (G, n, m: Rational := true);
   d, n, m, Degree (P);
   time f := IsFiniteMatrixGroup (P);
   time g := IsFinite (P);
   "=============================";
end for;
end for;
end for;
*/

/* 
DB := RationalMatrixGroupDatabase();
for d in [4..10] do 
for e in [1..NumberOfGroups (DB, d)] do 
for n in [3..7] do 
for m in [1..NumberOfPrimitiveGroups (n)] do 
   P := PrimitiveExample (d, e, n, m: Rational := true);
   d, e, n, m, Degree (P);
   time f := IsFiniteMatrixGroup (P);
   time g := IsFinite (P);
   "=============================";
end for;
end for;
end for;
end for;
*/
