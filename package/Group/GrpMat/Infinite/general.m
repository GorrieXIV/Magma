freeze;

import "attributes.m": RF;

/* is G trivial? */

MyIsTrivial := function (G)
   if Type (G) in {GrpMat, AlgMat} then 
      // return forall{i: i in [1..Ngens (G)] | G.i eq Identity (G)};
      // id := Identity (G); id;
      if Ngens (G) eq 0 then return true; end if;
      id := G.1^0;
      return forall{i: i in [1..Ngens (G)] | G.i eq id};
   elif Type (G) in {SeqEnum, SetEnum} then 
      if #G eq 0 then return true; end if;
      id := Rep (G)^0;
      // return forall{g: g in G | g eq g^0};
      return forall{g: g in G | g eq id};
   else
      error "Error in input type to MyIsTrivial";
   end if;
end function;

/* write nilpotent G as S x U where S generated by
   semisimple matrices, U unipotent */

JordanDecompositionForGroup := function (G)
   F := BaseRing (G);
   MA := MatrixAlgebra (F, Degree (G));
   X := [<s, u> where s, u :=
         MultiplicativeJordanDecomposition (MA!G.i) : i in [1..Ngens (G)]];
   return sub<Generic (G) | [X[i][1]: i in [1..#X]]>,
          sub<Generic (G) | [X[i][2]: i in [1..#X]]>;
end function;

/* is matrix g diagonalisable over some extension field? Suprenenko p 119 */
IsDiagonalisable := function (g)
   m := MinimalPolynomial (g);
   d := Derivative (m);
   return Gcd (m, d) eq 1;
end function;

/* do generators of G and K commute? */ 

AllCommute := function (G, K)
   return forall{<g, k>: g in Generators (G), k in Generators (K) | g*k eq k*g};
end function;

/* return set of generators of G, possibly closed under
   taking inverses */

MatrixGenerators := function (G)
   if Type(G) in {GrpMat, AlgMat} then
      X := [Generic (G) | G.i : i in [1..Ngens (G)]];
   else
      X := G;
   end if;

   if exists{x : x in X | Determinant (x) eq 0} then
      return X;
   else
      if Type(G) in {GrpMat, AlgMat} and assigned G`InvMats  
         and #X eq #G`InvMats then 
         Xm1 := G`InvMats; 
      else 
         Xm1 := [x^-1: x in X];
         if Type(G) in {GrpMat, AlgMat} then G`InvMats := Xm1; end if;
      end if;
      return X cat Xm1;
   end if;
end function;

/* is G known to be finite? */

IsKnownFinite := function (G)
   if MyIsTrivial (G) then return true; end if;
   if assigned G`Order then return true; end if;
   return assigned G`Congruence and assigned G`Congruence`Finite and
      G`Congruence`Finite eq true;
end function;

/* is G known to be infinite? */

IsKnownInfinite := function (G)
   return assigned G`Congruence and assigned G`Congruence`Finite and
      G`Congruence`Finite eq false;
end function;

HasKnownIsomorphicCopy := function (G)
   return assigned G`Congruence and assigned G`Congruence`Image and
      assigned G`Congruence`Isomorphism and
      G`Congruence`Isomorphism eq true; 
end function;

HasKnownCongruenceSubgroup := function (G)
    return assigned G`Congruence and assigned G`Congruence`Subgroup;
end function;

IsUpperTriangularGroup := function (G)
   return forall{x : x in Generators (G) | IsUpperTriangular (x)}
      or  forall{x : x in Generators (G) | IsLowerTriangular (x)};
end function;

/* G nilpotent? */
IsKnownNilpotent := function (G)
   if assigned G`Congruence and assigned G`Congruence`Nilpotent then
      return G`Congruence`Nilpotent;
   end if;
   return "unknown";
end function;

/* G soluble? */
IsKnownSoluble := function (G)
   if assigned G`Congruence and assigned G`Congruence`Soluble then
      return G`Congruence`Soluble;
   end if;
   return "unknown";
end function;

/* G soluble-by-finite? */
IsKnownSF := function (G)
   if assigned G`Congruence and assigned G`Congruence`SolubleByFinite then
      return G`Congruence`SolubleByFinite;
   end if;
   return "unknown";
end function;

/* G nilpotent-by-finite? */
IsKnownNF := function (G)
   if assigned G`Congruence and assigned G`Congruence`NilpotentByFinite then
      return G`Congruence`NilpotentByFinite;
   end if;
   return "unknown";
end function;

/* G abelian-by-finite? */
IsKnownAF := function (G)
   if assigned G`Congruence and assigned G`Congruence`AbelianByFinite then
      return G`Congruence`AbelianByFinite;
   end if;
   return "unknown";
end function;

/* G central-by-finite? */
IsKnownCF := function (G)
   if assigned G`Congruence and assigned G`Congruence`CentralByFinite then
      return G`Congruence`CentralByFinite;
   end if;
   return "unknown";
end function;

/* G completely reducible? */
IsKnownCR := function (G)
   if assigned G`Congruence and assigned G`Congruence`CompletelyReducible then
      return G`Congruence`CompletelyReducible;
   end if;
   return "unknown";
end function;

/* N is congruence subgroup, H is congruence image of G;
   Rels are relations for N */

procedure SetValues (G, H, N, Rels)
   G`Congruence`Subgroup := N;
   finite := MyIsTrivial (N);
   G`Congruence`Finite := finite;
   if finite then
      G`Congruence`Isomorphism := true;
      G`Congruence`Relations := Rels;
      G`Order := H`Order;
   end if;
end procedure;

/* set virtual flags for "Nilpotent", "Soluble", 
   "SF", "NF", "AF", "CF", and "CR" based on value */

procedure SetVirtualValues (G, type, value)

   if not assigned G`Congruence then G`Congruence := rec<RF | >; end if;

   if type eq "Soluble" then
      G`Congruence`Soluble := value;
      if value eq true then 
         G`Congruence`SolubleByFinite := value;
      end if;
      if value eq false then 
         G`Congruence`Nilpotent := value; 
      end if;
   end if;

   if type eq "Nilpotent" then
      G`Congruence`Nilpotent := value;
      if value eq true then 
         G`Congruence`NilpotentByFinite := value;
         G`Congruence`Soluble := value; 
         G`Congruence`SolubleByFinite := value; 
      end if;
   end if;

   if type eq "SF" then
      G`Congruence`SolubleByFinite := value; 
      if value eq false then 
         G`Congruence`NilpotentByFinite := value; 
         G`Congruence`AbelianByFinite := value; 
         G`Congruence`CentralByFinite := value; 
         G`Congruence`Soluble := false;
      end if;
   end if;
   
   if type eq "NF" then 
      G`Congruence`NilpotentByFinite := value; 
      if value eq false then 
         G`Congruence`AbelianByFinite := value; 
         G`Congruence`CentralByFinite := value; 
         G`Congruence`Nilpotent := false;
      end if;
      if value eq true then 
         G`Congruence`SolubleByFinite := value; 
      end if;
   end if;

   if type eq "AF" then 
      G`Congruence`AbelianByFinite := value; 
      if value eq false then 
         G`Congruence`CentralByFinite := value; 
      end if;
      if value eq true then 
         G`Congruence`NilpotentByFinite := value; 
         G`Congruence`SolubleByFinite := value; 
      end if;
   end if;

   if type eq "CF" then 
      G`Congruence`CentralByFinite := value; 
      if value eq true then 
         G`Congruence`AbelianByFinite := value; 
         G`Congruence`NilpotentByFinite := value; 
         G`Congruence`SolubleByFinite := value; 
      end if;
   end if;

   if type eq "CR" then
      G`Congruence`CompletelyReducible := value; 
      if value eq false then return; end if;
      /* completely reducible? all 3 of SF, NF, AF are equivalent */
      if assigned G`Congruence`SolubleByFinite then
         G`Congruence`NilpotentByFinite := G`Congruence`SolubleByFinite; 
         G`Congruence`AbelianByFinite := G`Congruence`SolubleByFinite; 
      elif assigned G`Congruence`NilpotentByFinite then
         G`Congruence`SolubleByFinite := G`Congruence`NilpotentByFinite; 
         G`Congruence`AbelianByFinite := G`Congruence`NilpotentByFinite; 
      elif assigned G`Congruence`AbelianByFinite then
         G`Congruence`NilpotentByFinite := G`Congruence`AbelianByFinite; 
         G`Congruence`SolubleByFinite := G`Congruence`AbelianByFinite; 
      end if;
   end if;
end procedure;

MyCongruenceSubgroup := function (G)
   d := Degree (G);
   F := BaseRing (G);
   A := G`Congruence`Subgroup;
   H := sub<GL(Degree (G), BaseRing (G)) | [A.i: i in [1..Ngens (A)]]>;
   if assigned A`UserWords then H`UserWords := A`UserWords; end if;
   if assigned A`UserGenerators then H`UserGenerators := A`UserGenerators; end if;
   return H;
end function;

