freeze;

/*
Compute the growth function of a finitely presented Coxeter group.
Code supplied by Bob Howlett.

If K<t> is rational functions over the integers and G such a group with
generating set X, for any Y, Y a subset of X, define g(Y;t) to be the
growth function for the subgroup of G generated by Y (standard parabolic
subgroup), and s(Y;t) = (-1)^|Y|/g(Y;t). Bob Howlett points out that

(*)    Sum_{Y <= X} s(Y;t) = 0		 	when G is infinite, 
			   = 1/g(X;t^-1)	when G is finite,

Code below uses the Mobius inversion of (*), which results in a sum over 
all finite standard parabolic subgroups of G.

(*) is possibly a result of Steinberg's:

R. Steinberg, "Endomorphisms of linear algebraic groups",
Mem. Amer. Math. Soc. 80 (1968).

It occurs as an exercise in 
N. Bourbaki, "Groupes et Algebres de Lie", Hermann, Paris, 1968
(Exercise 26, p45).

See also
R. Charney and M. Davis, Reciprocity of growth functions of Coxeter groups,
Geometriae Dedicata 39 (1991), 373-378.

*/

/* Old code of Bill Unger's, still used for the finite case */
gf_irred_finite := function(G, t)
    /* assumes G is irreducible and finite */
    /* returns growth function, number of positive roots */
    r := Rank(G);
    K := Parent(t);
    if r le 4 then
	/* deal with low ranks any way we can */
	if r eq 1 then return 1+t, 1; end if;
	if r eq 2 then
	    M := CoxeterMatrix(G);
	    N := M[1,2];
	    return (1+t)*(1-t^N)/(1-t), N;
	end if;
	if r eq 3 then
	    case Order(G):
		when 24:  return (1-t^2)*(1-t^3)*(1-t^4)/(1-t)^3, 6; /* A3 */
		when 48:  return (1-t^2)*(1-t^4)*(1-t^6)/(1-t)^3, 9; /* B3 */
		when 120: return (1-t^2)*(1-t^6)*(1-t^10)/(1-t)^3, 15; /* H3 */
	    end case;
	end if;
	if r eq 4 then
	    case Order(G):
		when 120: return (1-t^2)*(1-t^3)*(1-t^4)*(1-t^5)/(1-t)^4, 10; /* A4 */
		when 384: return (1-t^2)*(1-t^4)*(1-t^6)*(1-t^8)/(1-t)^4, 16; /* B4 */
		when 192: return (1-t^2)*(1-t^4)*(1-t^6)*(1-t^4)/(1-t)^4, 12; /* D4 */
		when 1152: return (1-t^2)*(1-t^6)*(1-t^8)*(1-t^12)/(1-t)^4, 24; /* F4 */
		when 14400: return (1-t^2)*(1-t^12)*(1-t^20)*(1-t^30)/(1-t)^4, 60; /* H4 */
	    end case;
	end if;
    end if;

    /* Rank at least 5, could be A, B, D or E */
    M := CoxeterMatrix(G);
    m := Max(Eltseq(M));
    assert m eq 3 or m eq 4;

    if m eq 4 then /* B */
	return &*[ (1-t^(2*i))/(1-t):i in [1..r]], r^2;
    end if;

    leaves := {i:i in [1..r]|
	Multiplicity(x,3) eq 1 where x := SequenceToMultiset(Eltseq(M[i]))};
    assert #leaves eq 2 or #leaves eq 3;

    if #leaves eq 2 then /* A */
	return &*[ (1-t^i)/(1-t):i in [2..r+1]], r*(r+1) div 2;
    end if;

    if r in {6,7,8} then /* need to distinguish D and E */
	D_flag :=  Order(G) in {23040, 322560, 5160960};
    else
	D_flag := true;
    end if;

    if D_flag then /* D */
	return &*[ (1-t^(2*i))/(1-t):i in [1..r-1]] * (1-t^r)/(1-t), r^2 - r;
    end if;
    
    /* E */
    if r eq 6 then /* E6 */
	return &*[ (1-t^(i+1))/(1-t): i in [1,5,7,11,4,8]], 36;
    elif r eq 7 then /* E7 */
	return &*[ (1-t^(i+1))/(1-t): i in [1,5,7,11,13,17,9]], 63;
    else /* E8 */
	assert r eq 8;
	return &*[ (1-t^(i+1))/(1-t): i in [1,7,11,13,17,19,23,29]], 120;
    end if;

end function;

gf_finite := function(G, t)
    /* assumes G is finite */
    /* returns growth function, number of positive roots */
    r := Rank(G);
    irred, X := IsIrreducible(G);
    if irred then return gf_irred_finite(G, t); end if;
    to_do := [X, {1..r} diff X];
    res := Parent(t)!1;
    N := 0;
    gen_num := func<x|Eltseq(x)[1]>;
    repeat
	new_to_do := [];
	for X in to_do do
	    H, toG := StandardParabolicSubgroup(G, X);
	    irred, Y := IsIrreducible(H);
	    if irred then
		gr, n := gf_irred_finite(H, t);
		res *:= gr;
		N +:= n;
	    else
		/* lift Y into X */
		Y := {gen_num(H.i@toG): i in Y};
		assert Y subset X;
		Append(~new_to_do, Y);
		Append(~new_to_do, X diff Y);
	    end if;
	end for;
	to_do := new_to_do;
    until #to_do eq 0;
    return res, N;
end function;

intrinsic GrowthFunctionOld(G::GrpFPCox) -> FldFunRatUElt
{The growth of G as a rational function over Z.}

    r := Rank(G);
    K := FunctionField(Integers());
    t := K.1;
    if r le 1 then
	/* make sure we don't trip over small cases */
	if r eq 0 then return K!1;
	else return 1+t;
	end if;
    end if;

    irred, X := IsIrreducible(G);
    if not irred then
	return GrowthFunctionOld(StandardParabolicSubgroup(G, X)) *
	    GrowthFunctionOld(StandardParabolicSubgroup(G, {1..r} diff X));
    end if;

    if IsFinite(G) then
	res := gf_irred_finite(G, t);
	return res; 
    end if;

    sum := 1 - r*t/(1+t); /* contribution from parabolic subgroups of rank 0 and 1 */

    for k := 2 to r-1 do
	/* look for finite parabolic subgroups of rank k, add their contribution in */
	changed := false;
	S := Subsets({1..r}, k);
	for J in S do
	    H := StandardParabolicSubgroup(G, J);
	    if IsFinite(H) then
		changed := true;
		gr, N := gf_finite(H, t);
		sum +:= t^N/gr;
	    end if;
	end for;
	if not changed then
	    break;
	end if;
	sum := -sum;
    end for;

    if Evaluate(sum, 0) eq -1 then sum := -sum; end if;

    return 1/sum;

end intrinsic;

/* Bob Howlett's code starts here */

intrinsic IrreducibleFiniteStandardParabolicSubgroups(G::GrpFPCox) -> SeqEnum, SeqEnum, SeqEnum
{A sequence coding all irreducible finite standard parabolic subgroups of G}
  M:=CoxeterMatrix(G);
  r:=Rank(G);
  ifsps:=[[Integers()|]];
  types:=["A"];
  parameters:=[0];
  if r eq 0 then return ifsps, types, parameters; end if;
  for i:=1 to r do
    Append(~ifsps,[i]);
    Append(~types,"A");
    Append(~parameters,1);
  end for;
/*
The three sequences ifsps, types and parameters will always be the same
length L. In the end, L will be the total number of irreducible finite
standard parabolic subgroups (IFSPs). For each i in [1..L], let P[i] denote
the i-th IFSP (corresponding to the i-th terms of each the above three
sequences. Each IFSP has a type, which is a letter, and a parameter, which
is an integer. The allowable types are "A", "B", "D", "E", "F", "H" and "I".
If P is an IFSP whose type is anything other than "I" then its parameter is
its rank: the number of elements in its canonical generating set. If P has
type "I" then its rank is 2, and its parameter is the edge weight M[i,j],
where {G.i, G.j} is P's canonical generating set. All IFSPs of rank 2 are
deemed to be either of type "A" (if the edge weight is 3) or type "I" (if
the edge weight is greater than 3).

First we are going to append to ifsps all the sequences that correspond to
IFSPs. They will be arranged in order of rank. If i is in [1..L] then the
type of the IFSP P[i] will also be called the type of the sequence ifsps[i].

Numbering conventions:
~~~~~~~~~~~~~~~~~~~~~~
Fix an i in [1..L], and let  p = ifsps[i]. If p has type "I", "F" or "A"
then p[1] will be less than p[#p] (provided #p > 1). If P[i] has type "B" or
"H" then [p[j]: j in [2..#p]] or its reverse will be a term of ifsps of
type "A" (and M[p[1],p[2]] > 2). If P[i] is of type "D" then M[p[1],p[3]]
and M[p[2],p[3]] and will both be 3, p[1] will be less than p[2] and
[p[j]: j in [3..#p]] or its reverse will be a term of ifsps of type A (and
M[p[1],p[2]] will be 2). If P[i] has type "D" and parameters[i] = [4] then
p[1] and p[2] will both be less than p[4]. If P[i] has type "E" and
parameters[i] = [6] then [p[1],p[2],p[3],p[4],p[6]] will be a term of fsps
of type "A" (so that p[1] < p[6] and M[p[3],p[5]] = 3). If p is of type "E"
and parameters[i] is 7 or 8 then [p[i] : i in [1..#p-1]] will be a term of
ifsps of type E (and M[p[#p-1],p[#p]] will be 3).
*/
  current:=r+1; /* ifsps[current] is now the last A_1 */
  for i:=1 to r do
    for j:=i+1 to r do
      if M[i,j] eq 3 then
        Append(~ifsps,[i,j]);
        Append(~types,"A");
        Append(~parameters,2);
      elif M[i,j] ne 0 and M[i,j] ne 2 then
        Append(~ifsps,[i,j]);
        Append(~types,"I");
        Append(~parameters,M[i,j]);
      end if;
    end for;
  end for;
  while current lt #ifsps do
    current+:=1;
    p:=ifsps[current];
    currenttype:=types[current];
    currentrank:=#p;
/*
We will now examine p and find all sequences of length #p+1 corresponding to
irreducible finite parabolic subgroups that are admissible extensions of p.
To be admissible the extension must be of the same type as p, except that
*  when #p is 2 and p is of type A the extension is allowed to be of type B or H,
*  when #p is 3 and p is of type A the extension is allowed to be of type D,
*  when #p is 3 and p is of type B then the extension is allowed to be of type F,
*  when #p is 5 and p is of type D then the extension is allowed to be of type E.
*/
    if currenttype eq "A" and currentrank eq 2 then
      for i:=1 to r do
        if M[p[1],i] eq 4 and M[p[2],i] eq 2 then
          Append(~ifsps, Insert(p,1,i));
          Append(~types,"B");
          Append(~parameters,3);
        elif M[p[2],i] eq 4 and M[p[1],i] eq 2 then
          Append(~ifsps, Reverse(Append(p,i)));
          Append(~types,"B");
          Append(~parameters,3);
        elif M[p[1],i] eq 5 and M[p[2],i] eq 2 then
          Append(~ifsps, Insert(p,1,i));
          Append(~types,"H");
          Append(~parameters,[3]);
        elif M[p[2],i] eq 5 and M[p[1],i] eq 2 then
          Append(~ifsps, Reverse(Append(p,i)));
          Append(~types,"H");
          Append(~parameters,3);
        end if;
      end for;
      for i:=p[1]+1 to r do
        if M[p[1],i] eq 2 and M[p[2],i] eq 3 then
          Append(~ifsps, Append(p,i));
          Append(~types,"A");
          Append(~parameters,3);
        end if;
      end for;
      for i:=p[2]+1 to r do
        if M[p[2],i] eq 2 and M[p[1],i] eq 3 then
          Append(~ifsps, Append(Reverse(p),i));
          Append(~types,"A");
          Append(~parameters,3);
        end if;
      end for;
    elif currenttype eq "A" and currentrank eq 3 then
      for i:=p[3]+1 to r do
        if M[p[1],i] eq 2 and M[p[3],i] eq 2 and M[p[2],i] eq 3 then
          Append(~ifsps, [p[1],p[3],p[2],i]);
          Append(~types,"D");
          Append(~parameters,4);
        end if;
      end for;
      for i:=p[1]+1 to r do
        if M[p[1],i] eq 2 and M[p[2],i] eq 2 and M[p[3],i] eq 3 then
          Append(~ifsps, Append(p,i));
          Append(~types,"A");
          Append(~parameters,4);
        end if;
      end for;
      for i:=p[3]+1 to r do
        if M[p[3],i] eq 2 and M[p[2],i] eq 2 and M[p[1],i] eq 3 then
          Append(~ifsps, Append(Reverse(p),i));
          Append(~types,"A");
          Append(~parameters,4);
        end if;
      end for;
    elif currenttype eq "B" and currentrank eq 3 then
      for i:=p[currentrank]+1 to r do
        if M[p[1],i] eq 3 and M[p[2],i] eq 2 and M[p[3],i] eq 2 then
          Append(~ifsps, Append(Reverse(p),i));
          Append(~types,"F");
          Append(~parameters,4);
        end if;
      end for;
      for i:=1 to r do
        if M[p[1],i] eq 2 and M[p[2],i] eq 2 and M[p[3],i] eq 3 then
          Append(~ifsps, Append(p,i));
          Append(~types,"B");
          Append(~parameters,4);
        end if;
      end for;
    elif currenttype eq "D" and currentrank eq 4 then
      for i:=1 to r do
        if M[p[3],i] eq 2 then
          if M[p[4],i] eq 3 then
            if M[p[2],i] eq 2 then
              if M[p[1],i] eq 2 then
                Append(~ifsps, Append(p,i));
                Append(~types,"D");
                Append(~parameters,5);
              end if;
            end if;
          elif M[p[4],i] eq 2 then
            if M[p[2],i] eq 3 then
              if M[p[1],i] eq 2 then
                Append(~ifsps, [p[1],p[4],p[3],p[2],i]);
                Append(~types,"D");
                Append(~parameters,5);
              end if;
            elif M[p[2],i] eq 2 then
              if M[p[1],i] eq 3 then
                Append(~ifsps, [p[2],p[4],p[3],p[1],i]);
                Append(~types,"D");
                Append(~parameters,5);
              end if;
            end if;
          end if;
        end if;
      end for;
    elif currenttype eq "D" and currentrank eq 5 then
      for i:=p[5]+1 to r do
        if M[p[5],i] eq 2 then
          if M[p[4],i] eq 2 then
            if M[p[3],i] eq 2 then
              if M[p[2],i] eq 2 then
                if M[p[1],i] eq 3 then
                  Append(~ifsps, [p[5],p[4],p[3],p[1],p[2],i]);
                  Append(~types,"E");
                  Append(~parameters,6);
                end if;
              elif M[p[2],i] eq 3 then
                if M[p[1],i] eq 2 then
                  Append(~ifsps, Append(Reverse(p),i));
                  Append(~types,"E");
                  Append(~parameters,6);
                end if;
              end if;
            end if;
          end if;
        end if;
      end for;
      for i:=1 to r do
        if M[p[5],i] eq 3 then
          ok:=true;
          for j:=1 to 4 do
            if M[p[j],i] ne 2 then
              ok:=false;
              break;
            end if;
          end for;
          if ok then
            Append(~ifsps, Append(p,i));
            Append(~types,"D");
            Append(~parameters,6);
          end if;
        end if;
      end for;
    elif currenttype eq "A" then
      for i:=p[1]+1 to r do
        if M[p[currentrank],i] eq 3 then
          ok:=true;
          for j:=1 to currentrank-1 do
            if M[p[j],i] ne 2 then
              ok:=false;
              break;
            end if;
          end for;
          if ok then
            Append(~ifsps, Append(p,i));
            Append(~types,"A");
            Append(~parameters,currentrank+1);
          end if;
        end if;
      end for;
      for i:=p[currentrank]+1 to r do
        if M[p[1],i] eq 3 then
          ok:=true;
          for j:=2 to currentrank do
            if M[p[j],i] ne 2 then
              ok:=false;
              break;
            end if;
          end for;
          if ok then
            Append(~ifsps, Append(Reverse(p),i));
            Append(~types,"A");
            Append(~parameters,currentrank+1);
          end if;
        end if;
      end for;
    elif currenttype eq "E" and currentrank eq 6 then
      for i:=1 to r do
        if M[p[6],i] eq 3 then
          ok:=true;
          for j:=1 to 5 do
            if M[p[j],i] ne 2 then
              ok:=false;
              break;
            end if;
          end for;
          if ok then
            Append(~ifsps, Append(p,i));
            Append(~types,"E");
            Append(~parameters,7);
          end if;
        end if;
      end for;
      for i:=1 to r do
        if M[p[1],i] eq 3 then
          ok:=true;
          for j:=2 to 6 do
            if M[p[j],i] ne 2 then
              ok:=false;
              break;
            end if;
          end for;
          if ok then
            Append(~ifsps, [p[6],p[4],p[3],p[2],p[5],p[1],i]);
            Append(~types,"E");
            Append(~parameters,7);
          end if;
        end if;
      end for;
    elif currenttype eq "A" then
      for i:=p[1]+1 to r do
        if M[p[currentrank],i] eq 3 then
          ok:=true;
          for j:=1 to currentrank-1 do
            if M[p[j],i] ne 2 then
              ok:=false;
              break;
            end if;
          end for;
          if ok then
            Append(~ifsps, Append(p,i));
            Append(~types,"A");
            Append(~parameters,currentrank+1);
          end if;
        end if;
      end for;
    elif currenttype in ["B","D"] or (currenttype eq "H" and currentrank eq 3) or (currenttype eq "E" and currentrank eq 7) then
      for i:=1 to r do
        if M[p[currentrank],i] eq 3 then
          ok:=true;
          for j:=1 to currentrank-1 do
            if M[p[j],i] ne 2 then
              ok:=false;
              break;
            end if;
          end for;
          if ok then
            Append(~ifsps, Append(p,i));
            Append(~types,currenttype);
            Append(~parameters,currentrank+1);
          end if;
        end if;
      end for;
    end if;
  end while;
  return ifsps,types,parameters;
end intrinsic;

signedGrowthIrredFinite := function(r,type,t)
/* r is the rank unless type is "I", then it is bond weight
   We return the growth function times (-1)^rank. */
  K := Parent(t);
  if type eq "A" then
    return &*[K|(t^d-1)/(1-t) : d in [2..r+1]];
  elif type eq "B" then
    return &*[(t^(2*i)-1)/(1-t):i in [1..r]];
  elif type eq "D" then
    return &*[(t^(2*i)-1)/(1-t):i in [1..r-1]]*(t^r-1)/(1-t);
  elif type eq "E" then
    if r eq 6 then
      return &*[ (1-t^(i+1))/(1-t): i in [1,5,7,11,4,8]];
    elif r eq 7 then
      return &*[ (t^(i+1)-1)/(1-t): i in [1,5,7,11,13,17,9]];
    else
      return &*[ (1-t^(i+1))/(1-t): i in [1,7,11,13,17,19,23,29]];
    end if;
  elif type eq "F" then
    return (1-t^2)*(1-t^6)*(1-t^8)*(1-t^12)/(1-t)^4;
  elif type eq "H" then
    if r eq 3 then
      return (t^2-1)*(t^6-1)*(t^10-1)/(1-t)^3;
    else
      return (1-t^2)*(1-t^12)*(1-t^20)*(1-t^30)/(1-t)^4;
    end if;
  else
    return (1+t)*(1-t^r)/(1-t);
  end if;
end function;

intrinsic GrowthFunction(G::GrpFPCox) -> FldFunRatUElt
{The growth of G as a rational function over Z}
    K := FunctionField(Integers());
    t := K.1;
    r := Rank(G);
    if r le 1 then
	/* make sure we don't trip over small cases */
	if r eq 0 then return K!1;
	else return 1+t;
	end if;
    end if;
    irred, X := IsIrreducible(G);
    if not irred then
	return GrowthFunction(StandardParabolicSubgroup(G, X)) *
	    GrowthFunction(StandardParabolicSubgroup(G, {1..r} diff X));
    end if;
    if IsFinite(G) then return gf_irred_finite(G, t); end if;

  ifsps,types,params:=IrreducibleFiniteStandardParabolicSubgroups(G);
  rsgif := [signedGrowthIrredFinite(params[i],types[i],t^-1)^-1: i in [1..#types]];
  sum := &+rsgif;
  M:=CoxeterMatrix(G);
  okpairs:={PowerSet({2..#ifsps})|};
  /* ifsps[1] corresponds to the identity subgroup, which never counts as
  component of a reducible parabolic subgroup */
  for i:=2 to #ifsps-1 do
    for j in [i+1..#ifsps] do
      ok:=true;
      for k in ifsps[i] do
        for l in ifsps[j] do
          if M[k,l] ne 2 then
            ok:=false;
            break k;
          end if;
        end for;
      end for;
      if ok then
        Include(~okpairs,{i,j});
	sum +:= rsgif[i]*rsgif[j];
      end if;
    end for;
  end for;

  //We index the vertices of the graph from 1 (rather than from 2), because otherwise 
  //  the indexing is going to be very confusing; However, we make 1 an isolated vertex 
  //  and ignore it if it comes up in AllCliques.
  x:=Graph<{1..#ifsps}|{p : p in okpairs | 1 notin p}>;
  assert forall{i : i in [1..#ifsps] | Index(VS.i) eq i } where VS := VertexSet(x);

  for level:=3 to #ifsps do
    if not HasClique(x,level,false) then
      break;
    end if;
    for c in AllCliques(x,level,false) do
	  if (#c eq 1) and (Index(Representative(c)) eq 1) then continue; end if;
	  assert 1 notin c;

      sum +:= &*[rsgif[Index(i)]: i in c];
    end for;
  end for;
  return sum^(-1);
end intrinsic;
