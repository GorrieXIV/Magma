freeze;

////////////////////////////////////////////////////////////
// Chabauty + Mordell-Weil Sieve                          //
//                                                        //
// Michael Stoll, 2007-2008                               //
////////////////////////////////////////////////////////////

// Main function:
//   Chabauty(ptJ : ptC)
// where
// * ptC is a rational point on C, a genus 2 curve over Q
// * ptJ is a rational point on J, the Jacobian of C,
//   such that ptJ generates the Mordell-Weil group J(Q) modulo torsion.

//*****
// New version: assumption that ptJ generates the free part no longer
//              necessary, only that rank is 1 and ptJ has infinite order.
// The known subgroup is automatically saturated at all necessary primes.
//
// Further functionality:
// * IsDivisibleBy(P::JacHypPt, n::RngIntElt) -> BoolElt, JacHypPt
//   checks if P is divisible by n in the Mordell-Weil group;
//   if so, returns some Q with n*Q = P as second value
// * Saturation(bas::SeqEnum[JacHypPt], p::RngIntElt : AuxPrimes := 3) -> SeqEnum
//   saturates the subgroup of the Mordell-Weil group generated by bas
//   at the prime p. Returns generators of the free part of the saturated group.
//
// (Michael Stoll, October 2012)
//*****

// The function returns three values:
// 1. the set of rational points on C,
// 2. the set of primes p such that information mod p was used,
// 3. the sequence of primes q that were used to build B,
//    where B is a number such that
//    + C(Q) --> J(Q) --> J(Q)/B J(Q) is injective  and
//    + for the cosets in J(Q)/ B J(Q) not in the image of the map above,
//      the information from the set of primes p (second return value)
//      proves that they are not in the image.

/* Example:
 P := PolynomialRing(Rationals()); x := P.1;
 C := HyperellipticCurve(P![1,8,22,22,5,6,1]);
 ptC := C![0,1];
 ptJ := C![0,1] - C![0,-1]; // a point of infinite order, rank is known to be 1
 SetVerbose("Chabauty", 1); // to see something...
 Chabauty(ptJ);
 Chabauty(ptJ : ptC:=ptC);
*/

/***********************************************************************
  Changes log
  -----------

 Early 2008, Steve:
   -- Define Kummer surface in Chabauty to avoid repeated construction

 November 2008 (for release in V2.15), Steve:
   -- ptC is now an optional argument (if not given, search for one)

   -- start with Epsilon:=0.1 instead of 0.01, often a bit quicker
      for simple curves (I'll experiment more with parameters though)

 October 2012 (sent to Magma in June 2013), Michael Stoll:
   -- added IsDivisibleBy() and Saturation()
   -- added automatic saturation at relevant primes to Chabauty(),
      so that ptJ is no longer required to generate the free part;
      (J(Q) : <ptJ>) < infinity is sufficient
 ***********************************************************************/

////////////////////////////////////////////////////////////////////////


/***********************************************************
 disclog.m

 General purpose discrete log for groups of smooth order

 M. Stoll, started 2005-06-07
 converted to package file 2006-03-05

 **********************************************************/

// given: Abelian group G, bijective map G -> X, X some structure
// #G smooth (so that for groups of order p^f|#G, lookup is feasible)

// Exported intrinsics:
// DiscreteLogMapSmooth(G, m)

function MakeLookup1(G, m)
  return pmap<Codomain(m) -> G| [<m(g), g> : g in G]>;
end function;

function MakeDLp1(G, m, p)
  // G a p-group
  if #G le 25 then
    return MakeLookup1(G, m);
  end if;
  invs := Invariants(G);
  // printf "MakeDLp: Invariants(G) = %o\n", invs;
  pp := ExactQuotient(invs[#invs], p);
  if pp eq 1 then
    return MakeLookup1(G, m);
  end if;
  // printf "MakeDLp: pp = %o\n", pp;
  h := hom<G -> G | [pp*G.i : i in [1..#invs]]>;
  G1 := Image(h);
  // printf "MakeDLp: Invariants(Image(h)) = %o\n", Invariants(G1);
  m1 := map<G1 -> Codomain(m) | x:->m(x)>;
  f1 := MakeLookup1(G1, m1);
  G2 := Kernel(h);
  // printf "MakeDLp: Invariants(Kernel(h)) = %o\n", Invariants(G2);
  m2 := map<G2 -> Codomain(m) | x:->m(x)>;
  f2 := MakeDLp1(G2, m2, p);
  return pmap<Codomain(m) -> G |
               x :-> f2(x - m(a)) + a where a := f1(pp*x) @@ h>;
end function;

intrinsic DiscreteLogMapSmooth(G::GrpAb, m::Map) -> Map
{Given a bijection  m : G -> X, this returns an inverse map.
 X must have group structure (compatible with G via m) and must have
 operations 'x+y' and 'n*x' defined for x,y in X and integers n.
 The returned inverse map X -> G may be more efficient to evaluate than
 the standard inverse given by Inverse(m), in the case where #G is smooth.
 (This intrinsic is temporary and will be removed in a later release)}

  n := #Invariants(G);
  f := Factorization(#G);
  cofs := [&*[Integers()|f[i,1]^f[i,2] : i in [1..#f] | i ne j] : j in [1..#f]];
  _, refs := XGCD(cofs);
  assert &+[Integers()|refs[i]*cofs[i] : i in [1..#f]] eq 1;
  DLs := [**];
  for i := 1 to #f do
    p := f[i,1];
    hp := hom<G -> G | [cofs[i]*G.j : j in [1..n]]>;
    Gp := Image(hp);
    mp := map<Gp -> Codomain(m) | x:->m(x)>;
    DLp := MakeDLp1(Gp, mp, p);
    Append(~DLs, DLp);
  end for;
  return pmap<Codomain(m) -> G
               | x :-> &+[G|refs[i]*G!(DLs[i](cofs[i]*x)) : i in [1..#f]]>;
end intrinsic;

/************************************************************
 * chabauty.m                                               *
 *                                                          *
 * Michael Stoll, started 2006-07-19                        *
 *                                                          *
 * Routines for Chabauty's method on genus 2 curves         *
 ************************************************************/

declare verbose Chabauty, 3;

// Find the reduction mod p of the differential over Q_p that kills
// the subgroup generated by a point on the Jacobian
intrinsic KillingDifferentialModp(pt::JacHypPt, p::RngIntElt) -> Pt
{ Given a point pt of infinite order on the Jacobian of a genus 2 curve
  over the rationals of the form y^2 = f(x) and a prime p of good reduction,
  this returns a point in P^1(F_p) which is the image of the two zeros
  of omega mod p, where omega is a Q_p-differential on the curve that kills
  the group generated by pt. }
  require Order(pt) eq 0: "Point pt must have infinite order.";
  J := Parent(pt);
  require Dimension(J) eq 2: "Point pt must be on a genus 2 Jacobian.";
  C := Curve(J);
  Jp := BaseChange(J, GF(p));
  n := Order(Jp!pt);
  prec := 1;
  K := KummerSurface(J);
  repeat
    prec +:= 2;
    // TO DO: this BaseChange involves BaseChange of J, which takes sig time
    K1 := BaseChange(K, pAdicField(p, prec));
    ptK := n*K1!K!pt;
  until Min([Valuation(ptK[i]) : i in [1..3]]) eq prec - 1;
  coords := [GF(p) | ExactQuotient(Integers()!ptK[i], p^(prec-1))
                   : i in [1..3]];
  assert coords[2]^2 eq 4*coords[1]*coords[3];
  Pr1 := ProjectiveSpace(GF(p), 1);
  return coords[1] eq 0 select Pr1![1,0] else Pr1![coords[2]/2,coords[1]];
end intrinsic;

function GroupInfo(J, bound, bas, ptC, GIlb, PrimeBound, SmoothBound : satknown := {Integers()|})
// Construct a list of "interesting" primes and information on
// C(F_p) and J(F_p)
// An entry is [* p, imbas, imC, flag *],
// where p is the prime,
//       imbas is the image of the given generators of J(Q) in G ~ J(F_p),
//       imC is the image of C(F_p) in G,
//       flag is true iff points in C(F_p) are separated in the image group.
// GIlb is a lower bound on the primes.
  bp := Seqset(BadPrimes(J));
  res := [Parent([**]) | ];
  lb := Max(3, IsEven(GIlb) select GIlb+1 else GIlb);
  satunknown := {Integers() | }; // primes at which saturation needs to be checked
  for p in Type(bound) eq RngIntElt select [lb..bound by 2] else bound do
    if IsPrime(p) and p notin bp then
      Jp := BaseChange(J, GF(p));
      oG := #Jp;
      if Max(PrimeDivisors(oG)) lt SmoothBound then
        G, m := AbelianGroup(Jp);
        vprintf Chabauty, 2: " GroupInfo: p = %o...\n", p;
        I := Invariants(G);
        Cp := BaseChange(Curve(J), Bang(Rationals(), GF(p)));
        pts := Points(Cp);
        vprintf Chabauty, 2:"   #C(F_p) = %o, Invariants(G) = %o\n", #pts, I;
        fI := Factorization(I[#I]);
        vprintf Chabauty, 2: "   Exponent = %o\n", fI;
        DL := DiscreteLogMapSmooth(G, m);
        imbas := [DL(Jp!b) : b in bas];
        orders := [Order(g) : g in imbas];
        fL := Factorization(LCM(orders));
        vprintf Chabauty, 3: "   Exponent of image = %o\n", fL;
        // We assume saturation has been checked at primes dividing the torsion order.
        // Find new primes at which saturation is known
        // (all primes q such that image of ptJ (= bas[1]) is not in q*J(F_p)).
        satknown join:= {a[1] : a in fI | imbas[1] notin a[1]*G};
        // Find primes where saturation needs to be checked
        // (all prime divisors of #J(F_p) for which saturation is not yet known).
        satunknown join:= {a[1] : a in fI};
        satunknown diff:= satknown;
        // function mapping points in C(F_p) into J(F_p)
        inj := func<pt | Jp![Cp!pt, bpt]> where bpt := Cp!ptC;
        // image of C(F_p) in J(F_p) (as abstract group)
        imC := {DL(inj(pt)) : pt in pts};
        // restrict to subgroup generated by image of J(Q) [assuming saturation]
        Gsub := sub<G | imbas>;
        imC := {Gsub | pt : pt in imC | pt in Gsub};
        imbas := ChangeUniverse(imbas, Gsub);
        vprintf Chabauty, 3: "     after restiction: group = %o, #C(F_p) = %o\n",
                             Invariants(Gsub), #imC;
        // check for possibility to simplify
        e1 := &*[Integers()| a[1]^a[2] : a in fL | a[1] lt PrimeBound];
        if e1 lt LCM(orders) then
          // kick out primes larger than PrimeBound
          Gq, qmap := quo<Gsub | [e1*g : g in Generators(Gsub)]>;
          imbas := [qmap(b) : b in imbas];
          imCold := imC;
          imC := {qmap(c) : c in imC};
          if #imC eq #Gq then
            vprintf Chabauty, 2:
                    "   Relevant part does not give information ==> discard.\n";
          else
            // last component of new entry indicates if C(F_p) injects into the quotient group
            Append(~res, [* p, imbas, imC, #imC eq #imCold *]);
          end if;
        else // e1 = LCM(orders)
          Append(~res, [* p, imbas, imC, true *]);
        end if; // e1 lt LCM(orders)
      end if; // Max(PrimeDivisors(oG)) lt SmoothBound
    end if; // IsPrime(p) and p notin bp
  end for; // p
  return res, satknown, satunknown;
end function;

function CheckKillingDifferential(f, ptJ, entry)
// Select the entries in GI (setting entry[4] = true), for which
// the Q_p-differential killing the group generated by ptJ does not vanish
// on any point of the curve mod p
  if not entry[4] then return entry; end if;
  p := entry[1];
  cl := KillingDifferentialModp(ptJ, p);
  fp := PolynomialRing(GF(p))!f;
  if cl[2] eq 0 select not IsSquare(Coefficient(fp, 6))
                else not IsSquare(Evaluate(fp, cl[1]/cl[2]))
  then
    vprintf Chabauty, 2:
            "Found prime p = %o with killing differential not vanishing on C(F_p).\n", p;
    return Append(entry, cl);
  else
    return [* p, entry[2], entry[3], false, cl *];
  end if;
end function;

function GetMinimalDivisors(set)
  res := {};
  while not IsEmpty(set) do
    a := Min(set);
    set := {s : s in set | not IsDivisibleBy(s, a)};
    Include(~res, a);
  end while;
  return res;
end function;

function FindMinimalBs(GI)
  function bestB(entry)
    G := Universe(entry[2]);
    for d in Divisors(Exponent(G)) do
      qG, qmap := quo<G | [d*g : g in OrderedGenerators(G)]>;
      if #{qmap(c) : c in entry[3]} eq #entry[3] then
        vprintf Chabauty, 2: "Best B for p = %o is %o\n", entry[1], d;
        return d, Set(PrimeDivisors(ExactQuotient(Exponent(G), d)));
      end if;
    end for;
    // never reached
  end function;
  return GetMinimalDivisors({bestB(entry) : entry in GI | entry[4]});
end function;

function dryRun1(GI, Bound, eps, tors, Bs)
  vprintf Chabauty, 1: "dryRun: Bound = %o, eps = %o\n", Bound, eps;
  function frac(B, entry)
    I := Invariants(Universe(entry[2]));
    Is := [Integers() | GCD(i,B) : i in I];
    n := &*Is;
    if Is eq I then return 1.0*#entry[3]/n; end if;
    cs := {};
    for cc in entry[3] do
      Include(~cs, [c[i] mod Is[i] : i in [1..#Is]] where c := Eltseq(cc));
      if #cs eq n then return 1.0; end if;
    end for;
    return 1.0*#cs/n;
  end function;
  red := func<B | B*tors*&*[frac(B, e) : e in GI]>;
  prl := [2] cat [p : p in [3..Bound by 2] | IsPrime(p)];
  max := &*[p^Max(&cat[[Valuation(i,p) : i in Invariants(Universe(e[2]))]
                         : e in GI])
             : p in prl];
  vprintf Chabauty, 2: "        max = %o\n", max;
  pl := [p : p in prl | IsDivisibleBy(max, p)];
  // optimze according to max red(B_i)
  // if B_0 = 1, B_{i+1} = B_i*p_i
  agendas := [[<1, 1, 1.0>]]; // entries <p, B, s>
  agendav :=[1.0];
  reached := {1}; // lists the values of B that have been seen so far
  while true do
    v, pos := Min(agendav); // try to extend cheapest path so far
    l := agendas[pos];
    vprintf Chabauty, 2: "  dryRun: l = %o,\n   v = %o\n",
                   [l[i,1] : i in [2..#l]], v;
    Remove(~agendas, pos);
    Remove(~agendav, pos);
    B := l[#l,2];
    s := l[#l,3];
    if B eq max or (s lt eps and exists{b : b in Bs | IsDivisibleBy(B,b)}) then
      break;  // reached success criterion
    end if;
    // list possible extensions
    new := [<p, Bp, red(Bp)> : p in pl
                             | Bp notin reached and IsDivisibleBy(max, Bp)
                               where Bp := B*p];
    // and update agenda
    agendas cat:= [Append(l, n) : n in new];
    agendav cat:= [n[3] : n in new];
    reached join:= {n[2] : n in new};
  end while;
  vprintf Chabauty, 1: "dryRun:\n Multipliers: %o\n",
                [l[i,1] : i in [2..#l]];
  vprintf Chabauty, 1: " Predicted sizes: %o\n", [Round(l[i,3]) : i in [2..#l]];
  return [<l[i,1], l[i,3]> : i in [2..#l]], s lt eps;
end function;

// Given a set of candidates <a, t> mod B, return all pairs mod B*p lifting
// them and compatible with GI. Return "primes" used in the process as second
// value.
function LiftInformation(S, GI, B, p)
  // S = {<a, t>, ...} , a : integer, t : element of abstract torsion subgroup
  // preparation: find relevant entries in GI
  vpB := Valuation(B, p);
  Bp := B*p;
  tests := [e : e in GI | Valuation(Exponent(Universe(e[2])), p) gt vpB];
  tests := [[* e[1], [q(b) : b in e[2]], {q(c) : c in e[3]} *]
              where _, q := quo< G | [Bp*g : g in Generators(G)] >
              where G := Universe(e[2])
             : e in tests];
  tests := [e : e in tests | #e[3] lt #Universe(e[3])];
  Sort(~tests, func<a,b | #a[3]/#Universe(a[3]) - #b[3]/#Universe(b[3])>);
  if IsVerbose("Chabauty", 2) then
    printf "LiftInformation: B = %o, p = %o, #S = %o\n", B, p, #S;
    if IsEmpty(tests) then
      printf "  no relevant entries.\n";
    else
      printf "  relevant entries:\n";
      for e in tests do
        printf "    %o : #G = %o, #imC = %o\n", e[1], #Universe(e[3]), #e[3];
      end for;
    end if;
  end if;
  res := {};
  primes := {};
  for tup in S do
    cands := {<a + i*B, t> : i in [0..p-1]}
               where a := tup[1] where t := tup[2];
    size := #cands;
    for e in tests do
      cands := {c : c in cands
                  | c[1]*e[2][1]
                     + &+[Universe(e[3])|ts[i]*e[2][i+1] : i in [1..#ts]]
                     in e[3]
                     where ts := Eltseq(c[2])};
      if #cands lt size then
        size := #cands; Include(~primes, e[1]);
      end if;
    end for;
    res join:= cands;
  end for;
  if IsVerbose("Chabauty", 2) then
    if not IsEmpty(tests) then
      printf "  entries used: %o\n", primes;
    end if;
    printf "  size of conditions mod %o is %o\n", Bp, #res;
  end if;
  return res, primes;
end function;

// Compute a heuristic value indicating whether we have collected
// enough information.
function CheckInvariant(GI, tors)
  rep := 10;
  function frac(B, entry)
    I := Invariants(Universe(entry[2]));
    Is := [Integers() | GCD(i,B) : i in I];
    n := &*Is;
    if Is eq I then return 1.0*#entry[3]/n; end if;
    cs := {};
    for cc in entry[3] do
      Include(~cs, [c[i] mod Is[i] : i in [1..#Is]] where c := Eltseq(cc));
      if #cs eq n then return 1.0; end if;
    end for;
    return 1.0*#cs/n;
  end function;
  //
  Gs := [Universe(e[2]) : e in GI];
  primes := &join[Seqset(PrimeDivisors(#G)) : G in Gs];
  // for each prime, find largest exponents in invariants of product
  Bs := [1 : j in [1..rep]];
  for p in primes do
    vals := &join[{* Valuation(i, p) : i in Invariants(G) *} : G in Gs];
    m := Max(vals);
    Exclude(~vals, m);
    for j := 1 to rep do
      Bs[j] *:= p^m;
      if m ne 0 then
        if IsEmpty(vals) then
          m := 0;
        else
          m := Max(vals);
          Exclude(~vals, m);
        end if;
      end if;
    end for;
  end for;
  // compute estimated number of candidates for B
  rs := [1.0*B*tors : B in Bs];
  for e in GI do
    rs := [rs[j]*frac(Bs[j], e) : j in [1..rep]];
  end for;
  return Min(rs);
end function;

function CheckPoint(gen, l, t, ptC, ht)
// Checks if l*gen + t (t a torsion point) gives
// a point on J that is of the form pt - ptC.
// Returns a flag, and (if successful) the point.
// ht is a bound for the logarithmic naive height of the point on J
  C := Parent(ptC);
  prec := 0.0;
  p := 101;
  disc := Integers()!Discriminant(Curve(Parent(ptC)));
  ht1 := ht + 2*Log(Max([Abs(ptC[1]), Abs(ptC[3])])) + Log(3);
  J := Parent(gen);
  while prec lt ht1 do
    if not IsDivisibleBy(disc, p) then
      Jp := BaseChange(J, GF(p));
      ptCp := Curve(Jp)!ptC;
      ptJp := l*(Jp!gen) + Jp!t;
      if not ( ptJp eq Jp!0 or
             ( ptCp[3] eq 0
               select (Degree(ptJp[1]) lt 2
                        and Coefficient(ptJp[2], 3) eq -ptCp[2])
               else (Evaluate(ptJp[1], x) eq 0
                      and Evaluate(ptJp[2], x) eq -ptCp[2]/ptCp[3]^3
                     where x := ptCp[1]/ptCp[3]) ) )
      then
        vprintf Chabauty, 3: "  CheckPoint: failed at p = %o\n", p;
        return false, _;
      end if;
    end if;
    prec +:= Log(p);
    p := NextPrime(p);
  end while;
  // Now there should be a point; find it!
  ptJ := l*gen + t;
  assert ptJ eq J! 0 or
         ( ptC[3] eq 0
               select (Degree(ptJ[1]) lt 2
                        and Coefficient(ptJ[2], 3) eq -ptC[2])
               else (Evaluate(ptJ[1], x) eq 0
                      and Evaluate(ptJ[2], x) eq -ptC[2]/ptC[3]^3
                     where x := ptC[1]/ptC[3]) );
  if ptJ eq J!0 then return true, ptC; end if;
  if ptC[3] eq 0 then
    if Degree(ptJ[1]) lt 1 then
      // other point also at infinity
      return true, C![1, Coefficient(ptJ[2], 3), 0];
    else
      return true, C![x, Evaluate(ptJ[2], x), 1]
                   where x := -Coefficient(ptJ[1], 0);
    end if;
  else
    if Degree(ptJ[1]) lt 2 then
      // other point at infinity
      return true, C![1, Coefficient(ptJ[2], 3), 0];
    else
      return true, C![x, Evaluate(ptJ[2], x), 1]
                   where x := -Coefficient(ptJ[1], 1) - ptC[1]/ptC[3];
    end if;
  end if;
end function;

//=========================================================================
// Find degree 2 and degree 3 genus 1 subcovers of a genus 2 curve
// when they exist.

// Degree 2
// ========

// We need an "extra involution" in the automorphism group of C.

function ExtraInvolutions(C)
  A, mA := AutomorphismGroup(C);
  function moebius(aut)
    ax,_,az := Explode(DefiningPolynomials(aut));
    P := Parent(ax);
    mat := Matrix([[a,b], [c,d]])
            where a := MonomialCoefficient(ax, P.1)
            where b := MonomialCoefficient(az, P.1)
            where c := MonomialCoefficient(ax, P.3)
            where d := MonomialCoefficient(az, P.3);
    if IsScalar(mat) then return {Parent(mat)|}; end if;
    assert IsScalar(mat^2);
    flag, s := IsSquare(-Determinant(mat));
    if flag then return {1/s*mat}; else return {}; end if;
  end function;
  mats := &join{moebius(mA(a)) : a in A | Order(a) eq 2};
  result := {Universe(mats)|};
  while not IsEmpty(mats) do
    m := Rep(mats);
    Include(~result, m);
    mats diff:= {m, -m};
  end while;
  return result;
end function;

// Given an "extra involution" (as a matrix), compute the subcover and map.

function Degree2Subcover(C, inv)
  trmat := Matrix([Eltseq(Basis(Eigenspace(inv, 1))[1]),
                   Eltseq(Basis(Eigenspace(inv, -1))[1])]);
  f := HyperellipticPolynomials(C);
  P := Parent(f);
  l1 := P!Eltseq(Transpose(trmat)[1]);
  l2 := P!Eltseq(Transpose(trmat)[2]);
  pol := &+[Coefficient(f, j)*l1^j*l2^(6-j) : j in [0..6]];
  assert Evaluate(pol, -P.1) eq pol;
  C1 := HyperellipticCurve(pol);
  tri := trmat^-1;
  mz := tri[1,1]*C.1 + tri[2,1]*C.3;
  mx := tri[1,2]*C.1 + tri[2,2]*C.3;
  mCC1 := map<C -> C1 | [mx, C.2, mz]>;
  pol3 := P![Coefficient(pol, 2*j) : j in [0..3]];
  E1 := HyperellipticCurveOfGenus(1, pol3);
  mC1E1 := map<C1 -> E1 | [C1.1^2, C1.2*C1.3, C1.3^2]>;
  EE1, mE1E := EllipticCurve(E1);
  E2 := HyperellipticCurveOfGenus(1, P![Coefficient(pol3, 3-j) : j in [0..3]]);
  mC1E2 := map<C1 -> E2 | [C1.3^2, C1.2*C1.1, C1.1^2]>;
  EE2, mE2E := EllipticCurve(E2);
  return <EE1, Expand(mCC1*mC1E1*mE1E)>, <EE2, Expand(mCC1*mC1E2*mE2E)>;
end function;

// Main function, returns all degree 2 genus 1 subcovers as a list
// of pairs <E, mCE>.

intrinsic Degree2Subcovers(C::CrvHyp) -> List
{Returns a list of pairs <E, mCE>, where E is an elliptic curve and mCE
 is a map of degree 2 from C to E. C must be of genus 2 and of the form
 y^2 = f(x).}
  f, h := HyperellipticPolynomials(C);
  require h eq 0: "Curve must be of the form y^2 = f(x)";
  require Genus(C) eq 2: "Curve must be of genus 2";
  result := [**];
  for inv in ExtraInvolutions(C) do
    cov1, cov2 := Degree2Subcover(C, inv);
    Append(~result, cov1);
    Append(~result, cov2);
  end for;
  return result;
end intrinsic;

// Degree 3
// ========

// Here, the right hand side in  y^2 = f(x)  has to factor into two cubics
//  f(x) = g(x) h(x) .
// The covering map  C --> E  induces a map of degree 3,  phi: P^1 --> P^1
// that sends the roots of g to infinity and is ramified at some rational point.
// So we can write  phi(x) = (x - u1)^2 (x - u2) / g(x)
// (with the understanding that u1 or/and u2 might be infinity).
// The other three ramification points must be the roots of h.
//
// We compute
//  d(x) := disc_t(x g(t) - (t-u1)^2 (t-u2))/x,  a cubic in x,
// and then
//  d(phi(x)) = -g(x) H(x,u1,u2) (k(x,u1,u2)/g(x)^2)^2 .
// If  H(x,u1,u2) = const h(x) , then
//  E : y^2 = -const d(x)  is the subcover,
// and
//  C --> E,  (x, y) |--> (phi(x), const y k(x,u1,u2)/g(x)^2)
// is the map.
//
// The polynomials H and k can be computed generically.

function Hpoly(g, u1, u2)
  // Gives the coefficients of H
  a0, a1, a2, a3 := Explode([Coefficient(g, j) : j in [0..3]]);
  return
    [- 4*a0^2*u1 + a0^2*u2 - 4*a0*a1*u1^2 - 4*a0*a2*u1^3 - 2*a0*a2*u1^2*u2
        - 4*a0*a3*u1^4 - 8*a0*a3*u1^3*u2 - 4*a1*a3*u1^4*u2 + a2^2*u1^4*u2,
     3*a0^2 + 2*a0*a1*u2 + 6*a0*a2*u1^2 + 4*a0*a2*u1*u2 + 12*a0*a3*u1^3
          + 18*a0*a3*u1^2*u2 - 4*a1^2*u1^2 - 4*a1*a2*u1^3 - 2*a1*a2*u1^2*u2
          + 8*a1*a3*u1^3*u2 - a2^2*u1^4 - 4*a2^2*u1^3*u2 - 2*a2*a3*u1^4*u2,
     2*a0*a1 - 8*a0*a2*u1 - 18*a0*a3*u1^2 - 12*a0*a3*u1*u2 + 4*a1^2*u1
          + a1^2*u2 + 2*a1*a2*u1^2 + 4*a1*a2*u1*u2 - 4*a1*a3*u1^3
          - 6*a1*a3*u1^2*u2 + 4*a2^2*u1^2*u2 - 2*a2*a3*u1^4 - 3*a3^2*u1^4*u2,
     4*a0*a2 + 8*a0*a3*u1 + 4*a0*a3*u2 - a1^2 + 2*a1*a3*u1^2 + 4*a1*a3*u1*u2
       + 4*a2*a3*u1^2*u2 - a3^2*u1^4 + 4*a3^2*u1^3*u2];
end function;

function kpoly(g, u1, u2)
  a0, a1, a2, a3 := Explode([Coefficient(g, j) : j in [0..3]]);
  return Parent(g)![-a0*u1 - 2*a0*u2 - a1*u1*u2,
                     3*a0 - a1*u2 - 2*a2*u1*u2,
                     2*a1 + a2*u1 - 3*a3*u1*u2,
                     a2 + 2*a3*u1 + a3*u2];
end function;

// Now the function that checks whether the factors g and h work.
// It returns a flag; if true, the second and third return values
// are the elliptic curve E and the map C --> E.

function TestDeg3Subcover(g, h, C)
  P := Parent(g);
  P2<u1,u2> := PolynomialRing(CoefficientRing(P), 2);
  H := Hpoly(g, u1, u2);
  hs := [Coefficient(h, j) : j in [0..3]];
  I := ideal<P2 | [hs[j]*H[k] - hs[k]*H[j] : k in [j+1..4], j in [1..4]]>;
  vI := Variety(I);
  if not IsEmpty(vI) then
    assert #vI eq 1;
    sol := [vI[1,1], vI[1,2]];
    Hi := P![Evaluate(c, sol) : c in H];
    // check if with these values, H is really proportional to h
    assert IsDivisibleBy(Hi, h);
    const := Evaluate(ExactQuotient(Hi, h), 0);
    PP := PolynomialRing(P);
    t := P.1*Evaluate(g, PP.1) - (PP.1-sol[1])^2*(PP.1-sol[2]);
    disc := Discriminant(t);
    if Degree(t) lt 3 then disc *:= LeadingCoefficient(t)^2; end if;
    d := ExactQuotient(disc, P.1);
    assert IsSquarefree(d);
    d *:= -const;
    E1 := HyperellipticCurveOfGenus(1, d);
    E, mE1E := EllipticCurve(E1);
    k := kpoly(g, sol[1], sol[2]);
    mx := (C.1 - sol[1]*C.3)^2*(C.1 - sol[2]*C.3);
    my := const*C.2*&+[Coefficient(k, j)*C.1^j*C.3^(3-j) : j in [0..3]];
    mz := &+[Coefficient(g, j)*C.1^j*C.3^(3-j) : j in [0..3]];
    mCE1 := map<C -> E1 | [mx, my, mz]>;
    return true, E, mCE1*mE1E;
  end if;
  // the coefficients of H are of degree 4 in u1 and of degree 1 in u2
  // the coefficients of k are of degree 1 in u1 and in u2

  // check special case  u1 = infinity
  // for H, this means we look at the coefficient of u1^4
  // (which is a polynomial in u2 of degree at most 1)
  H1 := [Evaluate(Coefficient(c, u1, 4), [0, P.1]) : c in H];
  seq := [hs[j]*H1[k] - hs[k]*H1[j] : k in [j+1..4], j in [1..4]];
  mat := Transpose(Matrix([[Coefficient(c, k) : k in [0,1]] : c in seq]));
  ker := Kernel(mat);
  if Dimension(ker) gt 0 then
    assert Dimension(ker) eq 1;
    b := Basis(ker)[1];
    if b[1] eq 0 then
      // u2 = infty as well
      // extract coefficient of u2^1
      Hi := P![Coefficient(c, 1) : c in H1];
      // check if with these values, H is really proportional to h
      assert IsDivisibleBy(Hi, h);
      const := Evaluate(ExactQuotient(Hi, h), 0);
      PP := PolynomialRing(P);
      t := P.1*Evaluate(g, PP.1) - 1;
      disc := Discriminant(t);
      if Degree(t) lt 3 then disc *:= LeadingCoefficient(t)^2; end if;
      d := ExactQuotient(disc, P.1);
      assert IsSquarefree(d);
      d *:= const;
      E1 := HyperellipticCurveOfGenus(1, d);
      E, mE1E := EllipticCurve(E1);
      k := P![-a1, -2*a2, -3*a3, 0] // coefficients of u1*u2
             where a0,a1,a2,a3 := Explode([Coefficient(g, j) : j in [0..3]]);
      mx := C.3^3;
      my := const*C.2*&+[Coefficient(k, j)*C.1^j*C.3^(3-j) : j in [0..3]];
      mz := &+[Coefficient(g, j)*C.1^j*C.3^(3-j) : j in [0..3]];
      mCE1 := map<C -> E1 | [mx, my, mz]>;
      return true, E, mCE1*mE1E;
    else
      // u2 = common root of the polynomials in seq
      sol2 := -b[2]/b[1];
      Hi := P![Evaluate(c, sol2) : c in H1];
      assert IsDivisibleBy(Hi, h);
      const := Evaluate(ExactQuotient(Hi, h), 0);
      PP := PolynomialRing(P);
      t := P.1*Evaluate(g, PP.1) - (PP.1-sol2);
      disc := Discriminant(t);
      if Degree(t) lt 3 then disc *:= LeadingCoefficient(t)^2; end if;
      d := ExactQuotient(disc, P.1);
      assert IsSquarefree(d);
      d *:= -const;
      E1 := HyperellipticCurveOfGenus(1, d);
      E, mE1E := EllipticCurve(E1);
      k := P![-a0-a1*sol2, -2*a2*sol2, a2-3*a3*sol2, 2*a3]
             where a0,a1,a2,a3 := Explode([Coefficient(g, j) : j in [0..3]]);
      mx := C.3^2*(C.1 - sol2*C.3);
      my := const*C.2*&+[Coefficient(k, j)*C.1^j*C.3^(3-j) : j in [0..3]];
      mz := &+[Coefficient(g, j)*C.1^j*C.3^(3-j) : j in [0..3]];
      mCE1 := map<C -> E1 | [mx, my, mz]>;
      return true, E, mCE1*mE1E;
    end if;
  end if;
  // check special case  u2 = infinity
  // extract coefficient of u2^1
  H1 := [Evaluate(Coefficient(c, u2, 1), [P.1, 0]) : c in H];
  // look for common root u1 (not at infinity; this case was already checked)
  pol := GCD([hs[j]*H1[k] - hs[k]*H1[j] : k in [j+1..4], j in [1..4]]);
  if Degree(pol) gt 0 then
    assert Degree(pol) eq 1;
    sol1 := -Coefficient(pol, 0)/Coefficient(pol, 1);
    Hi := P![Evaluate(c, sol1) : c in H1];
    assert IsDivisibleBy(Hi, h);
    const := Evaluate(ExactQuotient(Hi, h), 0);
    PP := PolynomialRing(P);
    t := P.1*Evaluate(g, PP.1) - (PP.1-sol1)^2;
    disc := Discriminant(t);
    if Degree(t) lt 3 then disc *:= LeadingCoefficient(t)^2; end if;
    d := ExactQuotient(disc, P.1);
    assert IsSquarefree(d);
    d *:= -const;
    E1 := HyperellipticCurveOfGenus(1, d);
    E, mE1E := EllipticCurve(E1);
    k := P![-2*a0-a1*sol1, -a1-2*a2*sol1, -3*a3*sol1, a3]
           where a0,a1,a2,a3 := Explode([Coefficient(g, j) : j in [0..3]]);
    mx := (C.1 - sol1*C.3)^2*C.3;
    my := const*C.2*&+[Coefficient(k, j)*C.1^j*C.3^(3-j) : j in [0..3]];
    mz := &+[Coefficient(g, j)*C.1^j*C.3^(3-j) : j in [0..3]];
    mCE1 := map<C -> E1 | [mx, my, mz]>;
    return true, E, mCE1*mE1E;
  end if;
  return false, _, _;
end function;

// A helper function: Given a sequence of positive integers,
// it finds all subsets of the index set such that the sum of the
// corresponding numbers is n.

function sumnsubsets(seq, n)
  if IsEmpty(seq) then
    return n eq 0 select {{Integers()|}} else {};
  elif seq[#seq] gt n then
    return sumnsubsets(Prune(seq), n);
  else
    sss := sumnsubsets(Prune(seq), n - seq[#seq]);
    return {Include(s, #seq) : s in sss} join sumnsubsets(Prune(seq), n);
  end if;
end function;


// The main function takes a curve C and returns all the subcovers
// as a list of pairs <E, mCE>.

intrinsic Degree3Subcovers(C::CrvHyp) -> List
{Returns a list of pairs <E, mCE>, where E is an elliptic curve and mCE
 is a map of degree 3 from C to E. C must be of genus 2 and of the form
 y^2 = f(x).}
  f, h := HyperellipticPolynomials(C);
  require h eq 0: "Curve must be of the form y^2 = f(x)";
  require Genus(C) eq 2: "Curve must be of genus 2";
  ff := Factorization(f);
  ff := [a[1] : a in ff];
  // find all factorizations into two (projective) cubics
  degs := [Degree(a) : a in ff];
  sss := sumnsubsets(degs, 3);
  if Degree(f) eq 5 then sss join:= sumnsubsets(degs, 2); end if;
  result := [**];
  for s in sss do
    g := &*[ff[j] : j in s];
    h := ExactQuotient(f, g);
    flag, E, mCE := TestDeg3Subcover(g, h, C);
    if flag then Append(~result, <E, Expand(mCE)>); end if;
  end for;
  return result;
end intrinsic;

//==========================================================================

// division.m
//
// Check if a point in the Mordell-Weil group of a genus 2 Jacobian over Q
// is divisible by n, and if so, compute an n-division point.
//
// M. Stoll, started 2008-06-24

declare verbose JacPtDivide, 3;

function MyKernel(mat, prec)
  // vprintf JacPtDivide, 3: "MyKernel: prec = %o, mat =\n%o\n", prec, mat;
  F := BaseRing(mat);
  p := UniformizingElement(F);
  nc := NumberOfColumns(mat);
  nr := NumberOfRows(mat);
  v := Min(prec, Min([Valuation(c) : c in Eltseq(mat)]));
  mat := Matrix([[mat[i,j]/p^v : j in [1..nc]] : i in [1..nr]]);
  assert forall{c : c in Eltseq(mat) | AbsolutePrecision(c) ge prec};
  Rp := pAdicRing(Integers()!p : Precision := prec);
  matR := ChangeRing(ChangeRing(mat, Integers(F)), Rp);
  bas := [ChangeRing(b, F) : b in Basis(Kernel(matR))];
  // vprintf JacPtDivide, 3: "MyKernel: bas =\n%o\n", bas;
  return bas;
end function;

intrinsic IsDivisibleBy(P::JacHypPt, n::RngIntElt) -> BoolElt, JacHypPt
{Check if P (point on a genus 2 Jacobian over Q) is divisible by n. If yes,
 return a point Q with n*Q = P as second value.}
  // simple tests
  vprintf JacPtDivide, 1: "IsDivisibleBy(pt = %o, n = %o)\n", P, n;
  J := Parent(P);
  if P eq J!0 then return true, P; end if;
  if n eq 0 then return false, _; end if;
  // deal with negative n
  if n lt 0 then P := -P; n := -n; end if;
  if n eq 1 then return true, P; end if;
  // checks
  require BaseField(J) cmpeq Rationals(): "P must be on a Jacobian over Q.";
  C := Curve(J);
  require Genus(C) eq 2: "P must be on a genus 2 Jacobian.";
  f, h := HyperellipticPolynomials(C);
  require h eq 0: "The curve of P's parent must be of the form y^2 = f(x).";
  require IsIntegral(C):
          "The curve of P's parent must have integral coefficients.";
  // another special case
  if 2*P eq J!0 then
    vprintf JacPtDivide, 1: "Special case: 2*P = 0.\n";
    v := Valuation(n, 2);
    if v eq 0 then return true, P; end if;
    T, mT := TorsionSubgroup(J);
    vprintf JacPtDivide, 2: "Torsion subgroup has invariants %o\n", Invariants(T);
    // find element of T mapping to P
    T2 := Kernel(hom<T -> T | [2*t : t in OrderedGenerators(T)]>);
    for t in T2 do
      if mT(t) eq P then tP := t; break; end if;
    end for;
    m := hom<T -> T | [2^v*t : t in OrderedGenerators(T)]>;
    if tP in Image(m) then
      vprintf JacPtDivide, 1: "P is divisible by %o in torsion subgroup\n", 2^v;
      tQ := tP @@ m;
      return true, mT(tQ);
    else
      vprintf JacPtDivide, 1: "P is not divisible by %o in torsion subgroup\n", 2^v;
      return false, _;
    end if;
  end if;
  // pick a prime p such that 2*P is not zero mod p
  K := KummerSurface(J);
  twoPK := 2*K!P;
  a := GCD([Integers()|twoPK[i] : i in [1..3]]);
  assert a ne 0;
  disc := Integers()!Discriminant(f);
  p := 3;
  while IsDivisibleBy(disc, p) or IsDivisibleBy(a, p) or IsDivisibleBy(n, p) do
    p := NextPrime(p);
  end while;
  vprintf JacPtDivide, 1: "First prime p = %o\n", p;
  // find n-division points of P mod p
  Jp := BaseChange(J, Bang(Rationals(), GF(p)));
  G, mG := AbelianGroup(Jp);
  Pp := Jp!P;
  PG := Pp @@ mG;
  mult := hom<G -> G | [n*g : g in OrderedGenerators(G)]>;
  if PG notin Image(mult) then
    vprintf JacPtDivide, 1: "P is not divisible by %o mod p\n", n;
    return false, _;
  end if;
  QG := PG @@ mult;
  QGs := [QG + k : k in Kernel(mult)];
  if #QGs gt 1 then
    vprintf JacPtDivide, 1:
            "P is not uniquely divisible by %o in group mod p\n", n;
    // try to improve on number of points to check for lifting
    T, mT := TorsionSubgroup(J);
    nT := Kernel(hom<T -> T | [n*t : t in OrderedGenerators(T)]>);
    vprintf JacPtDivide, 2: "#J(Q)[%o] = %o\n", n, #nT;
    count := 1;
    p1 := NextPrime(p);
    while count lt 10 and #QGs gt #nT do
      while IsDivisibleBy(disc, p1) or IsDivisibleBy(a, p1)
              or IsDivisibleBy(n, p1) do
        p1 := NextPrime(p1);
      end while;
      vprintf JacPtDivide, 1: "Next prime p = %o\n", p1;
      Jp1 := BaseChange(J, Bang(Rationals(), GF(p1)));
      G1, mG1 := AbelianGroup(Jp1);
      Pp1 := Jp1!P;
      PG1 := Pp1 @@ mG1;
      mult1 := hom<G1 -> G1 | [n*g : g in OrderedGenerators(G1)]>;
      if PG1 notin Image(mult1) then
        vprintf JacPtDivide, 1: "P is not divisible by %o mod p\n", n;
        return false, _;
      end if;
      QG1 := PG1 @@ mult1;
      QGs1 := [QG1 + k : k in Kernel(mult1)];
      if #QGs1 lt #QGs then
        vprintf JacPtDivide, 2: "Current prime gives fewer division points\n";
        p := p1;
        Jp := Jp1;
        G := G1; mG := mG1;
        Pp := Pp1;
        PG := PG1;
        mult := mult1;
        QG := QG1;
        QGs := QGs1;
      end if;
      count +:= 1;
      pt := NextPrime(p1);
    end while;
    // reduce to representatives of cosets of nT
    nTp := Set(sub<G | [(Jp!mT(t)) @@ mG : t in Generators(nT)]>);;
    reps := {};
    rem := Set(QGs);
    while not IsEmpty(rem) do
      q := Rep(rem);
      Include(~reps, q);
      for t in nTp do
        Exclude(~rem, q+t);
      end for;
    end while;
    QGs := Setseq(reps);
    vprintf JacPtDivide, 1:
            "Need to check %o division points mod %o\n", #QGs, p;
  else // #QGs eq 1
    vprintf JacPtDivide, 1:
            "P is uniquely divisible by %o in group mod %o\n", n, p;
  end if;
  // Now QGs is a sequence of points Q in J(F_p) such that n*Q = P-bar
  // and such that if P is n-divisible, then one of them must lift to
  // an n-division point of P in J(Q).

  // Some preliminary computations.
  hP := Height(P);
  vprintf JacPtDivide, 2: "\nCanonical height of P is %o\n", hP;
  hQ := hP/n^2; // canonical height of a potential Q
  vprintf JacPtDivide, 2: "Canonical height of P/%o would be %o\n", n, hQ;
  hc := HeightConstant(J);
  vprintf JacPtDivide, 2: "Height constant bound for J is %o\n", hc;
  bound := hQ + hc; // bound for naive height of Q
  Bound := Exp(bound);           // non-log height bound
  bound1 := Log(64.0) + 2*bound; // bound for p-adic precision
  pbound := Ceiling(bound1/Log(p)); // p-adic precision needed
  vprintf JacPtDivide, 2: "%o-adic precision needed is %o\n", p, pbound;
  F := pAdicField(p);
  KF := BaseExtend(K, F);
  Kp := KummerSurface(Jp);
  PKp := Kp!Pp;
  PK := K!P;
  jP := 1;
  while jP le 4 and PKp[jP] eq 0 do jP +:= 1; end while;
  // loop through the possible images of Q in J(F_p) (mod J(Q)[n])
  for QG in QGs do
    prec := 1;
    Qp := mG(QG);
    QpK := Kp!Qp;
    dkv := [ Evaluate(Kp`DEquation[i], Eltseq(QpK)) : i in [1..4] ];
    // vprintf JacPtDivide, 3: "QpK = %o, dkv = %o\n", QpK, dkv;
    jQ := 1;
    while jQ le 4 and QpK[jQ] eq 0 do jQ +:= 1; end while;
    iQ := 1;
    while iQ le 4 and dkv[iQ] eq 0 do iQ +:= 1; end while;
    assert iQ le 4;
    vprintf JacPtDivide, 1:
            "\nTrying to lift Q = %o...\n", QpK;
    QK:= KF![ (F!Integers()!a) + O(F!p) : a in Eltseq(QpK) ];
    L := Lattice(4, ChangeUniverse(Eltseq(QK), Integers())
                     cat [p,0,0,0, 0,p,0,0, 0,0,p,0, 0,0,0,p]);
    app := Eltseq(Basis(L)[1]);
    while prec lt pbound do
      vprintf JacPtDivide, 2: "Current precision is %o\n", prec;
      // next lift
      newprec := Min(2*prec, pbound);
      vprintf JacPtDivide, 2: "New precision is %o\n", newprec;
      F`DefaultPrecision := Max(F`DefaultPrecision, newprec);
      Onew := O(F!p^newprec);
      KF := BaseExtend(K, F);
      // lift point
      s := [ (F!Integers()!a) + Onew : a in Eltseq(QK) ];
      kv := Evaluate(KF`Equation, s);
      dkv := [ Evaluate(KF`DEquation[i], s) : i in [1..4] ];
      assert Valuation(dkv[iQ]) eq 0;
      s1 := s;
      s1[iQ] -:= kv/dkv[iQ];
      s1 := Eltseq(KF!s1);
      mat := Matrix([[dkv[k], k eq jQ select 1 else 0] : k in [1..4]]);
      vprintf JacPtDivide, 3:
              "matrix:\n%o\n", mat;
      matker := MyKernel(mat, prec);
      matker := [bs : b in matker | Min([Valuation(c) : c in bs]) eq 0
                                     where bs := Eltseq(b)];
      vprintf JacPtDivide, 3:
              "Kernel of matrix:\n%o\n", matker;
      assert #matker eq 2;
      assert Min([Min([AbsolutePrecision(c) : c in b]) : b in matker]) ge prec;
      s2 := KF![s1[i] + p^prec*matker[1][i] : i in [1..4]];
      s3 := KF![s1[i] + p^prec*matker[2][i] : i in [1..4]];
      s1 := KF!s1;
      vprintf JacPtDivide, 3:
              "Possible lifts:\n  %o\n  %o\n  %o\n", s1, s2, s3;
      // find correct lift so that n*Q = P
      ns1 := Eltseq(n*s1);
      ns2 := Eltseq(n*s2);
      ns3 := Eltseq(n*s3);
      assert Valuation(ns1[jP]) eq 0
               and Valuation(ns2[jP]) eq 0 and Valuation(ns3[jP]) eq 0;
      ns1 := Vector([a/ns1[jP] + Onew : a in ns1]);
      ns2 := Vector([a/ns2[jP] + Onew : a in ns2]);
      ns3 := Vector([a/ns3[jP] + Onew : a in ns3]);
      ns := Vector([a/es[jP] + Onew : a in es]) where es := Eltseq(KF!PK);
      vprintf JacPtDivide, 3: "Target (P on Kummer surface):\n  %o\n", ns;
      vprintf JacPtDivide, 3:
              "Approximations:\n  %o\n  %o\n  %o\n", ns1, ns2, ns3;
      ds1 := ns1 - ns;
      ds2 := ns2 - ns;
      ds3 := ns3 - ns;
      vprintf JacPtDivide, 3: "Errors:\n  %o\n  %o\n  %o\n", ds1, ds2, ds3;
      // write ds1 as linear combination of ds2 and ds3 (or similar)
      mat := Matrix([ds1, ds2, ds3]);
      matker := MyKernel(mat, newprec-prec);
      vprintf JacPtDivide, 3: "Kernel of corresponding matrix:\n%o\n", matker;
      matker := [b : b in matker | Min([Valuation(c) : c in Eltseq(b)]) eq 0];
      assert #matker eq 1;
      b := matker[1];
      s := &+Eltseq(b);
      assert Valuation(s) eq 0;
      b := [a/s : a in Eltseq(b)];
      v, i := Min([Valuation(c) : c in b]);
      if i eq 1 then
        QK := KF![s1[i] + b[2]*(s2[i]-s1[i]) + b[3]*(s3[i]-s1[i]) + Onew
                   : i in [1..4]];
      elif i eq 2 then
        QK := KF![s2[i] + b[1]*(s1[i]-s2[i]) + b[3]*(s3[i]-s2[i]) + Onew
                   : i in [1..4]];
      else
        QK := KF![s3[i] + b[1]*(s1[i]-s3[i]) + b[2]*(s2[i]-s3[i]) + Onew
                   : i in [1..4]];
      end if;
      vprintf JacPtDivide, 2: "New approximate lift:\n%o\n", QK;
      assert Min([AbsolutePrecision(c) : c in Eltseq(QK)]) ge newprec;
      qs := Vector([a/es[jP] : a in es]) where es := Eltseq(n*QK);
      vprintf JacPtDivide, 3: "approx. error n*Q - P:\n%o\n", qs-ns;
      assert forall{i : i in [1..4] | Valuation(qs[i]-ns[i]) ge newprec};
      // compute approximation
      q := p^newprec;
      L := Lattice(4, ChangeUniverse(Eltseq(QK), Integers())
                       cat [q,0,0,0, 0,q,0,0, 0,0,q,0, 0,0,0,q]);
      app1 := Eltseq(Basis(L)[1]);
      // check if already found
      if app eq app1 and IsPoint(K, app1) then
        QK := K!app1;
        if n*QK eq PK then break; end if; // finish the prec while loop
      end if;
      prec := newprec; app := app1;
    end while;
    // now prec = b. Check if found
    if IsPoint(K, app) then
      QK := K!app;
      if n*QK eq PK then
        QJ := {Q : Q in Points(J, QK) | n*Q eq P};
        if not IsEmpty(QJ) then
          vprintf JacPtDivide, 1: "\nFound rational point Q = %o\n\n", Rep(QJ);
          return true, Rep(QJ);
        end if;
      end if;
    end if;
    vprintf JacPtDivide, 1:
            "Q = %o does not lift to a %o-division point of P\n", QpK, n;
  end for;
  // nothing found
  return false, _;
end intrinsic;

intrinsic Saturation(bas::SeqEnum[JacHypPt], p::RngIntElt : AuxPrimes := 3) -> SeqEnum
{Saturate the subgroup of the Mordell-Weil group generated by bas
 at the prime p. Returns generators of the free part of the saturated group.}
  J := Universe(bas);
  require IsPrime(p): "p must be a prime number.";
  // find a number (rank + AuxPrimes) of good primes q s.t. p|#J(F_q)
  require BaseField(J) cmpeq Rationals(): "P must be on a Jacobian over Q.";
  C := Curve(J);
  require Genus(C) eq 2: "P must be on a genus 2 Jacobian.";
  f, h := HyperellipticPolynomials(C);
  require h eq 0: "The curve of P's parent must be of the form y^2 = f(x).";
  require IsIntegral(C):
          "The curve of P's parent must have integral coefficients.";
  vprintf JacPtDivide, 1: "Saturation: p = %o, bas =\n%o\n", p, bas;
  T, mT := TorsionSubgroup(J);
  bas := ReducedBasis(bas);
  rank := #bas + #[i : i in Invariants(T) | IsDivisibleBy(i, p)];
  num := rank + AuxPrimes;
  disc := Integers()!Discriminant(Curve(J));
  q := 2;
  MW := AbelianGroup(Invariants(T) cat [0 : b in bas]);
  genMW := [mT(t) : t in OrderedGenerators(T)] cat bas;
  vprintf JacPtDivide, 2:
          "Generators of known subgroup (torsion first):\n%o\n", genMW;
  mMW := map<MW -> J | x :-> &+[J | s[i]*genMW[i] : i in [1..#genMW]]
                        where s := Eltseq(x)>;
  MWp, qmap := quo<MW | [p*g : g in Generators(MW)]>;
  curr := MWp;
  // curr is the subgroup of MW/p*MW of potentially p-divisible elements
  count := 0;
  while count lt num do
    repeat
      q := NextPrime(q);
      while IsDivisibleBy(disc, q) do q := NextPrime(q); end while;
      Jq := BaseChange(J, Bang(Rationals(), GF(q)));
      h := #Jq;
    until IsDivisibleBy(h, p);
    vprintf JacPtDivide, 2: "Found relevant prime q = %o\n", q;
    Gq, mGq := AbelianGroup(Jq);
    Gqp, Gqmap := quo<Gq | [p*g : g in Generators(Gq)]>;
    m := hom<curr -> Gqp
             | [Gqmap((Jq!mMW((MWp!g) @@ qmap)) @@ mGq)
                 : g in OrderedGenerators(curr)]>;
    curr := Kernel(m);
    vprintf JacPtDivide, 2: "Dimension of remaining space is %o\n",
                            Valuation(#curr, p);
    if #curr eq 1 then
      // no potential p-divisible elements left
      return bas;
    end if;
    count +:= 1;
  end while;
  // now check for elements of curr if they are p-divisible
  // finds subgroup (assumed of finite index) on which test is true
  // (assuming this _is_ a subgroup!)
  vprintf JacPtDivide, 1: "Trying to divide remaining points...\n";
  function test(g)
    return IsDivisibleBy(mMW((MWp!g) @@ qmap), p);
  end function;
  cbas := OrderedGenerators(curr);
  gens := [];
  new := [];
  As := { curr!0 }; // known part of quotient group
  for b in cbas do
    // find smallest multiple of b such that As + b meets the subgroup
    j := 1;
    bb := b;
    repeat
      for a in As do
        flag, d := test(bb+a);
        if flag then
          vprintf JacPtDivide, 1:
                  "Found divisible point; new generator is\n  %o\n", d;
          Append(~new, d);
          a0 := a;
          break;
        end if;
      end for;
      if not flag then
        j +:= 1;
        bb +:= b;
      end if;
    until flag;
    // note new kernel generator
    Append(~gens, bb + a0);
    // extend As to get set of representatives of the image of the
    // group generated by the first few generators of A in the quotient
    As := { a + i*b : i in [0..j-1], a in As };
  end for;
  curr := sub< curr | gens >;
  if #curr eq 1 then
    // no potential p-divisible elements left
    return bas;
  end if;
  // Otherwise, extend bas and repeat (not very efficient... should store
  // the mod q information computed above and re-use it)
  return Saturation(bas cat new, p : AuxPrimes := AuxPrimes);
end intrinsic;

//==========================================================================

// The following version (using IsDivisibleBy directly rather than Saturation)
// is more appropriate for the purpoese here, since the saturation check using
// reductions mod various primes has already been performed by GroupInfo.
function saturateatp(ptJ, p : repT := {})
  // Given a point ptJ of infinite order on a genus 2 Jacobian,
  // find a point that generates the free part of the p-saturation of <ptJ>.
  if IsEmpty(repT) then
    J := Parent(ptJ);
    T, mT := TorsionSubgroup(J);
    Tp, qmap := quo<T | [p*t : t in OrderedGenerators(T)]>;
    repT := {mT(t @@ qmap) : t in Tp}; // representatives of torsion points mod p*torsion
  end if;
  for t in repT do
    flag, pt := IsDivisibleBy(ptJ + t, p);
    if flag then
      // recurse
      return saturateatp(pt, p : repT := repT);
    end if;
  end for;
  // not divisible
  return ptJ;
end function;

// function saturateatp(ptJ, p)
//   // Given a point ptJ of infinite order on a genus 2 Jacobian,
//   // find a point that generates the free part of the p-saturation of <ptJ>.
//   return Saturation([ptJ], p : AuxPrimes := 1)[1];
// end function;

//==========================================================================

intrinsic Chabauty(ptJ::JacHypPt : ptC := 0,
                   PrimeBound := 30, SmoothBound := 50, Epsilon := 1e-1,
                   CheckBound := 300, GiveUpBound := 1000, Saturate := true)
                    -> SetEnum, SetEnum, SeqEnum
{For a curve C of genus 2 over Q, this returns the full set of rational points,
 using Chabauty's method combined with a Mordell-Weil sieve. There are two
 conditions: (i) the Jacobian of C has rank 1 and the given point ptJ has infinite order,
 and (ii) the set of rational points on C is non-empty.
 The optional argument ptC, if given, should be a rational point on C.
 If Saturate is set to false, then it is assumed that ptJ generates the free part of
 the Mordell-Weil group and the computation is faster. If the assumption does not hold,
 then the result may be incorrect in this case.}

  J := Parent(ptJ);
  C := Curve(J);
  require Genus(C) eq 2: "The curve should have genus 2.";

  if ptC cmpne 0 then
    require Curve(Parent(ptC)) cmpeq C and Ring(Parent(ptC)) cmpeq Rationals() :
           "The optional argument ptC should be a rational point on the curve";
  else
    vprintf Chabauty: " Searching for a rational point on the curve ... "; vtime Chabauty:
    for n := 0 to 16 by 2 do
      pts := Points(C : Bound := 2^n);
      if #pts gt 0 then break; end if;
    end for;
    require not IsEmpty(pts):
            "No rational point found on the curve. Please provide one through the ptC argument.";
    ptC := pts[1];
    vprintf Chabauty, 1: " Found point %o.\n", ptC;
  end if;

  f, h := HyperellipticPolynomials(C);
  require h eq 0: "Curve must be of the form y^2 = f(x).";
  require Order(ptJ) eq 0: "ptJ must be a point of infinite order.";
  // find torsion subgroup and hence generators of J(Q)
  T, mT := TorsionSubgroup(J);
  vprintf Chabauty, 1: " Torsion subgroup has invariants %o.\n", Invariants(T);
  saturated := {Integers() | }; // primes at which <ptJ> + torsion is known to be saturated
  if Saturate then
    // saturate at primes dividing #T
    vprintf Chabauty, 2: " Saturating at primes dividing the torsion order...\n";
    for p in PrimeDivisors(#T) do
      vprintf Chabauty, 2: "  saturating at p = %o...\n", p;
      newptJ := Saturation([ptJ] cat [mT(t) : t in OrderedGenerators(T)], p)[1];
      Include(~saturated, p);
      if newptJ ne ptJ then
        vprintf Chabauty, 1: " Saturation at %o enlarges group.\n", p;
        ptJ := newptJ;
      end if;
    end for;
  end if;
  bas := [ptJ] cat [mT(t) : t in OrderedGenerators(T)];
  ht := Height(ptJ);
  hc := HeightConstant(J);
  // compute GroupInfo for sufficiently many primes
  // initialize
  oldbound := 2; // lower bound for reduction primes
  GI := [];      // GroupInfo structure
  b := 10;       // upper bound for reduction primes (will be doubled)
  est := 1.0;    // will be used for value estimating quality of information obtained
  Bs := {};      // set of B such that rational points are separated in J(Q)/B*J(Q)
  tosaturate := {Integers() | }; // primes at which we have to saturate
  while true do
    // loop is executed until success (or failure)
    vprintf Chabauty, 1: " Computing GroupInfo...\n";
    checked := false; // flag indicating whether elliptic subcovers have been checked
    while est ge Epsilon or IsEmpty(Bs) do
      // information not yet sufficient or no separating B found so far
      if b ge CheckBound and not checked and est lt Epsilon then
        // information sufficient, no check for elliptic subcovers yet
        //  ==> check for elliptic subcovers
        vprintf Chabauty, 1: " No useable prime found so far.\n";
        vprintf Chabauty, 1: "   checking for elliptic subcovers...\n\n";
        subcov := Degree2Subcovers(C);
        vprintf Chabauty, 1: "  %o degree 2 subcovers found.\n\n", #subcov;
        if IsEmpty(subcov) then
          subcov := Degree3Subcovers(C);
          vprintf Chabauty, 1: "  %o degree 3 subcovers found.\n\n", #subcov;
        end if;
        if not IsEmpty(subcov) then
          // find an E such that ptJ maps to torsion
          ptJa := ptJ[1];
          ptJb := ptJ[2];
          ptJd := ptJ[3];
          facta := Factorization(ptJa);
          infd := ptJd - Degree(ptJa);
          // take representative points with multiplicities
          rep := [];
          for ff in facta do
            if Degree(ff[1]) eq 1 then
              xP := -Coefficient(ff[1], 0)/Coefficient(ff[1], 1);
              Append(~rep, <C![xP, Evaluate(ptJb, xP)], ff[2]>);
            else
              KP := ext<BaseField(C) | ff[1]>;
              xP1 := KP.1;
              xP2 := -Coefficient(ff[1], 1)/Coefficient(ff[1], 2) - xP1;
              Append(~rep, <C(KP)![xP1, Evaluate(ptJb, xP1)], ff[2]>);
              Append(~rep, <C(KP)![xP2, Evaluate(ptJb, xP2)], ff[2]>);
            end if;
          end for;
          if infd gt 0 then
            Append(~rep, <C![1, Coefficient(ptJb, 3), 0], infd>);
          end if;
          // Find an E where the image of ptJ is torsion, and check
          // for preimages of torsion points on E.
          // Note: we assume without checking that this E has rank 0,
          // which follows from the assumptions that J has rank <= 1
          // and ptJ has infinite order.
          for pair in subcov do
            E := pair[1];
            vprintf Chabauty, 1: "  Checking image of ptJ on\n  %o...\n", E;
            mCE := Extend(pair[2]);
            // map to E and add
            imP := E(BaseField(E))!&+[a[2]*mCE(a[1]) : a in rep];
            if Order(imP) ne 0 then
              // point is torsion ==> OK
              vprintf Chabauty, 1: "  ... image is torsion ==> OK!\n\n";
              T, mT := TorsionSubgroup(E);
              vprintf Chabauty, 1: "  E has %o torsion points\n", #T;
              ptsE := {mT(t) : t in T};
              result := &join{Points(pt @@ mCE) : pt in ptsE};
              vprintf Chabauty, 1: "giving points on C: %o\n", result;
              return result, {}, [];
            else
              vprintf Chabauty, 1:
                      "  ... image has infinite order ==> continue\n\n";
            end if;
          end for;
          require false: "The given Jacobian J should have rank 1.\n"*
                         "(Instead, this J is isogenous to a product of \n"*
                         "elliptic curves that both have rank at least 1)";
        end if;
        checked := true; // check for elliptic subcovers has been done
      end if;
      if b ge GiveUpBound and est lt Epsilon then
        // b too large and information sufficient ==> give up
        // try to find rational killing differential
        L := Lattice(IdentityMatrix(Integers(), 2));
        for entry in GI do
          p := entry[1];
          a, b := Explode(ChangeUniverse(Eltseq(entry[5]), Integers()));
          L meet:= Lattice(Matrix([[p, 0], [0, p], [-b, a]]));
        end for;
        sv := ShortestVectors(L)[1];
        if (sv, sv) lt Log(Determinant(L)) then
          ptsC := Points(C, sv[2] eq 0 select Infinity() else sv[1]/sv[2]);
          if not IsEmpty(ptsC) then
            printf "Chabauty: Global killing differential %oomega_0\n"
                     *"vanishing at the rational point %o detected.\n",
                   sv[2] eq 0 select ""
                              else sv[1] eq 0 select Sprintf("%o ", Parent(f).1)
                              else Sprintf("(%o)", Parent(f).1 - sv[1]/sv[2]),
                   Rep(ptsC);
          end if;
        end if;
//        require false:
        print "No useable prime found.\nMost likely, "*
                       "C covers an elliptic curve, with map of degree > 3.";
        return {}, {}, GI;
      end if;
      b *:= 2; // double upper bound for reduction primes
      vprintf Chabauty, 1: "   for bound = %o...\n", b;
      // compute new information
      nGI, saturated, satunknown
        := GroupInfo(J, b, bas, ptC, oldbound, PrimeBound, SmoothBound : satknown := saturated);
      // include information on differentials killing J(Q)
      nGI := [CheckKillingDifferential(f, ptJ, entry) : entry in nGI];
      tosaturate join:= satunknown;
      tosaturate diff:= saturated;
      // find new separating B's and update set of (minimal w.r.t. divisibility) separating B's
      Bs := GetMinimalDivisors(Bs join FindMinimalBs(nGI));
      vprintf Chabauty, 1: "  set of minimal Bs found so far:\n    %o\n", Bs;
      oldbound := b; // update lower bound (= previous upper bound) for reduction primes
      GI cat:= nGI;  // extend GroupInfo structure
      // compute heuristic value indicating sufficiency of information
      est := CheckInvariant(GI, #T);
      vprintf Chabauty, 1: "   check value is %o.\n", est;
    end while;
    vprintf Chabauty, 2: " Saturation was checked at the primes in %o.\n", saturated;
    // saturate if necessary (and not excluded)
    if not IsEmpty(tosaturate) and Saturate then
      vprintf Chabauty, 1: " Need to saturate at primes in %o.\n", tosaturate;
      ptJnew := ptJ;
      for p in tosaturate do
        vprintf Chabauty, 2: "  Saturating at p = %o...\n", p;
        ptJnew := saturateatp(ptJnew, p);
      end for;
      // update sets of primes at which saturation is known/necessary
      saturated join:= tosaturate;
      tosaturate := {Integers() | };
      if ptJnew ne ptJ then
        // saturation has changed the group ==> start from scratch
        vprintf Chabauty, 1: " `Generator' was replaced ==> start over.\n";
        ptJ := ptJnew;
        bas := [ptJ] cat [mT(t) : t in OrderedGenerators(T)];
        ht := Height(ptJ);
        oldbound := 2;
        GI := [];
        b := 10;
        est := 1.0;
        Bs := {};
        continue;
      end if;
    end if;
    // Based on the information obtained, find heuristically optimal sequence of primes
    // whose product N separates the rational points on C in J(Q) and such that
    // the Mordell-Weil sieve computation is likely to succeed in proving that
    // cosets without points from C have this property.
    run, flag := dryRun1(GI, PrimeBound, 5*Epsilon, #T, Bs);
    if not flag then
      // expected size goal not reached: need more information
      vprintf Chabauty, 1:
              " No good run found  ==>  reduce Epsilon and start over.\n";
      Epsilon *:= 0.5;
      continue;
    end if;
    // Now run the Mordell-Weil sieve computation.
    // initialize
    result := {C|}; // rational points found on C
    primes := {};   // set of reduction primes where information was actually used
    B := 1;         // we are looking at cosets of B*J(Q) in J(Q)
    cands := {<0, t> : t in T}; // remaining cosets, represented as <n, t> for n*ptJ + t + B*J(Q)
    for j := 1 to #run do
      p := run[j,1]; // next prime factor of B
      // find remaining cosets mod new B = (old B)*p
      cands, pr := LiftInformation(cands, GI, B, p);
      primes join:= pr; // update the set of reduction primes used
      B *:= p;          // update B
      vprintf Chabauty, 1: "    B = %o, size = %o (predicted: %o)\n",
                           B, #cands, Round(run[j,2]);
      if IsEmpty(cands) then
        // Success!
        vprintf Chabauty, 1: "  No more points!\n";
        assert Points(C : Bound := 1000) subset result; // sanity check
        return result, primes, [run[i,1] : i in [1..j]];
      end if;
      // otherwise check if rational points are separated
      if exists{b : b in Bs | IsDivisibleBy(B, b)} then
        // For each candidate coset, try to identify a rational point from the curve in it
        // (we know there can be at most one).
        if IsVerbose("Chabauty", 3) then
          printf "   current list:\n   ";
          for c in cands do printf " %o", c; end for;
          printf "\n";
        end if;
        oldcands := cands;
        cands := {};       // this will contain the cosets that are still undecided
        while not IsEmpty(oldcands) do
          vprintf Chabauty, 2: "  %o candidate%o remaining.\n",
                               #oldcands, #oldcands eq 1 select "" else "s";
          c := Rep(oldcands);
          vprintf Chabauty, 2: "   Checking candidate %o...\n", c;
          // take point of smallest canonical height in coset
          l := 2*c[1] le B select c[1] else c[1]-B;
          // check if it comes from the curve
          flag, pt := CheckPoint(bas[1], l, mT(c[2]), ptC, l^2*ht+hc);
          if flag then
            vprintf Chabauty, 1: "  Point %o on C found!\n", pt;
            Include(~result, pt);
            // Remove all candidates excluded by the fact that rational points on C
            // are separated by the numbers in Bs.
            dl := {d : d in Bs | IsDivisibleBy(B, d)};
            for d in dl do
              Td := sub<T | [d*t : t in OrderedGenerators(T)]>;
              oldcands := {oc : oc in oldcands
                              | not (IsDivisibleBy(oc[1]-c[1], d)
                                      and oc[2]-c[2] in Td)};
              cands :=    {oc : oc in cands
                              | not (IsDivisibleBy(oc[1]-c[1], d)
                                      and oc[2]-c[2] in Td)};
            end for;
          else
            // move to cands
            Exclude(~oldcands, c);
            Include(~cands, c);
          end if; // flag
        end while; // not IsEmpty(oldcands)
        if IsEmpty(cands) then
          // Success!
          vprintf Chabauty, 1: "  No more points!\n";
          assert Points(C : Bound := 1000) subset result; // sanity check
          return result, primes, [run[i,1] : i in [1..j]];
        end if;
      end if; // exists{b : b in Bs | IsDivisibleBy(B, b)}
    end for; // j := 1 to #run
    // run used up, but some classes left undecided
    vprintf Chabauty, 1:
            not Saturate select " Some classes unresolved ==> reduce Epsilon and start over.\n"
            else " Some classes unresolved ==> reduce Epsilon, improve saturation, and start over.\n";
    Epsilon *:= 0.1;
    if Saturate then
      // find smallest prime p such that group is not known to be p-saturated
      p := 1; repeat p := NextPrime(p); until p notin saturated;
      // and saturate
      ptJnew := saturateatp(ptJ, p);
      Include(~saturated, p);
      if ptJnew ne ptJ then
        vprintf Chabauty, 2: " Saturation at %o gives new generator\n", p;
        oldbound := 2;
        GI := [];
        b := 10;
        est := 1.0;
        Bs := {};
        ptJ := ptJnew;
        bas := [ptJ] cat [mT(t) : t in OrderedGenerators(T)];
        ht := Height(ptJ);
      end if;
    end if;
  end while;
  // never reached
end intrinsic;


