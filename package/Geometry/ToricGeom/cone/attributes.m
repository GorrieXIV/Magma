freeze;

////////////////////////////////////////////////////////////////////////
// attributes.m
/////////////////////////////////////////////////////////////////////////
// $Revision: 39050 $
// $Date: 2012-07-01 00:22:01 +1000 (Sun, 01 Jul 2012) $
// $LastChangedBy: kasprzyk $
/////////////////////////////////////////////////////////////////////////
// Authors: Gavin Brown, Jaroslaw Buczynski, Alexander Kasprzyk
/////////////////////////////////////////////////////////////////////////
// Intrinsics for returning attributes of cones.
/////////////////////////////////////////////////////////////////////////
// Note
// ====
// The distinction between "properties" and "attributes" is totally of my
// own invention. Approximately speaking:
//  * if the questions is of the form "is it true that...?" -- i.e. if the
//    instrisic can be named "IsProperty(C)" -- then I regard it as a
//    property and it belongs in "property.m";
//  * if the question is more a request ("tell me the dimension", "give
//    me the...") then I regard it as an attribute.
/////////////////////////////////////////////////////////////////////////

import "../utilities/strings.m": impose_brackets;
import "../utilities/functions.m": next_seq_of_k_subsets;
import "../lattice/lattice.m": dual_lattice_string;
import "generators.m": are_R_generators_minimal;

declare attributes TorCon:
    lattice,                // The ambient toric lattice 
    dim,                    // The dimension of the cone
    index,                  // Index of the cone in the R-spanned lattice
    cone_in_sublattice,     // The cone in the lower dimensional sublattice
                            // i.e. in the R-linear span of itself
    cone_in_sublattice_map, // ...and the corresponding lattice map
    quotient_map;           // Quotient of L by the lin subspace contained in C

/////////////////////////////////////////////////////////////////////////
// Local Functions
/////////////////////////////////////////////////////////////////////////

// Copies the data from "C" to "dC".
// Note: Doesn't attempt to set the sublattice data.
procedure attributes_copy(C,dC)
    if assigned C`lattice then
        dC`lattice:=C`lattice; end if;
    if assigned C`dim then
        dC`dim:=C`dim; end if;
    if assigned C`index then
        dC`index:=C`index; end if;
    if assigned C`quotient_map then
        dC`quotient_map:=C`quotient_map; end if;
end procedure;

// Sets the data of "dC" equal to minus "C".
// Note: Doesn't attempt to set the sublattice data.
procedure attributes_minus(C,dC)
    if assigned C`lattice then
        dC`lattice:=C`lattice; end if;
    if assigned C`dim then
        dC`dim:=C`dim; end if;
    if assigned C`index then
        dC`index:=C`index; end if;
end procedure;

// Sets the data of "dC" equal to "C", but with the ambient changed to "L".
// Note: Doesn't attempt to set the sublattice data.
procedure attributes_change_ambient(C,dC,L)
    dC`lattice:=L;
    if assigned C`dim then
        dC`dim:=C`dim; end if;
    if assigned C`index then
        dC`index:=C`index; end if;
end procedure;

// True iff the matrix generated by the sequence 'a' has absolute det = 1.
// Also returns the subsequence which gave that determinant.
function has_det_1(a,n)
    s:=[1];
    k:=1;
    repeat
        i:=a[s];
        M:=Matrix(i);
        r:=Rank(M);
        if r lt k then 
            bool,s:=next_seq_of_k_subsets(s,#a,k);
        else
            ind:=Minor(SmithForm(M),[1..k],[1..k]);
            if ind eq 1 then
                if k eq n then return true,i; end if;
                Append(~s,s[k]+1);
                k+:=1;
                bool:=s[k] le #a;
            else 
                bool,s:=next_seq_of_k_subsets(s,#a,k);
            end if;
        end if;
    until not bool;
    return false,a;
end function;

// Returns true iff the cone C is contained in the positive orthant
function is_in_positive_orthant(C)
    return &and[&and[c ge 0 : c in Eltseq(r)] : r in Rays(C)];
end function;

// Performs a change of basis s.t. C lies in the positive orthant. Returns
// the new C.
function move_to_positive_orthant(C)
    if is_in_positive_orthant(C) then
        return C;
    end if; 
    B:=LatticeBasisInCone(Dual(C));
    return Cone([Ambient(C) | [r * b : b in B] : r in Rays(C)]);
end function;

/////////////////////////////////////////////////////////////////////////
// Intrinsics
/////////////////////////////////////////////////////////////////////////

intrinsic LinearSpanEquations(C::TorCon) -> SeqEnum[TorLatElt]
{The sequence of equations of the minimal linear subspace containing the cone C}
    equs:=LinearSpanEquations(RGenerators(C));
    C`dim:=Dimension(Ambient(C)) - #equs;
    return equs;
end intrinsic;

intrinsic LinearSpanGenerators(C::TorCon) -> SeqEnum[TorLatElt]
{The sequence of generators of the minimal linear subspace containing the cone C}
    equs:=LinearSpanGenerators(RGenerators(C));
    C`dim:=#equs;
    return equs;
end intrinsic;

intrinsic LinearSubspaceGenerators(C::TorCon) -> SeqEnum[TorLatElt]
{The basis of the maximal linear subspace contained in the cone C}
    return LinearSpanEquations(Dual(C));
end intrinsic;

intrinsic ConeInSublattice(C::TorCon) -> TorCon, Map[TorLat,TorLat]
{The cone of maximal dimension given by the intersection of the cone C with its linear span, together with the embedding of the sublattice in the ambient toric lattice}
    if not assigned C`cone_in_sublattice then
        eqs:=LinearSpanEquations(C);
        if IsEmpty(eqs) then
            C`cone_in_sublattice:=C;
            C`cone_in_sublattice_map:=IdentityMap(Ambient(C));
        else
            map_seq:=[Ambient(C)|v:v in Basis(Kernel(Transpose(Matrix(eqs))))];
            L,phi:=Sublattice(map_seq);
            CL:=C @@ phi;
            CL`are_Rgens_minimal:=are_R_generators_minimal(C);
            CL`dim:=Dimension(L);
            if assigned C`Zgens then
                CL`Zgens:=C`Zgens @@ phi;
            end if;
            if assigned C`is_simplicial then
                CL`is_simplicial:=IsSimplicial(C);
            end if;
            if assigned C`dual then
                D:=Dual(C);
                DL:=Dual(CL);
                DL`are_Rgens_minimal:=are_R_generators_minimal(D);
                if assigned D`dim then
                    DL`dim:=Dimension(D) - Dimension(Ambient(C))+ Dimension(CL);
                end if;
                if assigned D`Zgens then
                    Dphi:=Dual(phi);
                    DL`Zgens:=[Codomain(Dphi) | v : v in Image(Dphi,D`Zgens) |
                                                                not IsZero(v)];
                end if;
            end if;
            C`cone_in_sublattice:=CL;
            CL`cone_in_sublattice:=CL;
            C`cone_in_sublattice_map:=phi;
            CL`cone_in_sublattice_map:=IdentityMap(L);
        end if;
    end if;
    return C`cone_in_sublattice,C`cone_in_sublattice_map;
end intrinsic;

intrinsic ConeQuotientByLinearSubspace(C::TorCon) -> TorCon, Map[TorLat,TorLat] 
{The stricly convex cone given by the quotient of the cone C by its maximal linear subspace, together with the quotient map}
    CL,phi:=ConeInSublattice(Dual(C));
    return Dual(CL),Dual(phi);
end intrinsic;

intrinsic Quotient(C::TorCon :
    name:="quo" cat impose_brackets(PrintName(Ambient(C))),
    dual_name:=dual_lattice_string(name))
    -> TorLat, Map[TorLat,TorLat]
{The quotient of the ambient lattice by the linear subspace contained in the cone C, together with the quotient map}
    if not assigned C`quotient_map then 
         _,proj:=Quotient(RGenerators(C): name:=name, dual_name:=dual_name);
         C`quotient_map:=proj;
    end if;
    return Codomain(C`quotient_map),C`quotient_map;
end intrinsic;

intrinsic Rays(C::TorCon) -> SeqEnum[TorLatElt]
{The sequence of generators of the rays of C. If C is strictly convex, this equals the minimal RGenerators. If it is a cone times a line, then returns plus and minus on the line. Otherwise, empty.}
    if IsStrictlyConvex(C) then 
        return MinimalRGenerators(C);
    end if;
    B:=LinearSubspaceGenerators(C);
    if #B eq 1 then 
        return [Ambient(C) | v, -v] where v is Representative(B);
    end if;
    return [Ambient(C)|];
end intrinsic;

intrinsic Ray(C::TorCon,i::RngIntElt) -> TorLatElt
{The i-th ray of the cone C}
    rays:=Rays(C);
    requirerange i,1,#rays;
    return rays[i];
end intrinsic;

intrinsic Dimension(C::TorCon) -> RngIntElt
{The dimension of cone C}
    if not assigned C`dim then
        if assigned C`is_of_max_dim and C`is_of_max_dim then
            C`dim:=Dimension(Ambient(C));
        else
            gens:=RGenerators(C);
            C`dim:=IsEmpty(gens) select 0 else Rank(Matrix(gens));
        end if;
    end if;
    return C`dim;
end intrinsic;

intrinsic Ambient(C::TorCon) -> TorLat
{The ambient lattice of the cone C}
    if not assigned C`lattice then
        if assigned C`Rgens then
            C`lattice:=Universe(C`Rgens);
        elif assigned C`dual then
            D:=Dual(C);
            if assigned D`lattice then
                C`lattice:=Dual(D`lattice);
            elif assigned D`Rgens then
                C`lattice:=Dual(Universe(D`Rgens));
            end if;
        end if;
        require assigned C`lattice: "Unable to recover ambient lattice";
    end if;
    return C`lattice;
end intrinsic;

intrinsic Grading(C::TorCon) -> TorLatElt
{The grading of the ambient of C}
    return Grading(Ambient(C));
end intrinsic;

intrinsic SimplicialSubcone(C::TorCon) -> TorCon
{A simplex of dimension equal to dimension of C, contained in C}
    if IsSimplicial(C) then  
        return C;
    end if;
    rgens:=MinimalRGenerators(C);
    new:=[Universe(rgens) | rgens[1]];
    i:=2;
    bool:=false;
    while not bool do
        new2:=Append(new,rgens[i]);
        M:=Matrix(new2);
        if Rank(M) eq #new2 then
            new:=new2;
            bool:=#new eq Dimension(C);
        end if;
        i +:= 1;
    end while;
    S:=Cone(new);
    S`is_simplicial:=true;
    S`are_Rgens_minimal:=true;
    S`is_linear_space:=false;
    S`dim:=Dimension(C);
    return S;
end intrinsic;

intrinsic LatticeBasisInCone(C::TorCon) -> SeqEnum[TorLatElt]
{If the cone C is of maximal dimension, gives a basis of its ambient lattice elements of which lie in C}
    require IsMaximumDimensional(C): "Cone is not of maximal dimension";
    SC:=SimplicialSubcone(C);
    n:=Dimension(Ambient(SC));
    S:=[Ambient(SC) | PrimitiveLatticeVector(v) : v in RGenerators(SC)];
    bool,basis:=has_det_1(S,n);
    if not bool then
        if not are_R_generators_minimal(SC) then 
            bool,basis:=has_det_1(MinimalRGenerators(SC),n);
        end if;
        if not bool then
            basis:=ZGenerators(SC);
            _,basis:=has_det_1(basis, n);
        end if;
    end if;
    return basis;
end intrinsic;

intrinsic PointInInterior(C::TorCon) -> TorLatElt
{An arbitrary point in the relative interior of the cone C}
    return PrimitiveLatticeVector(&+RGenerators(C));
end intrinsic;

intrinsic Representative(C::TorCon) -> TorLatElt
{A representative element of the cone C}
    return Zero(Ambient(C));
end intrinsic;

intrinsic Index(C::TorCon) -> RngIntElt
{The index of the sublattice generatated by the minimal R-generators of the cone C in its linear span}
    if not assigned C`index then
        rgens:=MinimalRGenerators(C);
        if IsEmpty(rgens) then 
            C`index:=1;
        else
            C`index:=Index(rgens);
        end if;
    end if;
    return C`index;
end intrinsic;

intrinsic Ideal(K::Rng,C::TorCon) -> RngMPol
{The toric ideal defined by the cone C}
    // We need C to be of maximum dimension in the lattice, and to lie in
    // the positive orthant
    C:=move_to_positive_orthant(ConeInSublattice(C));
    // Compute the relations
    B:=[Eltseq(pt) : pt in ZGenerators(C)];
    b:=#B;
    d:=Dimension(Ambient(C));
    R:=PolynomialRing(K,b + d);
    gens:=[R.j - &*[R.(b + i)^B[j][i] : i in [1..d]] : j in [1..b]];
    rels:=EliminationIdeal(Ideal(gens),{R.i : i in [1..b]});
    // Recreate the ideal in the smaller ring
    RR:=PolynomialRing(K,b);
    gens:=[RR|];
    for gen in Generators(rels) do
        coeffs,mons:=CoefficientsAndMonomials(gen);
        Append(~gens,&+[coeffs[i] * &*[RR.j^e[j] : j in [1..b]]
                                where e:=Exponents(mons[i]) : i in [1..#mons]]);
    end for;
    return ideal<RR | gens>;
end intrinsic;
