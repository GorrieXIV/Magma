freeze;

/////////////////////////////////////////////////////////////////////////
// mmp.m
/////////////////////////////////////////////////////////////////////////
// $Revision: 42282 $
// $Date: 2013-03-05 05:22:02 +1100 (Tue, 05 Mar 2013) $
// $LastChangedBy: kasprzyk $
/////////////////////////////////////////////////////////////////////////
// Authors: Gavin Brown, Jaroslaw Buczynski, Alexander Kasprzyk
/////////////////////////////////////////////////////////////////////////
// Implements the toric Minimal Model Programme.
/////////////////////////////////////////////////////////////////////////

import "../variety/divisor.m": get_curves, intersection_form;

declare attributes TorVar:
    extremal_rays_divisors,
    nef_cone;

/////////////////////////////////////////////////////////////////////////
// Local functions
/////////////////////////////////////////////////////////////////////////

// Returns a sequence S of divisors on X. S[i] exists iff the divisor defining
// i-th extremal ray is already known.
function extremal_ray_contraction_divisors_sequence(X)
    if not assigned X`extremal_rays_divisors then 
        X`extremal_rays_divisors:=[DivisorGroup(X)|];
    end if;
    return X`extremal_rays_divisors;    
end function;

// Returns true iff i is a valid index for an extremal ray. If false, also
// returns a string to be used as an error message.
function valid_extremal_index(X,i,divisor,inequality)
    if i le 0 then
        return false, "The index of the extremal ray must be a positive integer";
    end if;
    nef_cone:=NefCone(X);
    if Dimension(nef_cone) gt 1 then
        extr_rays:=ExtremalRays(X : divisor:=divisor, inequality:=inequality);
        if i gt #extr_rays then
            return false, Sprintf("The index of the extremal ray must be in the range [1..%o]",#extr_rays);
        end if;
    else
        if i gt 1 then
            return false, "The index of the extremal ray must be in the range [1..1]";
        end if;
    end if;
    return true,_;
end function;

// Returns true iff the arguments are valid. If false, also returns a string to
// be used as an error message.
function valid_divisor_and_inequality(X,divisor,inequality)
    if Type(inequality) ne MonStgElt or (inequality ne "strong" and
        inequality ne "weak") then
        return false,"'inequality' must be either \"strong\" or \"weak\"";
    end if;
    if Type(divisor) ne DivTorElt or Variety(divisor) ne X then
        return false,"'divisor' must a divisor on the toric variety";
    end if;
    if divisor eq CanonicalDivisor(X) then
        if not IsQCartier(divisor) then
            return false,"The canonical divisor must be Q-Cartier";
        end if;
    else
        if not IsQCartier(divisor) then
            return false,"'divisor' must be Q-Cartier";
        end if;
    end if;
    return true,_;
end function;

// Returns the index of the X in the given sequence of varieties. The fans are
// tested for equality.
function index_of_variety(X,Ys)
    F:=Fan(X);
    for i in [1..#Ys] do
        if Fan(Ys[i]) eq F then return i; end if;
    end for;
    return 0;
end function;

/////////////////////////////////////////////////////////////////////////
// Intrinsics
/////////////////////////////////////////////////////////////////////////

intrinsic NefCone(X::TorVar) -> TorCon
{The nef-cone of the toric variety X}
    if not assigned X`nef_cone then
/*        if BaseRing(X) cmpeq Rationals() and
           NumberOfQuotientGradings(X) eq 0 and
           IsQFactorial(X) and
           IsFano(X) then
            L:=PicardLattice(X);
            M:=ChangeUniverse(RowSequence(Transpose(Matrix(Gradings(X)))),L);
            mK:=&+M;
            cones:=[];
            for idx in Subsets({1..#M},Dimension(L)) do
                C:=Cone([L | M[j] : j in idx]);
                if mK in C then
                    Append(~cones,C);
                end if;
            end for;
            X`nef_cone:=&meet cones;
        else*/
            F:=Fan(X);
            L:=Ambient(F);
            X`nef_cone:=ConeWithInequalities(IntersectionForms(X));
//        end if;
    end if;
    return X`nef_cone;
end intrinsic;

intrinsic MoriCone(X::TorVar) -> TorCon
{The Mori Cone of toric variety X (i.e. the cone generated by the numerical classes of torus invariant curves on X)}
    return Dual(NefCone(X));
end intrinsic;

intrinsic ExtremalRays(X::TorVar : divisor:=CanonicalDivisor(X),
    inequality:="strong") -> TorCon
{The sequence of numerical classes of curves which are extremal rays in the sence of Mori Theory. Their intersection with the Q-Cartier divisor specified by the parameter 'divisor' (by default the canonical divisor) is negative (by default the inequality is "strong", but can be set to "weak") and are rays of the Mori cone.}
    // Sanity checks
    bool,err:=valid_divisor_and_inequality(X,divisor,inequality);
    require bool: err;
    // Return the rays
    class:=PicardClass(divisor);
    return inequality eq "weak" select
        [ray : ray in MinimalInequalities(NefCone(X)) | class * ray le 0] else
        [ray : ray in MinimalInequalities(NefCone(X)) | class * ray lt 0];
 end intrinsic;

intrinsic ExtremalRayContractionDivisor(X::TorVar,i::RngIntElt :
    divisor:=CanonicalDivisor(X), inequality:="strong") -> SeqEnum[DivTorElt]
{The divisor on X defining the contraction of the i-th extremal ray of the toric variety X}
    // Sanity checks
    bool,err:=valid_divisor_and_inequality(X,divisor,inequality);
    require bool: err;
    bool,err:=valid_extremal_index(X,i,divisor,inequality);
    require bool: err;
    // Compute the corresponding vector and index
    nef_cone:=NefCone(X);
    if Dimension(nef_cone) gt 1 then
        extr_ray:=ExtremalRays(X : divisor:=divisor,inequality:=inequality)[i];
        index:=Index(MinimalInequalities(nef_cone),extr_ray);
        facet:=FaceSupportedBy(nef_cone,extr_ray);
        vector:=PointInInterior(facet);
    else
        vector:=Zero(PicardLattice(X));
        index:=1;
    end if;
    if not IsDefined(extremal_ray_contraction_divisors_sequence(X),index) then
        X`extremal_rays_divisors[index]:=Representative(X,vector);
    end if;
    // Return the divisor
    return extremal_ray_contraction_divisors_sequence(X)[index];
end intrinsic;

intrinsic ExtremalRayContraction(X::TorVar,i::RngIntElt :
    divisor:=CanonicalDivisor(X), inequality:="strong") -> TorVar
{The image of contraction of i-th extremal ray of the toric variety X}
    // Sanity checks
    bool,err:=valid_divisor_and_inequality(X,divisor,inequality);
    require bool: err;
    bool,err:=valid_extremal_index(X,i,divisor,inequality);
    require bool: err;
    // Return the corresponding variety
    D:=ExtremalRayContractionDivisor(X,i : divisor:=divisor,
                                                        inequality:=inequality);
    return IsPrincipal(D) select ToricVariety(BaseRing(X)) else Proj(D);
end intrinsic;

// THINK: It shouldn't be necessary to construct the contraction as a variety.
// Instead, it should be enough to compute the dimension of then polyhedron.
intrinsic IsMoriFibreSpace(X::TorVar,i::RngIntElt :
    divisor:=CanonicalDivisor(X), inequality:="strong") -> BoolElt
{True iff the contraction of the i-th extremal ray is a Mori fibre space}
    // Sanity checks
    bool,err:=valid_divisor_and_inequality(X,divisor,inequality);
    require bool: err;
    bool,err:=valid_extremal_index(X,i,divisor,inequality);
    require bool: err;
    // Return the result
    return Dimension(ExtremalRayContraction(X,i : divisor:=divisor,
                                       inequality:=inequality)) lt Dimension(X);
end intrinsic;

// THINK: It shouldn't be necessary to construct the contraction as a variety.
// Instead, it should be enough to count the facets of the polyhedron.
intrinsic IsDivisorialContraction(X::TorVar,i::RngIntElt :
    divisor:=CanonicalDivisor(X), inequality:="strong") -> BoolElt
{True iff the contraction of the i-th extremal ray is a divisorial contraction}
    // Sanity checks
    bool,err:=valid_divisor_and_inequality(X,divisor,inequality);
    require bool: err;
    bool,err:=valid_extremal_index(X,i,divisor,inequality);
    require bool: err;
    // Return the result
    extr:=ExtremalRayContraction(X,i : divisor:=divisor,inequality:=inequality);
    return Dimension(extr) eq Dimension(X) and Length(extr) lt Length(X);
end intrinsic;

// THINK: It shouldn't be necesary to construct the contraction as a variety.
// Instead, it should be enough to count the facets of the polyhedron.
intrinsic IsFlipping(X::TorVar,i::RngIntElt:
    divisor:=CanonicalDivisor(X), inequality:="strong") -> BoolElt
{True iff the contraction of the i-th extremal ray is flipping}
    // Sanity checks
    bool,err:=valid_divisor_and_inequality(X,divisor,inequality);
    require bool: err;
    bool,err:=valid_extremal_index(X,i,divisor,inequality);
    require bool: err;
    // Return the result
    extr:=ExtremalRayContraction(X,i : divisor:=divisor,inequality:=inequality);
    return Dimension(extr) eq Dimension(X) and Length(extr) eq Length(X);
end intrinsic;

intrinsic TypeOfContraction(X::TorVar,i::RngIntElt :
    divisor:=CanonicalDivisor(X), inequality:="strong") -> MonStgElt
{A string describing the type of contraction of the i-th extremal ray}
    // Sanity checks
    bool,err:=valid_divisor_and_inequality(X,divisor,inequality);
    require bool: err;
    bool,err:=valid_extremal_index(X,i,divisor,inequality);
    require bool: err;
    // Get the ray and its dimension
    extr:=ExtremalRayContraction(X,i : divisor:=divisor,inequality:=inequality);   
    dim:=Dimension(extr);
    // Return the appropriate string
    if dim eq 0 then
        return "map to point";
    elif dim lt Dimension(X) then
        if IsQGorenstein(X) then 
            d:=CanonicalClass(X) *
                ExtremalRays(X : divisor:=divisor,inequality:=inequality)[i];
            if d lt 0 then
                return "fibration (K.C<0)";
            elif d eq 0 then 
                return "fibration (K.C=0)";
            elif d gt 0 then 
                return "fibration (K.C>0)";
            end if;
        end if;
        return "fibration";
    elif Length(extr) lt Length(X) then
        if IsQGorenstein(X) then 
            d:=CanonicalClass(X) *
                ExtremalRays(X : divisor:=divisor,inequality:=inequality)[i];
            if d lt 0 then
                return "divisorial (K.C<0)";
            elif d eq 0 then 
                return "divisorial (K.C=0)";
            elif d gt 0 then 
                return "divisorial (K.C>0)";
            end if;
        end if;
        return "divisorial";
    elif Length(extr) eq Length(X) then 
        if IsQGorenstein(X) then 
            d:=CanonicalClass(X) *
                ExtremalRays(X : divisor:=divisor,inequality:=inequality)[i];
            if d gt 0 then
                return "anti-flip";
            elif d eq 0 then 
                return "flop";
            end if;
        end if;
        return "flip";
    end if;
    // If we're here then we don't know what this is
    return "unknown type";
end intrinsic;

intrinsic ExtremalRayContractions(X::TorVar :
    divisor:=CanonicalDivisor(X), inequality:="strong") -> SeqEnum[DivTorElt]
{The images of extremal contractions of rays in the nef-cone of the toric variety X}
    // Sanity checks
    bool,err:=valid_divisor_and_inequality(X,divisor,inequality);
    require bool: err;
    // Return the images
    n:=#ExtremalRays(X : divisor:=divisor,inequality:=inequality);
    return [ExtremalRayContraction(X,i:divisor:=divisor,inequality:=inequality):
                                                                   i in [1..n]];
end intrinsic;

intrinsic TypesOfContractions(X::TorVar :
    divisor:=CanonicalDivisor(X), inequality:="strong") -> SeqEnum[BoolElt]
{A sequence of strings describing the types of contractions of the extremal rays in the nef-cone of the toric variety X}
    // Sanity checks
    bool,err:=valid_divisor_and_inequality(X,divisor,inequality);
    require bool: err;
    // Return the descriptions
    n:=#ExtremalRays(X : divisor:=divisor,inequality:=inequality);
    return [TypeOfContraction(X,i : divisor:=divisor,inequality:=inequality) :
                                                                   i in [1..n]];
end intrinsic;

intrinsic Flip(X::TorVar,i::RngIntElt :
    divisor:=CanonicalDivisor(X), inequality:="strong")-> TorVar
{Gives the image of the flip associated to the i-th extremal ray in the nef-cone of the toric variety X}
    // Sanity checks
    bool,err:=valid_divisor_and_inequality(X,divisor,inequality);
    require bool: err;
    bool,err:=valid_extremal_index(X,i,divisor,inequality);
    require bool: err;
    require IsFlipping(X,i : divisor:=divisor, inequality:=inequality):
        Sprintf("The indicated extremal ray (%o) is not of flipping type",i);
    // Return the flip
    D:=ExtremalRayContractionDivisor(X,i : divisor:=divisor,
                                                        inequality:=inequality);
    return Flip(D);
end intrinsic;

intrinsic Flip(D::DivTorElt) -> TorFan
{The image of the flip (or anti-flip) associated with the Q-Cartier divisor D}
    // Assert that this is a Q-Cartier divisor
    require IsQCartier(D): "Divisor must be Q-Cartier";
    // Assert that this gives a codim 1 isomorphism
    X:=Variety(D);
    X1:=Proj(D);
    require PureRays(Fan(X1)) eq PureRays(Fan(X)):
        "Divisor must give an isomorphism in codimension 1";
//  THINK: In MMP we can ignore the following line
//  require IsFanMap(Fan(X), Fan(X1)): "Divisor must define a regular map";
    // Assert that the divisor is flipping
    Pic:=PicardLattice(X);
    Pic1:=PicardLattice(X1);
    require Dimension(Pic1) lt Dimension(Pic):
        "Divisor must correspond to a flip (or anti-flip)";
    // Construct the image
    AllX:= get_curves(X);
    AllX1:= get_curves(X1);
    classes_of_contracted_curves:=[intersection_form(X,i) :
                                        i in [1..#AllX] | not AllX[i] in AllX1];
    rep:=-PointInInterior(ConeWithInequalities(classes_of_contracted_curves));
    D1:=Representative(X,rep : effective:=false);
    D2:=Divisor(X1,Eltseq(Weil(D1)));
    Y:=RelativeProj(D2);
    return Y;
end intrinsic;

intrinsic WeightsOfFlip(X::TorVar,i::RngIntElt :
    divisor:=CanonicalDivisor(X), inequality:="strong")-> SeqEnum[RngIntElt]
{The weights of the flip of the toric variety X associated to the i-th extremal ray of X, assuming that this ray is of flipping type. The extremal rays of X are computed and ordered with respect to the parameter 'divisor' (a divisor on X, by default a canonical divisor) and 'inequality' (by default "strong", but can also be "weak").}
    // Sanity checks
    bool,err:=valid_divisor_and_inequality(X,divisor,inequality);
    require bool: err;
    bool,err:=valid_extremal_index(X,i,divisor,inequality);
    require bool: err;
    require IsFlipping(X,i : divisor:=divisor,inequality:=inequality):
        Sprintf("The indicated extremal ray (%o) is not of flipping type",i);
    // Compute the weights
    Y:=ExtremalRayContraction(X,i : divisor:=divisor,inequality:=inequality);
    F:=Fan(Y);
    flipping_inds:=Sort(Setseq(&join[ConeIndices(F,C) : C in Cones(F) |
                                                         not IsQFactorial(C)]));
    M:=Submatrix(Matrix(Rays(F)),flipping_inds,[1..Dimension(Ambient(F))]);
    return [Eltseq(b) : b in Basis(Kernel(M))];
end intrinsic;

intrinsic MMP(X::TorVar : type:="terminal") -> SeqEnum, SeqEnum
{The sequence of varieties arising by running the Minimal Model Program on the toric variety X, together with the sequence of arrows. The parameter 'type' can be "terminal" (default), "canonical" or "all".}
    // Sanity checks
    require Type(type) eq MonStgElt and (type eq "terminal" or
        type eq "canonical" or type eq "all"):
        "'type' must be \"terminal\", \"canonical\", or \"all\"";
    // Set the inequality based on the type
    inequality:=type eq "terminal" select "strong" else "weak";
    // Run the MMP
    i:=1;
    dim:=Dimension(X);
    varieties:=[X];
    arrows:=[];
    while i le #varieties do
        Y:=varieties[i];
        if Dimension(Y) eq dim then
            if type eq "all" then
                divisor:=ZeroDivisor(Y);
            else 
                divisor:=CanonicalDivisor(Y);
            end if;
            types:=TypesOfContractions(Y : inequality:=inequality,
                                                              divisor:=divisor);
            for j in [1..#types] do
                current_type:=types[j];
                if current_type eq "flip" or current_type eq "flop" or
                    current_type eq "anti-flip" then 
                    Z:=Flip(Y,j : inequality:=inequality,divisor:=divisor);
                else
                    Z:=ExtremalRayContraction(Y,j : inequality:=inequality,
                                                              divisor:=divisor);
                end if;
                idxZ:=index_of_variety(Z,varieties);
                if idxZ eq 0 then 
                    Append(~varieties, Z);
                    idxZ:=#varieties;
                end if;
                new_arrow:=[* [i,idxZ], current_type *];
                Append(~arrows,new_arrow);
            end for;
        end if;
        i +:= 1;
    end while;
    return varieties, arrows;
end intrinsic;
