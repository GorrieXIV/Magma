freeze;

/////////////////////////////////////////////////////////////////////////
// pyramid.m
/////////////////////////////////////////////////////////////////////////
// $Revision: 36857 $
// $Date: 2012-01-09 07:02:03 +1100 (Mon, 09 Jan 2012) $
// $LastChangedBy: kasprzyk $
/////////////////////////////////////////////////////////////////////////
// Author: Alexander Kasprzyk
/////////////////////////////////////////////////////////////////////////
// Functions for computing with pyramids of polytopes.
/////////////////////////////////////////////////////////////////////////

import "../lattice/lattice.m": lattice_from_cache;
import "../lattice/gradedlattice.m": default_origin;
import "faces/support.m": amb_get_fp_generating_points;

/////////////////////////////////////////////////////////////////////////
// Local functions
/////////////////////////////////////////////////////////////////////////

// Returns true if the polytope P is a pyramid. If true, also returns the
// index of an apex vertex and the index of the containing ("base") facet.
function is_pyramid(P)
    // Work through the rows of the vertex-facet height matrix looking for
    // a match
    M:=VertexFacetHeightMatrix(P);
    for i in [1..NumberOfRows(M)] do
        row:=Eltseq(M[i]);
        if &+row eq 1 and &+[Integers() | 1 : s in row | s ne 0] eq 1 then
            // If the apex is integral then we have an pyramid
            idx:=Index(row,1);
            if IsIntegral(Vertices(P)[idx]) then
                return true,idx,i;
            end if;
        end if;
    end for;
    // If we're here then this isn't a pyramid
    return false,_,_;
end function;

// Returns a change of basis phi, and a translation v such that
// phi(P) + v is in the form of a pyramid.
function base_projection(P,apex,base)
    L:=Ambient(P);
    // Get the apex and supporting hyperplane containing the base
    verts:=Vertices(P);
    apex:=verts[apex];
    H:=Inequalities(P)[base];
    // If necessary get a random point of the base and translate to the origin
    if H[2] ne 0 then
        v:=verts[Representative(FacetIndices(P)[base])];
        apex -:= v;
        H[2] -:= H[1] * v;
    else
        v:=Zero(Ambient(P));
    end if;
    // Compute a basis for the sublattice containing the base
    subbasis:=KernelBasis(H[1]);
    // Compute the change of basis
    V:=Matrix([apex] cat subbasis);
    assert Abs(Determinant(V)) eq 1;
    B:=V^-1;
    // Return the data
    phi:=LatticeMap(L,L,B);
    return phi(-v),phi;
end function;

/////////////////////////////////////////////////////////////////////////
// Intrinsics
/////////////////////////////////////////////////////////////////////////

intrinsic Pyramid(P::TorPol) -> TorPol, Map[TorLat,TorLat], Map[TorLat,TorLat],
    Map[TorLat,TorLat], Map[TorLat,TorLat]
{The pyramid given by embedding the polyhedron P in the lattice Z x L (where L is the ambient toric lattice of P) and adding the point (1,0,...,0) to the convex hull. Also gives the two embedding maps and the two projection maps of the underlying lattices.}
    // Create the new ambient lattice and apex
    Z:=lattice_from_cache(1);
    L,embL1,embL2,projL1,projL2:=DirectSum(Z,Ambient(P));
    apex:=embL1(Z.1);
    if IsPolytope(P) then
        // Embed the generators and return the polytope
        gens:=embL2(amb_get_fp_generating_points(P));
        return Polytope(Append(gens,apex)),embL1,embL2,projL1,projL2;
    else
        // Create the graded lattice
        L,emb:=GradedToricLattice(L);
        // Move the apex and generator into the lattice
        gens:=Append((embL2 * emb)(amb_get_fp_generating_points(P)),emb(apex));
        inf:=(embL2 * emb)(RGenerators(InfinitePart(P)));
        // Shift the generators to the new origin
        origin:=default_origin(L,1);
        gens:=[L | v + origin : v in gens];
        // Return the polyhedron
        return Polyhedron(Cone(gens cat inf)),embL1,embL2,projL1,projL2;
    end if;
end intrinsic;

intrinsic IsPyramid(P::TorPol) ->
    BoolElt,TorLatElt,TorPol,Map[TorLat,TorLat],TorLatElt
{True iff the polytope P is a pyramid, i.e. if there exists a facet F and an integral vertex u of P such that P = conv(F \\cup u), where u is at height 1 relative to F. If true, also gives a choice of apex u, base facet F, an element phi in GL(n,Z), and a lattice translation v such that Image(phi,P) + v sends u to (1,0,...,0) and F to the (n-1)-dimensional sublattice generated by (0,1,...,0),...,(0,0,...,1).}
    // Sanity check
    require IsPolytope(P): "The polyhedron must be a polytope";
    // Is this a pyramid?
    bool,apex,base:=is_pyramid(P);
    if not bool then return false,_,_,_,_; end if;
    // We know this is a pyramid -- compute the map
    v,phi:=base_projection(P,apex,base);
    return true,Vertices(P)[apex],Facets(P)[base],phi,v;
end intrinsic;
