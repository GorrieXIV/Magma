freeze;

/////////////////////////////////////////////////////////////////////////
// coneembedding.m
/////////////////////////////////////////////////////////////////////////
// $Revision: 36421 $
// $Date: 2011-12-05 20:48:11 +1100 (Mon, 05 Dec 2011) $
// $LastChangedBy: kasprzyk $
/////////////////////////////////////////////////////////////////////////
// Authors: Gavin Brown, Jaroslaw Buczynski, Alexander Kasprzyk
/////////////////////////////////////////////////////////////////////////
// Functions for dealing with the embedding of a polyhedron in a cone.
/////////////////////////////////////////////////////////////////////////
// Note
// ====
// It's natural to wish to construct a cone C from a polyhedron P by
// taking a lattice of one greater dimension than the ambient, imposing
// a height function on the lattice, and embedding P at height 1. C is
// the cone generated by the image of P.
// Conversely, it's natural to construct a polyhedron P from a cone D
// by taking a slice through D at some given integral height.
// We use the following notation to describe these concepts:
//      ce_normalised_cone   - the cone C above
//      ce_cone              - the cone D above
// 
// If P in L comes from taking a slice through "ce_cone" in L', the
// embedding into L' can be described via:
//      L \rightarrow L'
//      u \mapsto     ce_embedding(u) + ce_origin
// where "ce_origin" is a lattice point in L' at height "ce_height".
//
// We make an effort to construct "ce_normalised" in the same ambient as
// "ce_cone" (if defined). The embedding is given by:
//      L \rightarrow L'
//      u \mapsto     ce_embedding(u) + origin
// where "origin" is a lattice point in L' at height 1 such that the
// natural projection to L sends "origin" to 0 (=Zero(L)).
//
// Note: We require that the cones are "graded cones". Perhaps it is
// more natural to impose the grading on the cone's ambient lattice,
// rather than on the cone itself? This is something that can be easily
// changed. (Grep for "IsGraded", "ImposeGrading", and "Grading".)
/////////////////////////////////////////////////////////////////////////

import "../lattice/gradedlattice.m": default_origin;
import "faces/support.m": amb_get_fp_generating_points;

declare attributes TorPol:
    ce_cone,               // The original graded cone ('D' above)
    ce_embedding,          // ...the embedding of the polyhedron into the cone
    ce_height,             // ...the height of the polyhedron in the cone
    ce_origin,             // ...the 'origin' in the cone at the height of P
    ce_normalised_cone;    // The normalised cone ('C' above)

/////////////////////////////////////////////////////////////////////////
// Construct default embedding data
/////////////////////////////////////////////////////////////////////////

// Constructs the default cone embedding data
procedure construct_default_cone_embedding_data(P)
    L:=GradedToricLattice(Ambient(P));
    _,P`ce_embedding:=HeightZeroSublattice(L);
    if not assigned P`ce_height then
        P`ce_height:=1;
    end if;
    origin:=Grading(Dual(L)) * P`ce_height;
    error if not IsIntegral(origin),
       "construct_default_cone_embedding_data: Only lattice embeddings allowed";
    P`ce_origin:=origin;
end procedure;

// Returns the default kernel embedding of the cone
function ce_default_embedding(C)
    return KernelEmbedding(Grading(C));
end function;

/////////////////////////////////////////////////////////////////////////
// Access functions
/////////////////////////////////////////////////////////////////////////

// Returns the embedding of the ambient of P into the ambient of the cone at
// height 0
function ce_get_embedding(P)
    if not assigned P`ce_embedding then
        if assigned P`ce_cone then
            P`ce_embedding:=ce_default_embedding(P`ce_cone);
        else
            construct_default_cone_embedding_data(P);
        end if;
    end if;
    return P`ce_embedding;
end function;

// Returns the height of the embedding of the ambient of P into the ambient
// of the cone
function ce_get_height(P)
    if not assigned P`ce_height then
        if assigned P`ce_origin and assigned P`ce_cone then
            P`ce_height:=P`ce_origin * Grading(P`ce_cone);
        else
            P`ce_height:=1;
        end if;
    end if;
    return P`ce_height;
end function;

// Returns the lattice point the origin of the ambient of P is sent to in the
// ambient of the cone
function ce_get_origin(P)
    if not assigned P`ce_origin then
        if assigned P`ce_height and assigned P`ce_cone then
            origin:=default_origin(P`ce_cone,P`ce_height);
            error if not IsIntegral(origin),
               "ce_get_origin: Only lattice embeddings allowed";
            P`ce_origin:=origin;
        else
            construct_default_cone_embedding_data(P);
        end if;
    end if;
    return P`ce_origin;
end function;

// Returns the cone generated by P in the embedding
function ce_get_cone(P)
    if not assigned P`ce_cone then
        origin:=ce_get_origin(P);
        emb:=ce_get_embedding(P);
        gens:=[emb(v) + origin : v in amb_get_fp_generating_points(P)] cat
                                         emb(RGenerators(InfinitePart(P)));
        P`ce_cone:=Cone(gens);
    end if;
    return P`ce_cone;
end function;

/////////////////////////////////////////////////////////////////////////
// Cone creation
/////////////////////////////////////////////////////////////////////////

// ce_normalised_cone - Creates a normalised cone for P with the given data
// Note: This cone is NOT cached
function ce_normalised_cone(P,emb,origin)
    gens:=[Codomain(emb) | emb(v) + origin :
                                       v in amb_get_fp_generating_points(P)] cat
                                       emb(RGenerators(InfinitePart(P)));
    return Cone(gens);
end function;

/////////////////////////////////////////////////////////////////////////
// Intrinsics
/////////////////////////////////////////////////////////////////////////

intrinsic NormalisedCone(P::TorPol) -> TorCon,Map[TorLat,TorLat]
{The graded cone C such that the polyhedron P is the intersection of C with a hyperplane at height one, together with the embedding of the ambient lattice of P into the ambient lattice of C}
    L:=GradedToricLattice(Ambient(P));
    _,emb:=HeightZeroSublattice(L);
    if not assigned P`ce_normalised_cone then
        if ce_get_height(P) eq 1 
               and Ambient(ce_get_cone(P)) eq L 
               and emb eq ce_get_embedding(P) then
            P`ce_normalised_cone:=ce_get_cone(P);
        else
            P`ce_normalised_cone:=ce_normalised_cone(P,emb,default_origin(L,1));
        end if;
    end if;
    return P`ce_normalised_cone,emb;
end intrinsic;

// This is an alias for NormalisedCone
intrinsic Cone(P::TorPol) -> TorCon,Map[TorLat,TorLat]
{The graded cone C such that the polyhedron P is the intersection of C with a hyperplane at height one, together with the embedding of the ambient lattice of P into the ambient lattice of C}
    C,emb:=NormalisedCone(P);
    return C,emb;
end intrinsic;
