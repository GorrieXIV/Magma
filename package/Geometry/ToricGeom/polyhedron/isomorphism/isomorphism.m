freeze;

/////////////////////////////////////////////////////////////////////////
// isomorphism.m
/////////////////////////////////////////////////////////////////////////
// $Revision: 42147 $
// $Date: 2013-02-20 01:03:59 +1100 (Wed, 20 Feb 2013) $
// $LastChangedBy: kasprzyk $
/////////////////////////////////////////////////////////////////////////
// Authors: Gavin Brown, Jaroslaw Buczynski, Alexander Kasprzyk
/////////////////////////////////////////////////////////////////////////
// Isomorphism of polytopes.
/////////////////////////////////////////////////////////////////////////

declare attributes TorPol:
    iso_vf_graph;       // The labeled vertex-facet graph of P

/////////////////////////////////////////////////////////////////////////
// Local functions
/////////////////////////////////////////////////////////////////////////

// Returns the labeled face graph of P.
function labeled_graph(P)
    if not assigned P`iso_vf_graph then
        // We'll need to know the vertex "round-ups" for the indices
        verts:=Vertices(P);
        if IsIntegral(P) then
            round:=verts;
        else
            prims:=[PrimitiveLatticeVector(v) : v in verts];
            round:=[Ceiling(verts[i] / prims[i]) * prims[i] : i in [1..#verts]];
        end if;
        // Create the labels for the vertices of P
        vlabels:=[[0,Denominator(v)] : v in verts];
        // Create the labels for the facets of P
        if Dimension(P) gt 0 then
            facets:=FacetIndices(P);
            flabels:=[[1,Index([round[i] : i in F])] : F in facets];
        else
            facets:=[];
            flabels:=[];
        end if;
        // Create the graph edges
        nv:=#verts;
        edges:={{i,j + nv} : i in facets[j], j in [1..#facets]};
        // Create and save the graph
        G:=Graph<nv + #facets | edges>;
        AssignVertexLabels(~G,vlabels cat flabels);
        P`iso_vf_graph:=G;
    end if;
    return P`iso_vf_graph;
end function;

// Returns a sequence of integers, where the i-th entry is the index of
// the sublattice generated by the vertices of the i-th facet.
function facet_sublattice_idxs(P)
    verts:=Vertices(P);
    return [Integers() | Index([Universe(verts) | verts[i] : i in F]) :
                                                          F in FacetIndices(P)];
end function;

// Returns a sequence of integers, where the i-th entry is the number of
// vertices defining the F[i]-th facet.
function facet_num_vertices(P,F)
    FF:=FacetIndices(P);
    return [Integers() | #FF[i] : i in F];
end function;

// Returns a sequence of integers, where the i-th entry is the number of
// integral vertices on the F[i]-th facet.
function facet_num_integral(P,F)
    FF:=FacetIndices(P);
    verts:=Vertices(P);
    return [Integers() | #[Integers() | 1 : j in FF[i] | IsIntegral(verts[j])]
                                                                      : i in F];
end function;

// Partitions the facets of P occuring in F by the denominators of the vertices.
// The paritions are canonically ordered so that the smallest partition comes
// first.
function partition_by_denominator(P,F)
    FF:=FacetIndices(P);
    verts:=Vertices(P);
    // First we partition by denominators
    buckets:=AssociativeArray(PowerSequence(Integers()));
    for i in F do
        key:=Sort([Integers() | Denominator(verts[j]) : j in FF[i]]);
        bool,A:=IsDefined(buckets,key);
        if not bool then
            A:=[Integers() | i];
        else
            Append(~A,i);
        end if;
        buckets[key]:=A;
    end for;
    // Now we order the data so that the smallest partition is first, the
    // largest partion last
    keys:=SetToSequence(Keys(buckets));
    vals:=[PowerSequence(Integers()) | buckets[key] : key in keys];
    keys:=[[#vals[i]] cat keys[i] : i in [1..#keys]];
    ParallelSort(~keys,~vals);
    return vals;
end function;

// Given the i-th facet of a polytope P, computes a linearly independent subset
// of the vertices of that facet. On success, return true.
// Also returns the corresponding matrix (over the rationals), along with the
// set of vertex indices used.
function facet_lin_indep(P,i)
    verts:=Vertices(P);
    for idxs in Subsets(FacetIndices(P)[i],Dimension(P)) do
        M:=Matrix(Rationals(),[Universe(verts) | verts[j] : j in idxs]);
        if Dimension(Kernel(M)) eq 0 then
            return true,M,SetToSequence(idxs);
        end if;
    end for;
    return false,_,_;
end function;

// Returns a sequence of integers corresponding to the facets of Q to which the
// i-th facet of P can be sent to under a graph isomorphism.
// phi is any isomorphism from the graph of P to the graph of Q.
function facet_graph_isomorphism(i,phi,P,Q)
    GQ:=labeled_graph(Q);
    nv:=NumberOfVertices(P);
    ii:=Index(Vertices(GQ),phi(i + nv));
    return {Integers() | jj - nv :
                          jj in SetToSequence(Orbit(AutomorphismGroup(GQ),ii))};
end function;

// Given a sequence of integers, returns true followed by a least common one.
// If the optional 'exclude' argument is specified and ends up excluding all
// the elements of S, returns false.
function least_common_element(S : exclude:=false)
    if Type(exclude) eq SetEnum and #exclude gt 0 then
        sums:=[PowerSequence(Integers()) | [#[Integers() | j :
                      j in S | j eq i],i] : i in SequenceToSet(S) diff exclude];
        if #sums eq 0 then
            return false,_;
        end if;
        Sort(~sums);
        return true,sums[1][2];
    else
        sums:=[PowerSequence(Integers()) | [#[Integers() | j :
                                   j in S | j eq i],i] : i in SequenceToSet(S)];
        Sort(~sums);
        return true,sums[1][2];
    end if;
end function;

// Some easy checks for isomorphism/equivalence. Returns true if they're passed,
// false otherwise.
function easy_checks(P,Q)
    if Dimension(P) ne Dimension(Q) then
        return false;
    end if;
    if NumberOfVertices(P) ne NumberOfVertices(Q) then
        return false;
    end if;
    if NumberOfFacets(P) ne NumberOfFacets(Q) then
        return false;
    end if;
    if IsIntegral(P) then
        if not IsIntegral(Q) then
            return false;
        end if;
    else
        if IsIntegral(Q) then
            return false;
        end if;
        if #[Integers() | 1 : v in Vertices(P) | IsIntegral(v)] ne
                #[Integers() | 1 : v in Vertices(Q) | IsIntegral(v)] then
            return false;
        end if;
    end if;
    if Dimension(P) gt 3 and (fVector(P) ne fVector(Q)) then
        return false;
    end if;
    return true;
end function;

// Given a matrix M, returns true if M sends P to Q via:
//      P * M = Q.
function gives_isomorphism(P,Q,M)
    vertsQ:=Sort([PowerSequence(Rationals()) | Eltseq(v) : v in Vertices(Q)]);
    for v in Vertices(P) do
        vv:=Eltseq(v * M);
        ChangeUniverse(~vv,Rationals());
        idx:=Index(vertsQ,vv);
        if idx eq 0 then
            return false;
        end if;
        Remove(~vertsQ,idx);
    end for;
    // If we're here then it's good
    return true;
end function;

// Returns true if there exists an element M in GL(n,Z) sending P to Q via:
//      P * M = Q,
// with the restriction that the vertices indexed by idxP are sent to the
// vertices of the i-th facet of Q.
// linP is the inverse of the matrix defined by the vertices indexed by indP,
// and phi is an isomorphism from  the graph of P to the graph of Q.
function has_facet_isomorphism(i,j,idxP,linP,phi,P,Q)
    // Collect the data we'll need
    det:=Determinant(linP);
    GQ:=labeled_graph(Q);
    // Get the vertex indices defining the i-th facet
    fullidxQ:=FacetIndices(Q)[i];
    vertsQ:=Vertices(Q);
    nv:=#vertsQ;
    // We need to map j to the i-th facet
    bool,perm:=IsConjugate(AutomorphismGroup(GQ),j,i + nv);
    if not bool then
        return false,_;
    end if;
    // Start working through the possible places the vertices could be sent
    for sigma in Stabilizer(AutomorphismGroup(GQ),i + nv) do
        idxQ:=[Integers() | Index(Vertices(GQ),phi(j))^(perm * sigma) :
                                                                     j in idxP];
        if idxQ subset fullidxQ then
            // We have that vertex idxP[j] is sent to idxQ[j]
            MQ:=Matrix(Rationals(),[Universe(vertsQ) | vertsQ[j] : j in idxQ]);
            if Abs(Determinant(MQ) * det) eq 1 then
                // Is the map in GL(n,Z)?
                bool,M:=CanChangeRing(linP * MQ,Integers());
                if bool then                    
                    // Is this an isomorphism?
                    if gives_isomorphism(P,Q,M) then
                        return true,M;
                    end if;
                end if;
            end if;
        end if;
    end for;
    // If we're here then it didn't work out
    return false,_;
end function;

// Given a sequence of facet ids to condider, picks a candidate facet about
// which to construct the isomorphism. Returns false,_,_,_,_,_ if each facet in
// the list lies in a hyperplane containing the origin (in which case they
// can't be used to construct a change of basis); returns true,false,_,_,_,_ if
// a valid facet exists, and it was discovered that an isomorphism is impossible
// (in which case you know for certain that P and Q are not isomorphic); returns
// true,true,fP,linP,idxP,newfsQ if a facet about which you can construct an
// isomorphism was discovered (in which case you have to now to on to actually
// try to build the isomorphism in order to determine the final result).
function candidate_facet(fsP,fsQ,phi,P,Q)
    // Start looking for a candidate facet in P's list
    fP:=0;
    while #fsP gt 0 and fP eq 0 do
        fP:=fsP[#fsP];
        Prune(~fsP);
        // Where is it sent to under graph isomorphism and automorphism?
        orb:=facet_graph_isomorphism(fP,phi,P,Q);
        newfsQ:=SequenceToSet(fsQ) meet orb;
        // Is there anything to do?
        if #newfsQ eq 0 then
            return true,false,_,_,_,_;
        end if;
        // Before we can continue, we need our facet to not lie in the same
        // hyperplane as the origin
        bool,linP,idxP:=facet_lin_indep(P,fP);
        if bool then
            linP:=linP^-1;
        else
            fP:=0;
        end if;
    end while;
    // Did we manage to find a facet not contained in the same hyperplane as
    // the origin?
    if fP eq 0 then
        return false,_,_,_,_,_;
    end if;
    // Return the data
    return true,true,fP,linP,idxP,newfsQ;
end function;

// Attempts to construct an isomorphism M in GL(n,Z) between P and Q such that:
//      P * M = Q.
// fsP and fsQ are sequences of facets (given by their indices) which might
// map to each other. phi is an isomorphism from the graph of P to the graph
// of Q.
// This method will fail if all the facets in fsP generate a hyperplane which
// contains the origin. Returns true if at least one facet in fsP did not lie
// in the same hyperplane as the origin.
// If returns true, the second return value is whether P and Q are isomophic.
// If returns true,true, the third return value is the matrix M.
function can_construct_isomorphism_main(fsP,fsQ,phi,P,Q)
    // Compare the number of integral vertices on each facet
    if not IsIntegral(P) then
        vxP:=facet_num_integral(P,fsP);
        vxQ:=facet_num_integral(Q,fsQ);
        if Sort(vxP) ne Sort(vxQ) then
            return true,false,_;
        end if;
        exclude:={Integers()|};
        success:=false;
        while not success do
            // Fetch least common number of integral vertices
            bool,idx:=least_common_element(vxP : exclude:=exclude);
            if not bool then
                return false,_,_;
            end if;
            Include(~exclude,idx);
            // We now try restricting our choices further by considering
            // the vertex denominators of these facets
            newfsP:=[Integers() | fsP[i] : i in [1..#fsP] | vxP[i] eq idx];
            newfsQ:=[Integers() | fsQ[i] : i in [1..#fsQ] | vxQ[i] eq idx];
            denP:=partition_by_denominator(P,newfsP);
            denQ:=partition_by_denominator(Q,newfsQ);
            // Check that the partitions agree
            if #denP ne #denQ or [#S : S in denP] ne [#S : S in denQ] then
                return true,false,_;
            end if;
            // Start hunting for a candodate facet
            i:=1;
            while i le #denP and not success do
                success,bool,fP,linP,idxP,newfsQ:=candidate_facet(denP[i],
                                                               denQ[i],phi,P,Q);
                i +:= 1;
            end while;
        end while;
    else
        success,bool,fP,linP,idxP,newfsQ:=candidate_facet(fsP,fsQ,phi,P,Q);
        if not success then
            return false,_,_;
        end if;
    end if;
    // Is an isomorphism possible?
    if not bool then
        return true,false,_;
    end if;
    // Now try to fix up a change of basis sending it to one of the facets
    // in Q's list
    j:=Index(Vertices(labeled_graph(Q)),phi(fP + NumberOfVertices(P)));
    for i in newfsQ do
        bool,M:=has_facet_isomorphism(i,j,idxP,linP,phi,P,Q);
        if bool then
            return true,true,M;
        end if;
    end for;
    // If we're here then they're not isomorphic
    return true,false,_;
end function;

function can_construct_isomorphism(fsP,fsQ,phi,P,Q)
    // We try to simplify matters if P is not simplicial by working with the
    // facets with fewer vertices first.
    if not IsSimplicial(P) then
        vxP:=facet_num_vertices(P,fsP);
        vxQ:=facet_num_vertices(Q,fsQ);
        if Sort(vxP) ne Sort(vxQ) then
            return true,false,_;
        end if;
        // Work upwards through the least common number of vertices
        success:=false;
        exclude:={Integers()|};
        while not success do
            bool,idx:=least_common_element(vxP : exclude:=exclude);
            if not bool then
                // We've ran out of candidates without managing to determine
                // isomorphism
                return false,_,_;
            end if;
            Include(~exclude,idx);
            // Extract the facets we're interested in
            nfsP:=[Integers() | fsP[i] : i in [1..#fsP] | vxP[i] eq idx];
            nfsQ:=[Integers() | fsQ[i] : i in [1..#fsQ] | vxQ[i] eq idx];
            // Try to build an isomorphism
            success,iso,M:=can_construct_isomorphism_main(nfsP,nfsQ,phi,P,Q);
        end while;
    else
        success,iso,M:=can_construct_isomorphism_main(fsP,fsQ,phi,P,Q);
    end if;
    // Were we successful in determining isomorphism?
    if success then
        if iso then
            return true,true,M;
        else
            return true,false,_;
        end if;
    end if;
    // If we're here then we couldn't determine anything
    return false,_,_;
end function;

// Returns true if there exists an element M in GL(n,Z) sending the polytope P
// to the polytope Q via:
//      P * M = Q.
// If so, also returns M.
// Note: Requires that P and Q are of maximum dimension.
function is_isomorphic(P,Q)
    // Get the easy isomorphism checks out of the way
    if Sort([Integers() | #F : F in FacetIndices(P)]) ne
                Sort([Integers() | #F : F in FacetIndices(Q)]) then
        return false,_;
    end if;
    if IsFano(P) then
        if not IsFano(Q) then
            return false,_;
        end if;
        if GorensteinIndex(P) ne GorensteinIndex(Q) then
            return false,_;
        end if;
    else
        if IsFano(Q) then
            return false,_;
        end if;
        if ContainsZero(P) ne ContainsZero(Q) then
            return false,_;
        end if;
        if #[Integers() | 1 : v in Vertices(P) | IsPrimitive(v)] ne
                #[Integers() | 1 : v in Vertices(Q) | IsPrimitive(v)] then
            return false,_;
        end if;
    end if;
    // It looks reasonable -- compare the facet sublattice indices
    idxsP:=facet_sublattice_idxs(P);
    idxsQ:=facet_sublattice_idxs(Q);
    if Sort(idxsP) ne Sort(idxsQ) then
        return false,_;
    end if;
    // Are the graphs of P and Q isomorphism? We've left this until now
    // because it's a little expensive.
    bool,phi:=IsIsomorphic(labeled_graph(P),labeled_graph(Q));
    if not bool then
        return false,_;
    end if;
    // Select the least common index to work with, and try to construct an
    // isomorphism
    success:=false;
    exclude:={Integers()|};
    while not success do
        bool,idx:=least_common_element(idxsP : exclude:=exclude);
        assert bool;
        Include(~exclude,idx);
        fsP:=[Integers() | i : i in [1..#idxsP] | idxsP[i] eq idx];
        fsQ:=[Integers() | i : i in [1..#idxsQ] | idxsQ[i] eq idx];
        success,iso,M:=can_construct_isomorphism(fsP,fsQ,phi,P,Q);
    end while;
    // Did we find an isomorphism?
    if iso then
        return true,M;
    end if;
    return false,_;
end function;

/////////////////////////////////////////////////////////////////////////
// Instrinsics
/////////////////////////////////////////////////////////////////////////

intrinsic IsIsomorphic(P::TorPol,Q::TorPol) -> BoolElt,Map[TorLat,TorLat]
{True iff the polytopes P and Q are isomorphic, i.e. if there exists an element in GL(n,Z) sending P to Q. If true, also gives an isomorphism from P to Q.}
    // Sanity checks
    require IsPolytope(P): "Argument 1 must be a polytope";
    require IsPolytope(Q): "Argument 2 must be a polytope";
    // Record the ambients and check their dimensions agree
    L_P:=Ambient(P);
    L_Q:=Ambient(Q);
    if Dimension(L_P) ne Dimension(L_Q) then
        return false,_;
    end if;
    // Test for equality
    if P eq Q then
        return true,IdentityMap(L_P);
    end if;
    // We do the easy checks before we continue
    if not easy_checks(P,Q) then
        return false,_;
    end if;
    // We handle the 0 dimensional case seperately
    if Dimension(P) eq 0 then
        // Get the corresponding primitive vectors and distances
        vP:=PrimitiveLatticeVector(Vertices(P)[1]);
        vQ:=PrimitiveLatticeVector(Vertices(Q)[1]);
        dP:=Vertices(P)[1] / vP;
        dQ:=Vertices(Q)[1] / vQ;
        // An isomorphism exists iff the distances agree
        if dP eq dQ then
            // Do we actually need to do anything fancy?
            if Eltseq(vP) eq Eltseq(vQ) then
                return true,LatticeMap(L_P,L_Q,
                                     IdentityMatrix(Integers(),Dimension(L_P)));
            end if;
            // Yes: Calculate the change of basis
            _,proj:=Quotient(vP);
            MP:=Matrix(Append(Basis(Codomain(proj)) @@ proj,vP));
            _,proj:=Quotient(vQ);
            MQ:=Matrix(Append(Basis(Codomain(proj)) @@ proj,vQ));
            M:=MP^-1 * MQ;
            return true,LatticeMap(L_P,L_Q,M);
        else
            return false,_;
        end if;
    end if;
    // Initialize the data
    embP:=false;
    embQ:=false;
    // Are P and Q of maximum dimension?
    if not IsMaximumDimensional(P) then
        // Does the hyperplane containing P (and Q) also contain the origin?
        if #LinearSpanGenerators(Vertices(P)) eq Dimension(P) then
            if #LinearSpanGenerators(Vertices(Q)) ne Dimension(Q) then
                return false,_;
            end if;
            P,embP:=PolyhedronInSublattice(P);
            Q,embQ:=PolyhedronInSublattice(Q);
        // If not, take the cone over P (and Q)
        else
            if #LinearSpanGenerators(Vertices(Q)) eq Dimension(Q) then
                return false,_;
            end if;
            P:=Polytope(Append(Vertices(P),Zero(Ambient(P))):areVertices:=true);
            Q:=Polytope(Append(Vertices(Q),Zero(Ambient(Q))):areVertices:=true);
            if not IsMaximumDimensional(P) then
                if IsMaximumDimensional(Q) then
                    return false,_;
                end if;
                P,embP:=PolyhedronInSublattice(P);
                Q,embQ:=PolyhedronInSublattice(Q);
            end if;
        end if;
    end if;
    // Build an isomorphism
    bool,M:=is_isomorphic(P,Q);
    if not bool then
        return false,_;
    end if;
    // Now we need to top and tail the isomorphism
    if not embP cmpeq false then
        BP:=Image(embP,Basis(Domain(embP)));
        _,proj:=Quotient(BP);
        K:=Basis(Codomain(proj)) @@ proj;
        BP:=Matrix(Integers(),BP cat K);
        
        embQ:=LatticeMap(Domain(embQ),L_Q,M * DefiningMatrix(embQ));
        BQ:=Image(embQ,Basis(Domain(embQ)));
        _,proj:=Quotient(BQ);
        K:=Basis(Codomain(proj)) @@ proj;
        BQ:=Matrix(Integers(),BQ cat K);

        M:=BP^-1 * BQ;
    end if;
    // Convert the matrix into a map and return it
    return true,LatticeMap(L_P,L_Q,M);
end intrinsic;
