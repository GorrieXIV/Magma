freeze;

/******************************************************************

    Miscellaneous functions to compute various genera of
     modular curves and quotients without computing
              any modular forms/symbols.

    mch - 03/07

******************************************************************/
 
intrinsic AtkinLehnerNumberOfFixedPoints(N::RngIntElt,A::RngIntElt) 
			-> RngIntElt
{Computes the number of fixed points of Atkin-Lehner involution
 W_A acting on X0(N)}
 
 /*
    Formulae are as follows for NA=#non-cuspidal fixed points
      [h(D)=class no of D, (a/b)=Jacobi symbol
      	P=product, p an odd prime]
    N=A*B (A,B)=1, A > 1.

    A=2:      P_{p|B}(1+(-1/p)) + P_{p|B}(1+(-2/p))

     in the remaining formulae P = P_{p|B}(1+(-A/p))

    A>2, A !=3 mod 4:
       h(-4A)*U2(B)*P where U2(B)= 0 if 4|B, 1 otherwise

    A=3 mod 8 A>3:
       4*h(-A)*P if B odd
       6*h(-A)*P if 2||B or 4||B
       0         if 8|B

    [
      A=3:
       0   if 8|B
       2*P otherwise
    ]

    A=7 mod 8:
       2*h(-A)*P if B odd
       4*h(-A)*P if 2||B
       6*h(-A)*P if 4||B
       8*h(-A)*P if 8|B
       
    NAc is the number of cuspidal points fixed by W_A.
      [ phi = Euler's totient function ]

      NAc=0 if A != 4

      NAc = sum_{d|B} phi((d,B/d)) if A=4
       ( fixed cusps are x/2d (x,2d)=1, x mod (d,B/d) )
  */

    require (A gt 1) and (N gt 1): 
 	"Arguments must both be greater than 1";
    boo,B := IsDivisibleBy(N,A);
    require boo and (GCD(A,B) eq 1) :
     "A must be a divisor of N, relatively prime to N/A";

    pow2B := Valuation(B,2);
    facts := Factorisation(B div(2^pow2B));
    Bps := [f[1] : f in facts];

    NA := &*[Integers()| 1+LegendreSymbol(-A,p) : p in Bps];
    if A eq 2 then
	NA +:= &*[Integers()| 1+LegendreSymbol(-1,p) : p in Bps];
    elif A eq 3 then
	if pow2B ge 3 then
	    NA := 0;
	else
	    NA *:= 2;
	end if;
    elif NA ne 0 then
      case (A mod 8):
	when 7: NA *:= 2*Min(pow2B+1,4)*ClassNumber(-A);
	when 3:
	  if pow2B ge 3 then
	    NA := 0;
	  else
	    NA *:= (4+((pow2B eq 0) select 0 else 2))*ClassNumber(-A);
	  end if;
	else:
	  if pow2B ge 2 then
	    NA := 0;
	  else
	    NA *:= ClassNumber(-4*A);
	  end if;
      end case;
    end if;
    
    // add in cuspidal fixed-points
    if A eq 4 then
   	NAc := 1;
	for f in facts do
	    p := f[1]; m := f[2];
	    if IsEven(m) then NAc *:= (p+1)*(p^((m div 2)-1));
	    else NAc *:= 2*(p^(m div 2)); end if;
	end for;
	NA +:= NAc;
    end if;
    
    return NA;

end intrinsic;

intrinsic GenusX0N(N::RngIntElt) -> RngIntElt
{ Genus of X0(N) }
/*
    Use formula 1+psi(N)/12-n2/4-n3/3-n_inf/2

    where
       [(a/b)=Jacobi symbol, p a prime]
    psi(N) = N*prod_{p|N}(p+1)/p
    n2 = prod_{p|N}(1+(-4/p)) [ or 0 if 4|N ]
    n3 = prod_{p|N}(1+(-3/p)) [ or 0 if 9|N ]
    n_inf := sum_{d|N} phi((d,N/d))
  */
  
    require N ge 1: "N must be >= 1";
    if N le 10 then 
	return 0;
    end if;
    facts := Factorisation(N);
    ps := [f[1] : f in facts];
    
    psiN := &*[(p+1)*p^(f[2]-1) where p is f[1]: f in facts];
    
    if Valuation(N,2) ge 2 then
	n2 := 0;
    else
	n2 := &*[((p mod 4) eq 1) select 2 else 0: p in ps| p ne 2];
    end if;
    
    if Valuation(N,3) ge 2 then
	n3 := 0;
    else
	n3 := &*[((p mod 3) eq 1) select 2 else 0: p in ps| p ne 3];
    end if;
    
    n_inf := 1;
    for f in facts do
	p := f[1]; m := f[2];
	if IsEven(m) then n_inf *:= (p+1)*(p^((m div 2)-1));
	else n_inf *:= 2*(p^(m div 2)); end if;
    end for;
    
    g := 1+(psiN/12)-(n2/4)-(n3/3)-(n_inf/2);
    return Integers()!g;

end intrinsic;

intrinsic GenusX1N(N::RngIntElt) -> RngIntElt
{ Genus of X1(N) }
/*
    Use formula 1+psi1(N)/12-n_inf/2
      for N >= 5
    where

    psi1(N) = (1/2)*N^2*prod_{p|N}(1-(1/p^2))
    n_inf := (1/2)*sum_{d|N} phi(d)*phi(N/d)
  */
  
    require N ge 1: "N must be >= 1";
    if N le 10 then 
	return 0;
    end if;
    facts := Factorisation(N);
    
    psi1N := &*[(p^2-1)*p^(2*(f[2]-1)) where p is f[1]: f in facts] div 2;
    
    n_inf := 1;
    for f in facts do
	p := f[1]; m := f[2];
	if m gt 1 then n_inf *:= (p-1)*(p^(m-2))*((m+1)*p-(m-1));
	else n_inf *:= 2*(p-1); end if;
    end for;
    n_inf := n_inf div 2;
    
    g := 1+(psi1N/12)-(n_inf/2);
    return Integers()!g;

end intrinsic;

intrinsic GenusX0NQuotient(N::RngIntElt, As::[RngIntElt]) -> RngIntElt
{ Computes the genus of the quotient of X0(N) by the group of
  automorphisms generated by the Atkin-Lehner involutions
  W_A for A in As }
  
/*
   Will use the fact that two commuting involutions have no
   fixed points in common and so if G is an elementary
   abelian 2-gp of autos of a curve X then Hurwitz formula
   gives (for char != 2):

   g(X)-1 = #G*(g(X/G)-1) + (1/2)*sum_g{Ng}
    where the summation is over all non-trivial elements
    g in G\{1] and Ng=#fixed points of g
*/
  
     require &and[a gt 1 : a in As]: "Atkin-Lehners must be > 1";
     require &and[N mod a eq 0 and Gcd(a,N div a) eq 1 : a in As]:
	"Atkin-Lehners must have gcd(Q,N/Q)=1";
	
     // get the genus of X0(N)
     g := GenusX0N(N);
     if #As eq 0 then return g; end if;
     
     // get the full set of Atkin-Lehners in G\[1]
     G := As;
     prods := Subsets(Seqset(As),2);
     while #prods gt 0 do
	newp := [];
	for p in prods do
	    A := (&*p) div GCD(p)^2;
	    if (A notin G) and (A notin newp) then
		Append(~newp,A);
	    end if;
	end for;
	if #newp gt 0 then
	    prods := {{a,b} : a in G, b in newp}
			join Subsets(Seqset(newp),2);
	    G := G cat newp;
	else
	    prods := {};
	end if;
     end while;
     
     // now use genus formula
     S := &+[AtkinLehnerNumberOfFixedPoints(N,A): A in G];
     assert IsEven(S);
     g1 := g-1-(S div 2);
     boo,g1 := IsDivisibleBy(g1,1+#G);
     assert boo and (g1 ge -1);
     return g1+1;

end intrinsic;
