freeze;

/*******************************************
 * 3-descent for elliptic curves           *
 *                                         *
 * Michael Stoll                           *
 * started 07-Aug-1999                     *
 *                                         *
 * Substantial modifications by            *
 * Steve Donnelly                          *
 * Last modified May 2013                  *
 *******************************************/

 /*--------------------------------------------------------------------
  
  2013-5 (released 2013-12), Steve
    - Rewrite final step, deprecate optional arguments
  
  2010-4, Steve
    - Compute local 3-torsion rank rigorously, rather than via p-adic
      calculations as was done in LocalImageInSpecialCase.
      (So the resulting Selmer rank was non-rigorous in the special case.)
    - In LocalImageInSpecialCase, use 3-power torsion in search for local points.

  2010-3, Steve
    - Use ResidueClassField, not MyResidueClassField (very slow). 
      (If problem with ResidueClassField, tell someone and it will be fixed!)
      In future if MyResidueClassField is wanted, import it from CrvG2/selmer.m

  2005-12 Steve
    - some minor bug fixes
    - important bug fixed in the following line of KS3():
      // h12 := hom< V1 -> V2 | [ V2 | Eltseq(CN!(I @@ mC))[cis] : I in S ] >;
    - removed some redundant stuff
    - Removed mUinv( . ), which was a work-around for ( . @@ mU )
    - fixed errors in local point searching by setting the correct
      (or at least hopefully correct) p adic precision.
    - There is now an attribute ThreeSelmerGroup of CrvEll, 
      and E`ThreeSelmerGroup stores a tuple containing the 
      output of ThreeSelmerGroup(E) whenever this has been computed.
    - Replaced calls to KS3 with calls to pSelmerGroup, 
      for each number field that occurs (and put in a different way
      of getting the kernel of the norm).
    - MAJOR CHANGES: Extended the program to work when the nontrivial
      3-torsion points are not all conjugate; in particular, the 3-isogeny case
      (but note this is doing full 3-descent, NOT 3-isogeny descent). 
      To do:  * Speed ups might still be possible: maybe look at IsPower
              * Make LocalImageInSpecialCase efficient, and 
                 set the p-adic precision properly


  2002, David
    - Removed obsolete mul([RngOrdIdl]) and IsSquare(RngPadElt).



  13/7/01	nicole	
      comments as to obsoleteness of first two functions



   2001-07: Paulette
   Scheme merge: new types now (CrvHyp, SetPtHyp & PtHyp)
   (there was nothing)
  
  ------------------------------------------------------------------*/

import "3selmerfunctions.m": LocalImageInSpecialCase;

declare attributes CrvEll: ThreeTorsionPoints, ThreeSelmerGroup;

// Nicely formatted output of sequences

procedure PrintBasis(B, indent)
  for b in B do
    printf " "^indent*"%o\n", b;
  end for;
end procedure;

function Denom(x)
  // x::FldNumElt
  den1 := LCM([Denominator(c) : c in Eltseq(x)]);
  O := Integers(Parent(x));
  x1 := O!(den1*x);
  num := GCD(den1, GCD(ChangeUniverse(Eltseq(x1), Integers())));
  return ExactQuotient(den1, num), O![ExactQuotient(c, num) : c in Eltseq(x1)];
end function;

intrinsic IsCubeHeuristically(a::RngElt : NumPrimes:=500 ) -> BoolElt
{For an element of a number field or an affine algebra, 
returns true if the element is a cube modulo p, for enough suitable primes p}
  A := Parent(a);
  require BaseField(A) eq Rationals() : "A must be a simple extension of Q";
  if Type(A) eq FldNum then
     pol := DefiningPolynomial(A);
  elif Type(A) eq RngUPolRes then
     pol := Modulus(A);
  else 
     require false : "Element must belong to a number field or an affine algebra";
  end if;
  assert Evaluate(pol, A.1) eq A!0;
  n := Numerator(Norm(a));
  aseq := Eltseq(a);
  dens := &*[ Denominator(q) : q in aseq ];
  p := 6; 
  for num := 1 to NumPrimes do
     // find the next suitable prime
     while true do 
        p := NextPrime(p); 
        if p mod 3 ne 1 then continue; end if;
        if IsDivisibleBy( n*dens, p) then continue; end if;
        hasrt, rt := HasRoot(pol, GF(p));
        if hasrt then 
           break;
        else
           continue; 
        end if;
     end while;
     // test a mod p
     amodp := &+[ Numerator(aseq[i])/GF(p)!Denominator(aseq[i])*rt^(i-1) : i in [1..#aseq] ];
     aIsCubemodp := amodp^((p-1) div 3) eq GF(p)!1;
     if not aIsCubemodp then return false; end if;
  end for;
  return true;
end intrinsic;


// First we need a means to construct groups 
//  K(S, 3) = { a in K^*/(K^*)^3 | (a) in I_K^3 I_S }
// where K is a number field, I_K is the ideal group of K,
// S is a set of prime ideals of K, and I_S is the subgroup of I_K
// generated by S.


// a function that tries to siplify x in K mod cubes
function red(x)
  den, x1 := Denom(x);
  fd := Factorization(den);
  den1 := (&*[ Integers() | a[1]^((a[2]+2) div 3) : a in fd ])^3;
  x1 := (den1 div den)*x1;
  num := GCD(ChangeUniverse(Eltseq(x1), Integers()));
  if Abs(num) lt 10^30 then
     fn := Factorization(num);
     num1 := (&*[ Integers() | a[1]^(a[2] div 3) : a in fn ])^3;
  else 
     num1 := 1;
  end if;
  return Parent(x1)![ ExactQuotient(c, num1) : c in Eltseq(x1) ];
end function;


// We represent a p-adic field by the following data:
// + a number field K;
// + a prime ideal in O, the integers of K, lying above p.
// From these, we deduce
// + a uniformizer;
// + a homomorphism K^* -->> finite elementary abelian 3-group with
//   kernel the elements that are cubes in the completion.

intrinsic MakeModCubes(K::FldNum, pid::RngOrdIdl) -> ModTupFld, Map
{Returns K_v^*/(K_v^*)^3 as a GF(3)-vector space, together with a map from K}

  // (K::FldNum, pid::prime ideal in K) -> ModTupFld, Map
  O := Integers(K);
  p := Minimum(pid);
  e := RamificationIndex(pid, p);
  f := Degree(pid);
  _, pi := TwoElementNormal(pid);
  F, m := ResidueClassField(pid);
  m0 := m;
  vprintf Selmer, 3: "MakeModCubes: p = %o, e = %o, f = %o\n", p, e, f;
  case #F mod 3:
    when 2:
        V := KSpace(GF(3), 1);
        h := map< K -> V | x :-> V![GF(3) | Valuation(x, pid)] >;
    when 1:
        V := KSpace(GF(3), 2); // the codomain of our homomorphism
        zeta := Roots(PolynomialRing(F)![F | 1,1,1])[1,1];
          // a cube root of unity in F
        if e*f eq 1 then
          pi := K!p;
          if Integers()!zeta gt Integers()!(zeta^2) then zeta := zeta^2; end if;
        end if;
        h := map< K -> V | x :-> V![ GF(3) | v, z eq F!1 select 0 
                                                else z eq zeta select 1 
                                                                else 2 ]
                                 where z := m(x2/(pi^v))^((#F-1) div 3)
                                 where x2 := O![ c mod ex
                                                 : c in ChangeUniverse(Eltseq(O!x1), Integers()) ]
                                 where ex := p^(Floor(v/e) + 1)
                                 where v := Valuation(x1, pid)
                                 where x1 := KisQ select x*Denominator(x)^3 
                                                   else  red(x) 
                                       where KisQ := Degree(Parent(x)) eq 1
                >;
    when 0:
        // p = 3

        // c is a pid-adic cube and a pid-unit, but lies in all other
        // prime ideals above 3 in O. 
        c := ChineseRemainderTheorem(pid^(Floor(3/2*e)+1), ideal<O | O!3>/pid^e,
                                     O!1, O!0);
        if e*f eq 1 then
          // Special case: completion is Q_3.
          // Fix the basis for Q_3^*/(Q_3^*)^3 to be 3, 1+3.
          // This is to ensure compatibility of bases between various
          //  degree 1 components of A_3; this is needed in the definition
          //  of the local descent map.
          R := quo< O | pid^2 >;
          sc := function(y) // y in K 
                vprintf Selmer, 3: "sc(<%o,%o,%o>, %o):\n", p, e, f, y;
                den, yd := Denom(y);
                vden := Valuation(den, 3);
                denp := ExactQuotient(den, 3^vden);
                _, denpi := XGCD(denp, 9); denpi := denpi mod 9;
                y := denpi*yd*3^((-vden) mod 3);
                vprintf Selmer, 3: "  Red = %o\n", y;
                v := Valuation(y, pid);
                vprintf Selmer, 3: "  Val = %o, mod 3 = %o\n", v, v mod 3;
                r := [GF(3) | v];
                y := y*3^(-v);
                while not IsIntegral(y) do y *:= c; end while;
                y := (R!y)^4;
                case y:
                  when R!1: Append(~r, GF(3)!0);
                  when R!4: Append(~r, GF(3)!1);
                  when R!7: Append(~r, GF(3)!2);
                  else error "!!! Something's wrong in sc(Q_3) !!!";
                end case;
                return r;
          end function;
          V := KSpace(GF(3), 2);
          h := map< K -> V | x :-> V!sc(x) >;
          return V, h;
        end if;
        
        // Our elementary abelian 3-group K_pid^*/(K_pid^*)^3 
        // has rank (1 or 2) + e*f. 2 <==> there is a primitive cube root
        // of unity in K_pid.
        // We can check this as follows. First of all, e most be even.
        // Then, write 3 = pi^e*u with a pid-adic unit u. Consider the 
        // additive map phi : F --> F, x |-> x*u + x^3. We have a cube root of 1
        // iff this map is not surjective.
        u := m((K!3)/(pi^e));
        vprintf Selmer, 3: "  u = %o\n", u;
        VF := KSpace(GF(3), f);
        FtoVF := map< F -> VF | x :-> VF!Eltseq(x) >;
        VFtoF := map< VF -> F | x :-> F!Eltseq(x) >;
        phi := hom< VF -> VF | [ FtoVF(x*u + x^3) where x := VFtoF(VF.i)
                                 : i in [1..f] ] >;
        vprintf Selmer, 3: "  Image(phi) = %o\n", Basis(Image(phi));
        flag := IsEven(e) and Image(phi) ne VF;
        vprintf Selmer, 3:
            "  Cube root of unity is "*(flag select "" else "not ")*"present\n";
        // if flag then
          VQ, epi := quo< VF | Image(phi) >;
        // end if;
        dim := 1 + e*f + (flag select 1 else 0);
        V := KSpace(GF(3), dim);
        // A pid-unit is a cube in K_pid iff it is a cube in R.
        R := quo<O | pid^(Floor(3/2*e)+1)>;
        // reps is a lift to O of an F_3-basis of F.
        reps := [ R!((F![ i eq j select 1 else 0 : i in [1..f] ]) @@ m0)
                   : j in [1..f] ];
        // A basis of pid-units modulo cubes is given by
        //  [ 1 + r*pi^i : r in reps, i in s ] (cat [ unr ]) ,
        // where s := [ i : i in [1..Floor(3/2*e)] | not IsDivisibleBy(i, 3) ]
        // and where in case flag is set, unr = 1 + a*pi^(3/2*e) 
        // such that the image of a in F is not in the image of phi above.
        // Together with pi itself, we get a basis of pid-adics modulo cubes.
        sc := 
        function(y) // y in K 
            vprintf Selmer, 3: "sc(<%o,%o,%o>, %o):\n", p, e, f, y;
            den, yd := Denom(y);
            vden := Valuation(den, 3);
            denp := ExactQuotient(den, 3^vden);
            _, denpi := XGCD(denp, 9); denpi := denpi mod 9;
            y := denpi*yd*3^((-vden) mod 3);
            vprintf Selmer, 3: "  Red = %o\n", y;
            v := Valuation(y, pid);
            vprintf Selmer, 3: "  Val = %o, mod 3 = %o\n", v, v mod 3;
            r := [GF(3) | v];
            ex := 3^Ceiling((v + 1 + Floor(3*e/2))/e);
            y := O![ (Integers()!c) mod ex : c in Eltseq(y) ];
            vprintf Selmer, 3: "  Redmod = %o\n", y;
            w := v;
            for j := 1 to v do
              y := (K!y)/pi;
              dy := Denom(y);
              if IsDivisibleBy(dy, 3) then
                y *:= c^Valuation(dy, 3);
                dy := Denom(y);
                error if IsDivisibleBy(dy, 3),
                      "Something's wrong in MakeModCubes in 3descent.m!";
              end if;
              _, dyi := XGCD(dy, 9); // inverse of dy mod 3-adic cubes
              dyi := dyi mod 9;
              y := dyi*O!(dy*y);
              w -:= 1;
              ex := 3^Ceiling((w + 1 + Floor(3*e/2))/e);
              y := O![ (Integers()!c) mod ex : c in Eltseq(y) ];
            end for;
            vprintf Selmer, 3: "  Integral, pid-unit y = %o\n", y;
            z := (R!y)^(3^f-1);
            vprintf Selmer, 3: "  z = %o\n", z;
              // put it into 1 + pid; changes class to negative
            for i := 1 to Floor((3*e-1)/2) do
              // check:
              error if z ne 1 and Valuation(O!(z-1), pid) lt i,
                       "In modCubes:sc: i =", i, ", y =", y, ", z =", z,
                       "Valuation(z-1) =", Valuation(O!(z-1), pid);
              z1 := m((K!O!(z - 1))/pi^i);
              if IsDivisibleBy(i, 3) then
                // Determine contribution of (1 + ?*pi^(i/3))^3
                _, z2 := IsPower(z1, 3);
                z *:= (1 - (R!(z2 @@ m0))*(R!pi)^(i div 3))^3;
              else
                // Determine contribution of (1 + ?*pi^i)
                seq := Eltseq(z1);
                r cat:= seq;
                for j := 1 to f do
                  if seq[j] ne 0 then
                    z *:= (1 - reps[j]*(R!pi)^i)^(Integers()!seq[j]);
                  end if;
                end for;
              end if;
            end for;
            if flag then
              // Determine unramified contribution
              z1 := m((K!O!(z - 1))/pi^(3*e div 2));
              r cat:= Eltseq(epi(FtoVF(z1)));
            end if;
            vprintf Selmer, 3: "  --> %o\n", r;
            return r;
       end function; 
       h := map< K -> V | x :-> V!sc(x) >;
  end case;
  return V, h;
end intrinsic;    


// Determination of local images
// =============================
// 
// For each bad prime p (i.e. p = 3 or 3|c_p), we have to find the image
// of E(Q_p)/3E(Q_p) in A_p^*/(A_p^*)^3. The map is given by
//  (x, y) |-> -2t(t-y) + (3s^2+a)(s-x)
// where  s^4 + 2as^2 + 4bs - a^2/3  = 0
// and    t^2 = s^3 + as + b .
// (A is the Q-algebra generated by s and t.)
//
// If (x,y) is a 3-torsion point, then A_p has two components Q_p with
// (s,t) = (x,y) and (s,t) = (x,-y), resp. The product of the images in
// these two components must be a cube. In the second component, the
// image is -(2t)^2 ~ (2t)^2, so we can take 2t as the image in the first
// component.
//
// If p is not 3, we can find the image from the Q_p-rational 3-power
// torsion.
//
// This is the old version of the function, for the generic case.
// The special case uses LocalImageInSpecialCase.

function LocalImage(V, mAS3, f, fnums, p, pids, sigma, tau, h, aInvs)  
  // + Elliptic curve is  given by aInvs (over Q)
  // + V is a GF(3)-vector space, mAS3 : V -> A a map giving representatives
  //   mod cubes for elements of V subset A(S, 3)
  // + f : (x,y) --> A, the descent map,
  //   and fnums is a sequence of numbers that determine the coefficients of f.
  // + p = [pid1, ..., pidk] the ideals above the prime p in A
  // + h is the involution on the field
  
  a1, a2, a3, a4, a6 := Explode(aInvs);

  // Set up map A^* --> prod_pid A_pid^*/(A_pid^*)^3
  A := Codomain(mAS3); O := Integers(A);
  // Find Q_p-rational 3-torsion
  pids0 := [ pid : pid in pids | RamificationIndex(pid) eq 1
                                 and Degree(pid) eq 1 ];  
  hI := func< I | ideal< O | [h(gen) : gen in Generators(I)]> >;
  indices := [ Position(pids0, hI(pid)) : pid in pids0 ]; 
  error if Seqset(indices) ne {1..#pids0},
     "!!! Sonething is seriously wrong in LocalImage in 3descent.m !!!";
  case #pids0:
    when 0:
      if p ne 3 then
        vprintf Selmer, 1:
                " No Q_%o-rational 3-torsion --> no restriction.\n", p;
        return V;
      else
        vprintf Selmer, 1: " dim E(Q_%o)[3] = 0\n", p;
        dim := 0;
        basis := [];
      end if;
    when 2:
      vprintf Selmer, 1: " dim E(Q_%o)[3] = 1\n", p;
      dim := 1;
      basis := [pids0[1]];
    when 8:
      vprintf Selmer, 1: " dim E(Q_%o)[3] = 2\n", p;
      dim := 2;
      basis := [pids0[1], pids0[indices[1] eq 2 select 3 else 2]];
    else error "Something is seriously wrong in LocalImage in 3descent.m!";
  end case;

// TO DO: unfinished business
  // Find p-adic coordinates of points
  // First determine the required p-adic precision
  valdiscrim := Valuation(Discriminant(MinimalPolynomial(A.1)), p);
  depth3 := p eq 3 select 4 else 1;
  f0,fx,fy,fc := Explode(fnums);
  fvalBound := 20; 
fvalBound := 100; 
  prec := 10 + Max( fvalBound + depth3 , valdiscrim );	
		// valdiscrim is the precision needed for factoring the polynomial,
		// depth3 is the # of p-adic significant figures needed
		//	to recognise cubes in the completions, 
		// fvalBound: we assume that there exist points P in E(Q_p)
		// 	such that f(P) is not divisible by p^fvalBound
		// 	(more precisely, by pid^(fvalBound*e(pid)) for any pid above p)
 		// 	and if there are not, an error will result,
		// 10 is a safety margin.
// TO DO: increase prec gradually
  vprintf Selmer, 2: "p-adic precision at p = %o is %o\n", p, prec;
  Qp := pAdicField(p, prec); 
  Rp := Integers(Qp);
  Rp1 := pAdicRing(p, Min(prec, 6)); // for output purposes
  PQp := PolynomialRing(Qp : Global := false); X := PQp.1;
  PRp := PolynomialRing(Rp); PI := PolynomialRing(Integers());
  polp := PQp!PRp!PI!MinimalPolynomial(A.1);
  fact := [ fa[1] : fa in Factorization(polp) ];
  if GetVerbose("Selmer") ge 2 then
    printf " Defining polynomial of A factors ";
    printf "into degrees %o\n", [Degree(fa) : fa in fact];
  end if;
  roots := [ Rp!(-Coefficient(fa, 0)) : fa in fact | Degree(fa) eq 1 ];
  error if #fact ne #pids,
           "!!! There must be as many factors as there are prime ideals !!!";
  error if #roots ne #pids0,
      "!!! There must be as many zeroes as there are ideals with e*f = 1 !!!";
  // find root corresponding to pid
//"Roots valuations:", [[Valuation(A.1 - O!Integers()!root, pid) : root in roots] : pid in basis ];
  broots := [ roots[pos] where 
                  _, pos := Max([Valuation(A.1 - O!Integers()!root, pid) : root in roots])
              : pid in basis ];
  tors3 := [ <Rp!hpid(sigma), Rp!hpid(tau)>
             where hpid := hom< A -> Qp | Qp!root >
              : root in broots ];
  if GetVerbose("Selmer") ge 3 and dim gt 0 then
    printf " Q_%o-rational 3-torsion has basis\n", p;
    PrintBasis([<Rp1!t[1], Rp1!t[2]> : t in tors3], 3);
  end if;
  mcs := [ <W, mW> where W, mW := MakeModCubes(A, pid) : pid in pids ];
  if GetVerbose("Selmer") ge 3 then
    printf "  Dimensions of local components:\n";
    for i := 1 to #pids do
      printf "    pid<%o, %o> : Dim = %o\n",
             RamificationIndex(pids[i]), Degree(pids[i]), Dimension(mcs[i,1]);
    end for;
  end if;
  Vp := KSpace(GF(3), &+[ Dimension(mc[1]) : mc in mcs ]);
  maps := [* *];
  for i := 1 to #pids do
    pidi := pids[i];
    if RamificationIndex(pidi)*Degree(pidi) eq 1 then
      j := Position(pids, pids0[indices[Position(pids0, pidi)]]);
      pidj := pids[j];
      mapi := mcs[i,2];
      mapj := mcs[j,2];
      Vi   := mcs[i,1];
/*
which := function(x)
Valuation(x, pidi), Valuation(x, pidj);
return Valuation(x, pidi) gt Valuation(x, pidj);
end function;
*/
      maps[i] := map< A -> Vi | x :-> // which(x)
                                      Valuation(x, pidi) gt Valuation(x, pidj)
                                      select Vi!Eltseq(-mapj(x))
                                      else   mapi(x) >;
    else
      maps[i] := mcs[i,2];
    end if;
  end for;
  mAp := map< A -> Vp | x :-> Vp!(&cat[ Eltseq(m(x)) : m in maps ]) >;
  function vals_okay(x)
/*
"Valuations", 
[ (Valuation(x, pid) - coeffGCD)/RamificationDegree(pid) 
  where coeffGCD := Min([Valuation( f0*fcoeff , pid) : fcoeff in [fx,fy,fc]])
: pid in pids ];
*/
    return forall{ pid : pid in pids | 
           (Valuation(x, pid) - coeffGCD)/RamificationDegree(pid) le fvalBound 
           where coeffGCD is Min([Valuation( f0*fcoeff , pid) : fcoeff in [fx,fy,fc]]) };
  end function;
  // Find image of 3-torsion in Vp
  ftors3 := [];
  for b in tors3 do
    fxy := f( Rationals()!b[1], Rationals()!b[2] );
    okay := vals_okay(fxy);
//if not okay then print "!!!!!!!!!!!!!!!! TORSION POINT NOT OKAY !!!!!!!!!!!!!!!!!!!"; end if;
    if okay then
      Append(~ftors3, fxy);
    end if;
  end for;
  Wp := sub< Vp | [ mAp(fxy) : fxy in ftors3] >;
  if GetVerbose("Selmer") ge 2 then
    printf "  Local image of 3-torsion is";
    if Dimension(Wp) eq 0 then
      printf " trivial\n";
    else
      printf "\n";
      PrintBasis(Basis(Wp), 4);
    end if;
  end if;
  dim1 := p eq 3 select dim + 1 else dim;
  vprintf Selmer, 2: " Total local image should have dimension %o\n", dim1;
  if Dimension(Wp) lt dim1 then
    vprintf Selmer, 2: " Need additional generator\n";
  end if;
  numtries := 0;
  numextrapointsforsafety := 0;
  while Dimension(Wp) lt dim1 or numextrapointsforsafety lt 5 do	
    numtries +:= 1;
    x := p^(2*Random(2))*Random(Rp);
    polb := a1*x + a3; polc := -(x^3 + a2*x^2 + a4*x + a6);
    flag, sqrt := IsSquare(polb^2 - 4*polc);
    if flag then
      y := Rp!((-polb + sqrt)/2);
      vprintf Selmer, 3: "  Found point (%o, %o)\n", Rp1!x, Rp1!y;
      // vprintf Selmer, 3: "    Check: v_%o(eqn(x,y)) = %o\n", p, Valuation(y^2 + polb*y + polc);
      fxy := f(Rationals()!x, Rationals()!y);
      // the point is suitable if the value of f is not too close to 0 
      // in any of the local fields
      if vals_okay(fxy) then
        if Dimension(Wp) ge dim1 then
          numextrapointsforsafety +:= 1;
        end if;
        im := mAp(fxy);
        Wp := sub< Vp | Wp, im >;
        vprintf Selmer, 3: "   Image = %o\n", im;
        vprintf Selmer, 3: "   Dimension of image so far = %o\n", Dimension(Wp);
        error if Dimension(Wp) gt dim1,
              "Finding spurious local points at ",p,
              " ... try increasing p-adic precision in LocalImages\n";
      end if;
    end if;
  end while;
  if GetVerbose("Selmer") ge 2 then
    printf " Finished finding local points at %o.\n", p;
    printf " Dimension of local image = %o = expected dimension.\n", dim1;
    printf " Basis:\n";
    PrintBasis(Basis(Wp), 3);
  end if;
  // Find inverse image in V
  homV := hom< V -> Vp | [ mAp(mAS3(V.i)) : i in [1..Dimension(V)] ] >;
  images := [ homV(V.i) : i in [1..Dimension(V)] ];
  if GetVerbose("Selmer") ge 2 then
    printf " Images of basis elements of V:\n";
    PrintBasis(images, 3);
  end if;
  VpQ, epi := quo< Vp | Wp >;
  homVV := hom< V -> VpQ | [ epi(im) : im in images ] >;
  V1 := Kernel(homVV);
  if GetVerbose("Selmer") ge 2 then
    printf " Basis of inverse image in V:\n";
    PrintBasis(Basis(V1), 3);
  end if;
  return V1;
end function;


function FindSubspace(V, pred)
  // Given a GF(3)-vector space V and some predicate pred on V such that 
  // the subset of elements satisfying pred is a subspace, find this subspace.
  
  // Divide the underlying set of V into three subsets:
  // - the elements known to satisfy pred
  // - the elements known not to satisfy pred
  // - the rest
  vprintf Selmer, 3: "  FindSubspace, dim(V) = %o\n", Dimension(V);
  Syes := { V!0 };
  basis := [ V | ]; // a basis of Syes
  Sno := { V | };
  Srest := { V | v : v in V | v ne V!0 };
  while not IsEmpty(Srest) do
    // take some element of Srest and check if it satisfies pred
    vprintf Selmer, 3: "   #Syes = %o, #Sno = %o, #Srest = %o\n",
                             #Syes, #Sno, #Srest;
    v := Random(Srest);
    vprintf Selmer, 3: "   Chose random element %o\n", v;
    if pred(v) then
      // found a new basis element
      vprintf Selmer, 3: "    v is in subspace\n";
      Append(~basis, v);
      Syesnew := { w+v : w in Syes } join { w-v : w in Syes };
      Syes join:= Syesnew;
      Snonew := { v1+v2 : v1 in Sno, v2 in Syesnew };
      Sno join:= Snonew;
      Srest diff:= Syesnew;
      Srest diff:= Snonew;
    else
      // can eliminate v and -v
      vprintf Selmer, 3: "    v is not in subspace\n";
      S0 := {v, -v};
      Snonew := { v1+v2 : v1 in Syes, v2 in S0 };
      Sno join:= Snonew;
      Srest diff:= Snonew;
    end if;
  end while;
  vprintf Selmer, 3: "  Subspace has dimension %o\n", #basis;
  return sub< V | basis >;
end function;



intrinsic ThreeSelmerGroup(E::CrvEll : ThreeTorsPts:=0, 
                                       MethodForFinalStep:=0)
   -> GrpAb, Map
{The 3-Selmer group of an elliptic curve over Q.  
Returns an abelian group, and a map from this to
the natural affine algebra}

    if MethodForFinalStep cmpne 0 then
      print "Optional argument \'MethodForFinalStep\' is obselete";
    end if;
 
    require CoefficientRing(E) cmpeq Rationals():
            "E must be defined over the rationals.";

    // check the cache...
    if assigned E`ThreeSelmerGroup and ThreeTorsPts eq 0 then
       return Explode(E`ThreeSelmerGroup);
    end if;

    originalE := E;      // for caching purposes
    E, originalEtoE, EtooriginalE := MinimalModel(E);
    aInvs := aInvariants(E);
    vprintf Selmer, 1: "Using minimal model %o\n", E;
    
    // Scaling E to make 3-division poly integral
    P := PolynomialRing(Rationals() : Global := false); x := P.1;
    phi3 := DivisionPolynomial(E, 3)/3;
    unscaledE := E;
    numScalings := 0;
    while not forall{c : c in Coefficients(phi3) | IsIntegral(c)} do
      numScalings +:= 1;
      vprintf Selmer, 1: 
              "3-division polynomial is not integral; scaling equation of E.\n";
      aInvs := [3*aInvs[1], 3^2*aInvs[2], 3^3*aInvs[3], 3^4*aInvs[4], 
                3^6*aInvs[5]];
      E := EllipticCurve(aInvs);
      phi3 := DivisionPolynomial(E, 3)/3;
    end while;
    Pr2<X,Y,Z> := Ambient(E);
    unscaledEtoE := map< unscaledE -> E | [3^(2*numScalings)*X,3^(3*numScalings)*Y,Z] >;
    originalEtoE *:= unscaledEtoE;
    EtooriginalE := Inverse(originalEtoE);

    // Now assign E`ThreeTorsionPoints and originalE`ThreeTorsionPoints (compatibly)
    if ThreeTorsPts cmpne 0 then  
       originalE`ThreeTorsionPoints := ThreeTorsPts;
    end if;
    if assigned originalE`ThreeTorsionPoints then
       E`ThreeTorsionPoints := < originalEtoE(T) : T in originalE`ThreeTorsionPoints >;
    else
       E`ThreeTorsionPoints := ThreeTorsionPoints(E);
       tup := < EtooriginalE(T) : T in E`ThreeTorsionPoints >;
       originalE`ThreeTorsionPoints := < EtooriginalE(T) : T in E`ThreeTorsionPoints >;
    end if;
    torspts := E`ThreeTorsionPoints;

    // torspts is of the form < T1, T2, ... > containing one 
    // element for each Galois orbit of E[3]-{0}, 
    // as elements of E(K) for appropriate fields K.
    // When T and -T are not in the same Galois orbit,
    // we assume that the list contains an inverse pair
    // T, -T (defined over the same field) 
    // EXCEPT in the case "mu3+Z/3Z", where the convention is.
    // here the convention is <T, -T, S, S+T, S-T>, where 
    // S, T are the basis of mu3+Z/3Z.
    // We convert to the other convention by twiddling the 5th component here
    // (and we will un-twiddle it before returning the answer).
    if ThreeTorsionType(E) eq "mu3+Z/3Z" then
       torspts[5] := -torspts[4];
    end if;
    
    a1, a2, a3, a4, a6 := Explode(aInvs);
    vprintf Selmer, 1: "3-division polynomial = %o\n", phi3;
    fact1 := [ f[1] : f in Factorization(phi3) ];
    if GetVerbose("Selmer") ge 2 then
      printf " 3-division polynomial factors into\n";
      PrintBasis(fact1, 3);
    end if;

    // Set up the algebra A 

    // SPECIAL CASE: Setting up the fields, sigma, tau.
    // Here phi3 is not irreducible.
    // We treat all subcases together, including the 3-isogeny case.
    // There are slight complications in the jInvariant 0 case.
    //
    // Here we:
    //    + define an algebra AA := Q[x]/phi3
    //    + represent AA as a sum of number fields (optimized),
    //      with maps to and from AA,
    //    + get sigma and tau as elements of AA,

    if not IsIrreducible(phi3) then
       P2<s,t> := PolynomialRing(Rationals(),2);
       AA<sigma,tau> := quo< P2 | [Evaluate(phi3,s),  
                      t^2 + a1*s*t + a3*t - s^3 - a2*s^2 - a4*s - a6] >;
       // compute the direct summands in AA and put them in 2 lists:
       // Klist1 consisting of the fields preserved by the involution,
       // Klist2 consisting of those where the involution interchanges
       // 2 copies of the same field.
       // Also compute maps  AA -> K for each field K.
       // Okay ... we need to 
       //  + make the Klists (NB DoLinearExtension), and auts
       //  + get sigma and tau, and make the maps
       FieldsIO := CartesianProduct(< Ring(Parent(T)) : T in torspts >); 
                // Fields for Input/Output
       function DoLinExt(K)
          if Type(K) eq FldRat then
             return NumberField(PolynomialRing(Rationals())![-1,1] : DoLinearExtension);
          else 
             return K;
          end if;
       end function;
       Klist1indices := [];    // Record the position in FieldsIO of each field in the Klists
       Klist2indices := [];
       Klist1 := [* *];
       Klist2 := [* *];
       for i in [1..#torspts] do
          T := torspts[i];
          if &and[-T cmpne torspts[j] : j in [1..#torspts]] then   
              // Field belongs in Klist1
              Append(~Klist1indices, i); 
              K := DoLinExt(FieldsIO[i]);
              sigmaK := K!T[1]; tauK := K!T[2];
              AAtoK := hom< AA -> K | sigmaK, tauK >;
              Kplus := sub< K | sigmaK >;
              s := Kplus!sigmaK;
              KoverKplus := RelativeField(Kplus, K);
              poltau := MinimalPolynomial(KoverKplus!tauK);
              assert Degree(poltau) eq 2;
              Kplustau<t> := ext< Kplus | poltau >;
              KplustautoK := iso< Kplustau -> K | tauK >;
              // get inverse iso via the absolute extension
              absKplustau<tt> := AbsoluteField(Kplustau);
              absKplustautoK := iso< absKplustau -> K | KplustautoK(absKplustau!tt) >;
              KtoabsKplustau := Inverse(absKplustautoK);
              KtoKplustau := hom< K -> Kplustau | Kplustau!KtoabsKplustau(K.1) >;
              autKplustau := hom< Kplustau -> Kplustau | -t - a1*s - a3 >;
              autK := hom< K -> K | KplustautoK(autKplustau(KtoKplustau(K.1))) >;
              // autK := KtoKplustau*autKplustau*KplustautoK;
              Append( ~Klist1, <K, AAtoK, autK >);
           else                                  
              // Field belongs in Klist2 
              j := [ j : j in [1..#torspts] | torspts[j] cmpeq -T ][1];
              if j gt i then                     // put in each pair only once!
                 Klist2indices cat:= [i,j];
                 K1 := DoLinExt(FieldsIO[i]);
                 K2 := K1;
                 K1toK2 := iso< K1 -> K2 | K2.1 >;    // are these maps ever used?
                 K2toK1 := iso< K2 -> K1 | K1.1 >;
                 sigmaK1 := K1!T[1]; tauK1 := K1!T[2];
                 sigmaK2 := K2!torspts[j][1]; tauK2 := K2!torspts[j][2];
                 AAtoK1 := hom< AA -> K1 | sigmaK1, tauK1 >;
                 AAtoK2 := hom< AA -> K2 | sigmaK2, tauK2 >;  
                 Append( ~Klist2, <K1, AAtoK1, K1toK2> );
                 Append( ~Klist2, <K2, AAtoK2, K2toK1> ); 
              end if;
           end if;
       end for;
       Klist := Klist1 cat Klist2;
       vprint Selmer,2: "The algebra decomposes into the following fields:",  
                                "\n   Fixed by the involution: ", Klist1,
                                "\n   Interchanged by the involution ", Klist2;

       // Now form two Q-vector spaces of dimension 8, both 
       // representing the underlying vector space of AA.
       // The basis of AAV1 will correspond to a fixed basis of AA,
       // while the basis of AAV2 will correspond to 
       // the standard bases of the fields in Klist, in that order.
       // Also define a function that does the change of basis.
       BasisofAA := [AA!1, sigma, sigma^2, sigma^3, tau, sigma*tau, sigma^2*tau, sigma^3*tau];
       AAV1 := VectorSpace(Rationals(), 8);
       AAV2 := VectorSpace(Rationals(), 8);
       AAV1toAAV2 := iso< AAV1 -> AAV2 | [AAV2! &cat[ Eltseq(AAtoK(b))
                                                       where AAtoK := tup[2] 
                                                    : tup in Klist ] 
                                         : b in BasisofAA] >;
       AAV2toAAV1 := Inverse(AAV1toAAV2);
       // functions between the AA and the direct sum of fields
       AAtoFields := func< a | < AAtoK(a) where AAtoK := tup[2]
                                 : tup in Klist > >;
                  // where a is in AA
       AAtoFieldsIO := func< a | < FieldsIO[i]!AAtoK(a) where AAtoK := Klist[j][2]
                                   where j := Index( Klist1indices cat Klist2indices, i)
                                 : i in [1..NumberOfComponents(FieldsIO)] > >;
       if ThreeTorsionType(E) eq "mu3+Z/3Z" then   // twiddle the 5th component
          AAtoFieldsIO := func< a | < aa[1], aa[2], aa[3], aa[4], Norm(aa[5])/aa[5] > 
                                    where aa := AAtoFieldsIO(a) >;
       end if;
       FieldstoAAV1 := func< tup | AAV2toAAV1(AAV2! &cat[ Eltseq(tup[i]) : i in [1..#Klist] ]) >;  
                    // where tup is a tuple <k_1,...> 
                    //              in which k_i is an element of the ith field in Klist
       FieldstoAA := func< tup | &+[ V1elt[i]*BasisofAA[i] : i in [1..8] ] 
                               where V1elt := FieldstoAAV1(tup) >;
       // Write an element of AA in terms of the chosen basis
       AAtoAAV1 := func< aa | FieldstoAAV1(AAtoFields(aa)) >;
       tors3 := no3torsionpt select 0 else 1       // rank of E(Q)[3];   
          where no3torsionpt := &and[ Degree(K[1]) gt 1 : K in Klist ];

    else

       // GENERIC CASE: Setting up the fields, sigma, tau.
       // Now phi3 is irreducible, monic and integral
    
       tors3 := 0;  // rank of E(Q)[3]
       torspt := E`ThreeTorsionPoints[1]; 
       AA := Ring(Parent(torspt));  
       sigma := torspt[1];
       tau := torspt[2];
       AAplus := sub< AA | sigma >;
       s := AAplus!sigma;
       AAoverAAplus := RelativeField(AAplus, AA);
       poltau := MinimalPolynomial(AAoverAAplus!tau);
       AAplustau<t> := ext< AAplus | poltau >;
       AAplustautoAA := iso< AAplustau -> AA | tau >;
       // get inverse iso via the absolute extension
       absAAplustau<tt> := AbsoluteField(AAplustau);
       absAAplustautoAA := iso< absAAplustau -> AA | AAplustautoAA(absAAplustau!tt) >;
       AAtoabsAAplustau := Inverse(absAAplustautoAA);
       AAtoAAplustau := hom< AA -> AAplustau | AAplustau!AAtoabsAAplustau(AA.1) >;
       autAAplustau := hom< AAplustau -> AAplustau | -t - a1*s - a3 >;
       autAA := hom< AA -> AA | AAplustautoAA(autAAplustau(AAtoAAplustau(AA.1))) >;
       OA := Integers(AA);
       // AA1 is an alternative model of AA, which we use in the final step
       AA1<tau1> := NumberField(MinimalPolynomial(tau));
       AA1toAA := iso< AA1 -> AA | tau >;
       AAtoAA1 := Inverse(AA1toAA);
    
    end if;


    // FIND THE BAD PRIMES

    bad0 := BadPrimes(E);
    bad := [ 3 ];
    for p in bad0 do
      cp := TamagawaNumber(E, p);
      vprintf Selmer, 2: "  Bad prime %o --> c_%o = %o\n", p, p, cp;
      if IsDivisibleBy(cp, 3) and p ne 3 then Append(~bad, p); end if;
    end for;
    vprintf Selmer, 1: " Bad primes for 3-descent: %o\n", bad;


    // COMPUTE A(S,3)
    // For each number field, find KS3 (and if the involution
    // preserves the field, find the kernel of the norm)
    // and combine the results into a group AS3 inside A/A^3
    
    if Type(AA) eq FldNum and IsSimple(AA) then   // GENERIC CASE
       badIdeals := [  [ id[1] : id in Decomposition(OA, p) ] 
                    : p in bad ];
       S := &cat badIdeals;
       vprintf Selmer,1: "Computing KS3 for %o ... \n", AA;
       vprint Selmer,2: "pSelmerGroup: ";
       t0 := Cputime();
       AS3full, AtoAS3full := pSelmerGroup(3, {pid : pid in S} : Raw);
       vprintf Selmer,1: "  ... pSelmerGroup time = %o, now finished computing KS3.\n", Cputime(t0);
       rankofthis := Ilog(3,#AS3full);
       vprintf Selmer, 2: "Rank = %o\n", rankofthis;

       // NEW WAY OF FINDING NORM KERNEL
       // Simply define the norm homomorphism on KS3full
       //       a :-> a + autAA(a)
       // by computing autAA on a basis of AS3full, and then find the kernel.
       vprint Selmer, 2: "Finding the kernel of the norm: ";
       t0 := Cputime();
       NormOnAS3full := hom< AS3full -> AS3full | 
                        [ g + autAA(g @@ AtoAS3full) @ AtoAS3full where g := AS3full.i 
                        : i in [1..#Generators(AS3full)] ] >;
       AS3 := Kernel(NormOnAS3full);
       V := VectorSpace(GF(3), Ilog(3,Order(AS3)));
       VtoAS3 := map< V -> AS3 | v :-> AS3!Eltseq(v) >;
       AS3toV := map< AS3 -> V | s :-> V!Eltseq(s) >;
       mAS3 := map< V -> AA | v :-> VtoAS3(v) @@ AtoAS3full>; 
       Selmermap := map< V -> CartesianProduct([AA]) | v :-> <VtoAS3(v) @@ AtoAS3full>,
                                                       tup :-> tup[1] @ AtoAS3full @ AS3toV >; 
       vprintf Selmer, 2: "  ... time = %o, norm kernel has rank %o\n", Cputime(t0), Dimension(V);
    
    elif Type(AA) eq RngMPolRes then              // reducible phi3 case
       // for fields in Klist1, call KS3 as in the generic case
       // (but the same comment applies)
       badIdeals := [ [* *] : p in bad ];       // these get passed to LocalImage
       KS3list1 := [* *];
       KS3list2 := [* *];
       for i in [1..#Klist1] do
         vprintf Selmer,1: "Computing KS3 for %o\n", K;
         K, AAtoK, autK := Explode(Klist1[i]);
         OK := Integers(K);
         for p in bad do
             Append( ~badIdeals[Index(bad,p)], 
                      [ id[1] : id in Decomposition(OK, p) ] );
         end for;
         S := &cat[ badIdeals[j][i] : j in [1..#bad] ];
         KS3full, KtoKS3full:= pSelmerGroup(3, {pid : pid in S} : Raw);
         // NEW WAY OF FINDING NORM KERNEL
         vprint Selmer,3: "Finding norm kernel (new way)";
         NormOnKS3full := hom< KS3full -> KS3full | 
            [ g + autK(g @@ KtoKS3full) @ KtoKS3full where g := KS3full.i 
              : i in [1..#Generators(KS3full)] ] >;
         KSthree := Kernel(NormOnKS3full);
         mKS3 := map< KSthree -> K | g :-> g @@ KtoKS3full>;
         Append( ~KS3list1, <KSthree, mKS3>);
       end for;
       for i in [1..#Klist2] do
         vprintf Selmer,3: "Doing K1S3 for %o\n", K1;
         K1, _, K1toK2 := Explode(Klist2[i]);
         OK := Integers(K1);
         for p in bad do
             Append( ~badIdeals[Index(bad,p)], 
                      [ id[1] : id in Decomposition(OK, p) ] );
         end for;
         if IsOdd(i) then        // only for the first in each identical pair of fields
           S := &cat[ badIdeals[j][#Klist1 + i] : j in [1..#bad] ];
           K2 := Explode(Klist2[i+1]);
           K1S3, mapp := pSelmerGroup( 3, {pid : pid in S} : Raw);
           mK1S3 := Inverse(mapp) * map< K1 -> K1 | a :-> a >;
           mK2S3 := mK1S3 * K1toK2 * map< K2 -> K2 | a :-> a^2 >; // image in K2, inverse to mK1S3
           Append( ~KS3list2, <K1S3, mK1S3, mK2S3>);
         end if;
       end for;
       
       AS3 := VectorSpace( GF(3), &+[ #Generators(Ktup[1]) : Ktup in KS3list1 cat KS3list2] ); 
       // define mAS3 on generators, 
       // first get images of generators of the KS3's in AA
       imagesinAA := [ AA | ];
       for i in [1..#KS3list1] do           // for each generator of AS3
          KSthree := KS3list1[i][1];             //   coming from Klist1
          for gen in Generators(KSthree) do 
              // run through the fields     
              imageinfields := < k eq i select mKS3(gen) 
                                               where mKS3 := KS3list1[i][2]
                                        else   K!1 
                                               where K := Klist[k][1] 
                               : k in [1..#Klist] >;
              Append( ~imagesinAA, FieldstoAA(imageinfields) );
          end for;
       end for;
       for i in [1..#KS3list2] do           // for each generator of AS3
          K1S3 := KS3list2[i][1];            //   coming from Klist2 
          mK1S3 := KS3list2[i][2]; 
          mK2S3 := KS3list2[i][3]; 
          for gen in Generators(K1S3) do 
              // run through the fields     
              imageinfields := < case< k-#Klist1 |   
                                       2*i-1     : mK1S3(gen), 
                                       2*i       : mK2S3(gen), 
                                       default   : K!1   where K := Klist[k][1] >
                                 : k in [1..#Klist] >;
              Append( ~imagesinAA, FieldstoAA(imageinfields) );
          end for;
       end for;
       mAS3 := map< AS3 -> AA | g :-> &*[ imagesinAA[i]^(Integers()!Eltseq(g)[i]) 
                                        : i in [1..#Generators(AS3)] ] >;
       Fields := CartesianProduct([ K[1] : K in Klist ]);                                       
       V := AS3;
       Selmermap := map< V -> FieldsIO | v :-> AAtoFieldsIO(mAS3(v)) >;
    end if; // special case
    
    vprintf Selmer, 1: "A(S, 3) (the kernel of the norm) has dimension %o\n", Dimension(V);
    if Dimension(V) eq tors3 then 
       Sel3group := AbelianGroup( [3 : i in [1..Dimension(V)]] );
       if IsIrreducible(phi3) then  // an inverse for Selmermap is implemented
          Sel3map := map< Sel3group -> Codomain(Selmermap) | 
                     s :-> Selmermap( &+[Eltseq(s)[i]*Basis(V)[i] : i in [1..Dimension(V)]] ),
                    im :-> &+[Coordinates(im @@ Selmermap)[i]*Sel3group.i : i in [1..Dimension(V)]] >;
       else
          Sel3map := map< Sel3group -> Codomain(Selmermap) | 
                     s :-> Selmermap( &+[Eltseq(s)[i]*Basis(V)[i] : i in [1..Dimension(V)]] ) >;
       end if;
       originalE`ThreeSelmerGroup := <Sel3group, Sel3map>;
       return Sel3group, Sel3map; 
    end if;

    // Define map f from Points(E) to AA 
    // (that defines the homomorphism E/3E -> AA/AA^3).
    // Below (x,y) denotes a point of E.
    fx := a1*tau - 3*sigma^2 - 2*a2*sigma - a4;
    fy := 2*tau + a1*sigma + a3;
    fc := -fx*sigma - fy*tau;
    f0 := fc^2 - a3*fc*fy - a6*fy^2;
    if Type(AA) eq FldNum then
       f0 := AA!red(f0);
    else
      x0 := 0;
      while &or[ AAtoK(f0) eq 0 where AAtoK := K[2] : K in Klist ] do
          // f0 is the value of fx*x + fy*y + fc on the divisor (0,y0)+(0,y0')
          // If f0 has image 0 in one of the fields in AA, replace it by another value
          x0 +:= 1;
          // Norm( fx*x0 + fy*y0 + fc ) = fy^2*Norm( -(fc+fx*x0)/fy - y0 ) 
          f0 := (fc+fx*x0)^2 - (a1*x0 + a3)*(fc+fx*x0)*fy - (x0^3 + a2*x0^2 + a4*x0 + a6)*fy^2;
          error if x0 gt 100, "Can't set up the descent map f";
      end while;
    end if;
    fnums := [f0, fx, fy, fc];
    vprintf Selmer, 3:
            " f(x,y) = (%o)*((%o)*x + (%o)*y + %o)\n", f0, fx, fy, fc;
    f := func< x, y | f0*(fx*x + fy*y + fc) >;


    
    // FIND LOCAL RESTRICTIONS: 
    // Cut down AS3 by testing local images using the map f
      
    for i in [1..#bad] do 
      vprintf Selmer: "Finding local image for p = %o ... ", bad[i];
      IndentPush();
      vtime Selmer:
      if IsIrreducible(phi3) then
         V := LocalImage(V, mAS3, f, fnums, bad[i], badIdeals[i], sigma, tau, autAA, aInvs);
      else                      
         // IMPORTANT: determine the local 3-torsion rank rigorously (ie not relying on p-adic calculations)
         num_local_tors := 0;
         for T in torspts do 
           L := Ring(Parent(T));
           if Type(L) eq FldRat then
             num_local_tors +:= 1;
           else
             num_local_tors +:= #[tup : tup in Decomposition(L,bad[i]) | LocalDegree(tup[1]) eq 1];
           end if;
         end for;
         assert num_local_tors in {0,2,8};
         rank_local_tors :=  case< num_local_tors | 0 : 0, 2 : 1, default : 2 >;
         V := LocalImageInSpecialCase(V, mAS3, f, fnums, bad[i], badIdeals[i], sigma, tau, aInvs, Klist1, Klist2, rank_local_tors);
      end if;
      IndentPop();
      vprintf Selmer, 1:
           "Local conditions at %o -> dimension = %o\n", bad[i], Dimension(V);
      if Dimension(V) eq tors3 then 
         Sel3group := AbelianGroup( [3 : i in [1..Dimension(V)]] );
         if IsIrreducible(phi3) then  // an inverse for Selmermap is implemented
            Sel3map := map< Sel3group -> Codomain(Selmermap) | 
                       s :-> Selmermap( &+[Eltseq(s)[i]*Basis(V)[i] : i in [1..Dimension(V)]] ),
                      im :-> &+[Coordinates(im @@ Selmermap)[i]*Sel3group.i : i in [1..Dimension(V)]] >;
         else
            Sel3map := map< Sel3group -> Codomain(Selmermap) | 
                       s :-> Selmermap( &+[Eltseq(s)[i]*Basis(V)[i] : i in [1..Dimension(V)]] ) >;
         end if;
         originalE`ThreeSelmerGroup := <Sel3group, Sel3map>;
         return Sel3group, Sel3map; 
      end if;
    end for;
   

    // FINAL STEP 

    // Further global restriction, using the algebra B.
    //  * Main idea: if an element of A is in H^1,
    // then it is in the kernel of the "norm" map from A to B
    // that we will construct.
    //  * B is another algebra of degree 8 over Q, defined as
    // the algebra of functions on lines in the plane that 
    // meet E in three nontrivial 3-torsion points.
    // It is generated by m = the slope of the line
    // (warning: in the "a=0" case, two of the lines are 
    // parallel, so the min poly of m has a double root).
    //  * The case "a=0" (in other words, j-invariant = 0)
    // is handled separately. In this case 
    // two of the lines are parallel, and so 
    // BA is not generated by the slope. 

    vprint Selmer,1: "Final step (involving the algebra B)";

    irred := Type(AA) eq FldNum; // in this case, B is also a field 

    if irred then
       P2 := PolynomialRing(P : Global := false); X := P2.1; Y := P2!P.1;
       polB := Resultant(Evaluate(phi3, X),
                        Y^2 + a1*Y - a2 + Coefficient(phi3, 3) + X);
       BA := NumberField(polB);
       slope := BA.1;
       sigmaB := -(slope^2 + a1*slope - a2 + Coefficient(phi3, 3));
       autBA := hom< BA -> BA | -slope - a1 >;
       linet := -1/(2*slope + a1)*(Coefficient(phi3, 2)
                 + sigmaB*(-slope^2 - a1*slope + a2) + a3*slope - a4);
    else
       P2<xx,yy> := PolynomialRing(Rationals(),2);
       if jInvariant(E) ne 0 then
          BA<sigmaB,slope> := quo< P2 | [ Evaluate(phi3,xx),  
                        yy^2 + a1*yy - a2 + Coefficient(phi3, 3) + xx ] >;
          linet := -1/(2*slope + a1)*(Coefficient(phi3, 2)
                    + sigmaB*(-slope^2 - a1*slope + a2) + a3*slope - a4);
       else
          // jInvariant = 0.
          // In this case, this BA is not yet right (one of its components is Q[m]/m^2).
          // We need to use t as well (where (m,t) determine the line is y=mx+t)
          // We can write down the relations for a model E : y^2 = x^3 + C6 
          // ... first mess around with the models ...
          EWModel, EtoEWM, EWMtoE := WeierstrassModel(E);
          _,_,_,C4,C6 := Explode(aInvariants(EWModel));
          require C4 eq 0: "Special case j-invariant = 0, ",
                           "something's going wrong while trying to define BA";
          xtrans, ytrans, ztrans := Explode(DefiningPolynomials(EWMtoE));
          PR := Parent(xtrans);
          u2:= MonomialCoefficient(xtrans, PR.1);
          rr:= MonomialCoefficient(xtrans, PR.3);
          u3:= MonomialCoefficient(ytrans, PR.2);
          ss:= MonomialCoefficient(ytrans, PR.1);
          tt:= MonomialCoefficient(ytrans, PR.3);
          mtrans := (u2*xx-ss)/u3;
          ttrans := (yy+rr*xx-tt)/u3;
          // define the relations on m and t (xx and yy respectively) 
          // in the coordinates of EWModel, by explicitly finding the 3 torsion
          rels1 := [ xx*(xx^6-4*C6), (yy^2+3*C6)*(yy^2-C6), xx*(xx^3+2*yy), 
                     (yy^2+3*C6)*(xx^3+2*yy), xx*(yy^2-C6) ]; 
          // transform back to E
          rels := [ Evaluate(rel, [mtrans, ttrans]) : rel in rels1 ];
          BA<slope, linet> := quo< P2 | rels >;   
          sigmaB := -(slope^2 + a1*slope - a2 + Coefficient(phi3, 3));
          require Dimension(BA) eq 8 and Evaluate(phi3, sigmaB) eq 0 :
            "Special case j-invariant = 0, ", "something's going wrong while trying to define BA";
       end if;
       vprintf Selmer, 2: "AbsoluteAlgebra ... "; 
       vtime Selmer, 2:
       BAfields, BAtofields := AbsoluteAlgebra(BA);
    end if;  // Type(AA) eq FldNum 

    // Define the map from A to B
    PB := PolynomialRing(BA);
    phi3red := ExactQuotient(PB!phi3, PB.1 - sigmaB);
    sx1 := -Coefficient(phi3red, 2);
    sx2 := Coefficient(phi3red, 1);
    sx3 := -Coefficient(phi3red, 0);
    sy1 := slope*sx1 + 3*linet;
    sy2 := slope^2*sx2 + 2*slope*linet*sx1 + 3*linet^2;
    sy3 := slope^3*sx3 + slope^2*linet*sx2 + slope*linet^2*sx1 + linet^3;
    P := PolynomialRing(Rationals()); 
    MBA3 := MatrixAlgebra(BA,3);
    mat := MBA3! [ BA | 0,1,0, 0,0,1, sy3,-sy2,sy1 ];    // Michael's mat for y
    if irred then
       AAtoBA := map< AA -> BA | aa :-> Determinant(Evaluate(P!Eltseq(AAtoAA1(aa)), mat)) >;
    else
       // now use x as well as y, and the relationship y = slope*x + linet
       matx := MBA3! [ BA | 0,1,0, 0,0,1, sx3,-sx2,sx1 ];
       maty := slope*matx + linet*Identity(MBA3);
       assert CharacteristicPolynomial(mat) eq CharacteristicPolynomial(maty);
       // BasisofAA := [AA!1, sigma, sigma^2, sigma^3, tau, sigma*tau, sigma^2*tau, sigma^3*tau];
       AAtoBA := map< AA -> BA | aa :-> Determinant(matrixForaaOverBA) 
                 where matrixForaaOverBA :=&+[ aaSeq[i]*matsForBasis[i] : i in [1..8] ] 
                   where aaSeq := Eltseq(AAtoAAV1(aa))
                   where matsForBasis := 
                         [MBA3!1, matx, matx^2, matx^3, maty, matx*maty, matx^2*maty, matx^3*maty] >;
    end if;

debug := false;

    // Find the subspace whose images in B are cubes.
    // First identify the subspace using residue fields, then verify cubeness

    V0 := V;
    if irred then
      V0basis_B := [< V0.i @mAS3 @AAtoBA > : i in [1..Ngens(V0)]];
    else
      V0basis_B := [ V0.i @mAS3 @AAtoBA @BAtofields : i in [1..Ngens(V0)]];
    end if;
    Vbasis_B := V0basis_B;

denoms := &* [Integers()| d where _,d := IsIntegral(xi) : xi in x, x in V0basis_B];
assert denoms eq 1;

    numB := irred select 1 else NumberOfComponents(BAfields);
    NUM := 0;
    repeat
      NUM +:= 10;

      vprintf Selmer: "Final step: testing cubeness in B using at least %o primes: ", NUM;
      vtime Selmer:

      for i := 1 to numB do
        ZBi := irred select Integers(BA) else Integers(BAfields[i]);
        p := 0;
        count := 0;
        while count lt NUM do
          repeat 
            p := NextPrime(p);
          until p mod 3 eq 1 and p notin bad and // GCD(p,denoms) eq 1 and
            exists(P) {tup[1] : tup in Factorization(p*ZBi) 
                              | tup[2] eq 1 and Degree(tup[1]) eq 1};
          k, res := ResidueClassField(P);
          bool, zeta3 := HasRoot(Polynomial([k| 1,1,1]));
          rts3 := [k| zeta3, zeta3^2, 1];
          e := (p - 1) div 3;

          // find images of Vbasis_B[.,i] in k*/k^3
          flag := false;
          C := Matrix(GF(3), Dimension(V), 1, []);
          for r := 1 to #Vbasis_B do
            xx := Vbasis_B[r,i] @res;
            if IsZero(xx) then
              flag := true;
              break;
            end if;
            c := Index(rts3, xx^e);
            assert c ne 0; // c = 1, 2 or 3
            C[r,1] := c;
          end for;
          if flag then
            continue;
          end if;

          V := RowSpace( KernelMatrix(C)*BasisMatrix(V) );

          if Ngens(V) lt #Vbasis_B then
            vprintf Selmer, 2: "(dimension = %o) ", Ngens(V);

            if Ngens(V) eq 0 then
              break i;
            end if;

            // Reset Vbasis_B = images of Basis(V)
            // (transform from V0, not cumulatively)
            T := Solution(BasisMatrix(V0), BasisMatrix(V));
            T := ChangeRing(T, Integers());
            Vbasis_B := [Universe(Vbasis_B)|
                           < &*[ V0basis_B[s,j] ^ T[r,s] : s in [1..Ngens(V0)]] : j in [1..numB] >
                        : r in [1..Ngens(V)]];
if debug then
if irred then
assert forall{r : r in [1..Ngens(V)] | IsPower( (V.r @mAS3 @AAtoBA) / Vbasis_B[r,1], 3)};
else
assert forall{<r,j> : r in [1..Ngens(V)], j in [1..numB] | IsPower( (V.r @mAS3 @AAtoBA @BAtofields)[j] / Vbasis_B[r,j], 3)};
end if;
end if;
            count := 0;
          else
            count +:= 1;
          end if;

        end while;
      end for;

      if Ngens(V) eq 0 then
        done := true;
      else
        vprintf Selmer: "Final step: verifying cubeness in B: ";
        vtime Selmer:
        done := forall{xi : xi in x, x in Vbasis_B | IsPower(xi, 3) };
      end if;

    until done;

    vprintf Selmer, 1: "Restriction to kernel of map to B^*/(B^*)^3 -> dimension = %o\n", Dimension(V);


    // This is a nice check of class group and S-unit calculations

    if debug and Ngens(V0) gt 0
and Type(BA) eq FldNum // TO DO
    then
      // Note that we can use BS3full here 
      // (it's not necessary to take the "norm kernel") 
      vprint Selmer, 1: "Checking with pSelmerGroup method";
      t0 := Cputime();
      IndentPush();

      OB := Integers(BA);
      SB := &cat[ [s[1] : s in Decomposition(OB, p)] : p in bad ];
      BS3full0, BAtoBS3full0 := pSelmerGroup(3, {sb : sb in SB} : Raw);
      BS3full := VectorSpace(GF(3), Ilog(3, #BS3full0) );
      BAtoBS3full := map< BA -> BS3full | a :-> BS3full!Eltseq(BAtoBS3full0(a)) >;
      homGlob2new := hom< V0 -> BS3full | [BAtoBS3full(AAtoBA(mAS3(v))) : v in Basis(V0)] >;
      assert V eq Kernel(homGlob2new);

      IndentPop();
      vprint Selmer, 1: "Time for pSelmerGroup method:", Cputime(t0);
    end if;


    Sel3group := AbelianGroup( [3 : i in [1..Dimension(V)]] );
    if IsIrreducible(phi3) then  // an inverse for Selmermap is implemented
       Sel3map := map< Sel3group -> Codomain(Selmermap) | 
                  s :-> Selmermap( &+[Eltseq(s)[i]*Basis(V)[i] : i in [1..Dimension(V)]] ),
                 im :-> &+[Coordinates(im @@ Selmermap)[i]*Sel3group.i : i in [1..Dimension(V)]] >;
    else
       Sel3map := map< Sel3group -> Codomain(Selmermap) | 
                  s :-> Selmermap( &+[Eltseq(s)[i]*Basis(V)[i] : i in [1..Dimension(V)]] ) >;
    end if;

    originalE`ThreeSelmerGroup := <Sel3group, Sel3map>;
    return Sel3group, Sel3map; 
end intrinsic;

