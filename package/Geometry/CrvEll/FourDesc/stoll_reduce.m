freeze;
 
/****************************************************
 * Reduction of intersections of two quadric surfaces
 *
 * Michael Stoll, 2002-02-26, 2002-04-23
 ****************************************************/

/****************************************************
 We associate to a pair of quadrics Q1,Q2 in four variables
 a positive definite quadratic form Q(x,y,z,w).
 
 This is done as follows. 
 The curve described by Q1 = Q2 = 0 is fixed by a subgroup
 of PGL_4 isomorphic to Z/4Z x Z/4Z, generated by matrices
 M_1 and M_2, which we can assume to have determinant 1
 (then M_1^4 = M_2^4 = I, and both matrices have eigenvalues
 1, i, -1, -i). There is a unique Hermitian form Q (up to
 scaling) that is fixed by this group.
 
 This Q is positive definite and (as a Hermitian form) 
 a covariant of <Q1,Q2> (up to scaling); in fact the unique
 (real) Hermitian covariant of <Q1,Q2>.
 
 Q defines a lattice which we can Minkowsi-reduce.
 Applying the corresponding transformations to <Q1,Q2>, we
 obtain a reduced curve.
 
 I.e., <Q1,Q2> is reduced if Q is reduced if the lattice
 defined by Q is Minkowski-reduced.
 ****************************************************/

import "quartred.m": QuarticReduceInternal;

function Covariant(mat1,mat2,qr)
 R:=CoefficientRing(mat1); vprintf ReduceFD,2: "Computing covariant\n";
 vprintf ReduceFD,3: "Covariant of pair of matrices:\n%o\n%o\n",mat1,mat2;
 size:=Log(Max([Abs(c) : c in Eltseq(mat1) cat Eltseq(mat2)|c ne 0]))/Log(10);
 prec:=Ceiling(size)+50; precok:=false;
 R:=FieldOfFractions(R); P1:=PolynomialRing(R);
 while true do f:=Determinant(P1.1*ChangeRing(mat1,P1)+ChangeRing(mat2,P1));
  if Degree(f) ne 4 then mat1:=mat1+mat2; else break; end if; end while;
 d:=Lcm([Denominator(x) : x in Eltseq(f)]);
 f1:=PolynomialRing(Integers())!(f*d); tr:=Matrix(2,2,[[1,0],[0,1]]);
 ok:=false; extra_prec:=0; vprintf ReduceFD,2: "Reducing quartic\n";
 // Bug fix below to allow for increased precision to avoid infinite loop,
 // for example for the quartic 78*x^4 - 25*x^3 - 468*x^2 + 25*x + 78  
 //     --- Steve
 while not ok do oldf1:=f1; 
  ok,f1,T,qr:=QuarticReduceInternal(f1,qr:extra_prec:=extra_prec); 
  if f1 eq oldf1 then extra_prec+:=10; end if; tr:=tr*T; end while;
 K:=quo<P1|f1>; s:=(tr[1][1]*K.1+tr[1][2])/(tr[2][1]*K.1+tr[2][2]);
 mat:=s*ChangeRing(mat1,K)+ChangeRing(mat2,K); //Evaluate(f,s) eq 0;
 vprintf ReduceFD,2: "Finding kernel\n";
 ker:=Kernel(mat); vprintf ReduceFD,2: "Kernel dim %o\n",Dimension(ker);
 v:=Eltseq(Basis(ker)[1]); v1:=v;
 if Dimension(ker) ge 2 then v2:=Eltseq(Basis(ker)[2]); end if;
 if Dimension(ker) ge 3 then v3:=Eltseq(Basis(ker)[3]); end if;
 if Dimension(ker) ge 4 then v4:=Eltseq(Basis(ker)[4]); end if;
 while (precok eq false) do vprintf ReduceFD,2: "Trying precision %o\n",prec;
  if Dimension(ker) ge 2 then v:=Vector(v)+Random([-1..1])*Vector(v1); end if; 
  if Dimension(ker) ge 2 then v:=Vector(v)+Random([-9..9])*Vector(v2); end if;
  if Dimension(ker) ge 3 then v:=Vector(v)+Random([-9..9])*Vector(v3); end if;
  if Dimension(ker) ge 4 then v:=Vector(v)+Random([-9..9])*Vector(v4); end if;
  precok:=true; roo:=Roots(f1,ComplexField(prec));
  homs:=[hom<K->ComplexField(prec) | r[1]> : r in roo];
  sing:=[Matrix([[h(mat[i,j]) : j in [1..4]] : i in [1..4]]): h in homs];
  vert:= [[h(c) : c in Eltseq(v)] : h in homs];
  vprintf ReduceFD,3: "Vertices of singular quadrics in pencil:\n%o\n",vert;
  t1:=Matrix(vert); u:=Determinant(t1);
  if #roo eq 4 and Norm(u) ne 0 then
   PC4<[X]>:=PolynomialRing(ComplexField(prec),4);
   singt:=[t1*s*Transpose(t1) : s in sing];
   singt1:=[DiagonalMatrix([i eq j select 0 else singt[i,j,j] :
				j in [1..4]]) : i in [1..4]];
   check:=func<m|&+[Norm(m[i,j]) : i,j in [1..4]] lt 1.0e-20>;
   ck:=[&+[Norm(k) : k in Eltseq(singt[i]-singt1[i])] : i in [1..4]];
   ck2:=[t lt 1.0e-20 : t in ck]; ck3:=[singt1[t,1,1] ne 0.0:t in [2..4]]; 
   if (&and ck2 ne true or &and ck3 ne true) then
    if (&and ck2 ne true) then
     vprintf ReduceFD,2: "Matrices not symmetric\n"; end if;
    if (&and ck3 ne true) then
     vprintf ReduceFD,2: "Leading coefficient 0 (!)\n"; end if;
     u:=Ceiling(Max([Log(Abs(t))/Log(10) : t in &cat vert | Abs(t) ne 0]));
     prec:=Max(u+50,Ceiling(Sqrt(2)*prec)); precok:=false;
   else vprintf ReduceFD,3: "Transformed singular quadrics:\n%o\n",
			    [&+[s[i,i]*PC4.i^2 : i in [1..4]] : s in singt1];
   three:=[[singt1[i,j,j]/singt1[i,1,1] : j in [1..4]] : i in [2..4]];
   covt:=[1] cat [Sqrt(Modulus(&*[three[i,j+1] : i in [1..3] | i ne j]))
		      : j in [1..3]];
   vprintf ReduceFD,3: "Transformed covariant:\n%o\n",
		       &+[covt[i]*PC4.i^2 : i in [1..4]];
   conj:=func<m|Matrix([[ComplexConjugate(m[i,j]):j in [1..4]]:i in [1..4]])>;
   t2:=Adjoint(t1)/u; CM:=conj(t2)*DiagonalMatrix(covt)*Transpose(t2);
   if not (check(CM-Transpose(CM)) and check(CM-conj(CM))) then
    vprintf ReduceFD,2: "Covariant not real symmetric\n"; precok:=false;
    u:=Ceiling(Max([Log(Abs(t))/Log(10) : t in Eltseq(CM) | Abs(t) ne 0]));
    prec:=Max(50+u,Ceiling(Sqrt(2)*prec));
   else
    CM:=Matrix([[Real(CM[i,j]):j in [1..4]]:i in [1..4]]); CM+:=Transpose(CM);
    x:=Sqrt(&+[Norm(c) : c in Eltseq(CM)]);
    if x eq 0 then precok:=false; prec:=Ceiling(Sqrt(2)*prec);
     vprintf ReduceFD,2: "Norms round to zero\n";
    elif not IsPositiveDefinite(CM) then precok:=false;
     prec:=Ceiling(Sqrt(2)*prec);
     vprintf ReduceFD,2: "Not positive definite\n";
    else CM*:=1/x; vprintf ReduceFD,3: "Covariant is %o\n",
				       &+[CM[i,j]*PC4.i*PC4.j : i,j in [1..4]];
    end if; end if; end if;
  else vprintf ReduceFD,2: "Determinant is zero or #roots!=4\n";
   precok:=false; prec:=Ceiling(Sqrt(2)*prec); end if;
  if (precok eq false) then
   vprintf ReduceFD,2: "Increasing precision to %o\n",prec; end if;
  end while; return ChangeRing(CM,RealField(prec)),qr; end function;
