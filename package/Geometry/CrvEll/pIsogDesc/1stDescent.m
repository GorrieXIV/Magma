freeze;
/****************************************************************
1stDescent.m
Brendan Creutz
Apr. 2011

  First q-isogeny descent. The method is described Tom Fisher's PhD thesis

  We consider an elliptic E1/Q with a Q-rational point P of order q = 5,7. 
  This gives an exact	sequences
    0 --> Z/qZ --> E1 --phi--> E2
    mu_q ---> E1 ---phi'---> E2

    ** function IsogenyDescent(lambda,q) -> nP,SelModnP,r1,r2,E1,E2
    ** RETURNS:
      nP::SeqEnum - models for the elements in the image of the group generated by P inside the phi'-Selmer group as g1nml curves.
      SelModnP::SeqEnum - models for the elements in the quotient of the phi'-Selmer group by nP as g1nml curves.
      r1::RngIntElt - the q-rank of the phi-Selmer group
      r2::RngIntElt - the q-rank of the phi'-Selmer group
      E1::CrvEll
      E2::CrvEll	
    
    **  function LambdaFromEandP(E,P) -> lambda
        lambda is the coordinate on X_1(q) corresponding to (E1,P).

    ** function WeierstrassFromLambda(lambda,q)-> E1,E2	

****************************************************************/


IsogenyDescent := function(lambda,q,ModTorsion);

lambda := Rationals()! lambda;
F := GF(q);
Zq2 := Integers(q^2);

if Valuation(lambda,q) lt 0 then
  if q eq 5 then
    lambda := -1/lambda;
  end if;
  if q eq 7 then
    lambda := (lambda-1)/lambda;
  end if;
end if;


if q eq 7 then
  alpha := lambda^4*(lambda-1);
  beta := lambda^3-8*lambda^2 + 5*lambda + 1;
  boolq := false;
  if Valuation(lambda,7) ge 0 and (F!Numerator(lambda)*(F!Denominator(lambda))^(-1)) eq 5 then
    boolq := true;
  end if;
  PP<[x]> := ProjectiveSpace(Rationals(),q-1);
  x0,x1,x2,x3,x4,x5,x6 := Explode(x);
end if;

if q eq 5 then
  alpha := lambda;
  beta := lambda^2-11*lambda-1;
  boolq := false;
  if Valuation(lambda,5) ge 0 and (Zq2!Numerator(lambda))*((Zq2!Denominator(lambda))^(-1)) eq 18 then
    boolq := true;
  end if;
  PP<[x]> := ProjectiveSpace(Rationals(),q-1);
  x0,x1,x2,x3,x4 := Explode(x);
end if;

pm := Sign(alpha);
primesNA := Factorization(Numerator(alpha));
primesDA := Factorization(Denominator(alpha));
primesA := primesNA cat [ <p[1],-p[2]> : p in primesDA ];
// primesA consists of primes in the set called A from Fisher's thesis, together with their multiplicities in alpha(lambda).

A := [ p[1] : p in primesA];



primesNB := Factorization(Numerator(beta));
B := [ p[1] : p in primesNB | (p[1] mod q) eq 1 and Valuation(beta,p[1]) gt 0];
if boolq then
  Include(~B,q);
end if;
// B is the 'other set of primes', labelled B in Fisher's thesis.

//Set up the pairing Xi : [A] x [B] -> Z/qZ.
//The Selmer groups are the left and right kernels.
//We do this with discrete logs... might be a better way
Xi := [];
for p in B do
  Fp := GF(p);
  if p ne q then
    prim := PrimitiveElement(Fp);
    for r in A do
      Xi cat:= [Log(prim,Fp!r) mod q];
    end for;
  else // p eq q

    //choose a primitive element
    if q eq 5 then
      a := Zq2 ! 2; // a primitive element.
    else // q eq 7
      a := Zq2 ! 3; // a primitive element.
    end if;

    //compute discrete logs mod q^2
    for r in A do
      an := a;
      n := 1;
      while an ne (r mod q^2) do
	an *:= a;
	n +:= 1;
      end while;
      Xi cat:= [n mod q];
    end for;

  end if;
end for;

XiMat := Matrix(F,#B,#A,Xi);
BracketA := KSpace(F,#A);
QtoBracketA := map< Rationals() -> BracketA | x :-> BracketA! [ Valuation(x,p) : p in A] >;
// Only well defined on rationals which have no primes outside A appearing in num and denom.

Sel := sub<BracketA|Kernel(Transpose(XiMat))>;
if ModTorsion then
  mwP := sub<Sel|QtoBracketA(alpha)>;
  // mwP is the subspace generated by the image of the rational torsion point under the connecting homomorphism.
  Selm,modmw := quo<Sel|mwP>;
else
  Selm,modmw := quo<Sel|Sel!0>;
end if;

if #Selm gt 1 then
  SelmSet := Set(Selm) diff {Selm!0};
  Selmpm := {};
  for v in SelmSet do
    if not -v in Selmpm then
      Include(~Selmpm,v);
    end if;
  end for;
else
  Selmpm := {Selm!0};
end if;
SelmpminSel := { Eltseq(w @@ modmw) : w in Selmpm};
// It remains to write down models for the elements in these sets.

GetEqs := function(t,lambda)

  if q eq 7 then
    eqs := [];
    for i in [0..6] do
      e1 := t[(0+i) mod 7 + 1]*x[(0+i) mod 7 + 1]^2 + x[(1+i) mod 7 + 1]*x[(6+i) mod 7 + 1] - (1/lambda)^2*t[(2+i) mod 7 + 1]*t[(3+i) mod 7 + 1]*t[(4+i) mod 7 + 1]*t[(5+i) mod 7 + 1]*x[(2+i) mod 7 + 1]*x[(5+i) mod 7 + 1];

      e2 := t[(0+i) mod 7 + 1]*x[(0+i) mod 7 + 1]^2  + lambda*x[(1+i) mod 7 + 1]*x[(6+i) mod 7 + 1]- (1/lambda)^3*t[(2+i) mod 7 + 1]*t[(3+i) mod 7 + 1]^2*t[(4+i) mod 7 + 1]^2*t[(5+i) mod 7 + 1]*x[(3+i) mod 7 + 1]*x[(4+i) mod 7 + 1];
      eqs cat:= [e1,e2];
    end for;
  end if;

  if q eq 5 then
    eqs := [];
    for i in [0..4] do
      eqs cat:= [t[(0+i) mod 5 + 1]*x[(0+i) mod 5 + 1]^2 + x[(1+i) mod 5 + 1]*x[(-1 + i) mod 5 + 1] - t[(2+i) mod 5 + 1]*t[(3+i) mod 5 + 1]*x[(2+i) mod 5 + 1]*x[(3+i) mod 5 + 1]];
    end for;
  end if;

  mkInt := function(C);
	  eqs := DefiningEquations(C);
	  neqs := [];
	  for e in eqs do
		  coeffs := Coefficients(e);
		  d := LCM([ Denominator(f) : f in coeffs ]);
		  neqs cat:= [ d*e ];
	  end for;
	  return Curve(AmbientSpace(C),neqs);
  end function;

  C := Scheme(PP,eqs);
  return mkInt(Curve(C));

end function;

shift := function(tau,a);
  t := tau;
  for i in [1..#tau] do
    tau[((i-1+a)mod q)+1] := t[i];
  end for;
  return tau;
end function;

DistributeLambda := function(alpha,primesA);

Sigs := [];
for pe in primesA do

  Sigma_p := [ Rationals()!1 : i in [1..q] ];
  p := pe[1]^(Sign(pe[2]));
  e := AbsoluteValue(pe[2]);

  if e mod q eq 0 then
    while e mod q eq 0 do
      Sigma_p[1] *:= p^2;
      for j in [3..q] do
	Sigma_p[j] *:= p;
      end for;
      e := Integers() !(e/q);
    end while;
    Sigs cat:= [<Sigma_p,1,pe[1]>];
  else
    while e gt 0 do
      if e mod 2 ne 0 then
	Sigma_p[q] *:= p;
	e -:= 1;
      end if;
      if (e mod q) ge (q -1) then
	for j in [1..q-1] do
	  Sigma_p[j] *:= p;
	end for;
	e -:= q-1;
      else
	if e ge 4 then
	  for j in [1,2,q-2,q-1] do
	    Sigma_p[j] *:= p;
	  end for;
	  e -:= 4;
	end if;
	if e ge 2 then
	  for j in [Integers()!((q-1)/2),Integers()!((q+1)/2)] do
	    Sigma_p[j] *:= p;
	  end for;
	  e -:= 2;
	end if;
      end if;
    end while;
    Sigs cat:= [<Sigma_p,pe[2] mod q,pe[1]>];
  end if;
end for;

if pm ne 1 then
  Sigs cat:= [<[0],0,0>];
end if;

return Sigs;
end function;


GetTau := function(sel,Sigs);

//shift trick will not work if e mod q eq 0 for some p^e in the factorization of alpha...
b := 1;
if Sigs[#Sigs][3] eq 0 then
  b *:= -1;
  Sigs := [ Sigs[j] : j in [1..#Sigs-1] ];
end if;
k := 1;
Sigsel := [ Rationals()! b ] cat [Rationals()!1 : j in [1..q-1] ];
for s in Sigs do

  Sigps := shift(s[1],Integers()! ((F!s[2])^(-1)*(F!sel[k])) );
  for r in [1..q] do
    Sigsel[r] *:= Sigps[r];
  end for;
  k +:= 1;

end for;
t := [ Sigsel[q+1-i] : i in [1..#Sigsel] ];
return t;
end function;

// Routine continues here.

Sigs := DistributeLambda(alpha,primesA);
sss := Setseq(SelmpminSel);
SEL := [ GetEqs(GetTau(w,Sigs),lambda) : w in sss ];

return SEL,Dimension(Kernel(XiMat)),Dimension(Kernel(Transpose(XiMat)));
end function; // IsogenyDescent

WeierstrassFromLambda := function(lambda,q);
//Computes Weierstrass equations for the curves corresponding to the point lambda in X_1(q)(Q) = P^1(Q).

if q eq 7 then
  D_lambda := EllipticCurve([1+lambda-lambda^2,lambda^2-lambda^3,lambda^2-lambda^3,0,0]);
  b2 := lambda^4 -6*lambda^3+3*lambda^2+2*lambda+1;
  t := lambda*(lambda-1)*(lambda^2-lambda+1) *(lambda^3+2*lambda^2-5*lambda+1);
  w := lambda^2*(lambda-1)^2*(2*lambda^6-2*lambda^5+lambda^4-8*lambda^3+15*lambda^2-9*lambda+2);
  C_lambda := EllipticCurve([1+lambda-lambda^2,lambda^2-lambda^3,lambda^2-lambda^3,-5*t,-b2*t-7*w]);
end if;
if q eq 5 then
  D_lambda := EllipticCurve([1-lambda,-lambda,-lambda,0,0]);
    b2 := lambda^2 - 6*lambda + 1;
  t := lambda*(lambda^2 + 2*lambda -1);
  w := lambda^2*(2*lambda^2+lambda + 1);
  C_lambda := EllipticCurve([1-lambda,-lambda,-lambda,-5*t,-b2*t-7*w]);
end if;
  return D_lambda, C_lambda;
end function; // WeierstrassFromLambda

LambdaFromEandP := function(E,P);
// P is a point of order q on an elliptic curve E;
// We want to find a Weierstrass equation for E of the form
// y^2 + (1-lambda)*x*y - lambda*y = x^3 - lambda*x^2 where P = (0,0)

q := Order(P);
R<r,s,t,u> := PolynomialRing(Rationals(),4);
a1,a2,a3,a4,a6 := Explode(aInvariants(E));

if not( P[1] eq 0 and P[2] eq 0 and a4 eq 0 and a6 eq 0 ) then
  // model is not yet in the right form
  // we look for the change of variables x :-> u^2x+r, y :-> u^3y+u^2sx+t
  r := P[1];
  t := P[2];
  f_4 := -a1*r*s - a1*t + 2*a2*r - a3*s + a4 + 3*r^2 - 2*s*t;
  f_6 := -a1*r*t + a2*r^2 - a3*t + a4*r + a6 + r^3 - t^2;
  if q eq 5 then
    // equate a2 and a3
    f_23 := u*(-a1*s + a2 + 3*r - s^2) - (-a1*r - a3 - 2*t);
    // equate a1 and a3+1
    f_13 := u^2*(-a1 - 2*s) - (-a1*r - a3 - 2*t) - u^3;
    rf := Reduce([f_4,f_6,f_13,f_23]);
    s := -Evaluate(rf[1],[0,0,0,0]);
    u := -Evaluate(rf[2],[0,0,0,0]);
  end if;

  if q eq 7 then
    // equate a2 and a3... and hope
    f_23 := u*(-a1*s + a2 + 3*r - s^2) - (-a1*r - a3 - 2*t);
    rf := Reduce([f_4,f_6,f_23]);
    s := -Evaluate(rf[1],[0,0,0,0]);
    u := -Evaluate(rf[2],[0,0,0,0]);
  end if;

  Q<X,Y,Z> := Parent(DefiningEquation(E));
  f := Evaluate(DefiningEquation(E),[u^2*X+r*Z,u^3*Y+u^2*s*X+t*Z,Z]);
  E := Curve(ProjectiveSpace(Rationals(),2),f);
  E := EllipticCurve(E,E(Rationals()) ! [0,1,0]);
end if;
if q eq 5 then
  return Rationals()!-aInvariants(E)[3];
end if;
if q eq 7 then
  a := aInvariants(E);
  if a[1] ne 1 then
    return a[2]/(a[1]-1);
  else
    return "lambda = 0";
  end if;
end if;
end function; // LambdaFromEandP

/*************************************
**************************************
//Examples where the second descent gives something non trivial.

q := 5;
E := EllipticCurve("570l3");
lambda := 48/5;
E := EllipticCurve("570l4");
lambda := 100/9;

E := EllipticCurve("870i3");
lambda := 45/4;
E := EllipticCurve("870i4");
lambda := 50/3;

E := EllipticCurve("1050o2");
lambda := 21/2;

E := EllipticCurve("1938j2");
lambda := -68/3;

E := EllipticCurve("1950y2");
lambda := 144/13;

E := EllipticCurve("2370m2");
lambda := 54/5;

E := EllipticCurve("2550be2");
lambda := 34/3;

E := EllipticCurve("3270h2");
lambda := 15/2;

q := 7;
E := EllipticCurve("546f2");
lambda := 7;

E := EllipticCurve("858k2");
lambda := -9/2;

E := EllipticCurve("1230k2");
lambda := 6;

****************************************************/
