freeze;
/***************************************

 pIsogDesc.m
 Brendan Creutz 
 started: April 2011
 
// Signatures for first and second
// p-isogeny descents on elliptic	
// and genus one normal curves of
// degrees p = 3,5,7
***************************************/


import "2nd3isog.m" : Second3IsogenyDescent;
import "2ndDescent.m" : PhiDescent;
import "1stDescent.m" : IsogenyDescent, WeierstrassFromLambda, LambdaFromEandP;

/*
pIsogenyDescent(E::CrvEll,p::RngIntElt) CHECK
pIsogenyDescent(E::CrvEll,P::PtEll) CHECK, 3
pIsogenyDescent(lambda::FldRat,p::RngIntElt) CHECK, 3

// Second p-isogeny descents:
pIsogenyDescent(C::Crv,E1::CrvEll,E2::CrvEll) CHECK
pIsogenyDescent(C::Crv,phi::MapSch) CHECK, 5,7
pIsogenyDescent(C::Crv,P::PtEll)  CHECK, 3

//without models:
FakeIsogenySelmerSet(C::Crv,E1::CrvEll,E2::CrvEll) CHECK
FakeIsogenySelmerSet(C::Crv,phi::MapSch) CHECK,5,7
FakeIsogenySelmerSet(C::Crv,PtEll) CHECK,3

ThreeDescentByIsogeny(E::CrvEll)
*/

intrinsic pIsogenyDescent(E::CrvEll[FldRat],p::RngIntElt : ModTorsion := true)
 -> RngIntElt,RngIntElt,SeqEnum,CrvEll
{Perform phi- and phi'-descents where phi:E -> E2 is an isogeny of degree p whose kernel is generated by P.}

  if p eq 3 then
    Selphi,m1,Selphihat,m2,phi := ThreeIsogenyDescent(E);
    return Ilog(3,2*#Selphi+1),Ilog(3,2*#Selphihat+1),Selphihat,Codomain(phi);
  end if;

  if p in {5,7} then
    G,m := TorsionSubgroup(E);
    error if (#G mod p) ne 0, "Not yet implemented for E(Q)[p] ne 0.\n";
    P := m(G.1);
    while Order(P) ne p do
      P := m(Random(G));
    end while;

    lambda := LambdaFromEandP(E,P);
    _,E2 := WeierstrassFromLambda(Rationals()!lambda,p);
    Sel,r1,r2 := IsogenyDescent(lambda,p,ModTorsion);
    return r1,r2,Sel,E2;
  end if;

  error if true,
    "Only implemented for p = 3,5,7.\n";
  return "";

end intrinsic;

intrinsic pIsogenyDescent
(E::CrvEll[FldRat],P::PtEll[FldRat] : ModTorsion := true)
 -> SeqEnum,RngIntElt,RngIntElt,CrvEll
{Perform phi- and phi'-descents where phi:E -> E2 is an isogeny of degree p whose kernel is generated by P.}

  require Curve(P) eq E : "Point P must be on elliptic curve E";
  p := Order(P);  
  error if not p in {5,7}, "Not yet implemented in this case.\n";
  if p in {5,7} then
    lambda := LambdaFromEandP(E,P);
    SEL,r1,r2 := IsogenyDescent(Rationals()!lambda,p,ModTorsion);
    _,E2 := WeierstrassFromLambda(Rationals()!lambda,p);
    return r1,r2,SEL,E2;
  end if;
  error if true, "Only implemented for p = 3,5,7\n";
  return "";

end intrinsic;

intrinsic pIsogenyDescent(lambda::FldRatElt,p::RngIntElt : ModTorsion := true)-> RngIntElt, RngIntElt, SeqEnum, CrvEll, CrvEll
{Perform phi- and phi'-descents where phi:E -> E2 is an isogeny of degree p whose kernel is generated by lambda.}

  error if not p in {5,7}, "Not yet implemented in this case.\n";

  if p in {5,7} then
    E1,E2 := WeierstrassFromLambda(Rationals()!lambda,p);
    SEL,r1,r2 := IsogenyDescent(Rationals()!lambda,p,ModTorsion);
  end if;
return r1,r2,SEL,E1,E2;

end intrinsic;


intrinsic pIsogenyDescent(C::Crv[FldRat],phi::MapSch)-> SeqEnum, List
{Computes the phi-Selmer set of the genus one normal curve C for an isogeny
phi: E1 -> E2 = Jac(C) whose kernel is generated by the point P.}

  // why is C not a GenusOneModel type?
  require Genus(C) eq 1: "Genus must be 1";
  // can we check if C is normal ?
  p := Degree(phi);

  error if p eq 7, "Not yet implemented, try calling FakeIsogenySelmerSet().";

  if p eq 3 then
    Covers,Maps := Second3IsogenyDescent(C,"","",phi,true);
    return Covers,Maps;
  end if;
  if p in {5,7} then
    Covers, Maps := pIsogenyDescent(C,Domain(phi),Codomain(phi));
    return Covers,Maps;
  end if;
  error if p ne 3, "Not yet implemented in this case.";

end intrinsic;


intrinsic pIsogenyDescent(C::Crv[FldRat],E1::CrvEll[FldRat],E2::CrvEll[FldRat])
 -> SeqEnum, List
{Computes the phi-Selmer set of the genus one normal curve C for an isogeny
phi: E1 -> E2 = Jac(C) whose kernel is generated by the point P.}

  // why is C not a GenusOneModel type?
  require Genus(C) eq 1: "Genus must be 1";
  // can we check if C is normal ?
  p := Dimension(AmbientSpace(C))+1;

  error if p eq 7, "Not yet implemented, try calling FakeIsogenySelmerSet().";

  if p eq 3 then
    Covers,Maps := Second3IsogenyDescent(C,E1,E2,"",true);
    return Covers,Maps;
  end if;

  if p in {5,7} then
    G,m := TorsionSubgroup(E1);
    error if (#G mod p) ne 0, "Not yet implemented for E1(Q)[p] ne 0";
    Covers,Maps := PhiDescent(C,E1,E2,true);
    return Covers,Maps;
  end if;

  error if true, "Only implemented for p = 3,5,7.";

end intrinsic;


intrinsic pIsogenyDescent(C::Crv[FldRat],P::PtEll[FldRat])-> SeqEnum, List
{Computes the phi-Selmer set of the genus one normal curve C for an isogeny
phi: E1 -> E2 = Jac(C) whose kernel is generated by the point P.}

  // why is C not a GenusOneModel type?
  require Genus(C) eq 1: "Genus must be 1";
  // can we check if C is normal ?

  p := Order(P);
  error if p eq 3, "Not yet implemented in this case.";
  error if p eq 7, "Not yet implemented, try calling FakeIsogenySelmerSet().";

  if p in {5,7} then
    E1 := Curve(P);
    lambda := LambdaFromEandP(E1,P);
    _,E2 := WeierstrassFromLambda(lambda,p);
    Covers,Maps := PhiDescent(C,E1,E2,true);
    return Covers, Maps;
  end if;

  error if not p in {3,5,7}, "Not yet implemented in this case.";

end intrinsic;




intrinsic FakeIsogenySelmerSet(C::Crv[FldRat],phi::MapSch)-> RngIntElt
{Computes the dimension of the fake phi-Selmer set of the genus one normal curve C 
for an isogeny phi: E1 -> E2 = Jac(C) whose kernel is generated by the point P.}

  // why is C not a GenusOneModel type?
  require Genus(C) eq 1: "Genus must be 1";
  // can we check if C is normal ?

  p := Degree(phi);
  if p eq 3 then
    return Second3IsogenyDescent(C,"","",phi,false);
  end if;

  if p in {5,7} then
    return FakeIsogenySelmerSet(C,Domain(phi),Codomain(phi));
  end if;

  error if not p in {3,5,7}, "Not yet implemented in this case.";

end intrinsic;

intrinsic FakeIsogenySelmerSet
(C::Crv[FldRat],E1::CrvEll[FldRat],E2::CrvEll[FldRat])-> RngIntElt
{Computes the dimension of the fake phi-Selmer set of the genus one normal curve C 
for an isogeny phi: E1 -> E2 = Jac(C) whose kernel is generated by the point P.}

  // why is C not a GenusOneModel type?
  require Genus(C) eq 1: "Genus must be 1";
  // can we check if C is normal ?

  p := Dimension(AmbientSpace(C))+1;
  if p eq 3 then
    return Second3IsogenyDescent(C,E1,E2,"",false);
  end if;
  if p in {5,7} then
    return PhiDescent(C,E1,E2,false);
  end if;
  error if not p in {3,5,7}, "Not yet implemented in this case.";
  
end intrinsic;

intrinsic FakeIsogenySelmerSet(C::Crv[FldRat],P::PtEll[FldRat])-> RngIntElt
{Computes the dimension of the fake phi-Selmer set of the genus one normal curve C 
for an isogeny phi: E1 -> E2 = Jac(C) whose kernel is generated by the point P.}

  // why is C not a GenusOneModel type?
  require Genus(C) eq 1: "Genus must be 1";
  // can we check if C is normal ?

  p := Order(P);
  error if p eq 3, "Not yet implemented in this case.";
  
  if p in {5,7} then
    E1 := Curve(P);
    lambda := LambdaFromEandP(E1,P);
    _,E2 := WeierstrassFromLambda(lambda,p);
    return PhiDescent(C,E1,E2,false);
  end if;

  error if not p in {3,5,7}, "Not yet implemented in this case.";
    
end intrinsic;


intrinsic ThreeDescentByIsogeny(E::CrvEll[FldRat]) ->  SeqEnum, List
{A list of elements of the 3-Selmer group of E, given as plane cubic curves, and a list 
of the corresponding maps to E, computed by first and second 3-isogeny descents.}
// needs work!!!

Selphi,m1,Selphihat,m2,phi := ThreeIsogenyDescent(E);
Sel3E := [];
M1 := [* *];
Sel3Ehat := [];
M2 := [* *];

for C in Selphihat do
  s := Index(Selphihat,C);
  rho := m2[s];
  Ds,pis := pIsogenyDescent(C,phi);
  for j in [1..#Ds] do
    D := Ds[j];
    pi := pis[j];
    Pi := pi*rho;
    Sel3E cat:= [D];
    Append(~M1,Pi);
  end for;
end for;

phihat := DualIsogeny(phi);
for C in Selphi do
  s := Index(Selphi,C);
  Sel3E cat:= [C];
  Append(~M1,m1[s]*phihat);
end for;

n := 1;
while n lt #Sel3E do
C := Sel3E[n];
for D in { Sel3E[r] : r in [n+1..#Sel3E]} do
  if IsEquivalent(GenusOneModel(C),GenusOneModel(D)) then
    s := Index(Sel3E,D);
    Remove(~Sel3E,s);
    Remove(~M1,s);
  end if;
end for;
n +:= 1;
end while;

// Now throw out the trivial covering:
Triv := GenusOneModel(CubicFromPoint(E,E(Rationals())!0));
for C in Sel3E do
  if IsEquivalent(GenusOneModel(C),Triv) then
    Remove(~Sel3E,Index(Sel3E,C));
    break;
  end if;
end for;

return Sel3E,M1;

end intrinsic;
