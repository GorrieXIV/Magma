freeze;

/////////////////////////////////////////////////////////////////
//   Abstract AbelianGroup of E(F_q), with discrete log map.   //
//                                                             //
//   Steve Donnelly, November 2009                             //
/////////////////////////////////////////////////////////////////

// work-around for discrete Log in finite fields 
// (doesn't handle trivial case where the base has small order)

function mylog(b, x, ordb)
  if ordb le 10^4 then
    bi := 1;
    for i := 0 to ordb-1 do 
      if bi eq x then
        return i;
      end if;
      bi *:= b;
    end for;
    error "No solution to discrete log";
  else
    // don't use Log(b,x)
    l := Log(x)/Log(b);
    ll := Numerator(l) * Modinv(Denominator(l), ordb);
    return ll mod ordb;
  end if;
end function;

// this assumes r is the exponent of G; returns 0 on failure

function point_of_order(r, G : use:=[])
  i := 0;
  P := Curve(G)! 0;
  order := 1;
  while order ne r do 
    i +:= 1;
    R := #use ge i select use[i] else Random(G);
    R := order*R;
    oR := Order(R);
    if r mod (order*oR) ne 0 then 
      return 0; // r is not the exponent of G 
    end if;  
    if GCD(oR, r div oR) eq 1 then
      P +:= R;
      order *:= oR;
    end if;
  end while;
  return P;
end function;

intrinsic MyAbelianGroup(E::CrvEll[FldFin]) -> GrpAb, Map
{The group E(F) of points on an elliptic curve E defined over a finite field F,
as an abstract group A together with a map (with inverse) from A to the point set E(F)}
  return MyAbelianGroup(E(BaseField(E)));
end intrinsic;
 
intrinsic MyAbelianGroup(G::SetPtEll[FldFin]) -> GrpAb, Map
{"} // "
  E := Curve(G);
  F := Ring(G);
  assert G eq E(F); // not possible to have a subgroup (?)

  q := #F;
  N := #G;
  primes := PrimeDivisors(N); // Factorization is needed, so do it now

  for k := 5 to 105 by 10 do 
    error if k gt 100,   // something must be wrong
          "Failed to determine AbelianGroup for", E, 
          "Please send this curve to magma-bugs@maths.usyd.edu.au";
    // figure out structure of G = Z/r + Z/s
    // (with at worst ~ 1/2^k probability of getting it wrong, 
    // in which case we find out below and start again from here)
    points := [Random(G) : i in [1..k]];
    r := LCM([Order(P) : P in points]);
    s := N div r;
    rdivs := r div s;
    sprimes := [p : p in primes | s mod p eq 0];
    awkward_primes := [p : p in sprimes | rdivs mod p eq 0];
    r2 := &* [Integers()| p^Valuation(r,p) : p in awkward_primes];
    s2 := &* [Integers()| p^Valuation(s,p) : p in awkward_primes];
    r1 := r div r2;
    s1 := s div s2;

    P1 := point_of_order(r, G : use:=points); 
    if P1 cmpeq 0 then
      continue k; // r is not the exponent of G
    end if;
    if s eq 1 then
      A := AbelianGroup([r]);
      AtoG := map< A -> G | a :-> Eltseq(a)[1] * P1, 
                            P :-> A! Log(P1, P) >;
    else
      // find an independent generator P2 of order r
      for tries := 1 to 100 do
        if tries eq 100 then
          continue k; // probably r and s are wrong
        end if;
        P2 := point_of_order(r, G);
        if P2 cmpeq 0 then
          continue k; // r is not the exponent of G
        end if;
        w := WeilPairing(P1, P2, r); // TO DO(?) use the s1*r2 pairing instead of r
        // P2 is independent if w has order s
        assert w^s eq 1;
        if forall{p : p in sprimes | w^(s div p) ne 1} then
          break tries;
        end if;
      end for;
      // Now we know the group structure Z/r + Z/s is correct, 
      // generated by P1 and P2; next adjust P2 to have order s
      if r2 eq 1 then
        P2 := rdivs*P2;
      else
        l := Log((r1*s2)*P1, (r1*s2)*P2); // fast (both arguments have small order)
        P2 := (r1 div s1)*(P2 - l*P1);
        assert Order(P2) eq s;
      end if; // r2 eq 1

      A := AbelianGroup([r,s]);
      // set up the discrete log map 
      rdivsP1 := rdivs*P1;
      if r2 eq 1 then 
        w := w^rdivs; 
      else
        w := WeilPairing(rdivsP1, P2, s); 
      end if;
      toA := function(P)
        l := Log(s*P1, s*P);
        PP := P - l*P1; 
        assert s mod Order(PP) eq 0;
        // find x,y such that PP = x*r/s*P1 + y*P2
        xx := WeilPairing(PP, P2, s);
        yy := WeilPairing(PP, rdivsP1, s);
        x := mylog(w, xx, s) mod s;
        y := -mylog(w, yy, s) mod s;
        assert PP eq x*rdivsP1 + y*P2;
        return A! [x*rdivs + l, y];
      end function;
      AtoG := map< A -> G | a :-> aa[1]*P1 + aa[2]*P2 where aa is Eltseq(a),
                            P :-> toA(P) >; 
    end if;   // s eq 1

    return A, AtoG;
  end for;
end intrinsic;

