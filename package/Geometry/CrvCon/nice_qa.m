freeze;

//////////////////////////////////////////////////////////////////////
//  Code for finding a nicer presentation of a quaternion algebra   //
//  Steve Donnelly                                                  //
//////////////////////////////////////////////////////////////////////

import "points.m" : can_factor;

function eltseq(x) 
   return &cat [Eltseq(y) : y in Eltseq(x)];
end function;

function seqelt(A, s)
   K := BaseRing(A);
   d := Degree(K);
   s := Eltseq(s);
   assert #s eq 4*d;
   sK := [K! s[m*d+1..m*d+d] : m in [0..3]];
 //assert eltseq(A!sK) eq s;
   return A! sK;
end function;

function z_module(M)
   d := Denominator(M);
   dM := ChangeRing(d*M, Integers());
   dB := HermiteForm(dM);
   dB := ChangeRing(dB, Rationals());
   dB := RowSubmatrix(dB, 1, Rank(dB));
   return dB/d;
end function;

function z_basis(elements)
   A := Universe(elements);
   M := Matrix([eltseq(x) : x in elements]);
   B := z_module(M);
   return [seqelt(A, B[i]) : i in [1..Nrows(B)]];
end function;

// T is the row matrix of images of the elements in ZB

function kernel_z_basis(ZB, T)
   TT := ChangeRing(T*Denominator(T), Integers());
   K := KernelMatrix(TT); // left kernel of T on standard Z-module 
   assert Ncols(K) eq #ZB;
   return [&+[K[i,j]*ZB[j] : j in [1..#ZB]] : i in [1..Nrows(K)]];
end function;

function trace_form_gram(ZB)
   diag := [Integers()! Trace(Norm(x)) : x in ZB]; 
   Gram := 2*DiagonalMatrix(diag);
   for i in [1..#ZB], j in [i+1..#ZB] do 
      ij := Integers()! (Trace(Norm(ZB[i]+ZB[j])) - diag[i] - diag[j]);
      Gram[i,j] := ij;
      Gram[j,i] := ij;
   end for;
   return Gram;
end function;

// returns a "reduced" Z-basis of the Z-module spanned by the given sequence

function reduced_z_basis(ZB)
   Gram := trace_form_gram(ZB);
//printf "LLLGram (%odefinite) ... ", IsPositiveDefinite(Gram) select "" else "in"; 
//time
   redGram, T := LLLGram(Gram); // redGram = T*Gram*Transpose(T) 
   redZB := [&+[ZB[i]*T[j,i] : i in [1..#ZB]] : j in [1..#ZB]];
   return redZB;
end function;

function size(x) 
   return Max([Abs(c) : c in Eltseq(x)]);
end function;

function smallest(seq : factor:=false, lazy:=false)
   norms := [Norm(x) : x in seq];
   if lazy then 
      // Norm takes way too long!!! so only check norms of some smaller elements 
      sizes := [size(x) : x in norms];
      Sort(~sizes, ~perm);
      perm := Eltseq(perm);
      seq1 := [seq[i] : i in perm];
      norms := [norms[i] : i in perm];
      num := Max(5, #seq div 10);
      norms := norms[1 .. num];
   else
      seq1 := seq;
   end if;
   Nnorms := [Abs(Norm(x)) : x in norms];
   Sort(~Nnorms, ~perm);
   perm := Eltseq(perm);
   seq2 := [seq1[i] : i in perm];
   norms := [norms[i] : i in perm];
   if not factor then
      return seq2[1];
   else
      for i := 1 to #seq2 do 
         if can_factor(norms[i], 2) then
            return seq2[i];
         end if;
      end for;
"OH NO!!! Can't factor any of the new candidates! Giving up..."; 
      return false;
   end if;
end function;

// Tries (small combinations) of a reduced basis wrt some natural quadratic form.
// on the Z-module generated by the order OK[1,i,j,ij] together with the given 'elements'.
// If 'reduce_a', then insist on making a smaller, although b may get larger.

intrinsic NicerQuaternionAlgebra(A::AlgQuat[FldAlg] : elements:=[], reduce_a:=false) -> AlgQuat, Map
{Tries to find an isomorphic algebra with nicer a and b}

   verb := IsVerbose("Quaternion") or IsVerbose("Conic");

   K := BaseField(A);
   OK := Integers(K);

   i := A.1; j := A.2; ij := A.3;
   require {Trace(i), Trace(j), Trace(ij)} eq {K|0} and i*j eq ij and -j*i eq ij :
          "The given algebra must be in standard form";
   require IsIntegral(Norm(i)) and IsIntegral(Norm(j)) : 
          "The generators of the given algebra are not integral";

   zb := z_basis([c*b : c in Basis(OK), b in [1,i,j,ij]] cat elements);

   // find the trace zero submodule
   traces := Matrix([Eltseq(Trace(x)) : x in zb]);
   trace_zero_z_basis := reduced_z_basis(kernel_z_basis(zb, traces));
   assert #trace_zero_z_basis eq 3*Degree(K);

   na := Abs(Norm(Norm(i)));
   if na eq 1 then
      if reduce_a then 
         return A, map< A->A | a:->a, a:->a >;
      end if;
      ii := i;
   elif Abs(Norm(Norm(j))) eq 1 then 
      ii := j;
   else  
      ii := smallest(trace_zero_z_basis : factor);
      if ii cmpeq false or reduce_a and na le Abs(Norm(Norm(ii))) then
         return A, map< A->A | a:->a, a:->a >;
      end if;
   end if;

   // find the submodule that anti-commutes with ii
   commutators := Matrix([eltseq(ii*x + x*ii) : x in zb]);
   jj_z_basis := reduced_z_basis(kernel_z_basis(zb, commutators));
   assert #jj_z_basis eq 2*Degree(K);

   jj := smallest(jj_z_basis : factor);
   if jj cmpeq false then
      return A, map< A->A | a:->a, a:->a >;
   end if;
   assert ii*jj + jj*ii eq 0;

   if exists(z){z: z in [ii,jj] | Norm(z) eq 0} then
      if verb then "Found a zero divisor!!! Returning matrix ring!"; end if;
      return MatrixRing(A, z);
   end if;

   // change of basis 
   T := Matrix(K, 4, 4, [Eltseq(A!x) : x in [1, ii, jj, ii*jj]]);
   Ti := T^-1;

   AA := QuaternionAlgebra< K | -Norm(ii), -Norm(jj) >;
   AtoAA := map< A -> AA | x :-> AA! Eltseq(Vector(Eltseq(A!x)) * Ti),
                           x :-> A! Eltseq(Vector(Eltseq(AA!x)) * T) >;
   return AA, AtoAA;
end intrinsic;

