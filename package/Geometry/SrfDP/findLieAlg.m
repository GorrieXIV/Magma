freeze;
// J. Pilnikova.
// Functions to find the lie algebra of the automorphism group of a variety
// defined by the intersection of degree 2 hypersurfaces.

intrinsic FindLieAlgebra(I::RngMPol: withId := false) -> ModMatFld, AlgLie
{ finds the Lie algebra of the variety defined by the ideal - 
  both the representation and the abstract algebra,
  the center is omitted}

  K := BaseRing(I);

  //  rank is the number of variables of the ring of I
  //  rank = 1 + dimension of the projective space where the variety
  //         defined by I is embedded
  rank := Rank(I);

  Qd := VectorSpace(K, rank);
  Qdxd := KMatrixSpace(K, rank, rank);

  //  if SymmetricBilinearForm(Basis(I)[k]);  
  //  returns a matrix (rank+1)x(rank+1), then it was a homogenous quadratic polynomial;
  //  no need to check the degree
  form := [];
  bI := Basis(I);
  if not &and[IsHomogeneous(b) and (TotalDegree(b) eq 2) : b in bI] then
    bI := MinimalBasis(I);
  end if;
  NumOfForms := #bI;
  for k := 1 to NumOfForms do
    require (IsHomogeneous(bI[k]) and (TotalDegree(bI[k]) eq 2)): 
      "The ideal is not generated by quadratic forms.";
    form[k] := Qdxd ! SymmetricBilinearForm(bI[k]);
  end for;


  VS := sub< Qdxd | form >;
  Lrep := Qdxd;

  //  for every form_indx find a vectorspace V (subspace of Q9x9)
  //    s.t. Transpose(form[form_indx]*v) + form[form_indx]*v
  //    is in VS (= vector space generated by form-s) for every v in V
  //  afterwards compute the intersection of these vector spaces
  //  - the resulting vector space should have dimension 7 and be a Lie algebra

  for form_indx := 1 to NumOfForms do
  
    //  Define the automorphism of Q9x9 sending the matrix v into
    //  Transpose(form[form_indx]*v) + form[form_indx]*v
    //  We are looking for the inverse image of VS

    M := [ Qdxd | ];

    for i := 1 to rank^2 do
      aux := form[form_indx]*Basis(Qdxd)[i];
      M[i] := aux + Transpose(aux);
    end for;
    phi := hom<Qdxd -> Qdxd | M>;

    image := Image(phi);
    _, psi := quo<image | image meet VS>;
    V := Kernel(phi*psi);

    //  ############################################ 
    //  ##  just a test - to be omitted later
    //  
    //  for i := 1 to #Basis(V) do
    //    a := form[form_indx]*Basis(V)[i];
    //    a := a + Transpose(a);
    //    if a notin VS then
    //      print "wrong matrix:",form_indx,i;
    //    end if;
    //  end for;
    //  ############################################ 

    Lrep := Lrep meet V;

  end for;

  if not withId then
    //  omit the center
    list := [Qdxd | ];
    for i := 1 to #Basis(Lrep) do
      m := Basis(Lrep)[i];
      tr := Trace(m)/rank;
      if (tr ne 0) then
        for j := 1 to rank do
          m[j][j] -:= tr;
        end for;
      end if;
      list[i] := m;
    end for;
    Lrep := sub< Qdxd | list >;
  end if;

  dim := Dimension(Lrep);
  //print "The dimension of the Lie algebra:", dim;


  // Choose a nice basis: saturate, and lll wrt matrix entries
  // March 2013, SRD
  if Type(K) eq FldRat then
    Qdxd_Z := RMatrixSpace(Integers(), rank, rank);
    Lrep_Z := Saturation(sub< Qdxd_Z | [ClearDenominator(x) : x in Basis(Lrep)] > );
    Lrep   := RMatrixSpaceWithBasis( ChangeUniverse(LLL(Basis(Lrep_Z)), Generic(Lrep)) );
  end if;


  //  ######################################################
  //  ##  test it - to be omitted later
  //
  //  //  whether it is correct vector space:
  //
  //  for form_indx := 1 to NumOfForms do
  //    for i := 1 to dim do 
  //      v := Transpose(form[form_indx]*Basis(Lrep)[i]) + 
  //                     form[form_indx]*Basis(Lrep)[i];
  //      if v notin VS then
  //        print "wrong vector space:", form_indx, i;
  //      end if;
  //    end for;
  //  end for;
  //
  //  //  whether it is a Lie algebra (mean a representation into g(10)):
  //
  //  for i := 1 to dim do
  //    for j := 1 to dim do
  //      v := Basis(Lrep)[i]*Basis(Lrep)[j] - Basis(Lrep)[j]*Basis(Lrep)[i];
  //      if v notin Lrep then
  //        print "not Lie algebra:", i,j;
  //      end if;
  //    end for;
  //  end for;
  //
  //  //  (Jacobi identity not tested)
  //  ##  end of test
  //  ######################################################


  //  create a structure-constants-Lie-algebra

  T := [];
  for i := 1 to dim do
    for j := 1 to dim do
      y := Basis(Lrep)[i]*Basis(Lrep)[j] - Basis(Lrep)[j]*Basis(Lrep)[i];
      cf := Coordinates(Lrep, y);
      for k := 1 to dim do
        if not IsZero( cf[k] ) then
          Append( ~T, <i,j,k,cf[k]> );
        end if;
      end for;
    end for;
  end for;
  if (dim gt 0) and (T eq []) then
    T := [<1,1,1, 0>];
  end if;
  L := LieAlgebra< K, dim | T >;


  //  ##############################################
  //  ##  check the isomorphism - test to be omitted
  //
  //  for i := 1 to dim do
  //    for j := 1 to dim do
  //      v1 := Vector(Coordinates(Lrep, Basis(Lrep)[i]*Basis(Lrep)[j] - 
  //                                      Basis(Lrep)[j]*Basis(Lrep)[i]));
  //      v2 := Vector(Basis(L)[i]*Basis(L)[j]);
  //      if v1 ne v2 then 
  //        print "not isomorphic:", i,j;
  //      end if;
  //    end for;
  //  end for;
  //  ##############################################

  return Lrep, L;

end intrinsic;



//  #####################################################################
//  ##  finding a representation of the Lie algebra 
//  ##  (without the center)
//  ##  of the hypersurface given by a single equation f
//  ##  = matrices X such that A*X + Transpose(A*X) = 0 
//  #####################################################################
intrinsic FindLieAlgebra(f::RngMPolElt) -> ModMatFld, AlgLie
{ finds the Lie algebra of the hypersurface defined by the polynomial - 
 both the representation and the abstract algebra,
 the center is omitted}

  K := BaseRing(Parent(f));

  rank := Rank(Parent(f));
  Qdxd := KMatrixSpace(K, rank, rank);

  form := Qdxd ! SymmetricBilinearForm(f);
  require NumberOfRows(form) eq rank :
       "bad input, homogenous polynomial in", rank, "vars expected";

  //  find a vectorspace VS (subspace of Qdxd)
  //    s.t. Transpose(form*v) + form*v is zero

  //  Define the automorphism of Qdxd sending the matrix v into
  //  Transpose(form[form_indx]*v) + form[form_indx]*v
  //  We are looking for the kernel

  M := [ Qdxd | ];

  for i := 1 to Dimension(Qdxd) do
    aux := form*Basis(Qdxd)[i];
    M[i] := aux + Transpose(aux);
  end for;
  phi := hom<Qdxd -> Qdxd | M>;
  Lrep := Kernel(phi);

  dim := Dimension(Lrep);
  //print "The dimension of the Lie algebra (without identity):", dim;

  //  ########################################################
  //  create a structure-constants-Lie-algebra

  T := [];
  for i := 1 to dim do
    for j := 1 to dim do
      y := Basis(Lrep)[i]*Basis(Lrep)[j] - Basis(Lrep)[j]*Basis(Lrep)[i];
      cf := Coordinates(Lrep, y);
      for k := 1 to dim do
        if not IsZero( cf[k] ) then
          Append( ~T, <i,j,k,cf[k]> );
        end if;
      end for;
    end for;
  end for;

  L := LieAlgebra< K, dim | T >;

  return Lrep, L;

end intrinsic;

