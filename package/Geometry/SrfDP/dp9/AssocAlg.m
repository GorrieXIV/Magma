freeze;

// W.A. de Graaf & J. Pilnikova.

function mat_rep( L )

    // L is a simple Lie algebra of dim 8 over Q; we try to find a
    // faithful rep such that its enveloping algebra has dimension 9.

    assert BaseRing(L) eq Rationals();
    assert Dimension(L) eq 8;


    // Choose a semisimple element h

    V := StandardLattice(Dimension(L));

    for n in [1..100], 
        v in ShortVectors(V,n,n)
    do
        h := L! Eltseq(v[1]);
        fh := CharacteristicPolynomial( AdjointMatrix( L, h ) );
        f := ExactQuotient(fh, Parent(fh).1^2);
        // TO DO: easy case where f has a rational root
        if Evaluate(f,0) ne 0 and IsSquarefree(f) then
            break n;
        end if;
    end for;

/*
for h in Basis(L) do h, CharacteristicPolynomial( AdjointMatrix( L, h ) ); end for;
"h =", h, f;
*/

    fac:= [ u[1] : u in Factorization( f )];
    F:= Rationals();
    while #fac gt 0 do
        P:= PolynomialRing( F );
        g:= P!fac[1];
        if Degree(g) gt 1 then
           F:= NumberField( g );
           fac_1:= [ ];
           for i in [1..#fac] do
               P:= PolynomialRing( F );
               fac_1 cat:= [ u[1] : u in Factorization( P!fac[i] )];
           end for;
           fac:= fac_1;
        else
           Remove( ~fac, 1 );
        end if;
    end while;

    //  Important to use the best available basis of the field.
    //  (Note: here it could be hard to factor Discriminant(F), 
    //   but later we would have to factor some multiple of it)
    //  March 2013, SRD
    F:= FieldOfFractions(LLL(Integers(F)));

    K := ChangeRing(L, F);

    // This is needed in CanonicalGenerators, which otherwise
    // will only work if CartanSubalgebra(K) is split.
    K`SplittingCartanSubalgebra := Centralizer(K, K!Eltseq(h));

    x,y,h:= CanonicalGenerators( K );
    Append( ~x, x[1]*x[2] );
    Append( ~y, -y[1]*y[2] );

    // x,y,h is now a Chevalley basis of L, realizing the
    // isomorphism to sl_3

    bas:= [ ];
    bas cat:= [ Vector( Eltseq( u ) ) : u in x ];
    bas cat:= [ Vector( Eltseq( u ) ) : u in y ];
    bas cat:= [ Vector( Eltseq( u ) ) : u in h ];

    V:= VectorSpace( F, 8 );
    B:= VectorSpaceWithBasis( [ V!u : u in bas ] );
    mats:= [
       Matrix( [[0,1,0],[0,0,0],[0,0,0]] ),
       Matrix( [[0,0,0],[0,0,1],[0,0,0]] ),
       Matrix( [[0,0,1],[0,0,0],[0,0,0]] ),
       Matrix( [[0,0,0],[1,0,0],[0,0,0]] ),
       Matrix( [[0,0,0],[0,0,0],[0,1,0]] ),
       Matrix( [[0,0,0],[0,0,0],[1,0,0]] ),
       Matrix( [[1,0,0],[0,-1,0],[0,0,0]] ),
       Matrix( [[0,0,0],[0,1,0],[0,0,-1]] ) ];

    // r is a faithful representation of L over F

    r:= function( v )
        cf:= Coordinates( B, V!(Eltseq(v)) );
        return &+[ cf[i]*mats[i] : i in [1..8] ];
    end function;

    // we construct the list of matrices corresponding to the
    // basis elements of L, where we `blow up' every entry.

    ee:= [ r(Basis(K)[i]) : i in [1..8] ];

    bF:= Basis(F);
    deg:= #bF;
    res:= [ ];
    for m in ee do
        mat:= ScalarMatrix( Rationals(), 3*deg, 0 );
        for i in [1..3] do
            for j in [1..3] do

                a:= [ Eltseq( m[i][j]*bF[k] ) : k in [1..deg] ];
            
                for u in [1..deg] do
                    for v in [1..deg] do
                        mat[(i-1)*deg+u][(j-1)*deg+v]:= a[u][v];
                    end for;
                end for;
            end for;
        end for; 
        Append( ~res, mat );
    end for;       

    return res;

end function;






intrinsic FindAsocAlgebraRep(L::AlgLie) -> AlgMat, ModMatFldElt
{ finds representation of an associative algebra generated by the Lie algebra }
  s:= mat_rep( L );
  //  check( L8, s );

  M := MatrixAlgebra( Rationals(), Nrows(s[1]) );
  A := sub< M | [ M!a : a in s ] >;

  rPhiM := MatrixAlgebra(Rationals(), 9) ! 0;
  for i := 1 to 8 do
    rPhiM[i] := Vector(Coordinates(A, s[i]));
  end for;
  rPhiM[9] := Vector(Coordinates(A, M!1));


  bool, mapM_aux := IsInvertible(rPhiM);
  mapM := KMatrixSpace(Rationals(), 9,8) ! 0;
  for i := 1 to 9 do
    c := mapM_aux[i];
    v := [c[1],c[2],c[3],c[4],c[5],c[6],c[7],c[8]];
    mapM[i] := Vector(v);
  end for;

  //  ####################################################################
  //  ##  check rMapM - 
  //  ##  whether it is a hom of representation of the same Lie algebra
  //  ####################################################################
  for i := 1 to 9 do
    for j := 1 to 9 do
      r1 := Vector(Coordinates(A, 
        Basis(A)[i]*Basis(A)[j] - Basis(A)[j]*Basis(A)[i])) * mapM;

      cc := Vector(Coordinates(A, Basis(A)[i])) * mapM;
      vi := &+[cc[k]*Basis(L)[k] : k in [1..8]];
      cc := Vector(Coordinates(A, Basis(A)[j])) * mapM;
      vj := &+[cc[k]*Basis(L)[k] : k in [1..8]];

      r2 := Vector(Coordinates(L, vi*vj));

      if (r1 ne r2) then
        error "There was an error in constructing the Lie algebra representation!";
      end if;
    end for;
  end for;

  return A, mapM;

end intrinsic;



