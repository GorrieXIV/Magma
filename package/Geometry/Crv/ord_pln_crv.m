freeze;
/**
    Functions for ordinary plane curves and computation of 
    Canonical images 
          mch - 2005
**/

declare attributes Crv: b_ord,ord_mult,Iadj;

function ReductionModp(F,Rp)
/* 
   If F is a homogeneous polynomial in n variables over Q (or Z)
   and Rp is the polynomial ring in n variables over GF(p) then
   computes the reduction mod p of F in Rp after removing p-power
   denominators
*/
    Fp := BaseRing(Rp);
    p := Characteristic(Fp);
    M := Monomials(F);
    coeffs := [MonomialCoefficient(F,m) : m in M];
    dens := [Denominator(coeff) : coeff in coeffs];
    vals := [Valuation(d,p) : d in dens];
    maxp := Maximum([v : v in vals]);
    idxs := [i : i in [1..#vals] | vals[i] eq maxp];
    return &+[(Fp!Numerator(coeffs[i])/Fp!(dens[i] div ppow))
		*Monomial(Rp,Exponents(M[i])) : i in idxs] where
			ppow is p^maxp;
end function;

function RelationsModI(Fseq,I)
/*
   Fseq is a sequence of elements in k[x_1,..x_n] and I is an ideal
   of that ring. Computes and returns a basis for all of the k-linear
   relations of the elements of Fseq mod I
*/
    Fs_red := [NormalForm(f,I) : f in Fseq];
    
    mons := Setseq(Seqset(&cat[Monomials(f):f in Fs_red]));
    Sort(~mons);
    
    //find all linear relations
    M := Matrix(BaseRing(I),[[MonomialCoefficient(f,m):m in mons]:
    						f in Fs_red]);
						
    // probably should echelonise quad_coeffs here to get canonical
    // set of quad forms

    M1 := KernelMatrix(M);
    return [Eltseq(M1[i]): i in [1..Nrows(M1)]];
    
end function;

function MyCanonicalImage(Fs,I,Pim)
// works out the canonical image of the curve map given by homog polys Fs
//  (I = ideal of curve) - also works for the rational normal curve or
//  more generally any image generated by ((g-1)*(g-2))/2  quadrics.
// If Pim is non-zero then use this as the image ambient.

    g := #Fs;
    K := BaseRing(I);
    if g eq 2 then
	if Type(Pim) eq Prj then
	    return Curve(Pim), true;
	else 
 	    return Curve(ProjectiveSpace(K,1)), true;
	end if;
    end if;

    F2s := [Fs[i]*Fs[j]: j in [i..g], i in [1..g]];
    quad_coeffs := RelationsModI(F2s,I); //get all quadratic relations
    delete F2s;
    if #quad_coeffs eq ((g-2)*(g-3)) div 2 then //non-hyperelliptic case
	bHyp := false;
    elif  #quad_coeffs eq ((g-1)*(g-2)) div 2 then //hyperelliptic case
	bHyp := true;
    else
	error "The equations didn't define the canonical map";
    end if;
    
    if Type(Pim) eq Prj then
	Pg := Pim;
	x := [Pg.i : i in [1..g]];
    else
	Pg<[x]> := ProjectiveSpace(K,g-1);
    end if;
    CRg := CoordinateRing(Pg);
    v2 :=  [x[i]*x[j]: j in [i..g], i in [1..g]];   
    Qs := [&+[r[i]*v2[i] : i in [1..#v2]] : r in quad_coeffs];
		
    I2 := ideal<CRg | Qs>;
    P := PolynomialRing(Rationals());
    H := P!HilbertPolynomial(I2);
    H1 := (bHyp select (g-1)*P.1 + 1 else (g-1)*(2*P.1-1));
    
    if (H ne H1) and (g gt 3) then // need to include cubics
	error if bHyp, "The equations didn't define the canonical map";
	F3s := [Fs[i]*Fs[j]*Fs[k]: k in [j..g], j in [i..g], i in [1..g]];    
	ter_coeffs := RelationsModI(F3s,I); //get all ternary relations
	delete F3s;
        assert #ter_coeffs eq ((g-3)*(g^2+6*g-10)) div 6;

        // now get space of cubics not coming from quadrics
	v3 := [x[i]*x[j]*x[k]: k in [j..g], j in [i..g], i in [1..g]];
        V3 := KSpace(K,#v3);	
	W1 := sub<V3|[V3!vec:vec in ter_coeffs]>;
	W2 := sub<V3|[V3![MonomialCoefficient(q*x[i],m): m in v3] :
			i in [1..g],q in Qs]>;
	//assert W2 subset W1
	W := Complement(W1,W2);
	Cs :=  [&+[r[i]*v3[i] : i in [1..#v3]] where r is
		Eltseq(v) : v in Basis(W)];
		
	I2 := ideal<CRg | Qs cat Cs>;
	assert P!HilbertPolynomial(I2) eq H1;
	
	return Curve(Pg,Qs cat Cs : Saturated := true),false;
    elif H ne H1 then // g=3, non-hyperelliptic -> quartic
	F4s := [Fs[i]*Fs[j]*Fs[k]*Fs[l]: l in [k..g], k in [j..g],
						j in [i..g], i in [1..g]];    
	quar_coeffs := RelationsModI(F4s,I); //get all quartic relations
	delete F4s;
	assert #quar_coeffs eq 1;
	v4 := [x[i]*x[j]*x[k]*x[l]: l in [k..g], k in [j..g],
						j in [i..g], i in [1..g]];    
	quar := quar_coeffs[1];
	return Curve(Pg,&+[quar[i]*v4[i] : i in [1..#v4]]),false;
    else
	return Curve(Pg,Qs : Saturated := true),bHyp;
    end if;

end function;

intrinsic CanonicalImage(C::Crv, phi::MapSch) -> Crv, BoolElt
{ Returns the image of C under canonical map phi and whether
  C is hyperelliptic. }
    P := Codomain(phi);
    require (Domain(phi) eq C) and (Type(P) eq Prj) and
	IsOrdinaryProjective(P) and (Dimension(P) ge 1):
	  "Map is not the canonical map on the curve.";
    return MyCanonicalImage(DefiningEquations(phi),Ideal(C),P);
end intrinsic;

intrinsic CanonicalImage(C::Crv, eqns::SeqEnum) -> Crv, BoolElt
{ Returns the image of C under canonical map defined by eqns
  and whether C is hyperelliptic. }
    R := Universe(eqns);
    if Type(R) eq RngMPol and (R cmpne Generic(R)) then
	R := Generic(R);
	eqns := ChangeUniverse(eqns,R);
    end if;
    I := Ideal(C);
    require (R cmpeq Generic(I)) and (#eqns ge 2):
	  "Equations don't define the canonical map on the curve.";
    return MyCanonicalImage(eqns,I,0);
end intrinsic;

intrinsic AdjointIdealForNodalCurve(C::Crv) -> RngMPol
{ Assuming plane curve C only has double points computes the adjoint
  ideal.}

    if assigned C`Iadj then return C`Iadj; end if;
    if IsAffine(C) then C := ProjectiveClosure(C); end if;
    require IsOrdinaryProjective(Ambient(C)) and
		(Dimension(Ambient(C)) eq 2):
	"Curve must line in affine or ordinary projective plane";
    F := Equation(C);
    R := Generic(Parent(F));
    seq := [R|Derivative(F,i) : i in [1..3]];
    p := Characteristic(BaseRing(R));
    if (p gt 0) and IsDivisibleBy(LeadingTotalDegree(F),p) then
	Append(~seq,F);
    end if;
    
    C`Iadj := Saturation(ideal<R|seq>);
    return C`Iadj;
    
end intrinsic;

function degree_d_graded_piece(I,d)
    R := Generic(I);
    B := ChangeUniverse(MinimalBasis(EasyIdeal(I)),R);
    
    pols_d := Setseq(MonomialsOfDegree(R,d));
    
    Wvecs := [];

    d1 := Min([LeadingTotalDegree(f) : f in B]);
    d2 := Min(d,Max([LeadingTotalDegree(f) : f in B]));
        
    for i in [d1..d2] do
	Wvecs cat:= [[MonomialCoefficient(f*m1,m) : m in pols_d] :
			m1 in MonomialsOfDegree(R,d-i), f in B |
			 LeadingTotalDegree(f) eq i];
    end for;

    if #Wvecs eq 0 then return [R|]; end if;    
    M := Matrix(BaseRing(R),Wvecs);
    M := EchelonForm(M);
    rk := Max([i : i in [1..Nrows(M)] | M[i] ne 0]);
    M := RowSubmatrix(M,rk);
        
    return Eltseq(ChangeRing(M,R)*Matrix(R,#pols_d,1,pols_d));
end function;

intrinsic AdjointLinearSystemForNodalCurve(C::Crv,d::RngIntElt) -> LinearSys
{Assuming plane curve C only has double points computes the adjoint
 linear system of degree d.}

    if IsAffine(C) then C := ProjectiveClosure(C); end if;
    require IsOrdinaryProjective(Ambient(C)) and
		(Dimension(Ambient(C)) eq 2):
	"Curve must line in affine or ordinary projective plane";

    if d le 0 then 
	return LinearSystem(LinearSystem(Ambient(C),1),
				[CoordinateRing(Ambient(C))|]); 
    end if;
    
    I := AdjointIdealForNodalCurve(C);
    pols := degree_d_graded_piece(I,d);
    return LinearSystem(LinearSystem(Ambient(C),d),pols) ;
end intrinsic;

intrinsic AdjointLinearSystemFromIdeal(I::RngMPol,d::RngIntElt) -> LinearSys
{ I is the (saturated) adjoint ideal of a plane projective curve. Returns
  the degree d adjoint linear system of the curve}
    R := Generic(I);
    require &and[wt eq 1 : wt in VariableWeights(R)] and
	IsHomogeneous(I): "First argument not an adjoint ideal";
    P := Proj(R);
    if d le 0 then
	return LinearSystem(LinearSystem(P,1),[R|]); 
    end if;
    return LinearSystem(LinearSystem(P,d),degree_d_graded_piece(I,d));
end intrinsic;

intrinsic CanonicalLinearSystemFromIdeal(I::RngMPol,d::RngIntElt) -> LinearSys
{ I is the (saturated) adjoint ideal of a plane projective curve. Returns
  the canonical linear system of the curve}
    return AdjointLinearSystemFromIdeal(I,d-3);
end intrinsic;

myDegree := func<I| Integers()!Coefficient(HilbertPolynomial(I),0)>;

intrinsic HasOnlyOrdinarySingularities(C::Crv : Adjoint := true)
					-> BoolElt, RngIntElt, RngMPol
{ Returns whether plane curve C only has ordinary singularities. 
  Also returns the maximum multiplicity of a singular point
  (1 if F is non-singular). If the boolean parameter Adjoint is true
   AND the curve is ordinary, then the adjoint ideal is computed and
   is a third return value.}
    if assigned C`b_ord then
	if not (C`b_ord and Adjoint) then
	   return C`b_ord,C`ord_mult,_;
	elif assigned C`Iadj then
	   return true,C`ord_mult,C`Iadj;
	elif C`ord_mult le 2 then
	   return true,C`ord_mult,AdjointIdealForNodalCurve(C);
	end if;
    end if;
	    
    retAdj := Adjoint;
    if IsAffine(C) then C := ProjectiveClosure(C); end if;
    require IsOrdinaryProjective(Ambient(C)) and
		(Dimension(Ambient(C)) eq 2):
	"Curve must line in the affine or ordinary projective plane";
    F := Equation(C);
    R0 := Generic(Parent(F));
    p := Characteristic(BaseRing(R0));
    R := Generic(EasyIdeal(ideal<R0|F>));
    F := R!F;
    d := LeadingTotalDegree(F);
    boo := ((p gt 0) and IsDivisibleBy(d,p));    

    J0 := ideal<R|JacobianSequence(F)>;
    J  := boo select J0 + ideal<R|F> else J0;
    maxmult := 1;

    if (Dimension(J) gt 1) or ( boo and ( (Dimension(J0) ne Dimension(J))
	 or (myDegree(J0) ne myDegree(J)) ) ) then
	C`b_ord := false; C`ord_mult := d; 
	return false,d,_; 
    end if;

    L := [];
    J1 := J;
    while Dimension(J1) gt 0 do
	B := MinimalBasis(J1);
	Append(~L,ideal<R|B>);
	J1 := ideal<R|Eltseq(JacobianMatrix(B)) cat B>;
	maxmult +:= 1;
    end while;
    if #L eq 0 then return true,1,Generic(Parent(F)); end if;
    L := [Saturation(L[i],L[i+1]): i in [1..#L-1]] cat [Radical(L[#L])];
    if &or[Dimension(ideal<R|Eltseq(JacobianMatrix(B)) cat B>) gt 0 where
		B is MinimalBasis(I) : I in L] then
	C`b_ord := false; C`ord_mult := maxmult; 
	return false,maxmult,_;
    end if;

    // mch - 03/14 - Fix old error! The L[i] should be the intersection
    // of the prime ideals corresponding to the singular points of
    // multiplicity i+1. However if C has a NON-ordinary singularity
    // of mult. i+1, the primary factor of L[i] <-> this point
    // may not be the full prime ideal (except in the final L[i]).
    // Replace with the radicals to guarantee we get the primes.
    // Can we do anything simpler?
    if #L gt 1 then
	L := [Radical(L[i]) : i in [1..#L-1]] cat [L[#L]];
    end if;

    boo := myDegree(J) eq &+[myDegree(L[i])*(i^2): i in [1..#L]];
    
    C`b_ord := boo; C`ord_mult := maxmult; 	 
    if not (retAdj and boo) then
	return boo,maxmult,_;
    else
	if not assigned C`Iadj then
	   C`Iadj := ideal<R0|ChangeUniverse(MinimalBasis(
		&meet[Saturation(L[i]^i) : i in [1..#L]] ), R0)>;
	end if;	
	return true,maxmult,C`Iadj;
    end if;

end intrinsic;

intrinsic AdjointIdeal(C::Crv) -> RngMPol
{ For ordinary plane curve C, returns the adjoint ideal. If C is not
  ordinary, an error results.}
    if assigned C`Iadj then return C`Iadj; end if;
    if (assigned C`b_ord) and C`b_ord and (C`ord_mult le 2) then
	return AdjointIdealForNodalCurve(C);
    end if;

    if IsAffine(C) then C := ProjectiveClosure(C); end if;
    require IsOrdinaryProjective(Ambient(C)) and
		(Dimension(Ambient(C)) eq 2):
	"Curve must line in affine or ordinary projective plane";
    boo,_,Iadj := HasOnlyOrdinarySingularities(C: Adjoint := true);
    require boo: "Curve must have only ordinary singularities.";
    return Iadj;
end intrinsic;

intrinsic HasOnlyOrdinarySingularitiesMonteCarlo(C::Crv) -> BoolElt, RngIntElt
{ For plane curve C over Q determines whether all singularities
  are PROBABLY ordinary using mod p reduction for 5 good primes.
  If so, also returns the maximum multiplicity of a singularity.}

    if assigned C`b_ord then return C`b_ord,C`ord_mult; end if;

    if IsAffine(C) then C := ProjectiveClosure(C); end if;
    require Type(BaseRing(C)) eq FldRat:
	"Curve must be defined over the rationals.";
    require IsOrdinaryProjective(Ambient(C)) and
		(Dimension(Ambient(C)) eq 2):
	"Curve must line in the affine or ordinary projective plane";
    F := Equation(C);
    R := Generic(Parent(F));

    JK := ideal<R|JacobianSequence(F)>;
    d := Dimension(JK);
    if d le 0 then
	return true,1; // nonsingular curve
    elif d gt 1 then
	return false,d; // nonreduced curve
    end if;
    d := myDegree(JK);
        
    //find "good" primes and test for ord sings mod p
    n := Rank(R);
    p := LeadingTotalDegree(F);
    nTries := 0;
    while nTries lt 5 do
	p := NextPrime(p);
	Rp := PolynomialRing(GF(p),n);
	Fp := ReductionModp(F,Rp);
	if Fp eq 0 then continue; end if;
	// check jacobian mod p has good length
	Jp := ideal<Rp|JacobianSequence(Fp)>;
	if (Dimension(Jp) ne 1) or (myDegree(Jp) ne d) then
	    continue;
	end if;
	// p is a good prime - test for ord sings mod p
	nTries +:= 1;
	L := [];
	J1 := Jp;
	maxmult := 1;
	while Dimension(J1) gt 0 do
	    B := MinimalBasis(J1);
	    Append(~L,ideal<Rp|B>);
	    J1 := ideal<Rp|Eltseq(JacobianMatrix(B)) cat B>;
	    maxmult +:= 1;
	end while;
	assert #L gt 0; // F can't be singular but non-singular mod p!
	L := [Saturation(L[i],L[i+1]): i in [1..#L-1]] cat [Radical(L[#L])];
	if &or[Dimension(ideal<Rp|Eltseq(JacobianMatrix(B)) cat B>) gt 0
		where B is MinimalBasis(I) : I in L] then
	    continue;  // not ordinary mod p
	end if;    
	// mch - 03/14 - Fix for old error - see non-MonteCarlo version
        // of the intrinsic.
	if #L gt 1 then
	  L := [Radical(L[i]) : i in [1..#L-1]] cat [L[#L]];
	end if; 
	if d eq &+[myDegree(L[i])*(i^2): i in [1..#L]] then //ord mod p!
	    return true,maxmult;
	end if;
   end while;
   return false,1;
	
end intrinsic;
