freeze;

/*******************************************************************************
				Simple ideal ops
*******************************************************************************/

is_compatible := func<I, J | Generic(I) cmpeq Generic(J)>;

intrinsic EasyBasis(I::RngMPol) -> []
{The basis of the easy ideal of I}
    return Basis(EasyIdeal(I));
end intrinsic;

intrinsic Ideal(f::GenMPolElt) -> RngMPol
{The ideal generated by f}
    return Ideal([f]);
end intrinsic;

intrinsic Ideal(I::RngMPol) -> RngMPol
{The ideal generated by I}
    return I;
end intrinsic;

intrinsic Ideal(I::RngMPol, f::RngMPolElt) -> RngMPol
{The ideal generated by I and f}
    require is_compatible(I, Parent(f)): "Arguments are not compatible";
    return I + Ideal(f);
end intrinsic;

/*******************************************************************************
				Quotient ops
*******************************************************************************/

/*
intrinsic QuotientDimension(I::GenMPol) -> RngIntElt
{The dimension of the vector space Generic(I)/I}
    if IsZeroDimensional(I) or 1 in I then
	return Dimension(Generic(I)/I);
    end if;
    return Infinity();
end intrinsic;
*/

/*******************************************************************************
				Hilbert, etc.
*******************************************************************************/

function get_ps_ring(p)
    R<s> := LaurentSeriesRing(IntegerRing(), p);
    return R;
end function;

intrinsic HilbertSeries(I::RngMPol, p::RngIntElt) -> RngSerPowElt
{The Hilbert series of R/I to precision p}
    require IsHomogeneous(I): "Ideal is not homogeneous";
    requirege p, 1;
    return get_ps_ring(p) ! HilbertSeries(I);
end intrinsic;

intrinsic HilbertSeries(M::ModMPol, p::RngIntElt) -> RngSerPowElt
{The Hilbert series of M to precision p}
    require IsHomogeneous(M): "Module is not homogeneous";
    requirege p, 1;
    return get_ps_ring(p) ! HilbertSeries(M);
end intrinsic;

/*******************************************************************************
				Ideal from Variety
*******************************************************************************/

intrinsic Ideal(Q::{[Tup]}, P::RngMPol) -> RngMPol
{Create the ideal of polynomial ring P whose variety is exactly Q};

    R := BaseRing(P);
    require IsField(R): "Base ring must be a field";
    C := CartesianPower(R, Rank(P));
    l, Q := CanChangeUniverse(Q, C);
    require l: "Set/sequence does not contain tuples coercible into R^n";
    if Type(Q) ne SeqEnum then
	Q := [t: t in Q];
    end if;

    if MonomialOrder(P) cmpeq <"lex"> then
	return InternalVarietyIdeal(Q, P);
    end if;

    PP := ChangeOrder(P, "lex");
    I := InternalVarietyIdeal(Q, PP);
    Groebner(I);
    I := ChangeOrder(I, P);
    Groebner(I);
    return I;

end intrinsic;

/*******************************************************************************
				Variety (Boolean)
*******************************************************************************/

function do_variety(I, Variety)

    n := Rank(I);
    R := PolynomialRing(GF(2), n);
    B := [R ! f: f in GroebnerBasis(I)];
    B cat:= [R.i^2 + R.i: i in [1 .. n]];
    J := Ideal(B);
    return Variety(J);

end function;

intrinsic Variety(I::RngMPolBool) -> []
{Given a boolean ideal I, return the variety of I as a sequence 
of tuples of field elements.}
    return do_variety(I, Variety);
end intrinsic;

intrinsic VarietySequence(I::RngMPolBool) -> []
{Given a boolean ideal I, return the variety of I as a sequence 
of sequences of field elements.}
    return do_variety(I, VarietySequence);
end intrinsic;
