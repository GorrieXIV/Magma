freeze;

/////////////////////////////////////////////////////////

intrinsic  JacobianSequence (p::RngMPolElt) -> SeqEnum
{Returns the sequence of all first partial derivatives of the polynomial.}

  parent_ring := Generic(Parent(p));
  return( [Derivative(p, parent_ring.i)  : i in [1..Rank(parent_ring)] ]);

end intrinsic;


intrinsic JacobianIdeal (p::RngMPolElt) -> RngMPol
{Returns the ideal generated by all first partial derivatives of the polynomial.}

  return( ideal< Parent(p) | JacobianSequence(p) >);

end intrinsic;


intrinsic JacobianIdeal (poly_list::[ RngMPolElt ]) -> RngMPol
{Returns the ideal generated by the partial derivatives of each polynomial in the
sequence, by each  indeterminate in its parent ring.}

  return( ideal< Parent(Rep(poly_list)) | &cat[JacobianSequence(p) : p in poly_list] >);

end intrinsic;


intrinsic JacobianMatrix (poly_list::[ RngMPolElt ]) -> GrpMat
{Returns the matrix with (i,j)'th entry the partial derivative of the i'th
polynomial in the list with the j'th indeterminate of its parent ring.}

  R := Generic(Universe(poly_list));
  return Matrix(R, Rank(R),
         &cat[ JacobianSequence(p) : p in poly_list]);
end intrinsic;



////////////////////////////////////////////////////////////////////////////////
//
// Extra commutative algebra code added by Ben 9.12.02
// Saturation:  the saturation of an ideal
// Extension: the 'extension' of an ideal under some map of rings: super trivial
//
////////////////////////////////////////////////////////////////////////////////

intrinsic Saturation(I::RngMPol, J::RngMPol) -> RngMPol
{The saturation of I with respect to J.}
    require Generic(I) cmpeq Generic(J):
        "I and J must be ideals of the same ring";

    B := [f: f in Basis(J) | f ne 0];
    if #B eq 0 then
        return Generic(I);
    else
        return &meet [ Saturation(I,f) : f in B ];
    end if;
end intrinsic;

intrinsic Saturation(I::RngMPol) -> RngMPol
{
    The saturation of I with respect to the ideal generated by the variables
    of its polynomial ring.
}
    R := Generic(I);
    return &meet [ Saturation(I, R.i) : i in [1..Rank(R)] ];
end intrinsic;

intrinsic Extension(phi::Map, I::RngMPol) -> RngMPol
{
    The extension of the ideal I with respect to the map phi.
}
    require Type(Domain(phi)) eq RngMPol and Type(Codomain(phi)) eq RngMPol:
        "phi must be a map of polynomial rings";
    require Domain(phi) cmpeq Generic(I):
        "I must be an ideal of the domain of phi";

    return ideal<Codomain(phi) | [phi(b): b in Basis(I)]>;
end intrinsic;

/// Convenience Degree function [Degree(I) = Degree(X) where X is
/// Scheme(Proj(P),I)] avoiding creating X - added mch 08/09

intrinsic Degree(I::RngMPol) -> RngIntElt
{Returns the degree of a homogeneous ideal of a polynomial ring all
 of whose variables have weight one.}
   
   try
      H,r := HilbertPolynomial(I);
   catch e
      error "Argument must be a homogenous ideal of a polynomial\n",
	"ring over a field with variables of weight one.";
   end try;
   deg := Degree(H);
   require (deg ge 0) or (r gt 0):
      "Argument should not be the full polynomial ring";
   if deg lt 0 then return 0;
   else
      return Integers()!(LeadingCoefficient(H)*Factorial(deg));
   end if;

end intrinsic;

////////////////////////////////////////////////////////////////////////////////

/*
intrinsic Saturation(idel::RngMPol, ring_elt::RngMPolElt) -> RngMPol
{Returns the ideal ( idel : f^(infinity) ), and the least integer n
such that ( idel : f^n ) = ( idel : f^(n+1) ). }

    max_attempts := 100;
    In := idel;
    for i in [0..max_attempts] do
        In_plus_1 := ColonIdeal(In, ring_elt);
        if In_plus_1 eq In then
            return In, i;
        else
            In := In_plus_1;
        end if;
    end for;
    error "Failed to find saturation after", max_attempts, "iterations",
            idel, ring_elt;

end intrinsic;
*/

