174,1
S,DecodeOverZ4_version,Return the current version of this package,0,0,0,0,0,0,0,82,-38,-38,-38,-38,-38
V,IsPDSetFlag,3
S,Z4StandardForm,"Given a code C over Z4, return a permutation-equivalent code S in standard form,  together with the corresponding isomorphism from C onto S, the generator matrix  of S in standard form, and the permutation of coordinates used to define  the isomorphism",0,1,0,0,0,0,0,0,0,202,,202,175,190,222,-38,-38
S,InformationSpace,"Given a code C over Z4 of length n and type 2^gamma 4^delta, return the  Z4-submodule of Z4^(gamma+delta) isomorphic to Z2^gamma x Z4^delta such that the first gamma coordinates are of order two, that is, the space of information  vectors for C. The function also returns the (gamma+2*delta)-dimensional binary  vector space, which is the space of information vectors for the corresponding  binary code Cbin=Phi(C), where Phi is the Gray map. Finally, for the encoding  process, it also returns the corresponding isomorphisms f and fbin from these  spaces of information vectors onto C and Cbin, respectively",0,1,0,0,0,0,0,0,0,202,,191,159,175,175,-38,-38
S,InformationSet,"Given a code C over Z4 of length n and type 2^gamma 4^delta, return an information  set I=[i_1,...,i_(gamma+delta)] in [1,...,n] for C such that the code C punctured  on [1,...,n] minus [i_(gamma+1),..., i_(gamma+delta)] is of type 4^delta, and  the corresponding information set Phi(I)=[2*i_1-1,..., 2*i_gamma-1, 2*i_(gamma+1)-1,  2*i_(gamma+1),..., 2*i_(gamma+delta)-1, 2*i_(gamma+delta)] in [1,...,2*n] for the  binary code Cbin=Phi(C), where Phi is the Gray map. The information sets I and  Phi(I) are returned as a sequence of gamma+delta and gamma+2*delta integers,  giving the coordinate positions that correspond to the information set of C  and Cbin, respectively.  An information set I for C is an ordered set of gamma+delta coordinate positions  such that |C^I|=2^gamma 4^delta, where C^I=[v^I : v in C] and v^I is the vector  v restricted to the I coordinates. An information set J for Cbin is an ordered  set of gamma+2*delta coordinate positions such that |C^J_bin|=2^(gamma+2*delta)",0,1,0,0,0,0,0,0,0,202,,82,82,-38,-38,-38,-38
S,IsInformationSet,"Given a code C over Z4 of length n and type 2^gamma 4^delta and a sequence  I in [1,...,n] or I in [1,...,2*n], return true if and only if I in [1,...,n]  is an information set for C. This function also returns another boolean, which  is true if an only if I in [1,...,2*n] is an information set for the corresponding  binary code Cbin=Phi(C), where Phi is the Gray map.  An information set I for C is an ordered set of gamma+delta coordinate positions  such that |C^I|=2^gamma 4^delta, where C^I=[v^I : v in C] and v^I is the vector  v restricted to the I coordinates. An information set J for Cbin is an ordered  set of gamma+2*delta coordinate positions such that |C^J_bin|=2^(gamma+2*delta)",1,1,1,82,0,148,2,0,0,0,0,0,0,0,82,,0,0,202,,36,36,-38,-38,-38,-38
S,SyndromeSpace,"Given a code C over Z4 of length n and type 2^gamma 4^delta, return the  Z4-submodule of Z4^(n-delta) isomorphic to Z2^gamma x Z4^(n-gamma-delta) such that the first gamma coordinates are of order two, that is, the space of  syndrome vectors for C. The function also returns the (2*n-2*delta-gamma)- dimensional binary vector space, which is the space of syndrome vectors  for the corresponding binary code Cbin=Phi(C), where Phi is the Gray map.  Note that these spaces are computed by using the function  InformationSpace(C) applied to the dual code of C, given by function Dual(C)",0,1,0,0,0,0,0,0,0,202,,191,159,-38,-38,-38,-38
S,Syndrome,"Given a code C over Z4 of length n and type 2^gamma 4^delta, and a vector u  from the ambient space V=Z4^n or V2=Z2^(2*n), construct the syndrome of u relative  to the code C. This will be an element of the syndrome space of C, considered  as the Z4-submodule of Z4^(n-delta) isomorphic to Z2^gamma x Z4^(n-gamma-delta)  such that the first gamma coordinates are of order two",0,2,0,0,0,0,0,0,0,202,,0,0,192,,192,-38,-38,-38,-38,-38
S,Syndrome,"Given a code C over Z4 of length n and type 2^gamma 4^delta, and a vector u  from the ambient space V=Z4^n or V2=Z2^(2*n), construct the syndrome of u relative  to the code C. This will be an element of the syndrome space of C, considered  as the Z4-submodule of Z4^(n-delta) isomorphic to Z2^gamma x Z4^(n-gamma-delta)  such that the first gamma coordinates are of order two",0,2,0,0,0,0,0,0,0,202,,0,0,160,,192,-38,-38,-38,-38,-38
S,CosetLeaders,"Given a code C over Z4 of length n, with ambient space V=Z4^n, return a set of  coset leaders (vectors of minimal Lee weight in their cosets) for C in V as an  indexed set of vectors from V. This function also returns a map from the syndrome  space of C into the coset leaders (mapping a syndrome into its corresponding  coset leader). Note that this function is only applicable when V and C are small",0,1,0,0,0,0,0,0,0,202,,151,175,-38,-38,-38,-38
S,CosetDecode,"Given a code C over Z4 of length n, and a vector u from the ambient space V=Z4^n,  attempt to decode u with respect to C. If the decoding algorithm  succeeds in computing a vector u' in C as the decoded version of u in V, then  the function returns true, u' and Phi(u'), where Phi is the Gray map. If the  decoding algorithm does not succeed in decoding u, then the function returns  false, the zero vector in V and the zero vector in V2.  The coset decoding algorithm considers the binary linear code Cu=Cbin U  (Cbin+Phi(u)), when Cbin=Phi(C) is linear. On the other hand, when Cbin is  nonlinear, we have that Cbin=U_(i=0)^t (Kbin + Phi(ci)), where Kbin=Phi(KC), KC  is the kernel of C as a subcode over Z4, [c0,c1,...,ct] are the coset  representatives of C with respect to KC (not necessarily of minimal weight in  their cosets) and c0 is the zero codeword. In this case, the algorithm considers  the binary linear codes K0=Kbin U (Kbin+Phi(u)), K1=Kbin U (Kbin+Phi(c1)+Phi(u)),  ..., Kt=Kbin U (Kbin+Phi(ct)+Phi(u)).  If the parameter MinWeightCode is not assigned, then the minimum weight of C,  which coincides with the minimum weight of Cbin, denoted by d, is computed.  Note that the minimum distance of Cbin coincides with its minimum weight. If Cbin is linear and the minimum weight of Cu is less than d, then  Phi(u')=Phi(u)+e, where e is a word of minimum weight of Cu; otherwise, the  decoding algorithm returns false. On the other hand, if Cbin is nonlinear and  the minimum weight of U_(i=0)^t Ki is less than the minimum weight of Kbin, then  Phi(u')=Phi(u)+e, where e is a word of minimum weight of U_(i=0)^t Ki; otherwise,  the decoding algorithm returns false. If the parameter MinWeightKernel is not  assigned, then the minimum Hamming weight of Kbin is computed",0,2,0,0,0,0,0,0,0,192,,0,0,202,,36,192,160,-38,-38,-38
S,CosetDecode,"Given a code C over Z4 of length n, and a vector Phi(u) from the ambient space  V2=Z2^(2*n), attempt to decode u with respect to C. If the decoding algorithm  succeeds in computing a vector u' in C as the decoded version of u in V, then  the function returns true, u' and Phi(u'), where Phi is the Gray map. If the  decoding algorithm does not succeed in decoding u, then the function returns  false, the zero vector in V and the zero vector in V2.  The coset decoding algorithm considers the binary linear code Cu=Cbin U  (Cbin+Phi(u)), when Cbin=Phi(C) is linear. On the other hand, when Cbin is  nonlinear, we have that Cbin=U_(i=0)^t (Kbin + Phi(ci)), where Kbin=Phi(KC), KC  is the kernel of C as a subcode over Z4, [c0,c1,...,ct] are the coset  representatives of C with respect to KC (not necessarily of minimal weight in  their cosets) and c0 is the zero codeword. In this case, the algorithm considers  the binary linear codes K0=Kbin U (Kbin+Phi(u)), K1=Kbin U (Kbin+Phi(c1)+Phi(u)),  ..., Kt=Kbin U (Kbin+Phi(ct)+Phi(u)).  If the parameter MinWeightCode is not assigned, then the minimum weight of C,  which coincides with the minimum weight of Cbin, denoted by d, is computed.  Note that the minimum distance of Cbin coincides with its minimum weight. If Cbin is linear and the minimum weight of Cu is less than d, then  Phi(u')=Phi(u)+e, where e is a word of minimum weight of Cu; otherwise, the  decoding algorithm returns false. On the other hand, if Cbin is nonlinear and  the minimum weight of U_(i=0)^t Ki is less than the minimum weight of Kbin, then  Phi(u')=Phi(u)+e, where e is a word of minimum weight of U_(i=0)^t Ki; otherwise,  the decoding algorithm returns false. If the parameter MinWeightKernel is not  assigned, then the minimum Hamming weight of Kbin is computed",0,2,0,0,0,0,0,0,0,160,,0,0,202,,36,192,160,-38,-38,-38
S,CosetDecode,"Given a code C over Z4 of length n, and a sequence Q of vectors from the ambient  space V=Z4^n, attempt to decode the vectors of Q with respect to C.  This function is similar to the function CosetDecode(C, u) except that rather than  decoding a single vector, it decodes a sequence of vectors and returns a sequence  of booleans and two sequences of decoded vectors corresponding to the given sequence.  The algorithm used and effect of the parameters MinWeightCode and MinWeightKernel  are as for the function CosetDecode(C, u)",1,1,1,82,0,192,2,0,0,0,0,0,0,0,82,,0,0,202,,82,82,82,-38,-38,-38
S,CosetDecode,"Given a code C over Z4 of length n, and a sequence Q of vectors from the ambient  space V2=Z2^(2*n), attempt to decode the vectors of Q with respect to C.  This function is similar to the function CosetDecode(C, u) except that rather than  decoding a single vector, it decodes a sequence of vectors and returns a sequence  of booleans and two sequences of decoded vectors corresponding to the given sequence.  The algorithm used and effect of the parameters MinWeightCode and MinWeightKernel  are as for the function CosetDecode(C, u)",1,1,1,82,0,160,2,0,0,0,0,0,0,0,82,,0,0,202,,82,82,82,-38,-38,-38
S,SyndromeDecode,"Given a code C over Z4 of length n, and a vector u from the ambient space V=Z4^n,  attempt to decode u with respect to C. The decoding algorithm always succeeds in  computing a vector u' in C as the decoded version of u in V, and the function  returns true, u' and Phi(u'), where Phi is the Gray map. Although the function  never returns false, the first output parameter true is given to be consistent  with the other decoding functions.  The syndrome decoding algorithm consists of computing a table pairing each possible  syndrome s with a vector of minimum Lee weight e_s, called coset leader, in the  coset of C containing all vectors having syndrome s. After receiving a vector u,  compute its syndrome s using the parity check matrix. Then, u is decoded as the  codeword c=u-e_s",0,2,0,0,0,0,0,0,0,192,,0,0,202,,36,192,160,-38,-38,-38
S,SyndromeDecode,"Given a code C over Z4 of length n, and a vector Phi(u) from the ambient space  V2=Z2^(2*n), attempt to decode u with respect to C. The decoding algorithm always  succeeds in computing a vector u' in C as the decoded version of u in V, and the  function returns true, u' and Phi(u'), where Phi is the Gray map. Although the  function never returns false, the first output parameter true is given to be  consistent with the other decoding functions.  The syndrome decoding algorithm consists of computing a table pairing each possible  syndrome s with a vector of minimum Lee weight e_s, called coset leader, in the  coset of C containing all vectors having syndrome s. After receiving a vector u,  compute its syndrome s using the parity check matrix. Then, u is decoded as the  codeword c=u-e_s",0,2,0,0,0,0,0,0,0,160,,0,0,202,,36,192,160,-38,-38,-38
S,SyndromeDecode,"Given a code C over Z4 of length n, and a sequence Q of vectors from the ambient  space V=Z4^n, attempt to decode the vectors of Q with respect to C.  This function is similar to the function SyndromeDecode(C, u) except that rather than  decoding a single vector, it decodes a sequence of vectors and returns a sequence  of booleans and two sequences of decoded vectors corresponding to the given sequence.  The algorithm used is as for the function SyndromeDecode(C, u)",1,1,1,82,0,192,2,0,0,0,0,0,0,0,82,,0,0,202,,82,82,82,-38,-38,-38
S,SyndromeDecode,"Given a code C over Z4 of length n, and a sequence Q of vectors from the ambient  space V2=Z2^(2*n), attempt to decode the vectors of Q with respect to C.  This function is similar to the function SyndromeDecode(C, u) except that rather than  decoding a single vector, it decodes a sequence of vectors and returns a sequence  of booleans and two sequences of decoded vectors corresponding to the given sequence.  The algorithm used is as for the function SyndromeDecode(C, u)",1,1,1,82,0,160,2,0,0,0,0,0,0,0,82,,0,0,202,,82,82,82,-38,-38,-38
S,LiftedDecode,"Given a code C over Z4 of length n, and a vector u from the ambient space V=Z4^n, attempt to decode u with respect to C. If the decoding algorithm succeeds in  computing a vector u' in C as the decoded version of u in V, then the function  returns true, u' and Phi(u'), where Phi is the Gray map. If the decoding algorithm  does not succeed in decoding u, then the function returns false, the zero vector  in V and the zero in V2 (in the Euclidean case it may happen that u' is not in C because there are too many errors in u to correct).  The lifted decoding algorithm consists of lifting decoding algorithms for two  binary linear codes C0 and C1, known as the residue and torsion codes of C. Let  t0 and t1 be the error-correcting capability of C0 and C1, respectively. Assume  the received vector u=c+e, where c in C and e in V is the error vector. Then,  the lifted decoding algorithm can correct all error vectors e such that  tau_1 + tau_3 <= t0 and tau_2 + tau_3 <= t1, where tau_i is the number of  occurrences of i in e.  In the decoding process, the function Decode(C, u) for linear codes is used.  The accessible algorithms for linear codes are: syndrome decoding and a Euclidean  algorithm, which operates on alternant codes (BCH, Goppa, and Reed--Solomon codes, etc.). If C0 or C1 is alternant, the Euclidean algorithm is used by default, but the  syndrome algorithm will be used if the parameter AlgMethod is assigned the value  ""Syndrome"". For non-alternant codes C0 and C1, only syndrome decoding is possible,  so the parameter AlgMethod is not relevant",0,2,0,0,0,0,0,0,0,192,,0,0,202,,36,192,160,-38,-38,-38
S,LiftedDecode,"Given a code C over Z4 of length n, and a vector Phi(u) from the ambient space  V2=Z2^(2*n), attempt to decode u with respect to C. If the decoding algorithm  succeeds in computing a vector u' in C as the decoded version of u in V, then the  function returns true, u' and Phi(u'), where Phi is the Gray map. If the decoding  algorithm does not succeed in decoding u, then the function returns false, the  zero vector in V and the zero in V2 (in the Euclidean case it may happen that u'  is not in C because there are too many errors in u to correct).  The lifted decoding algorithm consists of lifting decoding algorithms for two  binary linear codes C0 and C1, known as the residue and torsion codes of C. Let  t0 and t1 be the error-correcting capability of C0 and C1, respectively. Assume  the received vector u=c+e, where c in C and e in V is the error vector. Then,  the lifted decoding algorithm can correct all error vectors e such that  tau_1 + tau_3 <= t0 and tau_2 + tau_3 <= t1, where tau_i is the number of  occurrences of i in e.  In the decoding process, the function Decode(C, u) for linear codes is used.  The accessible algorithms for linear codes are: syndrome decoding and a Euclidean  algorithm, which operates on alternant codes (BCH, Goppa, and Reed--Solomon codes, etc.). If C0 or C1 is alternant, the Euclidean algorithm is used by default, but the  syndrome algorithm will be used if the parameter AlgMethod is assigned the value  ""Syndrome"". For non-alternant codes C0 and C1, only syndrome decoding is possible,  so the parameter AlgMethod is not relevant",0,2,0,0,0,0,0,0,0,160,,0,0,202,,36,192,160,-38,-38,-38
S,LiftedDecode,"Given a code C over Z4 of length n, and a sequence Q of vectors from the ambient  space V=Z4^n, attempt to decode the vectors of Q with respect to C.  This function is similar to the function LiftedDecode(C, u) except that rather than  decoding a single vector, it decodes a sequence of vectors and returns a sequence  of booleans and two sequences of decoded vectors corresponding to the given sequence.  The algorithm used and effect of the parameter AlgMethod are as for the function  LiftedDecode(C, u)",1,1,1,82,0,192,2,0,0,0,0,0,0,0,82,,0,0,202,,82,82,82,-38,-38,-38
S,LiftedDecode,"Given a code C over Z4 of length n, and a sequence Q of vectors from the ambient  space V2=Z2^(2*n), attempt to decode the vectors of Q with respect to C.  This function is similar to the function LiftedDecode(C, u) except that rather than  decoding a single vector, it decodes a sequence of vectors and returns a sequence  of booleans and two sequences of decoded vectors corresponding to the given sequence.  The algorithm used and effect of the parameter AlgMethod are as for the function  LiftedDecode(C, u)",1,1,1,82,0,160,2,0,0,0,0,0,0,0,82,,0,0,202,,82,82,82,-38,-38,-38
S,IsPermutationDecodeSet,"Given a code C over Z4 of length n and type 2^gamma 4^delta, a sequence I in  [1,...,2*n], a sequence S of elements in the symmetric group Sym(2*n) of  permutations on the set [1,...,2*n], and an integer s>1, return true if and only  if S is an s-PD-set for Cbin=Phi(C), where Phi is the Gray map, with respect to  the information set I.   The parameters I and S can also be given as a sequence I in [1,...,n] and a  sequence S of elements in the symmetric group Sym(n) of permutations on the set  [1,...,n], respectively. In this case, the function returns true if and only if  Phi(S) is an s-PD-set for Cbin=Phi(C) with respect to the information set Phi(I),  where Phi(I) and Phi(S) are the sequences defined as in the manual.  Depending on the length of the code C, its type, and the integer s, this function  could take some time to compute whether S or Phi(S) is an s-PD-set for Cbin with  respect to I or Phi(I), respectively. Specifically, if the function returns true,  it is necessary to check sum_(i=1)^s (|I| choose i)*((N-|I|) choose (s-i)) s-sets,  where N=n and |I|=gamma+delta when I is given as an information set for C, or  N=2*n and |I|=gamma+2*delta when I is given as an information set for Cbin.  The verbose flag IsPDsetFlag is set to level 0 by default. If it is set to level  1, the total time used to check the condition is shown. If it is set to level 2,  the percentage of the computation process performed is also printed",2,1,1,82,0,148,2,1,82,0,222,4,0,0,0,0,0,0,0,148,,0,0,82,,0,0,82,,0,0,202,,36,-38,-38,-38,-38,-38
S,PermutationDecode,"Given a code C over Z4 of length n and type 2^gamma 4^delta; an information set  I=[i_1,...,i_(gamma+delta)] in [1,...,n] for C as a sequence of coordinate  positions, such that the code C punctured on [1,...,n] minus [i_(gamma+1),..., i_(gamma+delta)] is of type 4^delta; a sequence S such that either S or Phi(S)  is an s-PD-set for Cbin=Phi(C), where Phi is the Gray map, with respect to Phi(I);  an integer s in [1,...,t], where t is the error-correcting capability of Cbin;  and a vector Phi(u) from the ambient space V2=Z2^(2*n), attempt to decode u  with respect to C. If the decoding algorithm succeeds in computing a vector u'  in C as the decoded version of u in V, then the function returns true, u' and  Phi(u'). If the decoding algorithm does not succeed in decoding u, then the  function returns false, the zero vector in V and the zero vector in V2.  The permutation decoding algorithm consists of moving all errors in a received  vector Phi(u)=c+e, where u in V, c in Cbin and e in V2 is the error vector with  at most t errors, out of the information positions, that is, moving the nonzero  coordinates of e out of the information set Phi(I) for Cbin, by using an  automorphism of Cbin.  Note that Phi(I) and Phi(S) are the sequences defined as in the manual. Moreover,  the function does not check neither that I is an information set for C, nor S or  Phi(S) is an s-PD-set for Cbin with respect to Phi(I), nor s <= t",2,1,1,82,0,148,2,1,82,0,222,5,0,0,0,0,0,0,0,160,,0,0,148,,0,0,82,,0,0,82,,0,0,202,,36,192,160,-38,-38,-38
S,PermutationDecode,"Given a code C over Z4 of length n and type 2^gamma 4^delta; an information set  I=[i_1,...,i_(gamma+delta)] in [1,...,n] for C as a sequence of coordinate  positions, such that the code C punctured on [1,...,n] minus [i_(gamma+1),..., i_(gamma+delta)] is of type 4^delta; a sequence S such that either S or Phi(S)  is an s-PD-set for Cbin=Phi(C), where Phi is the Gray map, with respect to Phi(I);  an integer s in [1,...,t], where t is the error-correcting capability of Cbin;  and a vector u from the ambient space V=Z4^n, attempt to decode u  with respect to C. If the decoding algorithm succeeds in computing a vector u'  in C as the decoded version of u in V, then the function returns true, u' and  Phi(u'). If the decoding algorithm does not succeed in decoding u, then the  function returns false, the zero vector in V and the zero vector in V2.  The permutation decoding algorithm consists of moving all errors in a received  vector Phi(u)=c+e, where u in V, c in Cbin and e in V2 is the error vector with  at most t errors, out of the information positions, that is, moving the nonzero  coordinates of e out of the information set Phi(I) for Cbin, by using an  automorphism of Cbin.  Note that Phi(I) and Phi(S) are the sequences defined as in the manual. Moreover,  the function does not check neither that I is an information set for C, nor S or  Phi(S) is an s-PD-set for Cbin with respect to Phi(I), nor s <= t",2,1,1,82,0,148,2,1,82,0,222,5,0,0,0,0,0,0,0,192,,0,0,148,,0,0,82,,0,0,82,,0,0,202,,36,192,160,-38,-38,-38
S,PermutationDecode,"Given a code C over Z4 of length n and type 2^gamma 4^delta; an information set  I=[i_1,..., i_(gamma+delta)] in [1,...,n] for C as a sequence of coordinate  positions, such that the code C punctured on [1,...,n] minus [i_(gamma+1),..., i_(gamma+delta)] is of type 4^delta; a sequence S such that either S or Phi(S)  is an s-PD-set for Cbin=Phi(C), where Phi is the Gray map, with respect to Phi(I);  an integer s in [1,...,t], where t is the error-correcting capability of Cbin;  and a sequence Q of vectors from the ambient space V2=Z2^(2*n), attempt to decode  the vectors of Q with respect to C. This function is similar to the function  PermutationDecode(C, I, S, s, u) except that rather than decoding a single vector,  it decodes a sequence of vectors and returns a sequence of booleans and two  sequences of decoded vectors corresponding to the given sequence. The algorithm  used is as for the function PermutationDecode(C, I, S, s, u)",3,1,1,82,0,148,2,1,82,0,222,4,1,82,0,160,5,0,0,0,0,0,0,0,82,,0,0,148,,0,0,82,,0,0,82,,0,0,202,,82,82,82,-38,-38,-38
S,PermutationDecode,"Given a code C over Z4 of length n and type 2^gamma 4^delta; an information set  I=[i_1,..., i_(gamma+delta)] in [1,...,n] for C as a sequence of coordinate  positions, such that the code C punctured on [1,...,n] minus [i_(gamma+1),..., i_(gamma+delta)] is of type 4^delta; a sequence S such that either S or Phi(S)  is an s-PD-set for Cbin=Phi(C), where Phi is the Gray map, with respect to Phi(I);  an integer s in [1,...,t], where t is the error-correcting capability of Cbin;  and a sequence Q of vectors from the ambient space V=Z4^n, attempt to decode  the vectors of Q with respect to C. This function is similar to the function  PermutationDecode(C, I, S, s, u) except that rather than decoding a single vector,  it decodes a sequence of vectors and returns a sequence of booleans and two  sequences of decoded vectors corresponding to the given sequence. The algorithm  used is as for the function PermutationDecode(C, I, S, s, u)",3,1,1,82,0,148,2,1,82,0,222,4,1,82,0,192,5,0,0,0,0,0,0,0,82,,0,0,148,,0,0,82,,0,0,82,,0,0,202,,82,82,82,-38,-38,-38
S,PDSetHadamardCodeZ4,"Given an integer m >= 5 and an integer delta such that 3 <= delta <= floor((m+1)/2), the Hadamard code C over Z4 of length n=2^(m-1) and type 2^gamma 4^delta, where  gamma=m+1-2*delta, given by the function HadamardCodeZ4(delta, m) is considered.  The function returns an information set I=[i_1,...,i_(gamma+delta)] subseteq [1,...,n]  for C together with a subset S of the permutation automorphism group of C such that  Phi(S) is an s-PD-set for Cbin=Phi(C) with respect to Phi(I), where Phi is the Gray map  and Phi(I) and Phi(S) are defined in the manual. The function also returns the  information set Phi(I) and the s-PD-set Phi(S). For m >= 1 and 1 <= delta 2,  the Gray map image of C is linear and it is possible to find an s-PD-set for  Cbin=Phi(C), for any s <= floor(2^(m)/(m+1))-1, by using the function  PDSetHadamardCode(m).  The information sets I and Phi(I) are returned as sequences of gamma+delta and  gamma+2*delta integers, giving the coordinate positions that correspond to the  information sets for C and Cbin, respectively. The sets S and Phi(S) are also  returned as sequences of elements in the symmetric groups Sym(n) and Sym(2*n) of  permutations on the set [1,...,n] and [1,...,2*n], respectively. The s-PD-set S  contains the s+1 permutations described in [BaVi16a].   A deterministic algorithm is used by default. In this case, the function returns  the s-PD-set of size s+1 with s=floor((2^(2*delta-2)-delta)/delta), which is the  maximum value of s when gamma=0, as described in [BaVi16a]. If the parameter AlgMethod  is assigned the value ""Nondeterministic"", the function tries to improve the previous  result giving an s-PD-set of size s+1 such that floor((2^(2*delta-2)-delta)/delta) <= s <= floor((2^(m-1)+delta-m-1)/(m+1-delta)). In this case, the function starts  from the maximum value of s and decreases it when the s-PD-set is not found after  a time out.  [BaVi16a] R. Barrolleta and M. Villanueva, ""Partial permutation decoding for binary  linear and Z4-linear Hadamard codes,"" submitted to Designs, Codes and Cryptography,  2016. arXiv:1512.01839",0,2,0,0,0,0,0,0,0,148,,0,0,148,,82,82,82,82,82,-38
S,PDSetKerdockCodeZ4,"Given an integer m >=4 such that 2^m-1 is not a prime number, the Kerdock code  C over Z4 of length n=2^m and type 4^(m-1), given by the function KerdockCodeZ4(m)  is considered. The function returns the information set I=[1,..,m+1] in [1,...,n]  for C together with a subset S of the permutation automorphism group of C such  that Phi(S) is an s-PD-set for Cbin=Phi(C) with respect to Phi(I), where Phi is  the Gray map and Phi(I) and Phi(S) are defined in the manual. The function also returns the information set Phi(I)=[1,..,2m+2] and the s-PD-set Phi(S). The size  of the s-PD-set S is always lambda=s+1, where lambda is the greatest divisor of  2^m-1 such that lambda <= 2^m/(m+1).  The information sets I and Phi(I) are returned as sequences of m+1 and  2m+2 integers, giving the coordinate positions that correspond to the  information sets for C and Cbin, respectively. The sets S and Phi(S) are also  returned as sequences of elements in the symmetric groups Sym(n) and Sym(2*n) of  permutations on the set [1,...,n] and [1,...,2*n], respectively. The s-PD-set S contains the s+1 permutations described in [BaVi16b].  [BaVi16b] R. Barrolleta and M. Villanueva, ""PD-sets for Z4-linear codes: Hadamard  and Kerdock codes,"" in Proceedings of the IEEE International Symposium on Information  Theory, 2016",0,1,0,0,0,0,0,0,0,148,,82,82,82,82,-38,-38
