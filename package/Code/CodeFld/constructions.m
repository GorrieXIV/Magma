freeze;

function IsCoercibleMatrix(S,M) // -> BoolElt, Mtrx
    // True if and only if all entries of M are coercible
    // into S; in that case, also return 'S!M'
    bool := true;
    nc := NumberOfColumns(M);
    nr := NumberOfRows(M);
    newentries := [ S | ];
    for i in [1..nr] do
	for j in [1..nc] do
	    iscoer,x := IsCoercible(S,M[i,j]);
	    if not iscoer then
		bool := false;
		break i;
	    end if;
	    Append(~newentries,x);
	end for;
    end for;
    if bool then
	Mnew := Matrix(nc,newentries);
	return bool,Mnew;
    else
	return bool,_;
    end if;
end function;

//------------------Subcode------------------------------------//
//Author: Markus Grassl

intrinsic Subcode(C::Code,k::RngIntElt)->Code
{Returns a subcode of the (possibly additive) code C with k generators. 
k must be a non negative integer
less than or equal to the number of generators of C}
  requirerange k,0,Ngens(C);
  require Type(C) ne CodeQuantum : "Subcodes not defined for quantum codes";
  D:=sub<C|{C.i: i in {1..k}}>;
  d:=C`MinimumWeightLowerBound;
  if d gt D`MinimumWeightLowerBound then
    D`MinimumWeightLowerBound:=d;
  end if;
  return D;
end intrinsic;

intrinsic Subcode(C::Code,S::{RngIntElt})->Code
{Returns the subcode of the (possibly additive) code C generated by the 
basis elements numbered in S, which
must contain positive integers less than or equal to Ngens(C)}
  require Type(C) ne CodeQuantum : "Subcodes not defined for quantum codes";
    k := Ngens(C);
    for x in S do
	require x gt 0 and x le k : 
	"Elements of S must be positive and less than or equal to Ngens(C)";
    end for;

    D:=sub<C|{C.i: i in S}>;
    d:=C`MinimumWeightLowerBound;
    if d gt D`MinimumWeightLowerBound then
	D`MinimumWeightLowerBound:=d;
    end if;
    return D;
end intrinsic;

//---------------------SubcodeWordsOfWeight----------------------//

intrinsic SubcodeWordsOfWeight(C::Code,W::RngIntElt: NumWords := 0) -> Code
{Given a non negative integer S less than Length(C), return the subcode
generated by those words of C with weight W.
If NumWords is set to a non-zero positive integer then the number of words
used will be limited to NumWords.}
  require Type(C) ne CodeQuantum : "Subcodes not defined for quantum codes";
    return SubcodeWordsOfWeight(C,{W}: NumWords := NumWords);
end intrinsic;
 
intrinsic SubcodeWordsOfWeight(C::Code,S::{RngIntElt}: NumWords := 0)->Code
{Given a set of non-negative integers S, each less than Length(C),
return the subcode generated by those words of C whose weights lie
in S
If NumWords is set to a non-zero positive integer then the number of words
used of each weight will be limited to NumWords.}
  require Type(C) ne CodeQuantum : "Subcodes not defined for quantum codes";
    requirege NumWords,0;
    L := Length(C);
    wordset := {};
    for i in S do
        require (i ge 0 ) and (i le L ) :
                "integers must be non-neg and less than length of code";
        wordset join:= Words(C,i: NumWords := NumWords);
    end for;
 
    D := sub<C | wordset >;
    d:=C`MinimumWeightLowerBound;
    if d gt D`MinimumWeightLowerBound then
        D`MinimumWeightLowerBound:=d;
    end if;
    return D;
 
end intrinsic;


//----------------Juxtaposition------------------------------//

//Author: Markus Grassl

intrinsic Juxtaposition(C1::Code,C2::Code)->Code
{Given codes C1=[n1,k,d1] and C2=[n2,k,d2], construct a [n1+n2,k,d>=d1+d2]
 code by pasting the generator matrix together }
  require Type(C1) ne CodeQuantum and
	Type(C2) ne CodeQuantum : "Not defined for quantum codes";

  require Alphabet(C1) cmpeq Alphabet(C2):
    "Argument 1 and argument 2 have different alphabets";

	/* different to alphabet for additive codes */
  require CoefficientRing(C1) cmpeq CoefficientRing(C2):
    "Argument 1 and argument 2 have different coefficient rings";
 
  require Ngens(C1) eq Ngens(C2):
    "Argument 1 and argument 2 have different dimensions";
 
  n1:=Length(C1);
  n2:=Length(C2);
  k:=Ngens(C1);
 
  G:=Zero(RMatrixSpace(Alphabet(C1),k,n1+n2));
  InsertBlock(~G,GeneratorMatrix(C1),1,1);
  InsertBlock(~G,GeneratorMatrix(C2),1,n1+1);
 
  if IsAdditive(C1) then
    C := AdditiveCode( CoefficientRing(C1), G);
  else
    C:=LinearCode(G);
  end if;
  dmin:=0;
  dmin+:=C1`MinimumWeightLowerBound;
  dmin+:=C2`MinimumWeightLowerBound;
  if dmin ne 0 then
    if dmin gt C`MinimumWeightLowerBound  then
      C`MinimumWeightLowerBound:=dmin;
    end if;
  end if;
  return C;
end intrinsic;


//-------------------ResidueCode---------------------------------//
//Author: Markus Grassl

intrinsic ResidueCode(C::Code) -> Code
{Take the residue of code C by puncturing at the support of a minimum word}
    v := MinimumWord(C);
    res := PunctureCode(C,Support(v));
    if ISA(Type(C), CodeLin) then
	res`MinimumWeightLowerBound := Ceiling( C`MinimumWeightLowerBound /
					    #Alphabet(C) );
    end if;
    return res;
end intrinsic;

//-----------------ConstructionX------------------------------//
//Author: Markus Grassl

intrinsic ConstructionX(C1::CodeLinFld,C2::CodeLinFld,C3::CodeLinFld)->CodeLinFld
{Given a code C1=[n,k,d], a subcode C2=[n,k-l,d+e], and a code
 C3=[a,l,e], construct a code C=[n+a,k,d+e].}
 
  require C2 subset C1: "Second argument must be a subcode of the first one";
  require Alphabet(C1) eq Alphabet(C3): "Alphabets must be the same";
  require Dimension(C1) eq Dimension(C2)+ Dimension(C3):
    "The dimension of the first argument must be the sum of the
     dimensions of the second and third one.";
  F:=Alphabet(C1);
  n:=Length(C1);
  k:=Dimension(C1);
  k2:=Dimension(C2);
  a:=Length(C3);
  G:=Zero(RMatrixSpace(F,k,n+a));
  cosets:=BasisMatrix(Complement(RSpace(C1),RSpace(C2)));
  InsertBlock(~G,GeneratorMatrix(C2),1,1);
  InsertBlock(~G,cosets,k2+1,1);
  InsertBlock(~G,GeneratorMatrix(C3),k2+1,n+1);
  C:=LinearCode(G);
  d:=Length(C);
  d:=Minimum({d,C2`MinimumWeightLowerBound});
  d:=Minimum({d,C1`MinimumWeightLowerBound+C3`MinimumWeightLowerBound});
  if d lt Length(C) and (not C`MinimumWeightLowerBound ge d) then
    C`MinimumWeightLowerBound:=d;
  end if;
  return C;
end intrinsic;

//------------------------ConstructionX3------------------------//
//Author: Markus Grassl

intrinsic
ConstructionX3(C1::CodeLinFld,C2::CodeLinFld,C3::CodeLinFld,D1::CodeLinFld,D2::CodeLinFld)->CodeLinFld
{Given a chain of codes C1=[n,k1,d1], C2=[n,k2,d2], and C3=[n,k3,d3]
 with k3 < k2 < k1, and suffix codes D1=[n1,k1-k2,e1] and D2=[n2,k2-k3,e2],
 construct a code C=[n+n1+n2,k1,d] with d >= min\{d3,d1+e1,d2+e2.\}
}
 
  require C2 subset C1: "Second argument must be a subcode of the first one";
  require C3 subset C2: "Third argument must be a subcode of the second one";
  require Dimension(C1) eq Dimension(C2)+Dimension(D1):
    "The dimension of the first argument must be the sum of the 
     dimensions of the second and fourth one.";
  require Dimension(C2) eq Dimension(C3)+Dimension(D2):
    "The dimension of the second argument must be the sum of the 
     dimensions of the third and fifth one.";
  F:=Alphabet(C1);
 
  n:=Length(C1);
 
  k1:=Dimension(C1);
  k2:=Dimension(C2);
  k3:=Dimension(C3);
 
  n1:=Length(D1);
  n2:=Length(D2);
 
  G:=Zero(RMatrixSpace(F,k1,n+n1+n2));
  cosets12:=BasisMatrix(Complement(RSpace(C1),RSpace(C2)));
  cosets23:=BasisMatrix(Complement(RSpace(C2),RSpace(C3)));
  InsertBlock(~G,GeneratorMatrix(C3),1,1);
  InsertBlock(~G,cosets23,k3+1,1);
  InsertBlock(~G,cosets12,k2+1,1);
  InsertBlock(~G,GeneratorMatrix(D2),k3+1,n+1);
  InsertBlock(~G,GeneratorMatrix(D1),k2+1,n+n2+1);
 
  C:=LinearCode(G);
  d:=Length(C);
  d:=Minimum({d,C3`MinimumWeightLowerBound,
                C1`MinimumWeightLowerBound+D1`MinimumWeightLowerBound,
                C2`MinimumWeightLowerBound+D2`MinimumWeightLowerBound});
  if d lt Length(C) and (not C`MinimumWeightLowerBound ge d) then 
    C`MinimumWeightLowerBound:=d;
  end if;
  return C;
end intrinsic;


//-------------------------ConstructionXX------------------------//
//Author: Markus Grassl

intrinsic ConstructionXX(C1::CodeLinFld,C2::CodeLinFld,C3::CodeLinFld,
                                      D2::CodeLinFld,D3::CodeLinFld)->CodeLinFld
{C2 and C3 must be subcodes of C1, while the dimensions of D2 and D3 must
add with the dimensions to C2 and C3 to give the dimension of C1.
The returned code is constructed via the constructionXX algorithm of Alltop.}

  require C2 subset C1: "Argument 2 must be a subcode of argument 1";
  require C3 subset C1: "Argument 3 must be a subcode of argument 1";
  require Dimension(C1) eq Dimension(C2)+Dimension(D2):
    "The dimension of argument 1 must be the sum of the
     dimensions of argument 2 and 4";
  require Dimension(C1) eq Dimension(C3)+Dimension(D3):
    "The dimension of argument 1 must be the sum of the
     dimensions of argument 3 and 5";
  F:=Alphabet(C1);
  n1:=Length(C1);
  n2:=Length(D2);
  n3:=Length(D3);
  k:=Dimension(C1);
  k2:=Dimension(C2);
  k3:=Dimension(C3);
  C4:=C2 meet C3;
  k4:=Dimension(C4);
 
  B4:=Basis(C4);
  B42:=ExtendBasis(B4,RSpace(C2));
  B43:=ExtendBasis(B4,RSpace(C3));
  B421:=RMatrixSpace(F,k,n1)!ExtendBasis(B42,RSpace(C1));
  B431:=RMatrixSpace(F,k,n1)!ExtendBasis(B43,RSpace(C1));
 
  T:=Solution(B421,B431);
 
  G:=Zero(RMatrixSpace(F,k,n1+n2+n3));
  InsertBlock(~G,B421,1,1);
  InsertBlock(~G,GeneratorMatrix(D2),k2+1,n1+1);
 
  G:=T*G;
  InsertBlock(~G,GeneratorMatrix(D3),k3+1,n1+n2+1);
 
  C:=LinearCode(G);
// compute bounds for minimum distance
// compute bounds for minimum distance
      //this is a bit of a hack, but will make the bounds a lot easier
  _ := MinimumWeight(C4 : MaximumTime := 1);
  d1 := C1`MinimumWeightLowerBound;
  d2 := C2`MinimumWeightLowerBound;
  d3 := C3`MinimumWeightLowerBound;
  d4 := C4`MinimumWeightLowerBound;
  d5 := D2`MinimumWeightLowerBound;
  d6 := D3`MinimumWeightLowerBound;

  C`MinimumWeightLowerBound := Max( C`MinimumWeightLowerBound,
                                Min( {d1+d5+d6, d3+d5, d2+d6, d4}) );
 
  return C;
end intrinsic;


//--------------------------ZinovievCode------------------------------//

intrinsic ZinovievCode(inner::[CodeLinFld],outer::[CodeLinFld])->CodeLinFld
{Construct a generalized concatenated code from the given sequences of 
inner and outer codes}
/* cf. MacWilliams/Sloane, Ch. 18, section 8.2 */
 
//Check inputs
  r := #inner;
  require r ne 0: "sequences must be non-empty";
  require #outer eq r: "sequences must be same length";
 
  require ISA( Type(inner[1]), Code) and ISA(Type(outer[1]), Code):
    "Sequences must contain Codes";
  m:=Length(outer[1]);
  n:=Length(inner[1]);
  F:=Alphabet(inner[1]);
  q:=#F;
  prevk:=Dimension(inner[1]);
  for i in [2..r] do
    require Length(outer[i]) eq m: "outer codes must be all same length";
    require Degree(Alphabet(outer[i]),F) eq (Dimension(inner[i])-prevk) :
      Sprintf("outer code alphabet %o ist not of the appropriate size (%o,
%o)",i, Degree(Alphabet(outer[i]),F),(Dimension(inner[i])-prevk) );
    prevk:=Dimension(inner[i]);
 
    require Alphabet(inner[i]) eq F: "inner codes must be of same alphabet";
    require inner[i-1] subset inner[i]: "inner codes must be nested";
  end for;
 
  L_dim:=[];
  // compute a basis of the inner code consisting of coset representatives
  // second largest code
  B:=Basis(inner[1]);
  L_dim:=[#B];
  for i:=2 to r do
    BE:=ExtendBasis(RSpace(inner[i-1]),RSpace(inner[i]));
    Append(~L_dim,#BE-#B);
    B cat:=BE[#B+1..#BE];
  end for;
 
  // generator matrix of the direct sum of the outer codes represented as
  // codes over the field F
  L:=[SubfieldRepresentationCode(c,F): c in outer];
  G1:=GeneratorMatrix(L[1]);
  for i:=2 to r do
    G1:=DirectSum(G1,GeneratorMatrix(L[i]));
  end for;
 
  // generator matrix of n copies of the inner code
  // the rows are permuted according to the columns of G1
  G2:=Zero(RMatrixSpace(F,Ncols(G1),n*m));
  a:=1;
  z:=1;
  for d in L_dim do
    M:=RMatrixSpace(F,d,n)!B[a..a+d-1];
    a+:=d;
    for i:=0 to m-1 do
      InsertBlock(~G2,M,z,i*n+1);
      z+:=d;
    end for;
  end for;
 
  C:=LinearCode(G1*G2);
    C`MinimumWeightLowerBound := Max( C`MinimumWeightLowerBound,
          Min([ (inner[i]`MinimumWeightLowerBound) *
                (outer[i]`MinimumWeightLowerBound) : i in [1..r]]) );

// compute C`MinimumWeightLowerBound etc. from the ingredients
  return C;
 
end intrinsic;
 

//------------------------ConstructionY1-------------------------------//

intrinsic ConstructionY1(C::Code) -> Code
{Given a binary linear [n,k,d] code C with dual distance d',return the
[n-d',k-d'+1,>=d] code obtained by shortening in the positions of a word
in Dual(C) of minimal weight}

    require Type(C) ne CodeQuantum : "Not defined for quantum codes";
    require #Alphabet(C) eq 2: "C must be a binary code";
 
    return ShortenCode(C,Support(MinimumWord(Dual(C))));
end intrinsic;

//-----------------ConstructionY1-----------------------------//
//Author: Markus Grassl
 
intrinsic ConstructionY1(C::Code,w::RngIntElt)->Code
{ Shorten the linear code C at the support of a word of weight w of the 
dual code, resulting in an [n-w,k-w+1,>=d] code}
 
    require Type(C) ne CodeQuantum : "Not defined for quantum codes";
  D:=Dual(C);
  if assigned D`MinimumWeight and MinimumWeight(D) eq w then
    v:=MinimumWord(D);
  else
    words:=Words(D,w:NumWords:=1);
    error if #words eq 0,
      Sprintf("The dual code contains no word of weight %o",w);
    v:=Representative(words);
  end if;
 
  return ShortenCode(C,Support(v));
 
end intrinsic;



//-----------------------ExpurgateCode-------------------------------//

intrinsic ExpurgateCode(C::CodeLinFld,L::[ModTupFldElt])->Code
{The code obtained by deleting the code words contained in the sequence L from C}
 
    for w in L do
        require w in C : "L must contain codewords of C";
    end for;
 
    V := RSpace(C);
    return sub<C|Complement( V , sub<V|L> )>;
 
end intrinsic;

//---------------------ExpurgateWeightCode----------------------//

intrinsic ExpurgateWeightCode(C::CodeLinFld,w::RngIntElt) -> Code
{Delete a subspace generated by a word of weight w}
    requirerange w,0,Length(C);

    S := Words(C,w:NumWords := 1);

    D := CodeComplement(C, sub<C|S> );

    d:=C`MinimumWeightLowerBound;
    if d gt D`MinimumWeightLowerBound then
        D`MinimumWeightLowerBound:=d;
    end if;
    return D;

end intrinsic;


//-------------------------ExtendCode-----------------------------//

intrinsic ExtendCode(C::Code,n::RngIntElt) -> Code
{Extend C n times.}
    require Type(C) ne CodeQuantum : "Not defined for quantum codes";
    require n ge 0 : "n must be non-negative";
 
    for i in [1..n] do
        C := ExtendCode(C);
    end for;
 
    return C;
 
end intrinsic;

//------------------------PadCode------------------------------//

intrinsic PadCode(C::Code,n::RngIntElt) -> Code
{Given a linear code, lengthen it by n positions (adding columns of zeros).}
 
    require Type(C) ne CodeQuantum : "Not defined for quantum codes";
    require n ge 0: "n must be non negative";
    K := Alphabet(C);

    /*
    Since 0-dimension codes for some reason define the minimum weight to
    be equal to the number of positions, we have to treat them specially. :(
    */
    if Ngens(C) eq 0 then
	return ZeroCode(K, Length(C) + n);
    end if;

    G:=Zero(RMatrixSpace(K, Ngens(C), Length(C) + n));
    InsertBlock(~G,GeneratorMatrix(C),1,1);

    if IsAdditive(C) then
	c2 := AdditiveCode( CoefficientRing(C), G);
    else
	c2 := LinearCode(G);
    end if;

    c2`MinimumWeightLowerBound := C`MinimumWeightLowerBound;
    c2`MinimumWeightUpperBound := C`MinimumWeightUpperBound;

    return c2;

end intrinsic;

//-----------------------------SubfieldCode-------------------------//
 
intrinsic SubfieldCode(C::CodeLinFld,K::FldFin) -> Code
{If C is a code over F, then each element of F is mapped into a column vector
over K. Returned is the code generated when each codeword of C is mapped
into multiple codewords over K in this way.}
    L := Alphabet(C);
 
    require Characteristic(L) eq Characteristic(K) and
            Degree(L) mod Degree(K) eq 0:
            "Alphabet(C) can not be represented over K";
 
    _,map := VectorSpace(L,K);
 
    m := Degree(L,K);
 
    G := Zero(RMatrixSpace(K,Dimension(C) * m,Length(C)));
    H := GeneratorMatrix(C);
 
    for j in [1..Nrows(H)] do
        for i in [1..Ncols(G)] do
            mat := RMatrixSpace(K,m,1) ! Eltseq(map(H[j][i]));
            InsertBlock(~G,mat,1 + (j - 1) * m,i);
        end for;
    end for;
 
    return LinearCode(G);
end intrinsic;
 
//------------------------SubfieldRepresentationParityCode------------------//
 
intrinsic SubfieldRepresentationParityCode(C::CodeLinFld,K::FldFin) -> CodeLinFld
{Given a linear code over GF(q^m), return a code whose codewords are 
obtained from those of C by expanding each coordinate in GF(q^m) as a 
vector of dimension m+1 over K := GF(q), including a parity check bit}


    L := Alphabet(C);
 
    require Characteristic(L) eq Characteristic(K) and
            Degree(L) mod Degree(K) eq 0:
            "Alphabet(C) can not be represented over K";
 
 
    _,map := MatrixAlgebra(L,K);
 
    m := Degree(L,K);
 
    G := Zero(RMatrixSpace(K,Dimension(C) * m,Length(C) * (m + 1)));
    H := GeneratorMatrix(C);
 
    for j in [1..Nrows(H)] do
        for i in [1..Ncols(H)] do
            InsertBlock(~G,map(H[j][i]),1 + (j - 1) * m,1 + (i - 1) * (m + 1));
            for k in [1..m] do
                G[(j - 1) * m + k][i * (m + 1)] :=
                    &+[G[(j - 1) * m + k][(i - 1) * (m + 1) + l] : l in [1..m]];
            end for;
        end for;
    end for;
 
    return LinearCode(G);
end intrinsic;

//-----------------------cat--------------------------------------//

intrinsic 'cat' (C1::Code,C2::Code) -> Code
{ Return the code concatenation of codes C1 and C2 (over the same field) }

    require (not ISA(Type(C1), CodeQuantum) ) and
            (not ISA(Type(C2), CodeQuantum) ) : "Not defined for quantum codes";

    F := Alphabet(C1);
    require #F eq #Alphabet(C2) : 
	 "Codes must have the same alphabet";
    require CoefficientField(C1) eq CoefficientField(C2) :
	 "Codes must have the same coefficient field";
    n := Length(C1) + Length(C2);
    k1 := NumberOfGenerators(C1);
    if k1 eq 0 then
	k1 := 1;
	G1 := RMatrixSpace(F,1,Length(C1))!0;
    else
	G1 := GeneratorMatrix(C1);
    end if;
    k2 := NumberOfGenerators(C2);
    if k2 eq 0 then
	k2 := 1;
	G2 := RMatrixSpace(F,1,Length(C2))!0;
    else
	G2 := GeneratorMatrix(C2);
    end if;
    k := k1*k2;
    G := RMatrixSpace(F,k,n)!&cat&cat[[
	(ElementToSequence(G1[i]) cat ElementToSequence(G2[j]))
	: i in [1..k1]]
	: j in [1..k2]];

    if F eq CoefficientField(C1) then
	return LinearCode(G);
    else
	return AdditiveCode( CoefficientField(C1), G);
    end if;

end intrinsic;

//------------------SubfieldRepresentationCode-------------------//

intrinsic SubfieldRepresentationCode(C::CodeLinFld,K::FldFin) -> CodeLinFld
{ Given a linear code over GF(q^m), return a code whose codewords are obtained 
from those of C by expanding each coordinate in GF(q^m) as a vector of 
dimension m over K := GF(q) }

    F := Alphabet(C);
    w := PrimitiveElement(F);
    require (Characteristic(F) eq Characteristic(K)) and
	((Degree(F) mod Degree(K)) eq 0) : "K is not an appropriate subfield";
    m := Degree(F) div Degree(K);
    G := GeneratorMatrix(C);
    k := Dimension(C);
    n := Length(C);
    GG := &cat[[w^l * G[i] : i in [1..k]] : l in [0..m-1]];
    g := RMatrixSpace(K,k*m,n*m)!
	&cat&cat
	[[ElementToSequence((ElementToSequence(GG[i])[j]),K)
	: j in [1..n]]
	: i in [1..k*m]];
    return LinearCode(g);

end intrinsic;

//----------------ConcatenatedCode -------------------------//

//can crash when both codes over same field

intrinsic ConcatenatedCode(Outer::CodeLinFld,Inner::CodeLinFld) -> CodeLinFld
{Create the [Nn,Kk,delta >= dD] concatenated code associated with the Outer
[N,K,D]-code over GF(q^k) and the Inner [n,k,d]-code over
GF(q) (where q is arbitrary)}
    F := Alphabet(Outer);
    N := Length(Outer);
    K := Dimension(Outer);
    f := Alphabet(Inner);
    n := Length(Inner);
    k := Dimension(Inner);

    require (Characteristic(F) eq Characteristic(f)) and
	((Degree(F) mod Degree(f)) eq 0) : "Fields are not appropriate";
    GG := GeneratorMatrix(SubfieldRepresentationCode(Outer,f));
    g := GeneratorMatrix(Inner);
    gg := RMatrixSpace(f,k*N,n*N)!0;
    for i in [0..N-1] do
	InsertBlock(~gg,g,k*i+1,n*i+1);
    end for;
    C := LinearCode(GG*gg);
    return C;
end intrinsic;

//--------------------DirectSum -----------------------//

intrinsic DirectSum(Q::[Code])->Code
{The direct sum of the codes in the sequence Q}
    require #Q ge 1: "Sequence must be non-empty";
  C:=Q[1];
  for i:=2 to #Q do
    C:=DirectSum(C,Q[i]);
  end for;
  return C;
end intrinsic;


//-------------- AdditivePermutationCode  -----------------------//

intrinsic AdditivePermutationCode(K::FldFin, v::ModTupFldElt, G::GrpPerm)->CodeAdd
{The additive code corresponding to the K-span by the set of vectors 
obtained by applying the permutations of G to the vector u, which is a 
tuple over some extension field of K.}
    F := CoefficientRing(v);
    require Characteristic(F) eq Characteristic(K) : "Fields must have the same characteristic";
    require K subset F : "v must be over an extension of K";
    require Degree(G) eq Ncols(v) : "Group must have degree equal to the length of the input vector";

    return AdditiveCode(GF(2),Matrix(Setseq(v^G)));
end intrinsic;
