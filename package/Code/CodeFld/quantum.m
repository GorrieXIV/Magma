freeze;

intrinsic NormalizerCode(Q::CodeQuantum: ExtendedFormat := false) -> CodeAdd
{Return the normalizer code of Q, which is the symplectic dual of its
stabilizer code.};
    return SymplecticDual(StabilizerCode(Q : ExtendedFormat := ExtendedFormat) 
					    : ExtendedFormat := ExtendedFormat);
end intrinsic;

intrinsic NormaliserCode(Q::CodeQuantum : ExtendedFormat := false) -> CodeAdd
{Return the normalizer code of Q, which is the symplectic dual of its
stabilizer code.};
    return NormalizerCode(Q : ExtendedFormat := ExtendedFormat);
end intrinsic;

intrinsic NormalizerMatrix(Q::CodeQuantum: ExtendedFormat := false) -> ModMatFldElt
{Return the generator matrix of the normalizer code of Q, 
which is the symplectic dual of its stabilizer code.};
    return GeneratorMatrix(NormalizerCode(Q: ExtendedFormat := ExtendedFormat));
end intrinsic;

intrinsic NormaliserMatrix(Q::CodeQuantum: ExtendedFormat := false) -> ModMatFldElt
{Return the generator matrix of the normalizer code of Q, 
which is the symplectic dual of its stabilizer code.};
    return GeneratorMatrix(NormalizerCode(Q: ExtendedFormat := ExtendedFormat));
end intrinsic;

intrinsic RandomQuantumCode(F::FldFin, n::RngIntElt, k::RngIntElt) -> CodeQuantum
{Return a random [[n,k]] quantum code over F, which must be a 
degree 2 extension of some base field for the quantum code.}
    requirege n, 1;
    requirerange k, 0, n;

    require IsEven(Degree(F)) : "Field in not a degree 2 extension";

    K := GF( Characteristic(F), Degree(F) div 2);
    Embed(K, F);
        //need to make sure of a relationsip or something

    G := ZeroMatrix(F, 0, n);

    while n - Nrows(G) gt k do
        C := AdditiveCode(K, G);
        D := SymplecticDual(C);

            //could do this efficiently with structured gaussian elim
        repeat
            v := Random(D);
        until v notin C;

        G := VerticalJoin(G, v);

    end while;

    Q := QuantumCode(AdditiveCode(K, G));

    return Q;
end intrinsic;

intrinsic Subcode(Q::CodeQuantum,k::RngIntElt)->CodeQuantum
{Returns a subcode of the quantum code Q of dimension k}

  dimhack := Floor(Dimension(Q));
  requirerange k,0,dimhack;

  S:=StabilizerCode(Q);

  for i:=k+1 to dimhack do
    N := SymplecticDual(S);
    S := sub<N|S, CodeComplement(N, S).1>;
  end for;

  res := QuantumCode(S);

  res`MinimumWeightLowerBound := Q`MinimumWeightLowerBound;

  return res;

end intrinsic;


intrinsic QuantumCode(G::Grph) -> CodeQuantum
{Return the self-dual quantum code defined by the adjacency
matrix of the graph G.}
    A := Matrix(GF(2), AdjacencyMatrix(G));
    M := HorizontalJoin( IdentityMatrix(GF(2), Nrows(A)), A);

    return QuantumCode(M : ExtendedFormat := true);
end intrinsic;

intrinsic Hexacode() -> CodeQuantum
{Return the [[6,0,4]] self dual quantum hexacode}
    G := Graph<6 | {1,2},{2,3},{3,4},{4,5},{5,1}, 
				   <6,{1,2,3,4,5}> >;
    Q := QuantumCode(G);
    Q`MinimumWeight := 4;
    return Q;
end intrinsic;

intrinsic Dodecacode() -> CodeQuantum
{Return the [[12,0,6]] self dual quantum dodecacode}
    S := {@ i : i in [0 .. 11] @};
    G := Graph<S |
	{ {4*k+i,4*k+i+2}                     : i in [0..1], k in [0..2] },
	{ {4*k+i,4*k+(i+1) mod 4}             : i in [0..3], k in [0..2] },
	{ {4*k+i,4*((k+1) mod 3)+(i+1) mod 4} : i in [0..3], k in [0..2] } >;
    Q := QuantumCode(G);
    Q`MinimumWeight := 6;
    return Q;
end intrinsic;

intrinsic ExtendCode(Q::CodeQuantum, m::RngIntElt) -> CodeQuantum
{Given an [[n,k,d]] quantum code, return an [[n+m,k,d]] quantum code}

    Q1 := QuantumCode( Matrix(Alphabet(Q), 1, 1, [1]) );
    res := DirectSum(Q, DirectSum([Q1 : i in [1..m]]));

    res`MinimumWeightLowerBound := Q`MinimumWeightLowerBound;
    return res;
end intrinsic;

intrinsic ExtendCode(Q::CodeQuantum) -> CodeQuantum
{Given an [[n,k,d]] quantum code, return an [[n+1,k,d]] quantum code}
    return ExtendCode(Q, 1);
end intrinsic;

intrinsic IsEven(C::CodeAdd) -> BoolElt
{Return true if the codewords of an additive GF(4) code
are even.}
   F := Alphabet(C);
   require F eq GF(4) : "Function only exists for quaternary additive codes";
   K := CoefficientField(C);
   n := Length(C);
   k := Ngens(C);
   GF4 := {@ 0, 1, F.1, F.1^2 @};
   GF2 := {@ [0,0,0], [0,1,1], [1,0,1], [1,1,0] @};

   G := GeneratorMatrix(C);
   G1 := KMatrixSpace(K, k, 3*n) ! &cat[ GF2[Index(GF4,e)] : e in Eltseq(G)];

   C1 := LinearCode(G1);

   return IsDoublyEven(C1);

end intrinsic;

/******************** Cyclic Codes *********************************/

intrinsic QuantumCyclicCode(v::ModTupFldElt 
				: LinearSpan := false) ->CodeQuantum
{Given a vector v, return the quantum code whose stabiliser 
code is generated by the cyclic shifts of v.

If the vararg LinearSpan is set to true, then the linear span of the 
shifts will be used, else the additive span will be used (default).
If the span of the shifts of v is not symplectic
self-orthogonal, an error will be returned}

    require Type(LinearSpan) eq BoolElt : "Vararg must be a boolean value";
    if LinearSpan then
	S := CyclicCode(v);
    else
	S := AdditiveCyclicCode(v);
    end if;
    require IsSymplecticSelfOrthogonal(S) : "The cyclic shifts are not symplectic self-orthogonal";

    return QuantumCode(S);
end intrinsic;



intrinsic QuantumCyclicCode(Q::SeqEnum[ModTupFldElt]) ->CodeQuantum
{Given a sequence Q of vectors, return the quantum code whose stabiliser 
code is generated by their cyclic shifts.

If the (additive) span of the shifts is not symplectic
self-orthogonal, an error will be returned.}

    S := AdditiveCyclicCode(Q);
    require IsSymplecticSelfOrthogonal(S) : "The cyclic shifts are not symplectic self-orthogonal";

    return QuantumCode(S);
end intrinsic;

intrinsic QuantumCyclicCode(n::RngIntElt, f::RngUPolElt
				: LinearSpan := false) ->CodeQuantum
{Given a polynomial f, return the quantum code whose stabiliser 
code is generated by the cyclic shifts of f of length n.

If the vararg LinearSpan is set to true, then the linear span of the 
shifts will be used, else the additive span will be used (default).
If the span of the shifts of f is not symplectic
self-orthogonal, an error will be returned}

    require Type(LinearSpan) eq BoolElt : "Vararg must be a boolean value";
    if LinearSpan then
	S := CyclicCode(n, f);
    else
	S := AdditiveCyclicCode(n, f);
    end if;
    require IsSymplecticSelfOrthogonal(S) : "The cyclic shifts are not symplectic self-orthogonal";

    return QuantumCode(S);
end intrinsic;



intrinsic QuantumCyclicCode(n::RngIntElt, Q::SeqEnum[RngUPolElt]) ->CodeQuantum
{Given a sequence Q of polynomials, return the quantum code whose stabiliser 
code is generated by their cyclic shifts of length n.

If the (additive) span of the shifts is not symplectic
self-orthogonal, an error will be returned.}

    S := AdditiveCyclicCode(n, Q);
    require IsSymplecticSelfOrthogonal(S) : "The cyclic shifts are not symplectic self-orthogonal";

    return QuantumCode(S);
end intrinsic;


intrinsic QuantumCyclicCode(v4::ModTupFldElt, v2::ModTupFldElt) ->CodeQuantum
{GF(2)-additive cyclic codes over GF(4) are totally described by two
generating vectors, one over GF(4) and the other over GF(2).
Given a vector v4 over GF(4), and a vector v2 over GF(2), return
the quantum code whose stabiliser code is the additive span
of their cyclic shifts.

If the (additive) span of the shifts is not symplectic
self-orthogonal, an error will be returned.}

    require CoefficientRing(v4) eq GF(4) : "v4 must be over GF(4)";
    require CoefficientRing(v2) eq GF(2) : "v2 must be over GF(2)";
    require Nrows(v4) eq 1 and Nrows(v2) eq 1 : "Inputs must be vectors";
    require Ncols(v4) eq Ncols(v2) : "vectors must have the same length";

    S := AdditiveCyclicCode(v4, v2);
    require IsSymplecticSelfOrthogonal(S) : "The cyclic shifts are not symplectic self-orthogonal";

    return QuantumCode(S);
end intrinsic;



/******************** Quasi Cyclic Codes *********************************/


intrinsic QuantumQuasiCyclicCode(n::RngIntElt, Q::SeqEnum[RngUPolElt]
				: LinearSpan := false) ->CodeQuantum
{Given a sequence Q of polynomials, return the quantum code whose 
additive stabilizer matrix is constructed from the length n 
cyclic blocks are generated by the cyclic shifts of the polynomials in Q.

If the vararg LinearSpan is set to true, then the linear span of the 
shifts will be used, else the additive span will be used (default).
If the span of the shifts is not symplectic
self-orthogonal, an error will be returned.}

    require Type(LinearSpan) eq BoolElt : "Vararg must be a boolean value";
    if LinearSpan then
	S := QuasiCyclicCode(n, Q);
    else
	S := AdditiveQuasiCyclicCode(n, Q);
    end if;
    require IsSymplecticSelfOrthogonal(S) : "The quasi-cyclic shifts are not symplectic self-orthogonal";

    return QuantumCode(S);
end intrinsic;



intrinsic QuantumQuasiCyclicCode(Q::SeqEnum[ModTupFldElt]
				: LinearSpan := false) ->CodeQuantum
{Given a sequence Q of vectors, return the quantum code whose 
additive stabilizer matrix is constructed from the length n 
cyclic blocks are generated by the cyclic shifts of the vectors in Q.

If the vararg LinearSpan is set to true, then the linear span of the 
shifts will be used, else the additive span will be used (default).
If the (additive) span of the shifts is not symplectic
self-orthogonal, an error will be returned.}

    require Type(LinearSpan) eq BoolElt : "Vararg must be a boolean value";
    if LinearSpan then
	S := QuasiCyclicCode(Q);
    else
	S := AdditiveQuasiCyclicCode(Q);
    end if;
    require IsSymplecticSelfOrthogonal(S) : "The quasi-cyclic shifts are not symplectic self-orthogonal";

    return QuantumCode(S);
end intrinsic;


///////////////////////////////////////////////////////////////////////////

intrinsic PunctureCode(Q::CodeQuantum,m::RngIntElt)->CodeQuantum
{Puncture the quantum code Q at position m}

  requirerange m,1,Length(Q);

  S:=StabilizerCode(Q);

  N:=SymplecticDual(S);

  N1:=sub<Generic(N)|N,Generic(S).(2*m-1)>;
  S1:=PunctureCode(SymplecticDual(N1),m);
  qecc:=QuantumCode(S1);
//  qecc`MinimumWeightLowerBound:=C`MinimumWeightLowerBound-1;
  return qecc;
end intrinsic;

intrinsic PunctureCode(Q::CodeQuantum,S::{RngIntElt})->CodeQuantum
{Puncture the quantum code Qc at the positions in S}

    for i in S do
	require 1 le i and i le Length(Q) : "Invalid puncturing position:", i;
    end for;

  L:=Reverse(Sort([x:x in S]));
  c:=Q;

  for p in L do
    c:=PunctureCode(c,p);
  end for;

  return c;
end intrinsic;

intrinsic ShortenCode(Q::CodeQuantum,i::RngIntElt)->CodeQuantum
{If possible, shorten the quantum code Q=[[n,k,d]] at position i,
yielding a quantum code [[n-1,k'>=k-1,d'>=d]]}

    requirerange i, 1, Length(Q);

  S:=StabilizerCode(Q);

  S1:=PunctureCode(S,i);
  if IsSymplecticSelfOrthogonal(S1) then
    return QuantumCode(S1);
  else
    error Sprintf("Shortening at position %o not possible",i);
  end if;
end intrinsic;

intrinsic ShortenCode(Q::CodeQuantum,S::{RngIntElt})->CodeQuantum
{If possible, shorten the quantum code Q=[[n,k,d]] at the positions 
specified by S, yielding a quantum code [[n-s,k'>=k-s,d'>=d]] where s:=#S}

    for i in S do
	require 1 le i and i le Length(Q) : "Invalid shortening position:", i;
    end for;

  stab:=StabilizerCode(Q);
  stab1:=PunctureCode(stab,S);
  if IsSymplecticSelfOrthogonal(stab1) then
    return QuantumCode(stab1);
  else
    error Sprintf("Shortening at the positions in %o not possible",S);
  end if;
end intrinsic;

//////////////////////////////// quantum state stuff /////////////////

intrinsic NormalisationCoefficient(e::HilbSpcElt) -> FldCom
{Return the normalisation coeficient of the quantum state e}
    return InnerProduct(e,e);
end intrinsic;

intrinsic NormalizationCoefficient(e::HilbSpcElt) -> FldCom
{Return the normalization coeficient of the quantum state e}
    return NormalisationCoefficient(e);
end intrinsic;









