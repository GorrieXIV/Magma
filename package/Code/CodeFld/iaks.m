freeze;

intrinsic SubfieldRepresentation(Code::Code, SubField::FldFin) -> Code
{Generate the homomorphic image of Code in a SubField, i.e.,
each symbol in Code is represented as sequence over SubField};

/* "tutorial version" 
   M. Grassl, 23.07.1996
   IAKS, Universitaet Karlsruhe, Germany
   
*/

// parameters derived from Code
  N:=Length(Code);
  K:=Dimension(Code);
  F:=Alphabet(Code);
  G:=GeneratorMatrix(Code);
// represent each element of F as matrix over SubField
  mat,map:=MatrixAlgebra(F,SubField);    
  m:=Degree(mat);                 // extension degree of F over SubField
// replace all elements in the generator matrix G of the OuterCode by the 
// corresponding matrix over SubField
  G_over_SubField:=Zero(RMatrixSpace(SubField,K*m,N*m));
  for i:=0 to K-1 do
    for j:=0 to N-1 do
      InsertBlock(~G_over_SubField,G[i+1][j+1]@map,i*m+1,j*m+1);
    end for;
  end for;
  return LinearCode(G_over_SubField);
end intrinsic;

intrinsic ConcatenatedCode(OuterCode::Code,InnerCode::Code) -> Code
{Construct the concatenated code from OuterCode and InnerCode};

/* "tutorial version" 
   M. Grassl, 23.07.1996
   IAKS, Universitaet Karlsruhe, Germany
   
*/

/* OuterCode is defined over an alphabet that is an extension field of
   the alphabet of the InnerCode

   each symbol of the OuterCode is encoded using the InnerCode based on its 
   representation as sequence over the alphabet of the InnerCode
*/

/* some tests for correct parameters should be included */

// parameters derived from the OuterCode
  N:=Length(OuterCode);
  K:=Dimension(OuterCode);
  F:=Alphabet(OuterCode);
  G:=GeneratorMatrix(OuterCode);
// parameters derived from the InnerCode
  n:=Length(InnerCode);
  k:=Dimension(InnerCode);
  f:=Alphabet(InnerCode);
  g:=GeneratorMatrix(InnerCode);
// represent each element of F as matrix over f
  mat,map:=MatrixAlgebra(F,f);    
  m:=Degree(mat);                 // extension degree of F over f
// replace all elements in the generator matrix G of the OuterCode by the 
// corresponding matrix over f
  G_over_f:=Zero(RMatrixSpace(f,K*m,N*m));
  for i:=0 to K-1 do
    for j:=0 to N-1 do
      InsertBlock(~G_over_f,G[i+1][j+1]@map,i*m+1,j*m+1);
    end for;
  end for;
// construct a block diagonal matrix with N copies of the generator matrix g
// of the InnerCode
  g_diag_N:=Zero(RMatrixSpace(f,k*N,n*N));
  for i:=0 to N-1 do
    InsertBlock(~g_diag_N,g,k*i+1,n*i+1);
  end for;
// the concatenated code is generated by the product of the two
  return LinearCode(G_over_f*g_diag_N);  
end intrinsic;

intrinsic JustesenCode(RSCode::Code,alpha::FldFinElt,k::RngIntElt) -> Code
{Construct the Justesen code from RSCode and a primitive element alpha
of the alphabet of RSCode the powers of the innercode are shifted by k};

/* "tutorial version" 
   M. Grassl, 23.07.1996
   IAKS, Universitaet Karlsruhe, Germany
   
*/
  

/* each symbol x_i of the RSCode is encoded using the inner codes 
   x -> (x,x*alpha^(i+k)) where alpha is a primitive element of the 
   alphabet of the RSCode

   each symbol in the resulting sequence is represented as sequence 
   over the PrimeField of the alphabet of the RSCode
*/

/* some tests for correct parameters should be included */

// parameters derived from the OuterCode
  N:=Length(RSCode);
  K:=Dimension(RSCode);
  F:=Alphabet(RSCode);
  G:=GeneratorMatrix(RSCode);
// construct the inner codes
  G_inner:=Zero(RMatrixSpace(F,N,2*N));
  for i:=0 to N-1 do
    G_inner[i+1][2*i+1]:=1;
    G_inner[i+1][2*i+2]:=alpha^(i+k);
  end for;
// concatenate the codes
  G_over_F:=G*G_inner;
// map to the PrimeField of F
  return SubfieldRepresentation(LinearCode(G_over_F),PrimeField(F));
end intrinsic;
