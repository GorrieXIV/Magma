freeze;

/*
**  Root data -- Sparse representation.
** 
**  $Id: RootDtmSprs.m 45907 2014-01-21 06:13:50Z don $
** 
**  Most of the actual code is in Pairs.m
** 
**  Sergei Haller and Scott H Murray
** 
**  April-May 2006
** 
** 
*/

import "Cartan.m":  typeToCartan, tnToType, typeToName, numPosRootsOfType, cartanToType,
                    nameToType, removeTorusFromType;
import "RootDtm.m": assignSpaces, checkSigns, ABByIsogeny, insertTorusIntoAB, rootDatum, standardMatrices;
import "Pairs.m":   Pair_Roots, PairToRoot, PairToCoroot, RootToPair,
                    Pair_Height, Pair_CoHeight,
                    Pair_LeftString, Pair_RightString, Pair_LeftStringLength, Pair_RightStringLength,
                    Pair_ReflectionPermutation;

import "RootDtmExt.m": computeGA;

/*
**   Printing
*/
intrinsic HackobjPrintNamedRootDtmSprs( R::RootDtmSprs, l::MonStgElt, name::MonStgElt )
{Internal intrinsic: Print the root datum R at level l}
    HackobjPrintNamedRootDtm(R,l,name);
end intrinsic;

intrinsic HackobjPrintRootDtmSprs( R::RootDtmSprs, l::MonStgElt )
{Internal intrinsic: Print the root datum R at level l}
    HackobjPrintRootDtm(R,l);
end intrinsic;

/*
**   Hash
*/
intrinsic HackobjHashRootDtmSprs( R::RootDtmSprs ) -> RngIntElt
{Internal intrinsic: Return a hash value for a root datum}
    return HackobjHashRootDtm(R);
end intrinsic;


/*
**   sub<R|...> constructors
*/
intrinsic HackobjSubConstrRootDtmSprs( R::RootDtmSprs, simples::SeqEnum ) -> RootDtm, .
{Internal intrinsic: The root subdatum of R with the given simples}
    return HackobjSubConstrRootDtm(R,simples);
end intrinsic;

intrinsic HackobjSubConstrRootDtmSprs(R::RootDtmSprs, gens::SetEnum ) -> RootDtm, .
{Internal intrinsic: The root subdatum of R generated by gens}
    return HackobjSubConstrRootDtm(R,gens);
end intrinsic;

intrinsic HackobjSubConstrRootDtmSprs( R::RootDtm, U::ModTupFld, V::ModTupFld ) -> RootDtm, .
{Internal intrinsic: The root subdatum of R on the subspaces U (resp V) of the (co)root space}
    return HackobjSubConstrRootDtm(R,U,V);
end intrinsic;



/*
** 
**   RootDtmSprs  constructors -- internal functions
** 
*/

createRawSprsDtm := function( A, B, type, signs )
    R := HackobjCreateRaw( RootDtmSprs );
    R`Rank                  := Nrows(A);
    R`Dimension             := Ncols(A);
    R`SimpleRoots           := A;
    R`SimpleCoroots         := B;
    R`Type                  := type;
    R`ExtraspecialSigns     := signs;
    return R; 
end function;

sprsRootDatum := function( A, B, C, type, signs )
    F := CoveringStructure(BaseRing(A), Rationals());
    F := CoveringStructure(BaseRing(B), F);
    A := Matrix(F,A);     // make sure we are consistent for Hashes
    B := Matrix(F,B);     //
 
    N := numPosRootsOfType( type );

    R := createRawSprsDtm(A,B,type,signs);

    R`CartanMatrix := C;
    R`Name := typeToName( type );

    /*
     *  dimension and field could be deduced from R (in principle)
     *  inside CreateRootVectorSpace.
     *  it is harder to get this info on C level, so we just pass it along.
     */
    d := R`Dimension;
    V := CreateRootVectorSpace( Rationals(), d, R );
    U := CreateRootVectorSpace( Rationals(), d, R : Coroots := true );

    R`RootSpace   := V;
    R`CorootSpace := U;

    R`GammaAction := computeGA(R,1);

    assignSpaces(~R);
    err := checkSigns(R);
    if err ne "" then
        error err;
    end if;
 
    return R;
end function;


/*
** 
**   RootDtmSprs  constructors -- various intrinsics, that will call other intrinsics in turn
** 
*/
/*
intrinsic IrreducibleRootDatum( `RootDtmSprs, X::MonStgElt, n::RngIntElt 
: Isogeny := "Ad", Signs := 1 ) -> RootDtmSprs
{The irreducible root datum with Cartan name X_n}
    return SparseIrreducibleRootDatum( X, n : Isogeny:=Isogeny, Signs:=Signs );
end intrinsic;

intrinsic StandardRootDatum( `RootDtmSprs, X::MonStgElt, n::RngIntElt 
: Signs := 1 ) -> RootDtmSprs
{The standard root datum with Cartan name X_n}
    return SparseStandardRootDatum(X,n : Signs:=Signs );
end intrinsic;

intrinsic RootDatum( `RootDtmSprs, R::RootDtm ) -> RootDtmSprs
{Return root datum R as sparse root datum}
    return SparseRootDatum( R );
end intrinsic;

intrinsic RootDatum( `RootDtmSprs, A::Mtrx, B::Mtrx
: Signs := 1 ) -> RootDtmSprs
{The root datum whose simple (co)roots are the rows of the matrix A (B)}
    return SparseRootDatum( A, B : Signs:=Signs );
end intrinsic;

intrinsic RootDatum( `RootDtmSprs, N::MonStgElt
: Isogeny := "Ad", Signs := 1 ) -> RootDtmSprs
{The root datum whose simple (co)roots are the rows of the matrix A (B)}
    return SparseRootDatum( N : Isogeny:=Isogeny, Signs:=Signs );
end intrinsic;

intrinsic RootDatum( `RootDtmSprs, C::AlgMatElt
: Isogeny := "Ad", Signs := 1 ) -> RootDtmSprs
{}
    return SparseRootDatum( C : Isogeny:=Isogeny, Signs:=Signs );
end intrinsic;

intrinsic RootDatum( `RootDtmSprs, D::GrphDir
: Isogeny := "Ad", Signs := 1 ) -> RootDtmSprs
{}
    return SparseRootDatum( D : Isogeny:=Isogeny, Signs:=Signs );
end intrinsic;

intrinsic RootDatum( `RootDtmSprs, R::RootSys
: Signs := 1 ) -> RootDtmSprs
{}
    return SparseRootDatum( R : Signs:=Signs );
end intrinsic;
*/


/*
** 
**   RootDtmSprs  constructors -- user intrinsics
** 
*/

intrinsic SparseRootDatum( R::RootDtm ) -> RootDtmSprs
{Root datum R as sparse root datum}
    if Category(R) eq RootDtmSprs then
        return R;
    end if;
    
    X := R`Type[1][1];
    require X in "ABCD" : "Not a classical type";

    require not IsTwisted(R) : "Root datum is twisted";

    A := SimpleRoots(R);
    B := SimpleCoroots(R);
    C := CartanMatrix(R);
    type  := R`Type;
    signs := R`ExtraspecialSigns;
    
    S := sprsRootDatum( A, B, C, type, signs );

    for attr in [ "IsAdjoint", "IsSimplyConnected" ] do
        if assigned R``attr then
            S``attr := R``attr;
        end if;
    end for;

    return S;
end intrinsic;

intrinsic RootDatum( R::RootDtmSprs ) -> RootDtmSprs
{Return sparse root datum R as non-sparse root datum}
    A := SimpleRoots(R);
    B := SimpleCoroots(R);
    C := CartanMatrix(R);
    type  := R`Type;
    signs := R`ExtraspecialSigns;
    
    S := rootDatum( A, B, C, type, signs );

    for attr in [ "IsAdjoint", "IsSimplyConnected" ] do
        if assigned R``attr then
            S``attr := R``attr;
        end if;
    end for;

    return S;
end intrinsic;


intrinsic SparseRootDatum( A::Mtrx, B::Mtrx
: Signs := 1 ) -> RootDtmSprs
{The sparse root datum whose simple (co)roots are the rows of the matrix A (B)}
    require Nrows(A) eq Nrows(B) : "Matrices must have the same number of rows";
    require Ncols(A) eq Ncols(B) : "Matrices must have the same number of columns";
    rank := Nrows(A);  dim := Ncols(A);
    F := CoveringStructure(BaseRing(A), Rationals());
    F := CoveringStructure(BaseRing(B), F);
    A := Matrix(F,A);
    B := Matrix(F,B);
    C := Matrix( A*Transpose(B) );
    require IsCartanMatrix( C ) : "A*Transpose(B) must be a Cartan matrix";
    type := cartanToType(C);
    require #type eq 1 : "The Cartan matrix is not indecomposable";
    require type[1][1] in "ABCD" : "Not a classical type";
    R := sprsRootDatum( A, B, C, type, Signs );

    if Category( Isogeny ) eq MonStgElt then
        if Isogeny eq "Ad" then
			R`IsAdjoint := Rank(R) eq Dimension(R);
			R`IsWeaklyAdjoint := true;
        elif Isogeny eq "SC" then
			R`IsSimplyConnected := Rank(R) eq Dimension(R);
			R`IsWeaklySimplyConnected := true;
        end if;
    end if;

    return R;
end intrinsic;


intrinsic SparseIrreducibleRootDatum( X::MonStgElt, n::RngIntElt 
: Isogeny := "Ad", Signs := 1 ) -> RootDtmSprs
{The sparse irreducible root datum with Cartan name X_n}
    return SparseRootDatum( typeToCartan( tnToType( X, n ) ) : Signs:=Signs, Isogeny:=Isogeny );
end intrinsic;


intrinsic SparseRootDatum( N::MonStgElt
: Isogeny := "Ad", Signs := 1 ) -> RootDtmSprs
{The sparse root datum with Cartan name N}
    type := nameToType(N : allowtorus );
    require Category( type ) ne BoolElt : "Invalid Cartan name";
    sstype := removeTorusFromType(type);
    require #sstype gt 0 : "The Cartan matrix has rank 0";
    require #sstype eq 1 : "The Cartan matrix is not indecomposable";
    require sstype[1][1] in "ABCD" : "Not a classical type";

    C := typeToCartan( sstype );
    A, B := ABByIsogeny( C, sstype, Isogeny );
    insertTorusIntoAB(~A, ~B, type);

    R := sprsRootDatum( A, B, C, sstype, Signs );

    if Category( Isogeny ) eq MonStgElt then
        if Isogeny eq "Ad" then
			R`IsAdjoint := Rank(R) eq Dimension(R);
			R`IsWeaklyAdjoint := true;
        elif Isogeny eq "SC" then
			R`IsSimplyConnected := Rank(R) eq Dimension(R);
			R`IsWeaklySimplyConnected := true;
        end if;
    end if;

    return R;
end intrinsic;


intrinsic SparseRootDatum( C::AlgMatElt
: Isogeny := "Ad", Signs := 1 ) -> RootDtmSprs
{The sparse root datum with Cartan matrix C}

    type := cartanToType(C);
    require #type eq 1 : "The Cartan matrix is not indecomposable";
    require type[1][1] in "ABCD" : "Not a classical type";

    A, B := ABByIsogeny( C, type, Isogeny );

    R := sprsRootDatum( A, B, C, type, Signs );

    if Category( Isogeny ) eq MonStgElt then
        if Isogeny eq "Ad" then
			R`IsAdjoint := Rank(R) eq Dimension(R);
			R`IsWeaklyAdjoint := true;
        elif Isogeny eq "SC" then
			R`IsSimplyConnected := Rank(R) eq Dimension(R);
			R`IsWeaklySimplyConnected := true;
        end if;
    end if;

    return R;
end intrinsic;

intrinsic SparseRootDatum( D::GrphDir
: Isogeny := "Ad", Signs := 1 ) -> RootDtmSprs
{The sparse root datum with Dynkin digraph D}
    R := SparseRootDatum( CartanMatrix( D ) : Signs:=Signs, Isogeny:=Isogeny );
    R`DynkinDigraph := D;
    return R;
end intrinsic;

intrinsic SparseRootDatum( R::RootSys
: Signs := 1 ) -> RootDtmSprs
{The sparse root datum of the root system R}
    return SparseRootDatum( R`SimpleRoots, R`SimpleCoroots : Signs:=Signs );
end intrinsic;


intrinsic SparseStandardRootDatum( X::MonStgElt, n::RngIntElt 
: Signs := 1 ) -> RootDtmSprs
{The sparse standard root datum with Cartan name X_n}
    A, B, C, type := standardMatrices( X, n );
    require #type eq 1 : "The Cartan matrix is not indecomposable";
    require type[1][1] in "ABCD" : "Not a classical type";
    R := sprsRootDatum( A, B, C, type, Signs );
    return R;
end intrinsic;




/*
** 
**   Basic Properties
** 
*/

intrinsic IsTwisted( R::RootDtmSprs ) -> BoolElt
{Returns true iff the root datum is twisted, that is, nonsplit}
    return false;
end intrinsic;
intrinsic IsSplit( R::RootDtmSprs ) -> BoolElt
{Returns true iff the root datum is split}
    return true;
end intrinsic;


/*
** 
**   Debug
** 
*/

intrinsic CheckSparseRootDatum( R::RootDtmSprs )
{Internal. Checks a sparse root datum for consistency}
    for attr in ["RootSystem",          "CorootSystem",
                 "RootSystemStandard",  "CorootSystemStandard",
                 "RootSystemWeight",    "CorootSystemWeight",
                 "RootNorms",           "CorootNorms",
//                 "CoxeterForm",         "DualCoxeterForm",
                 "LeftStrings",         "RightStrings",
                 "Epsilons",            "NontrivialPairs",
                 "multiplicationData",  "LieConstant_eta",      "cartanIntegers" ] 
    do
        assert not assigned R``attr;
    end for;
end intrinsic;


/*
** 
**   Roots and Coroots
** 
*/

intrinsic Root( R::RootDtmSprs, r::RngIntElt : Basis := "Standard" ) -> .
{The rth root of R} /* get comment from the intrinsic for RootDtm */
    N := NumPosRoots(R);
    require Basis in {"Standard","Root","Weight"}: "Invalid Basis flag";
    requirerange r, 1, 2*N;
    X := R`Type[1][1];
    n := Rank(R);
    v := PairToRoot(X,n,InternalGrpLieIndex2Pair(X,n,r,N));
    if Basis ne "Root" then
        v := BasisChange( R, v : InBasis := "Root", OutBasis := Basis );
    end if;
    return v;
end intrinsic;
intrinsic Coroot( R::RootDtmSprs, r::RngIntElt : Basis := "Standard" ) -> .
{The rth coroot of R} /* get comment from the intrinsic for RootDtm */
    N := NumPosRoots(R);
    require Basis in {"Standard","Root","Weight"}: "Invalid Basis flag";
    requirerange r, 1, 2*N;
    X := R`Type[1][1];
    n := Rank(R);
    v := PairToCoroot(X,n,InternalGrpLieIndex2Pair(X,n,r,N));
    if Basis ne "Root" then
        v := BasisChange( R, v : InBasis := "Root", OutBasis := Basis, Coroots );
    end if;
    return v;
end intrinsic;


intrinsic RootPosition( R::RootDtmSprs, v::. : Basis := "Standard" ) -> RngIntElt
{The position of the vector v as a root of R} /* get comment from the intrinsic for RootDtm */
    require Basis in {"Standard","Root","Weight"}: "Invalid Basis flag";
    if Basis ne "Root" then
        v := BasisChange( R, v : InBasis := Basis, OutBasis := "Root" );
    end if;
    X := R`Type[1][1];
    n := Rank(R);
    r := InternalGrpLiePair2Index(X,n,RootToPair(X,n,v),NumPosRoots(R));
    return r;
end intrinsic;
intrinsic CorootPosition( R::RootDtmSprs, v::. : Basis := "Standard" ) -> RngIntElt
{The position of the vector v as a coroot of R} /* get comment from the intrinsic for RootDtm */
    require Basis in {"Standard","Root","Weight"}: "Invalid Basis flag";
    if Basis ne "Root" then
        v := BasisChange( R, v : InBasis := Basis, OutBasis := "Root", Coroots );
    end if;
    X := R`Type[1][1];
    n := Rank(R);
    r := InternalGrpLiePair2Index(X,n,RootToPair(X,n,v),NumPosRoots(R));
    return r;
end intrinsic;


intrinsic Roots( R::RootDtmSprs : Basis := "Standard" ) -> {@ @}
{The roots of R} /* get comment from the intrinsic for RootDtm */
    require Basis in {"Standard","Root","Weight"}: "Invalid Basis flag";
    X := R`Type[1][1];
    n := Rank(R);
    rts := {@ PairToRoot(X,n,p) : p in Pair_Roots(X,n) @};
    if Basis ne "Root" then
      rts := {@ BasisChange( R, v : InBasis := "Root", OutBasis := Basis ) : v in rts @};
    end if;
    return rts;
end intrinsic;
intrinsic Coroots( R::RootDtmSprs : Basis := "Standard" ) -> {@ @}
{The coroots of R} /* get comment from the intrinsic for RootDtm */
    require Basis in {"Standard","Root","Weight"}: "Invalid Basis flag";
    X := R`Type[1][1];
    n := Rank(R);
    rts := {@ PairToCoroot(X,n,p) : p in Pair_Roots(X,n) @};
    if Basis ne "Root" then
      rts := {@ BasisChange( R, v : InBasis := "Root", OutBasis := Basis, Coroots ) : v in rts @};
    end if;
    return rts;
end intrinsic;


/*
** 
**   Norms and Heights
** 
*/


intrinsic RootNorms( R::RootDtmSprs ) -> []
{The squares of the root lengths of R} /* get comment from the intrinsic for RootDtm */
    return [RootNorm(R,r) : r in [1..2*NumPosRoots(R)]];
end intrinsic;

intrinsic CorootNorms( R::RootDtmSprs ) -> []
{The squares of the coroot lengths of R} /* get comment from the intrinsic for RootDtm */
    return [CorootNorm(R,r) : r in [1..2*NumPosRoots(R)]];
end intrinsic;

intrinsic RootNorm( R::RootDtmSprs, r::RngIntElt ) -> RngIntElt
{The square of the length of the rth root of R} /* get comment from the intrinsic for RootDtm */
    X := R`Type[1][1];
    n := Rank(R);
    return InternalGrpLiePairNorm(X,n,InternalGrpLieIndex2Pair(X,n,r,NumPosRoots(R)));
end intrinsic;

intrinsic CorootNorm( R::RootDtmSprs, r::RngIntElt ) -> RngIntElt
{The square of the length of the rth coroot of R} /* get comment from the intrinsic for RootDtm */
    X := R`Type[1][1];
    m := RootNorm(R,r);
    case X :
    when "A", "D" : return m;
    when "B", "C" : return m eq 1 select 2 else 1;
    end case;
end intrinsic;


intrinsic RootHeight( R::RootDtmSprs, r::RngIntElt ) -> RngIntElt
{The height of the rth root of R}
    X := R`Type[1][1];
    n := Rank(R);
    return Pair_Height(X,n,InternalGrpLieIndex2Pair(X,n,r,NumPosRoots(R)) );
end intrinsic

intrinsic CorootHeight( R::RootDtmSprs, r::RngIntElt ) -> RngIntElt
{The height of the rth coroot of R}
    X := R`Type[1][1];
    n := Rank(R);
    return Pair_CoHeight(X,n,InternalGrpLieIndex2Pair(X,n,r,NumPosRoots(R)) );
end intrinsic



/*
** 
**   Strings 'n stuff
** 
*/

intrinsic LeftString( R::RootDtmSprs, r::RngIntElt, s::RngIntElt ) -> []
{} /* get comment from the intrinsic for RootDtm */
    N := NumPosRoots(R);
    require (r ne s) : "Equal roots not allowed";
    require (r ne s+N) and (r+N ne s) : "Antipodal roots not allowed";
    X := R`Type[1][1];
    n := Rank(R);
    str := Pair_LeftString( X, n, InternalGrpLieIndex2Pair(X,n,r,N), 
                                  InternalGrpLieIndex2Pair(X,n,s,N) );
    return [Integers()| InternalGrpLiePair2Index(X,n,p,N) : p in str ];
end intrinsic;

intrinsic RightString( R::RootDtmSprs, r::RngIntElt, s::RngIntElt ) -> []
{} /* get comment from the intrinsic for RootDtm */
    N := NumPosRoots(R);
    require (r ne s) : "Equal roots not allowed";
    require (r ne s+N) and (r+N ne s) : "Antipodal roots not allowed";
    X := R`Type[1][1];
    n := Rank(R);
    str := Pair_RightString( X, n, InternalGrpLieIndex2Pair(X,n,r,N), 
                                   InternalGrpLieIndex2Pair(X,n,s,N) );
    return [Integers()| InternalGrpLiePair2Index(X,n,p,N) : p in str ];
end intrinsic;

intrinsic LeftStringLength( R::RootDtmSprs, r::RngIntElt, s::RngIntElt ) -> []
{} /* get comment from the intrinsic for RootDtm */
    N := NumPosRoots(R);
    require (r ne s) : "Equal roots not allowed";
    require (r ne s+N) and (r+N ne s) : "Antipodal roots not allowed";
    X := R`Type[1][1];
    n := Rank(R);
    return Pair_LeftStringLength( X, n, InternalGrpLieIndex2Pair(X,n,r,N), 
                                        InternalGrpLieIndex2Pair(X,n,s,N) );
end intrinsic;

intrinsic RightStringLength( R::RootDtmSprs, r::RngIntElt, s::RngIntElt ) -> []
{} /* get comment from the intrinsic for RootDtm */
    N := NumPosRoots(R);
    require (r ne s) : "Equal roots not allowed";
    require (r ne s+N) and (r+N ne s) : "Antipodal roots not allowed";
    X := R`Type[1][1];
    n := Rank(R);
    return Pair_RightStringLength( X, n, InternalGrpLieIndex2Pair(X,n,r,N), 
                                         InternalGrpLieIndex2Pair(X,n,s,N) );
end intrinsic;



/*
** 
**   Reflection Permutations
** 
*/


intrinsic ReflectionPermutation( R::RootDtmSprs, r::RngIntElt ) -> GrpPermElt
{} /* get comment from the intrinsic for RootDtm */
    N := NumPosRoots(R);
    requirerange r, 1, 2*N;
    X := R`Type[1][1];
    n := Rank(R);
    return Pair_ReflectionPermutation( X, n, InternalGrpLieIndex2Pair(X,n,r,N) );
end intrinsic;

intrinsic ReflectionPermutations( R::RootDtmSprs ) -> SeqEnum[GrpPermElt]
{} /* get comment from the intrinsic for RootDtm */
    return [ ReflectionPermutation(R,r) : r in [1..2*NumPosRoots(R)] ];
end intrinsic;


/*
** 
**   Extraspecial pairs 
** 
*/

intrinsic ExtraspecialPair( R::RootDtmSprs, r::RngIntElt ) -> RngIntElt, RngIntElt
{} /* get comment from the intrinsic for RootDtm */
    X := R`Type[1][1];
    n := Rank(R);
    N := NumPosRoots(R);
    requirerange r, n+1, N;
    esp := InternalGrpLiePairExtraspecialPair(X,n,InternalGrpLieIndex2Pair(X,n,r,N)); 
    return InternalGrpLiePair2Index(X,n,esp[1],N), InternalGrpLiePair2Index(X,n,esp[2],N);
end intrinsic;

intrinsic ExtraspecialPairs( R::RootDtmSprs ) -> SeqEnum[RngIntElt]
{} /* get comment from the intrinsic for RootDtm */
    X := R`Type[1][1];
    n := Rank(R);  N := NumPosRoots(R);
    return [ <InternalGrpLiePair2Index(X,n,esp[1],N), InternalGrpLiePair2Index(X,n,esp[2],N)>
             where esp is InternalGrpLiePairExtraspecialPair(X,n,InternalGrpLieIndex2Pair(X,n,r,N))
           : r in [n+1..N] ];
end intrinsic;

/*
** 
**   Signs and Constants
** 
*/


intrinsic LieConstant_epsilon( R::RootDtmSprs, r::RngIntElt, s::RngIntElt ) -> RngIntElt
{} /* get comment from the intrinsic for RootDtm */
    X := R`Type[1][1];
    n := Rank(R);  N := NumPosRoots(R);
    return InternalGrpLiePairEpsilon( X, n, R`ExtraspecialSigns, InternalGrpLieIndex2Pair(X,n,r,N), 
                                                                 InternalGrpLieIndex2Pair(X,n,s,N), N );
end intrinsic;
intrinsic LieConstant_epsilon( R::RootDtmSprs, r::Tup, s::Tup ) -> RngIntElt
{} /* get comment from the intrinsic for RootDtm */
    X := R`Type[1][1];
    n := Rank(R);  N := NumPosRoots(R);
    return InternalGrpLiePairEpsilon( X, n, R`ExtraspecialSigns, r, s, N );
end intrinsic;


intrinsic LieConstant_C( R::RootDtmSprs, i::RngIntElt, j::RngIntElt, r::RngIntElt, s::RngIntElt ) -> RngIntElt
{} /* get comment from the intrinsic for RootDtm */
    X := R`Type[1][1];
    n := Rank(R);  N := NumPosRoots(R);
    return LieConstant_C(R,i,j,InternalGrpLieIndex2Pair(X,n,r,N),
                               InternalGrpLieIndex2Pair(X,n,s,N));
end intrinsic;
intrinsic LieConstant_C( R::RootDtmSprs, i::RngIntElt, j::RngIntElt, r::Tup, s::Tup ) -> RngIntElt
{} /* get comment from the intrinsic for RootDtm */

    if i eq 1 and j eq 1 then return LieConstant_N(R,r,s); end if;

    X := R`Type[1][1];
    n := Rank(R);
    
    t := InternalGrpLiePairSum(X,n,r,s);     if t eq <0,0> then return 0; end if;
    if i eq 1 and j eq 2 then
      return LieConstant_N(R,r,s)*LieConstant_N(R,t,s) div 2;
    elif i eq 2 and j eq 1 then
      return LieConstant_N(R,r,s)*LieConstant_N(R,t,r) div 2;
    elif i eq 1 and j eq 3 then
      u := InternalGrpLiePairSum(X,n,t,s);   if u eq <0,0> then return 0; end if;
      return LieConstant_N(R,r,s)*LieConstant_N(R,t,s)*LieConstant_N(R,u,s) div 6;
    elif i eq 3 and j eq 1 then
      u := InternalGrpLiePairSum(X,n,t,r);   if u eq <0,0> then return 0; end if;
      return LieConstant_N(R,r,s)*LieConstant_N(R,t,r)*LieConstant_N(R,u,r) div 6;
    elif i eq 2 and j eq 3 then
      u := InternalGrpLiePairSum(X,n,t,s);   if u eq <0,0> then return 0; end if;
      return -LieConstant_N(R,s,t)*LieConstant_N(R,u,t) div 6;
    elif i eq 3 and j eq 2 then
      u := InternalGrpLiePairSum(X,n,t,r);   if u eq <0,0> then return 0; end if;
      return -LieConstant_N(R,r,t)*LieConstant_N(R,u,t) div 3;
    else return 0;
    end if;
end intrinsic;

intrinsic LieConstant_N( R::RootDtmSprs, r::RngIntElt, s::RngIntElt ) -> RngIntElt
{} /* get comment from the intrinsic for RootDtm */
    X := R`Type[1][1];
    n := Rank(R);  N := NumPosRoots(R);
    return LieConstant_N(R,InternalGrpLieIndex2Pair(X,n,r,N),
                           InternalGrpLieIndex2Pair(X,n,s,N));
end intrinsic;
intrinsic LieConstant_N( R::RootDtmSprs, r::Tup, s::Tup ) -> RngIntElt
{} /* get comment from the intrinsic for RootDtm */
    X := R`Type[1][1];
    n := Rank(R);  N := NumPosRoots(R);
    epsilon := InternalGrpLiePairEpsilon( X,n, R`ExtraspecialSigns, r,s, N );
    absN    := Pair_LeftStringLength( X,n, r,s ) + 1;
    return epsilon * absN;
end intrinsic;


intrinsic LieConstant_M( R::RootDtmSprs, r::RngIntElt, s::RngIntElt, i::RngIntElt ) -> RngIntElt
{} /* get comment from the intrinsic for RootDtm */
    X := R`Type[1][1];
    n := Rank(R);  N := NumPosRoots(R);
    return LieConstant_M(R, InternalGrpLieIndex2Pair(X,n,r,N),
                            InternalGrpLieIndex2Pair(X,n,s,N),i);
end intrinsic;
intrinsic LieConstant_M( R::RootDtmSprs, r::Tup, s::Tup, i::RngIntElt ) -> RngIntElt
{} /* get comment from the intrinsic for RootDtm */
    X := R`Type[1][1];
    n := Rank(R);  N := NumPosRoots(R);
    epsilon := InternalGrpLiePairEpsilon( X,n, R`ExtraspecialSigns, s,r, N );
    p := Pair_LeftStringLength( X,n, s,r );

    string := Pair_RightString( X,n, r,s );
    
    if i-1 gt #string then
        return 1;
    else
        M := epsilon * Binomial( p + i, i );
        for j in [1..i-1] do
            M *:= InternalGrpLiePairEpsilon( X,n, R`ExtraspecialSigns, string[j], r, N );
        end for;
        return M;
    end if;
end intrinsic;

function lie_eta_sprs(X,n,N,espsigns,r,s);
    if (r eq s) or (r eq InternalGrpLiePairNegative(X,n,s)) or (InternalGrpLiePairNegative(X,n,r) eq s) then 
        return -1; 
    else
        p := Pair_LeftStringLength ( X,n, r,s );
        q := Pair_RightStringLength( X,n, r,s );
        if p eq 0 and q eq 0 then 
            return 1; 
        elif p eq q then 
            return -1; 
        else
            string := Reverse( Pair_LeftString( X,n, r,s ) ) 
                 cat [s] 
                 cat Pair_RightString( X,n, r,s );

            return 
                IsEven(p + Multiplicity({* InternalGrpLiePairEpsilon( X,n, espsigns, string[i], r, N ) 
                             : i in [Min(p,q)+1..Max(p,q)]*}, -1)
                ) select  1 
                    else -1 ;
        end if;
    end if;
end function;

intrinsic LieConstant_eta( R::RootDtmSprs, r::RngIntElt, s::RngIntElt ) -> RngIntElt
{} /* get comment from the intrinsic for RootDtm */
    X := R`Type[1][1];
    n := Rank(R);  N := NumPosRoots(R);
    return lie_eta_sprs(X,n,N,R`ExtraspecialSigns,
                            InternalGrpLieIndex2Pair(X,n,r,N),
                            InternalGrpLieIndex2Pair(X,n,s,N));
end intrinsic;
intrinsic LieConstant_eta( R::RootDtmSprs, r::Tup, s::Tup ) -> RngIntElt
{} /* get comment from the intrinsic for RootDtm */
    X := R`Type[1][1];
    n := Rank(R);
    return lie_eta_sprs(X,n,NumPosRoots(R),R`ExtraspecialSigns,r,s);
end intrinsic;

cartanIntegerSprs := function(X,n,N,r,s)
    case r:
        when s:         
            return 2;
        when InternalGrpLiePairNegative(X,n,s):
            return -2;
        else
            return Pair_LeftStringLength(X,n,s,r) - Pair_RightStringLength(X,n,s,r);
    end case;
end function;

intrinsic CartanInteger( R::RootDtmSprs, r::RngIntElt, s::RngIntElt ) -> RngIntElt
{} /* get comment from the intrinsic for RootDtm */
    X := R`Type[1][1];
    n := Rank(R);  N := NumPosRoots(R);
    return cartanIntegerSprs(X,n,N, InternalGrpLieIndex2Pair(X,n,r,N),
                                    InternalGrpLieIndex2Pair(X,n,s,N));
end intrinsic;
intrinsic CartanInteger( R::RootDtmSprs, r::Tup, s::Tup ) -> RngIntElt
{} /* get comment from the intrinsic for RootDtm */
    X := R`Type[1][1];
    n := Rank(R);
    return cartanIntegerSprs(X,n,NumPosRoots(R),r,s);
end intrinsic;




/*
** 
**   Structrue Constants for Lie Algebras
** 
*/


import "Const.m" : posnegcar;

intrinsic StructureConstants( R::RootDtmSprs ) -> SeqEnum
{} /* get comment from the intrinsic for RootDtm */

    N := NumPosRoots(R);  n := Rank(R);  d := Dimension(R);
    X := R`Type[1][1];
    pos, neg, cart := posnegcar( N, d );
    T := [];

    // [x_r, x_s] = N_rs x_t
    for r in [1..N], s in [r+1..N] do
        rp := InternalGrpLieIndex2Pair(X,n,r,N);
        sp := InternalGrpLieIndex2Pair(X,n,s,N);
        sump := InternalGrpLiePairSum(X,n,rp,sp);
        if sump ne <0,0> then
            eps  := InternalGrpLiePairEpsilon( X,n, R`ExtraspecialSigns, rp,sp, N );
            p    := Pair_LeftStringLength ( X,n, rp,sp );
            q    := Pair_RightStringLength( X,n, rp,sp );
            qrev := Pair_RightStringLength( X,n, sp,rp );

            e := eps*(p+1);  f := eps*q;  g := eps*qrev;

            sum := InternalGrpLiePair2Index(X,n,sump,N);

            Append( ~T, <pos(r), pos(s), pos(sum),  e> );
            Append( ~T, <pos(s), pos(r), pos(sum), -e> );
            Append( ~T, <neg(r), neg(s), neg(sum), -e> );
            Append( ~T, <neg(s), neg(r), neg(sum),  e> );

            Append( ~T, <pos(s), neg(sum), neg(r),  g> );
            Append( ~T, <neg(sum), pos(s), neg(r), -g> );
            Append( ~T, <pos(sum), neg(s), pos(r),  g> );
            Append( ~T, <neg(s), pos(sum), pos(r), -g> );

            Append( ~T, <pos(r), neg(sum), neg(s), -f> );
            Append( ~T, <neg(sum), pos(r), neg(s),  f> );
            Append( ~T, <pos(sum), neg(r), pos(s), -f> );
            Append( ~T, <neg(r), pos(sum), pos(s),  f> );
        end if;
    end for;

    for r in [1..N] do
        rt := Root(R,r);
        co := Coroot(R,r);
        for i in [1..d] do
            // [x_-r,x_r] = \sum d_i h_i  where al_r^* = \sum d_i f_i
            if co[i] ne 0 then
                e := co[i];
                Append( ~T, <neg(r), pos(r), cart(i),  e> );
                Append( ~T, <pos(r), neg(r), cart(i), -e> );
            end if;

            // [x_r, h_i] = c_i x_r,      where al_r   = \sum c_i e_i
            if rt[i] ne 0 then
                c := rt[i];
                Append( ~T, <pos(r), cart(i), pos(r),  c> );
                Append( ~T, <neg(r), cart(i), neg(r), -c> );
                Append( ~T, <cart(i), pos(r), pos(r), -c> );
                Append( ~T, <cart(i), neg(r), neg(r),  c> );
            end if;
        end for;
    end for;

    return T, 2*N + d;
end intrinsic;




/*
**  Hall polys -- direct computation
** 
*/ 

// ASSUME THIS IS ONLY CALLED WITH SPARSE ROOT DATA
collectionOrderSprs := function(R)
    X := R`Type[1][1];
    n := Rank(R);
    N := NumPosRoots(R);

    case X:
    when "A":
        ord := [ [ j eq 1 select i else Self(j-1)+n-j+2 : j in [1..n-i+1]] : i in [1..n] ];
    when "B", "C":
        lens := [n] cat &cat [ [i,i] : i in [n-1..1 by -1] ];
        diags := [[Integers()|]];
        done := 0;
        for d in [1..2*n-1] do;
            last := done+lens[d];
            diags[d] := [done+1..last];
            done := last;
        end for;
        ord := [ [ d[i] : d in diags[[1..2*(n-i)+1]] ] : i in [1..n] ];
    when "D":
        r := 1;
        ord := [ [Integers()|] : i in [1..2*(n-1) div 2 ] ];
        for row in [1..2*(n-1)],
            col in [1..n - row div 2] do
            
            rc2 := row+col-2;
 
            if col - rc2 div (n-1) gt 0 then
                 ord[col - rc2 div (n-1)]
                    [row + rc2 div (n-1)] := r;
                 r +:= 1;
            end if;
        end for;
    else
        error "collectionOrderSprs for type",X,"not yet implemented";
    end case;
    
    return &cat ord;
end function;

hallPolysSprs := function(R,K,a,b)
    X := R`Type[1][1];
    n := Rank(R);
    N := NumPosRoots(R);

    case X:
    when "A":
        return // multiplication hall polys
               [ a[r] + b[r] +
                 &+[K| // LieConstant_epsilon(R,[...])
                         b[InternalGrpLiePair2Index(X,n,<i,k>,N)]
                       * a[InternalGrpLiePair2Index(X,n,<k,j>,N)] : k in [i+1..j-1] ]
                 where i,j is Explode(InternalGrpLieIndex2Pair(X,n,r,N))
               : r in [1..N] ],
               // inverse hall polys
               [ -a[r] -
                     &+[K|   d[InternalGrpLiePair2Index(X,n,<i,k>,N)]
                           * a[InternalGrpLiePair2Index(X,n,<k,j>,N)] : k in [i+1..j-1] ]
                     where d is Self()
                     where i,j is Explode(InternalGrpLieIndex2Pair(X,n,r,N))
               : r in [1..N] ];
    when "B":
        app := [ // a''
                 -(        a[InternalGrpLiePair2Index(X,n,<i, 0>,N)]^2
                   + &+[K| a[InternalGrpLiePair2Index(X,n,<i, k>,N)]*
                           a[InternalGrpLiePair2Index(X,n,<i,-k>,N)]  : k in [i+1..n]]
                  ) 
                : i in [1..n]];
        
        ap  := [ // a'
                -(j eq 0 
                 select   a[r]
                        + &+[K| a [InternalGrpLiePair2Index(X,n,< i, k>,N)]*
                                ap[InternalGrpLiePair2Index(X,n,< k, 0>,N)]  : k in [i+1..n]]
                 else j gt 0
                 select   a[r]
                        + &+[K| a [InternalGrpLiePair2Index(X,n,< i, k>,N)]*
                                ap[InternalGrpLiePair2Index(X,n,< k, j>,N)]  : k in [i+1..j-1]]
                 else     a[r]
                        + a  [InternalGrpLiePair2Index(X,n,<i,-j>,N)]*
                          app[-j]
                        +    2* a [InternalGrpLiePair2Index(X,n,< i, 0>,N)]*
                                a [InternalGrpLiePair2Index(X,n,<-j, 0>,N)]
                        + &+[K| a [InternalGrpLiePair2Index(X,n,< i, k>,N)]*
                                a [InternalGrpLiePair2Index(X,n,<-j,-k>,N)]  : k in [-j+1..n]cat[-n..j-1]]
                        + &+[K| a [InternalGrpLiePair2Index(X,n,< i, k>,N)]*
                                ap[InternalGrpLiePair2Index(X,n,< k, j>,N)]  : k in [i+1..-j-1]]
                 )
                 where ap is Self()
                 where i,j is Explode(InternalGrpLieIndex2Pair(X,n,r,N))
               : r in [1..N] ];

        return // multiplication hall polys
               [
                 (j eq 0
                 select   a[r] + b[r]
                        + &+[K| b [InternalGrpLiePair2Index(X,n,< i, k>,N)]*
                                a [InternalGrpLiePair2Index(X,n,< k, 0>,N)] : k in [i+1..n] ]
                 else j gt 0 
                 select   a[r] + b[r]
                        + &+[K| b [InternalGrpLiePair2Index(X,n,< i, k>,N)]*
                                a [InternalGrpLiePair2Index(X,n,< k, j>,N)] : k in [i+1..j-1] ]
                 else     a[r] + b[r] 
                        + app[-j]*b[InternalGrpLiePair2Index(X,n,<i,-j>,N)]
                        + &+[K| b [InternalGrpLiePair2Index(X,n,< i, k>,N)]*
                                a [InternalGrpLiePair2Index(X,n,< k, j>,N)] : k in [i+1..-j-1] ]
                        +    2* b [InternalGrpLiePair2Index(X,n,< i, 0>,N)]*
                                ap[InternalGrpLiePair2Index(X,n,<-j, 0>,N)] 
                        + &+[K| b [InternalGrpLiePair2Index(X,n,< i, k>,N)]*
                                ap[InternalGrpLiePair2Index(X,n,<-j,-k>,N)] : k in [-j+1..n]cat[-n..j-1] ]
                 )  
                 where i,j is Explode(InternalGrpLieIndex2Pair(X,n,r,N))
               : r in [1..N] ],
               // inverse hall polys
               [ 
                -(j eq 0
                 select  a[r]
                       + &+[K| d[InternalGrpLiePair2Index(X,n,<i,k>,N)]*
                               a[InternalGrpLiePair2Index(X,n,<k,0>,N)] : k in [i+1..n] ]
                 else j gt 0 
                 select  a[r] 
                       + &+[K| d[InternalGrpLiePair2Index(X,n,<i,k>,N)]*
                               a[InternalGrpLiePair2Index(X,n,<k,j>,N)] : k in [i+1..j-1] ]
                 else    a[r]
                       + app[-j]*d[InternalGrpLiePair2Index(X,n,<i,-j>,N)]
                       + &+[K| d [InternalGrpLiePair2Index(X,n,< i, k>,N)]*
                               a [InternalGrpLiePair2Index(X,n,< k, j>,N)] : k in [i+1..-j-1] ]
                       +    2* d [InternalGrpLiePair2Index(X,n,< i, 0>,N)]*
                               ap[InternalGrpLiePair2Index(X,n,<-j, 0>,N)] 
                       + &+[K| d [InternalGrpLiePair2Index(X,n,< i, k>,N)]*
                               ap[InternalGrpLiePair2Index(X,n,<-j,-k>,N)] : k in [-j+1..n]cat[-n..j-1] ]
                 )
                 where d is Self()
                 where i,j is Explode(InternalGrpLieIndex2Pair(X,n,r,N))
               : r in [1..N] ];
    when "C":
        app := [ // a''
                       a[InternalGrpLiePair2Index(X,n,<i,-i>,N)]-
                 &+[K| a[InternalGrpLiePair2Index(X,n,<i, k>,N)]*
                       a[InternalGrpLiePair2Index(X,n,<i,-k>,N)]  : k in [i+1..n]]
                : i in [1..n]];
        
        bpp := [ // b''
                       b[InternalGrpLiePair2Index(X,n,<i,-i>,N)]-
                 &+[K| b[InternalGrpLiePair2Index(X,n,<i, k>,N)]*
                       b[InternalGrpLiePair2Index(X,n,<i,-k>,N)]  : k in [i+1..n]]
                : i in [1..n]];
        
        ap  := [ // a'
                 j eq -i 
                 select 0 // should never be needed !!!
                 else j gt 0
                 select - a[r]
                        - &+[K| a [InternalGrpLiePair2Index(X,n,< i, k>,N)]*
                                ap[InternalGrpLiePair2Index(X,n,< k, j>,N)]  : k in [i+1..j-1]]
                 else     a[r]
                        - a  [InternalGrpLiePair2Index(X,n,<i,-j>,N)]*
                          app[-j]
                        - &+[K| a [InternalGrpLiePair2Index(X,n,< i, k>,N)]*
                                a [InternalGrpLiePair2Index(X,n,<-j,-k>,N)]  : k in [-j+1..n] ] 
                        + &+[K| a [InternalGrpLiePair2Index(X,n,< i, k>,N)]*
                                a [InternalGrpLiePair2Index(X,n,<-j,-k>,N)]  : k in [-n..j-1] ]
                        - &+[K| a [InternalGrpLiePair2Index(X,n,< i, k>,N)]*
                                ap[InternalGrpLiePair2Index(X,n,< k, j>,N)]  : k in [i+1..-j-1]]
                 where ap is Self()
                 where i,j is Explode(InternalGrpLieIndex2Pair(X,n,r,N))
               : r in [1..N] ];

        // as long as we are debugging, we want to ensure we don't touch the a'_{i\ibar}
        for i in [1..n] do
            r := InternalGrpLiePair2Index(X,n,<i,-i>,N);
            assert ap[r] eq 0;
            Undefine(~ap, r);
        end for;

        return // multiplication hall polys
               [
                 (j eq -i
                 select   app[i] + bpp[i]
                        + &+[K| b [InternalGrpLiePair2Index(X,n,< i, k>,N)]*
                                ap[InternalGrpLiePair2Index(X,n,< i,-k>,N)] : k in [i+1..n]cat[-n..-i-1] ]
                        + &+[K| c [InternalGrpLiePair2Index(X,n,< i, k>,N)]*
                                c [InternalGrpLiePair2Index(X,n,< i,-k>,N)] : k in [i+1..n]] 
                 else j gt 0 
                 select   a[r] + b[r]
                        + &+[K| b [InternalGrpLiePair2Index(X,n,< i, k>,N)]*
                                a [InternalGrpLiePair2Index(X,n,< k, j>,N)] : k in [i+1..j-1] ]
                 else     a[r] + b[r] 
                        + app[-j]*b[InternalGrpLiePair2Index(X,n,<i,-j>,N)]
                        + &+[K| b [InternalGrpLiePair2Index(X,n,< i, k>,N)]*
                                a [InternalGrpLiePair2Index(X,n,< k, j>,N)] : k in [i+1..-j-1] ]
                        + &+[K| b [InternalGrpLiePair2Index(X,n,< i, k>,N)]*
                                ap[InternalGrpLiePair2Index(X,n,<-j,-k>,N)] : k in [-j+1..n]cat[-n..j-1] ]
                 )  
                 where c is Self()
                 where i,j is Explode(InternalGrpLieIndex2Pair(X,n,r,N))
               : r in [1..N] ],
               // inverse hall polys
               [ 
                -(j eq -i
                 select   app[i]
                        + &+[K| d [InternalGrpLiePair2Index(X,n,< i, k>,N)]*
                                ap[InternalGrpLiePair2Index(X,n,< i,-k>,N)] : k in [i+1..n]cat[-n..-i-1] ]
                        - &+[K| d [InternalGrpLiePair2Index(X,n,< i, k>,N)]*
                                d [InternalGrpLiePair2Index(X,n,< i,-k>,N)] : k in [i+1..n]] 
                 else j gt 0 
                 select   a[r] 
                        + &+[K| d [InternalGrpLiePair2Index(X,n,< i, k>,N)]*
                                a [InternalGrpLiePair2Index(X,n,< k, j>,N)] : k in [i+1..j-1] ]
                 else     a[r]
                        + app[-j]*d[InternalGrpLiePair2Index(X,n,<i,-j>,N)]
                        + &+[K| d [InternalGrpLiePair2Index(X,n,< i, k>,N)]*
                                a [InternalGrpLiePair2Index(X,n,< k, j>,N)] : k in [i+1..-j-1] ]
                        + &+[K| d [InternalGrpLiePair2Index(X,n,< i, k>,N)]*
                                ap[InternalGrpLiePair2Index(X,n,<-j,-k>,N)] : k in [-j+1..n]cat[-n..j-1] ]
                 )
                 where d is Self()
                 where i,j is Explode(InternalGrpLieIndex2Pair(X,n,r,N))
               : r in [1..N] ];
    when "D":
        app := [ // a''
                 - &+[K| a[InternalGrpLiePair2Index(X,n,<i, k>,N)]*
                         a[InternalGrpLiePair2Index(X,n,<i,-k>,N)]  : k in [i+1..n]] 
                : i in [1..n]];
        
        ap  := [ // a'
                -(j gt 0 
                 select   a[r]
                        + &+[K| a [InternalGrpLiePair2Index(X,n,< i, k>,N)]*
                                ap[InternalGrpLiePair2Index(X,n,< k, j>,N)]  : k in [i+1..j-1]]
                 else     a[r]
                        + a  [InternalGrpLiePair2Index(X,n,<i,-j>,N)]*
                          app[-j]
                        + &+[K| a [InternalGrpLiePair2Index(X,n,< i, k>,N)]*
                                a [InternalGrpLiePair2Index(X,n,<-j,-k>,N)]  : k in [-j+1..n]cat[-n..j-1]]
                        + &+[K| a [InternalGrpLiePair2Index(X,n,< i, k>,N)]*
                                ap[InternalGrpLiePair2Index(X,n,< k, j>,N)]  : k in [i+1..-j-1]]
                 )
                 where ap is Self()
                 where i,j is Explode(InternalGrpLieIndex2Pair(X,n,r,N))
               : r in [1..N] ];

        return // multiplication hall polys
               [
                 (j gt 0 
                 select   a[r] + b[r]
                        + &+[K| b [InternalGrpLiePair2Index(X,n,< i, k>,N)]*
                                a [InternalGrpLiePair2Index(X,n,< k, j>,N)] : k in [i+1..j-1] ]
                 else     a[r] + b[r] 
                        + app[-j]*b[InternalGrpLiePair2Index(X,n,<i,-j>,N)]
                        + &+[K| b [InternalGrpLiePair2Index(X,n,< i, k>,N)]*
                                a [InternalGrpLiePair2Index(X,n,< k, j>,N)] : k in [i+1..-j-1] ]
                        + &+[K| b [InternalGrpLiePair2Index(X,n,< i, k>,N)]*
                                ap[InternalGrpLiePair2Index(X,n,<-j,-k>,N)] : k in [-j+1..n]cat[-n..j-1] ]
                 )  
                 where i,j is Explode(InternalGrpLieIndex2Pair(X,n,r,N))
               : r in [1..N] ],
               // inverse hall polys
               [ 
                -(j gt 0 
                 select  a[r] 
                       + &+[K| d[InternalGrpLiePair2Index(X,n,<i,k>,N)]*
                               a[InternalGrpLiePair2Index(X,n,<k,j>,N)] : k in [i+1..j-1] ]
                 else    a[r]
                       + app[-j]*d[InternalGrpLiePair2Index(X,n,<i,-j>,N)]
                       + &+[K| d [InternalGrpLiePair2Index(X,n,< i, k>,N)]*
                               a [InternalGrpLiePair2Index(X,n,< k, j>,N)] : k in [i+1..-j-1] ]
                       + &+[K| d [InternalGrpLiePair2Index(X,n,< i, k>,N)]*
                               ap[InternalGrpLiePair2Index(X,n,<-j,-k>,N)] : k in [-j+1..n]cat[-n..j-1] ]
                 )
                 where d is Self()
                 where i,j is Explode(InternalGrpLieIndex2Pair(X,n,r,N))
               : r in [1..N] ];
    else
        error "hallPolysSprs for type",X,"not yet implemented";
    end case;
    
end function;















