freeze;

import "Reduce.m" : InduceAut, GetX;

/* 
  <example>
    SetIsClaus(false);
    G := PGL(3, 4);
    X := CharacterTable(G);
    R := RepresentationOfCharacter(G, X[5]);
    Attach("/home/claus/Magma/Grp/Integral.m");
    L1 := [R(G.i) : i in [1..Ngens(G)]];
    time L2 := [x^-1 : x in L1];
    SetInterrupt(false);
    IntegralMakeIntegral(L1:Inv := L2);
    
    K := BaseRing(Codomain(R));
    V := RModule(K, 20);
    b := [V.i : i in [1..20]];
    time M := ([b[i]*x where x := R(Random(G)) : i in [1..20], j in [1..5]]);
    MF := SteinitzForm(MM);

  </example>  
*/

intrinsic Content(M::ModDed:UseBasis := false) -> RngOrdFracIdl
  {Computes the "content" of the module, ie the ideal generated by the matrix and the coeff. ideals.}
  if UseBasis then  
    p := PseudoBasis(M);  
  else
    p := PseudoGenerators(M);  
  end if;

  N := Order(p[1][1]);
  c := &+ [ x[1] * ideal<N|Eltseq(x[2])> : x in p];
  return c;
end intrinsic;

intrinsic Simplify(M::ModDed:UseBasis := false) -> ModDed
  {Simplify M by pulling out the contents.}
  p1 := PseudoGenerators(M);
  p2 := PseudoBasis(M);
  c := Content(M:UseBasis := UseBasis);
  ci := c^-1;

  if p1 eq p2 then
    return Module([< x[1]*ci, x[2]> : x in p1]);
  elif UseBasis then
    return Module([< x[1]*ci, x[2]> : x in p2]);
  else
    return Module([< x[1]*ci, x[2]> : x in p1]);
  end if;
end intrinsic;

intrinsic SteinitzForm(P::PMat) -> PMat, Mtrx
  {The Steinitz (almost free) form of P}
  D := Module(P);
  S := SteinitzForm(D);
  Q := PseudoMatrix(S:Generators);
  fl, T := IsConsistent(Matrix(P), Matrix(Q));
  assert fl;
  return Q, T;
end intrinsic;

intrinsic SteinitzClass(P::PMat) -> PMat, Mtrx
  {The Steinitz class of P}
  return &* CoefficientIdeals(P);
end intrinsic;



intrinsic InternalMakeIntegral(L::[Mtrx]:Inv := false, Step := -1, St := false, Id_in := false) -> []
{}
  
  if Inv cmpeq false then
    Li := [ x^-1 : x in L];
    Inv := Li;
  else
    Li := Inv;
  end if;

  K := BaseRing(L[1]);
  M := MaximalOrder(K);
  FM := FieldOfFractions(M);
  n := Ncols(L[1]);
  V := RSpace(K, n);
  W := RSpace(FM, n);

  L := L cat Li;

  T := IdentityMatrix(K, n);
  Ti := T;
  if Id_in cmpne false then
    mo := [<Id_in[i], V.i> : i in [1..n]];
  else
    mo := [<1*M, V.i> : i in [1..n]];
  end if;
  if n gt 10 then
    u := 2;
  else
    u := 3;
  end if;

  while Step ne 0 do
    Step -:= 1;

    new := 1;
    for j in [1..u] do
      X := IdentityMatrix(K, n);
      for i in [1..4] do
        X := X*Random(L);
        Append(~L, X);
      end for;
      for i in [1..n] do
        if #mo gt u*n and new gt 5 then
          break;
        end if;
        Append(~mo, <1*M,
                     &+[mo[j][2] * Random(mo[j][1], 5) : j in [1..#mo]] * X>);
        new +:=1;             
      end for;
      if #mo gt u*n then
        break;
      end if;
    end for;

    vprint LLL, 2: "Module";
    mmo := [<x[1], W!x[2]> : x in mo];
    vtime LLL, 2: Mo := Module(mmo);
    p := PseudoBasis(Mo);
    // check if Mo is G-invariant, ie. Mo*g in Mo for all g
    // it's sufficient to check for all generators.
    mo := [];
    for j in [1..#Li] do
      for k in p do
        N := Module([<k[1], W!((V!k[2])*L[j])>]);
        if not IsSubmodule(N, Mo) then
          Append(~mo, k);
        else
          assert Random(k[1], 2)*(W!((V!k[2])*L[j])) in Mo;
        end if;
      end for;
    end for;
    vprint LLL, 1: "Check done, using ", #mo, "new generators";
    if Type(M) in {RngOrd, RngCyc} then
      C, mC := ClassGroup(M:Proof := "Current");
    else
      C, mC := ClassGroup(M);
    end if;
    vprint LLL, 1: "Normalize";
    if #C eq 1 then
      p := PseudoBasis(Mo);
      p := [<1*M, f*x[2]> where _, f := IsPrincipal(x[1]) : x in p];
      ma := Matrix([x[2] : x in p]);
    else
      if St then
        vprint LLL, 2: "Steinitz";
        vtime LLL, 2: Mos := SteinitzForm(Mo);
        p := PseudoGenerators(Mos);
        id := p[n][1];
        id, f := ClassRepresentative(id);
        p[n][2] := p[n][2] / f;
        p[n][1] := p[n][1] * f;
      else
        p := PseudoBasis(Mo);
      end if;
      ma := Matrix([x[2] : x in p]);
    end if;
    ma := Matrix(K, ma);
    old_p := p;
    p := [<p[i][1], e[i]> : i in [1..#p]] where e := IdentityMatrix(K, n);
    assert forall{x : x in [1..n] | p[x][2]*ma eq old_p[x][2]};
    vprint LLL, 1: "inv";
    mai := ma^-1;
    T := ma*T;
    Ti := Ti * mai;
    vprint LLL, 1: "Conju";
    L := [ ma*x*mai : x in L];
    if #mo eq 0 then
      mo := p;
      break;
    end if;
    mo := [<x[1], (V!x[2])*mai>: x in mo];
    mo cat:=p;
  end while;
  assert #mo ne 0;


  Mo := Module([<x[1], W!x[2]> : x in mo]);
  if false and GetAssertions() then
    assert PseudoBasis(Mo) eq mo;
    p := mo;
    assert #mo eq n;
    for j in [1..#Li] do
      for k in p do
        N := Module([<k[1], W!((V!k[2])*L[j])>]);
        assert IsSubmodule(N, Mo);
        assert Random(k[1], 2)*(W!((V!k[2])*L[j])) in Mo;
      end for;
    end for;
  end if;

  return T, Ti, Mo, L;
end intrinsic;

//

declare verbose IntegralGModule, 3;
declare verbose IntegralEquivalence, 3;


/*
  <example>

G := TransitiveGroup(8, 5);
T := CharacterTable(G);
R := GModule(T[5]);
S := WriteGModuleOver(R, NumberField(x^2+35)); //example from Weiss, Cliff, 
SetVerbose("IntegralGModule", 2);
SS := Nice(S);
s := SubmoduleClasses(SS); // => works


S := WriteGModuleOver(R, NumberField(x^2+21)); //larger number of classes
s := SubmoduleClasses(S);

</example>
*/


intrinsic IsFree(L::PMat) -> BoolElt
  {Tests if L represents a free module, ie. all coeff. ideals are the same}
  I := CoefficientIdeals(L);
  return forall{x : x in I | x eq I[1]};
end intrinsic;

intrinsic RepresentsFreeModule(L::PMat) -> BoolElt, PMat, Mtrx
  {Tests if the module represented by L is free}
  I := CoefficientIdeals(L);
  if not IsPrincipal(&*I) then
    return false, _, _;
  end if;
  repeat
    A, T := SteinitzForm(L);
  until true or Module(A) eq Module(L);
  //assert Module(A) eq Module(L);
  //assert Determinant(A) eq Determinant(L);
  I := CoefficientIdeals(A);
  fl, g := IsPrincipal(I[#I]);
  assert fl;
  //assert IsOne(I[#I]/g);
  //assert forall{x : x in I[1..#I-1] | IsOne(x)};
  t := DiagonalMatrix([1 : i in [1..#I-1]] cat [g]);
  B := PseudoMatrix(t*Matrix(A));
  return true, B, t*T;
end intrinsic;

intrinsic CanMakeIntegral(L::ModGrp) -> BoolElt, ModGrp
  {Returns true and an integral module, integrally equivalent to L if possible}
  if forall{x : x in ActionGenerators(L) | forall{y : y in Eltseq(x) | IsIntegral(y)}} then
    return true, L;
  end if;
  fl := IsAlmostIntegral(L);
  assert fl;
  P := L`PMat;
  assert not IsFree(P);
  fl, N, T := RepresentsFreeModule(P);
  if not fl then
    return false, _;
  end if;
  //assert T*Matrix(P) eq Matrix(N);
  //assert Module(N) eq Module(P);
  T := Matrix(CoefficientRing(L), Matrix(N));
  Ti := T^-1;
  //assert OrbitSum(L, P) eq P;
  //assert OrbitSum(L, N) eq HermiteForm(N);
  M := GModule(Group(L), [T*x*Ti : x in ActionGenerators(L)]);
  return true, M;
end intrinsic;

intrinsic CanReallyMakeIntegral(L::ModGrp:GroupOrder := false) -> BoolElt, ModGrp
  {Returns true and an integral module, fractional equivalent to L if possible}
  if forall{x : x in ActionGenerators(L) | forall{y : y in Eltseq(x) | IsIntegral(y)}} then
    return true, L;
  end if;
  fl := IsAlmostIntegral(L);
  assert fl;
  P := L`PMat;
  assert not IsFree(P);
  fl, N, T := RepresentsFreeModule(P);
  if not fl then
    l := SubmoduleClasses(L:Filter := func<x|IsFree(x`PMat)>, MaxFound := 1, 
                            GroupOrder := GroupOrder);
    for i in l do
      a,b := CanMakeIntegral(i);
      if a then
        return a,b;
      end if;
    end for;
    return false, _;
  end if;
  T := Matrix(CoefficientRing(L), Matrix(N));
  Ti := T^-1;
  M := GModule(Group(L), [T*x*Ti : x in ActionGenerators(L)]);
  return true, M;
end intrinsic;

intrinsic IsIntegral(L::ModGrp) -> BoolElt
  {Returns true if all the action generator matrices are integral.}
  if assigned L`PMat then
    return forall{x : x in ActionGenerators(L) | forall{y : y in Eltseq(x) | IsIntegral(y)}};
  end if;
  n := Nrows(ActionGenerators(L)[1]);
  M := IdentityMatrix(CoefficientRing(L), n);
  M := PseudoMatrix([1*m : i in [1..n]], M) where m := MaximalOrder(CoefficientRing(L));
  P := OrbitSum(L, M);
  if M eq P then
    L`PMat := M;
    return true;
  end if;
  return false;
end intrinsic;

intrinsic IsAlmostIntegral(L::ModGrp) -> BoolElt
  {Checks that there is some module invariant under the action}
    
  if assigned L`PMat then
    return true;
  end if;
  n := Nrows(ActionGenerators(L)[1]);
  M := IdentityMatrix(CoefficientRing(L), n);
  M := PseudoMatrix([1*m : i in [1..n]], M) where m := MaximalOrder(CoefficientRing(L));
  L`PMat := OrbitSum(L, M);
  return true;
end intrinsic;

intrinsic IsEquivalent(L::ModGrp, R::ModGrp) -> BoolElt, Mtrx
  {Tests if the two (almost) integral modules are equivalent}
  require IsAlmostIntegral(L): "Both modules need to be almost integral";
  require IsAlmostIntegral(R): "Both modules need to be almost integral";

  vprint IntegralEquivalence, 1: "Testing integral equivalence (O_K[G]-module)";
  //Step 1: find out if they are field equivalent:
//  "calling ahom";
//  time X := Matrix(AHom(L, R).1);
  X := GetX(ActionGenerators(L), ActionGenerators(R));
  if X cmpeq false then
    vprint IntegralEquivalence, 2: "modules are not K[G] equivalent";
    return false, _;
  end if;
  assert forall{x : x in [1..#ActionGenerators(L)] | ActionGenerators(L)[x]*X eq X*ActionGenerators(R)[x]};
  //Step 2: X is only unique modulo scalars. For things to be
  //equivalent, the PMats need to be mapped as well, this means
  //lambda X_i,j in a_j/b_i for all i, j, thus
  //lambda in meet a_j/b_i /X_i,j
  //
  //and
  //det(L) *Det(X*lambda) = Det(R)
  //thus lambda^n = Det(Mat(R))/Det(Mat(L)/Det(X) * prod Ideals(R)/Ideals(L)
  //so the RHS needs to be principal - and needs to have a generators that is
  //an n-th power. (So we compute the ideal of the RHS, extract the n-th root
  //and do a principal test)

  PR := R`PMat;
  PL := L`PMat;

  n := Nrows(Matrix(PR));

  a := Determinant(Matrix(PR))/Determinant(Matrix(PL))/Determinant(X) *
               &* CoefficientIdeals(PR)/&* CoefficientIdeals(PL);
  b := a;             
  f, a := IsPower(a, n);             
  if not f then
    vprint IntegralEquivalence, 2: "Index ideal no", n, "-th power";
    return false, _;
  end if;
  assert a^n eq b;
  f, l := IsPrincipal(a);
  if not f then
    vprint IntegralEquivalence, 2: "Index ideal not principal";
    return false, _;
  end if;
  assert l*Order(a) eq a;
  assert #z eq #y and forall{x : x in z | x in y} where z := Factorization(l*Order(a)) where y := Factorization(a);

  Y := Matrix(PL)*l*X*Matrix(PR)^-1;
  iL := [x^-1 : x in CoefficientIdeals(PL)];
  iR := CoefficientIdeals(PR);
  if forall{i : i in car<[1..n], [1..n]> | Y[i[1]][i[2]] in iR[i[2]]*iL[i[1]]}
  then
    vprint IntegralEquivalence, 2: "modules are O_K[G]-equivalent";
    return true, X;
  else
    vprint IntegralEquivalence, 2: "Map defines no module morphism";
    return false, _;
  end if;
end intrinsic;

intrinsic pMaximalSubmodules(L::ModGrp, p::RngOrdIdl:Classes := false) -> []
  {Uses Plesken's centering method to find maximal submodules of index a p-power}
  _ := IsAlmostIntegral(L);
  iL := CoefficientIdeals(L`PMat);
  M := Order(iL[1]);
  lp := [x[1] : x in Decomposition(M, Minimum(p))];
  vi := [Valuation(x, p) : x in iL];
  FM := FieldOfFractions(M);

  vprint IntegralGModule, 1: "Looking for", p, "maximal submodules";

  // we have L`PMat as the 1st module, scaling by D changes the basis of
  // L`PMat to be identity and makes the coeff. ideals p-free
  // The modules should map like e_i -> Matrix(L`PMat)[i]
  // which means the action generators should map to D x D^-1
  // Now, since the new modulus is p-free, L/pL is easy: basis is the
  // standard basis e_i, action generators are just mapped to residue
  // class field.
  //
  // Again: given (A, alpha)
  // 1) make A p-free: find x s.th. v_q(x) = v_q(A) for all q | Min(p)
  //    and set A -> A/x, alpha -> alpha*x
  // 2) make A integral (and maintain p-free):
  //    find x s.th. x = 1 mod Min(p) and x = 0 mod C
  //    for A = C/B with C, B integral, coprime
  //    and set A -> A*x, alpha -> alpha/x
  // 3) find x s.th. x = 1 (p), x = pi_A (A^2)
  //    then A/pA = R/pR = F_p with -> using just residue map and 
  //    <- being multiplication by x.
  
  I := 1*M;
  pZ := Minimum(p)*M;

  D1 := DiagonalMatrix(FM, [WeakApproximation(lp, [Valuation(x, y) : y in lp]) : x in iL]);
  D2 := DiagonalMatrix(FM, [CRT(pZ, M!!(GCD(I, iL[x]/D1[x][x])^-1), M!1, M!0) : x in [1..#iL]]);
  D3 := DiagonalMatrix(FM, [CRT(p, A^2, M!1, b where _, b := TwoElementNormal(A))
      where A := M!!(iL[x]/D1[x][x]*D2[x][x]) : x in [1..#iL]]);
  M := Matrix(L`PMat);    
  D := D2^-1*D1*M;
  Di := D^-1;
  pL := GModule(Group(L), [Evaluate(D*x*Di, p) : x in ActionGenerators(L)]);
  C := CompositionFactors(pL);
  vprint IntegralGModule, 1: "composition factors are", C;
  F, pF := ResidueClassField(p);
  assert CoefficientRing(pL) eq F;
  res := [];
  all_k := {};
  all_P := {};
  for c in C do
    vprint IntegralGModule, 2: "finding all morphisms...";
    h := GHom(pL, c); // loop not over all elements!!! factor by scalars...
    for f in h do
      if IsZero(f) then 
        continue;
      end if;
      k := Kernel(f);
      if k in all_k then
        continue;
      end if;
      Include(~all_k, k);
      assert Image(f) eq c;
      if Dimension(k) eq 0 then
        vprint IntegralGModule, 2: "multiplication by p submodule";
        P := p*L`PMat;
      else
        vprint IntegralGModule, 2: "lifting basis of kernel";
        b := [pL!x : x in Basis(k)];
        P := VerticalJoin(
               PseudoMatrix(Matrix(FM, [[x@@pF : x in Eltseq(y)] : y in b])*D3*D),
               p*L`PMat);
        P := HermiteForm(P);       
        assert P eq OrbitSum(L, P);
        assert #f eq 1 and f[1][1] eq p 
                where f := Factorization(Determinant(P)/Determinant(L`PMat));
      end if;
      if Classes and P in all_P then
        continue;
      end if;
      Include(~all_P, P);
      R := GModule(Group(L), ActionGenerators(L));
      R`PMat := P;
      if Classes and exists{x : x in res | IsEquivalent(x, R)} then
        continue;
      end if;
      if assigned L`Character then
        R`Character := L`Character;
      end if;
      if assigned L`InvForm then
        R`InvForm := L`InvForm;
      end if;
      Append(~res, R);
    end for;
  end for;
  return res, pL;
end intrinsic;

_ClassGroup := ClassGroup;
intrinsic SubmoduleClasses(L::ModGrp: ClassGroup := true, Filter := false, MaxFound := Infinity(), GroupOrder := false) -> []
  {Using Plesken's centering method, finds all non-equivalent submodules}

  /* The THEORY - as I understand it. 
Let L be a G-Module and N be any other G-Module. Then, since
the vectorspace generated by the PMat is the same, there is 
some lambda such that lambda*N subset L.
So, lambda*N < L. Now we build any chain of maximal submodules down from 
  L to lambda*N
And we fix a set S or prime ideals generating the class group.
  
Looking at 2 terms in this chain, ie. a module A and a maximal submodule B.
Then the index (A:B) has to be a power of some prime ideal p.
Also, we have A > B > pA 
If p is coprime to the group order, then B has to be pA since the
underlying representation stays irreducible. In this case, find an ideal
q in <S> and l_q in K such that p = l_q*q. Then
B = pA = l_q q A which is equivalent to q A (since l_q is a scalar)

So modifying the chain this way we get a (equivalent) chain where the
indices are either in S or related to the group order.

Now if we have a chain A > pA > B, then we also have A > p^-1 B > B (since
pA/B is equivalent to A/p^-1 B), so we can assume that all modules are
represented by s.th that has submodules from the group order on top, and
class group generators underneath.
*/  
   
  vprint IntegralGModule, 1: "Finding (all) submodules of", L;
  M := MaximalOrder(CoefficientRing(L));
  if GroupOrder cmpeq false then
    GroupOrder := Order(Group(L));
  end if;
  lp := SetToSequence(Support(GroupOrder*M));
  vprint IntegralGModule, 1: "need to consider", #lp, "primes";
  _ := IsAlmostIntegral(L);

  res := [Parent(L)|];
  if Filter cmpne false and Filter(L) then
    res := [L];
  else
    res := [L];
  end if;
  if #res ge MaxFound then 
    return res;
  end if;

  nw := [L];
  pm := {L`PMat};
  repeat
    vprint IntegralGModule, 2: "have", #nw, 
      "modules to look for submodules, found a total of", #res, "so far";
    S := &cat [&cat [pMaximalSubmodules(x,p) : p in lp] : x in nw];
    vprint IntegralGModule, 2: "found", #S, "new ones";
    nw := [];
    for s in S do
      if s`PMat in pm then
        vprint IntegralGModule, 3: "same underlying module";
        continue;
      end if;
      if exists{x : x in res | IsEquivalent(s, x)} then
        vprint IntegralGModule, 3: "modules was equivalent";
        Include(~pm, s`PMat);
        continue;
      end if;
      vprint IntegralGModule, 3: "new module found";
      if Filter cmpne false and Filter(s) then
        Append(~res, s);
      else
        Append(~res, s);
      end if;
      if #res ge MaxFound then
        return res;
      end if;
      Append(~nw, s);
      Include(~pm, s`PMat);
    end for;
  until #nw eq 0;
  vprint IntegralGModule, 1: "found", #res, "submodules";
  if ClassGroup then
    vprint IntegralGModule, 1: "adding the class group generators";
    if Type(M) eq RngQuad then
      C, mC := _ClassGroup(M);
    else
      C, mC := _ClassGroup(M:Bound := 25*Degree(M));
    end if;
    U := sub<C|[x @@ mC : x in lp]>;
    aP := [];
    p := 1; 
    while U ne C do
      repeat
        p := NextPrime(p);
      until not p in lp;
      P := Decomposition(M, p);
      for x in P do
        y := x[1] @@ mC;
        if not y in U then
          Append(~aP, x[1]);
          U := sub<C|U, y>;
          if U eq C then
            break;
          end if;
        end if;
      end for;
    end while;
    vprint IntegralGModule, 2: "need to look at ", #aP, "new prime ideals";
    nw := res;
    function Mult(p, x)
      X := GModule(Group(x), ActionGenerators(x));
      if assigned x`InvForm then
        X`InvForm := x`InvForm;
      end if;
      X`PMat := p*x`PMat;
      return X;
    end function;

    repeat
      S := [Mult(p, x) : x in res, p in aP];
      nw := [];
      for s in S do
        if exists{x : x in res | IsEquivalent(s, x)} then
          continue;
        else
          if Filter cmpne false and Filter(s) then
            Append(~res, s);
          else
            Append(~res, s);
          end if;
          if #res ge MaxFound then
            return res;
          end if;
          Append(~nw, s);
        end if;
      end for;
    until #nw eq 0;
    vprint IntegralGModule, 1: "Finally returning", #res, "classes";
  end if;
  return res;
end intrinsic;


intrinsic OrbitSum(M::ModGrp, L::[]) -> PMat
  {The mimimal module containing L and invariant under M}
  return OrbitSum(M, PseudoMatrix(Matrix(L)));
end intrinsic;

intrinsic OrbitSum(M::ModGrp, L::Mtrx) -> PMat
  {"} // "
  return OrbitSum(M, PseudoMatrix(Matrix(L)));
end intrinsic;

intrinsic OrbitSum(M::ModGrp, L::PMat) -> PMat
  {"} // "

  require ISA(Type(CoefficientRing(M)), FldAlg):
     "GModule must be over some number field";
  A := ActionGenerators(M);
  A := [Matrix(CoefficientRing(Matrix(L)), a) : a in A];
  N := HermiteForm(L);
  repeat
    M := N;
    L := Matrix(M);
    C := CoefficientIdeals(M);
    for a in A do
      N := VerticalJoin(N, PseudoMatrix(C, L*a));
    end for;
//    "HNF of", Nrows(Matrix(N)), Ncols(Matrix(N));
    N := HermiteForm(N);
  until M eq N;
  return M;
end intrinsic;

