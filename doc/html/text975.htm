<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <link rel='stylesheet' href='help.css' type='text/css'>
  <TITLE>Homomorphisms of Modules</TITLE>
</head>
<body BGCOLOR="#FFFFFF">

 <A  HREF = "text976.htm">[Next]</A><A  HREF = "text974.htm">[Prev]</A> <A  HREF = "text976.htm">[Right]</A> <A  HREF = "text974.htm">[Left]</A> <A  HREF = "text966.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<PRE></PRE><H3><A NAME = "11029">Homomorphisms of Modules</A></H3>

<P>
<P>
<P>
A homomorphism from module M to module N is simply a matrix that
commutes with the action of the algebra on M and N.



<H5>Subsections</H5>
<UL>
<LI> <A  HREF = "text975.htm#11030">Creation</A>
<LI> <A  HREF = "text975.htm#11038">Access Functions</A>
<LI> <A  HREF = "text975.htm#11044">Projective Covers and Resolutions</A>
</UL>
<H4><A NAME = "11030">Creation</A></H4>



<H5><A NAME = "11031">AHom(M, N) : ModAlg, ModAlg -&gt; ModMatFld</A></H5>
<BLOCKQUOTE>
The space of homomorphisms from module M to module N.
</BLOCKQUOTE>
<H5><A NAME = "11032">PHom(M,N) : ModAlg, ModAlg -&gt; ModMatFld</A></H5>
<BLOCKQUOTE>
The space of projective homomorphisms from module M to module N. That is, 
the space of all homomorphisms that factor through a projective module. 
</BLOCKQUOTE>
<H5><A NAME = "11033">ZeroMap(M, N) : ModAlg, ModAlg -&gt; ModMatFld</A></H5>
<BLOCKQUOTE>
The zero homomorphism from module M to module N.
</BLOCKQUOTE>
<H5><A NAME = "11034">LiftHomomorphism(x, n) : ModAlgElt, RngIntElt -&gt; ModMatFldElt</A></H5>
<BLOCKQUOTE>
Given an element  x in a module over a basic algebra and a
natural number n, the function returns the homomorphism from 
the n<sup>th</sup> projective module for the algebra to the module with 
the property that the idempotent e of the projective module maps 
to x * e.
</BLOCKQUOTE>
<H5><A NAME = "11035">LiftHomomorphism(X, N) : SeqEnum[ModAlgElt], SeqEnum[RngIntElt] -&gt; ModMatFldElt</A></H5>
<BLOCKQUOTE>
Given a sequence  X = [x<sub>1</sub>, ..., x<sub>t</sub>] of elements in a module 
M over a basic algebra and a sequence N = [n<sub>1</sub>, ..., n<sub>s</sub>] of 
nonnegative integers, such that n<sub>1</sub> + ... + n<sub>s</sub> = t, the function 
returns the homomorphism P -&gt; M from the projective module 
P = &sum;<sub>j=1</sub><sup>s</sup> P<sub>j</sub><sup>n<sub>i</sub></sup>  to M that takes the idempotent e for
the i<sup>th</sup> summand in P to the element x<sub>i</sub> * e in M. Here P<sub>j</sub>
denotes the j<sup>th</sup> projective module for the algebra.
</BLOCKQUOTE>
<H5><A NAME = "11036">Pushout(M, f1, N1, f2, N2) : ModAlg, ModMatFldElt, ModAlg, ModMatFldElt, ModAlg		-&gt; ModAlg, ModMatFldElt, ModMatFldElt</A></H5>
<BLOCKQUOTE>
The pushout of the diagram 
<P>
vbox(offinterlineskip
halign(hfil()#()hfil&amp;hfil()#()hfil&amp;hfil()#()hfil cr
M &amp; mapright(f<sub>1</sub>) &amp; N<sub>1</sub> cr
mapdown(f<sub>2</sub>) &amp; &amp; cr
N<sub>2</sub> &amp; &amp; cr
))
<P>
The function returns the module L = (N<sub>1</sub> direct-sum N<sub>2</sub>)/{(f<sub>1</sub>(m), - f<sub>2</sub>(m))|m &isin;M} and the homomorphisms g<sub>1</sub>:N<sub>1</sub> -&gt; L and 
g<sub>2</sub>: N<sub>2</sub> -&gt; L such that f<sub>1</sub>g<sub>1</sub> = f<sub>2</sub>g<sub>2</sub>.
</BLOCKQUOTE>
<H5><A NAME = "11037">Pullback(f1, M1, f2, M2, N) : ModAlg, ModMatFldElt, ModAlg, ModMatFldElt, ModAlg		-&gt; ModAlg, ModMatFldElt, ModMatFldElt</A></H5>
<BLOCKQUOTE>
The pullback of the diagram 
<P>
vbox(offinterlineskip
halign(hfil()#()hfil&amp;hfil()#()hfil&amp;hfil()#()hfil cr
 &amp; &amp; M<sub>2</sub> cr
 &amp; &amp; mapdown(f<sub>2</sub>)cr
M<sub>1</sub> &amp; mapright(f<sub>1</sub>) &amp; N cr
))
<P>
The function returns the module L = {(m<sub>1</sub>, m<sub>2</sub>) &isin;M<sub>1</sub> direct-sum M<sub>2</sub> |f<sub>1</sub>(m<sub>1</sub>) = f<sub>2</sub>(m<sub>2</sub>)} and the homomorphisms g<sub>1</sub>:L -&gt; M<sub>1</sub> and 
g<sub>2</sub>: L -&gt; M<sub>2</sub> such that g<sub>1</sub>f<sub>1</sub> = g<sub>2</sub>f<sub>2</sub>.
</BLOCKQUOTE>
<H4><A NAME = "11038">Access Functions</A></H4>



<H5><A NAME = "11039">IsModuleHomomorphism(f) : ModMatFldElt -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if the map f is a homomorphism of modules over the algebra.
</BLOCKQUOTE>
<H5><A NAME = "11040">Domain(f) : ModMatFldElt -&gt; ModAlg</A></H5>
<BLOCKQUOTE>
The domain of f.
</BLOCKQUOTE>
<H5><A NAME = "11041">Codomain(f) : ModMatFldElt -&gt; ModAlg</A></H5>
<BLOCKQUOTE>
The codomain of f.
</BLOCKQUOTE>
<H5><A NAME = "11042">Kernel(f) : ModMatFldElt -&gt; ModAlg,ModMatFldElt</A></H5>
<BLOCKQUOTE>
The kernel of f and the inclusion of the kernel in cs{Domain(f).}
</BLOCKQUOTE>
<H5><A NAME = "11043">Cokernel(f) : ModMatFldElt -&gt; ModAlg,ModMatFldElt</A></H5>
<BLOCKQUOTE>
The cokernel of f and the quotient map from cs{Codomain(f)} onto the 
cokernel.
</BLOCKQUOTE>
<H4><A NAME = "11044">Projective Covers and Resolutions</A></H4>

<P>
<P>
<P>
A projective cover of a module M is a projective module P and a 
surjective homomorphism &phi;:P -&gt; M such that P is 
minimal with respect to the property of having such a surjective 
homomorphism to M. A projective resolution to n steps of an A-module 
M is a pair consisting of a complex 
<P>
P<sub>n</sub> mapright(&part;<sub>n</sub>) P<sub>n - 1</sub> -&gt; ... -&gt; P<sub>1</sub> mapright(&part;<sub>1</sub>) P<sub>0</sub>
<P>
which is exact except at the ends, and an augmentation 
homomorphism &epsilon;: P<sub>0</sub> -&gt; M that is a projective cover of M. In addition, the image
of &part;<sub>1</sub> must equal the kernel of &epsilon;. The resolution is 
minimal if each P<sub>i</sub> is a projective cover of its image in P<sub>i - 1</sub>.
In this case the i<sup>th</sup> syzygy module is the image of &part;<sub>i</sub>. 
<P>
In the implementation the main function is cs{CompactProjectiveResolution.}
This function computes a minimal projective resolution of a given
module and stores the minimal amount of information that is necessary
to create the boundary maps and the terms of the resolution. It runs
relatively fast because it avoids the computation of the terms of the 
projective resolution as modules over the algebra. Instead the terms
in the compact resolution are only vector spaces together with a 
sequence of types for the projective modules. The other information
that is recorded is the sequence of images of the generators for
the indecomposable projective modules. That is, for the boundary
map 
<P>
P<sub>n</sub> mapright(&part;<sub>n</sub>) P<sub>n - 1</sub> 
<P>
the module P<sub>n</sub> isomorphic to direct-sum <sub>i = 1</sub><sup>m</sup> Q<sub>i</sub> where each Q<sub>i</sub> is an 
indecomposable projective module generated by an element a<sub>i</sub> corresponding
to the appropriate idempotent in the basic algebra. The function 
records the images &part;<sub>n</sub>(a<sub>i</sub>) as a sequence of vectors in
the vector space of the module P<sub>n - 1</sub>.


<H5><A NAME = "11045">ProjectiveCover(M) : ModAlg -&gt; ModAlg, ModMatFldElt, SeqEnum[ModMatFldElt],                        SeqEnum[ModMatFldElt], SeqEnum[RngIntElt]</A></H5>
<BLOCKQUOTE>
The projective cover of the module M given as the projective module P, the surjective 
homomorphism of P onto M, the sequences of inclusion and projection 
homomorphism of P from and to its indecomposable direct summands and 
the isomorphism type of P in the form of a list of the number of copies 
of the projective modules of the algebra of each type that make up P.
</BLOCKQUOTE>
<H5><A NAME = "11046">ProjectiveResolution(M, n) : ModAlg, RngIntElt -&gt; ModCpx, ModMatFldElt</A></H5>
<BLOCKQUOTE>
The complex giving the minimal projective resolution of the module M
out to n steps together with the augmentation homomorphism from the 
projective cover of M into M. Note that homomorphisms go from left to
right so that last term of the complex (in degree 0) is the projective
cover of M and the cokernel of the last homomorphism in the complex is M.
The complex is constructed from the compact projective resolution of
M. The function creates the compact projective resolution if it has 
not already been computed. 
<P>
<P>
</BLOCKQUOTE>
<H5><A NAME = "11047">CompactProjectiveResolution(M, n) : ModAlg, RngIntElt -&gt; Rec</A></H5>
<BLOCKQUOTE>
Returns a  minimal projective resolution for the module M out 
to n steps in compact form together 
with the augmentation map (P<sub>0</sub> -&gt; M). The compact form of 
the resolution is a list of the minimal pieces of information needed 
to reconstruct the boundary maps in the resolution. That is the boundary map
(P<sub>i</sub> mapright(&part;<sub>i</sub>) P<sub>i - 1</sub>) is recorded as  
a matrix whose entries are the images of the generators 
for indecomposable projective modules making up P<sub>i</sub> in the indecomposable 
projective modules making up P<sub>i - 1</sub>. 
If a compact projective resolution has been
previously computed to degree m and m &lt; n then the function extends
that resolution by n - m steps. If m &ge;n the function returns the 
previously computed compact projective resolution. 
The function returns a record with the fields:
<DL COMPACT class='compact'>
<DT>(a)</DT><DD>The list of isomorphism types of the projective modules in 
the resolution, each given as a sequence of integers giving the number
of direct summands of each indecomposable projective in the module
(field name <TT>BettiNumbers</TT>).
<DT>(b)</DT><DD>The record of the boundary maps (field name <TT>ResolutionRecord</TT>).
<DT>(c)</DT><DD>The module M (field name <TT>Module</TT>).
<DT>(d)</DT><DD>The augmentation map (field name <TT>AugmentationMap</TT>). 
<DT>(e)</DT><DD>The type of the resolution, whether projective or injective
(field name <TT>Typ</TT>).</DL>
</BLOCKQUOTE>
<H5><A NAME = "11048">CompactProjectiveResolutionsOfSimpleModules(A,n) : AlgBas, RngIntElt -&gt; SeqEnum</A></H5>
<BLOCKQUOTE>
Returns a sequence of the compact projective resolutions of the simple
A-modules computed to degree n.
<P>
<P>
</BLOCKQUOTE>
<H5><A NAME = "11049">SyzygyModule(M, n) : ModAlg, RngIntElt -&gt; ModAlg</A></H5>
<BLOCKQUOTE>
The n<sup>th</sup> syzygy module of the module M. The module is constructed from the 
compact projective resolution of M. The compact resolution is 
constructed if it does not already exist. 
</BLOCKQUOTE>
<H5><A NAME = "11050">SimpleHomologyDimensions(M) : ModAlg -&gt; SeqEnum</A></H5>
<BLOCKQUOTE>
The sequence of sequences of dimensions of the homology groups 
Tor<sub>j</sub>(S<sub>i</sub>, M) for simple modules S<sub>i</sub> and module M, to the extent that they have
been computed.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "11051">Example <TT>AlgBas_Homomorphisms (H90E18)</TT></A></H3>
We consider the basic algebra of a quiver with relation. The quiver has 
four nodes and 5 nonidempotent generators (a, b, c, d, e). The first goes from 
node 1 to node 2, the second from 2 to 3, the third from 3 to 4, the 
fourth from 3 to 2 and the last from 4 to 1. They satisfy the relations
bcfadbd = (abcf)<sup>5</sup>ab = (bd)<sup>2</sup>b = 0. 
<P>
<P>
<PRE>
&gt; ff := GF(8);
&gt; FA&lt;e1,e2,e3,e4,a,b,c,d,f&gt; := FreeAlgebra(ff,9);
&gt; rrr := [b*c*f*a*b*d*b,a*b*c*f*a*b*c*f*a*b*c*f*a*b*c*f*a*b*c*f*a*b,
&gt;     b*d*b*d*b];
&gt; BA := BasicAlgebra(FA,rrr,4,[&lt;1,2&gt;,&lt;2,3&gt;,&lt;3,4&gt;,&lt;3,2&gt;,&lt;4,1&gt;]);
&gt; BA;
Basic algebra of dimension 296 over GF(2^3)
Number of projective modules: 4
Number of generators: 9
</PRE>
Now we take the projective resolutions of the simple modules out to 5 steps.
We print the type of the projective module at each stage. 
<P>
<P>
<PRE>
&gt; for i := 1 to 4 do
&gt;     S := SimpleModule(BA,i);
&gt;     prj := CompactProjectiveResolution(S, 5);
&gt;     SimpleHomologyDimensions(S);
&gt; end for;
[
    [ 0, 0, 10, 0 ],
    [ 0, 0, 5, 0 ],
    [ 0, 0, 2, 0 ],
    [ 0, 0, 1, 0 ],
    [ 0, 1, 0, 0 ],
    [ 1, 0, 0, 0 ]
]
[
    [ 0, 0, 16, 0 ],
    [ 0, 0, 8, 0 ],
    [ 0, 0, 4, 0 ],
    [ 0, 0, 2, 0 ],
    [ 0, 0, 1, 0 ],
    [ 0, 1, 0, 0 ]
]
[
    [ 0, 0, 0, 0 ],
    [ 0, 0, 0, 0 ],
    [ 0, 0, 0, 0 ],
    [ 0, 0, 0, 0 ],
    [ 0, 1, 0, 1 ],
    [ 0, 0, 1, 0 ]
]
[
    [ 0, 0, 0, 0 ],
    [ 0, 0, 0, 0 ],
    [ 0, 0, 0, 0 ],
    [ 0, 0, 0, 0 ],
    [ 1, 0, 0, 0 ],
    [ 0, 0, 0, 1 ]
]
</PRE>
So we see that the third and fourth simple modules have finite projective 
dimension. The projective resolutions of the first and second simple modules 
appear to have exponential rates of growth but the terms after the second 
term are all direct sums of copies of the third projective module. 
<P>
<P>
<PRE>
&gt; for i := 1 to 4 do
&gt;     Dimension(Socle(ProjectiveModule(BA,i)));
&gt; end for;
12
13
25
12
</PRE>
Notice that the socles of the projective modules have very
large dimensions so the injective resolutions are probably going
to grow at a very rapid rate. 
<HR>
<H3><A NAME = "11052">Example <TT>AlgBas_Homomorphisms-2 (H90E19)</TT></A></H3>
We create the quotient of the group algebra of a p-group by the ideal 
generated by a central element. In particular, we choose the group algebra 
of an extra special 3-group and factor out the ideal generated by (z - 1)<sup>2</sup>
where z is a central element of order 3. Then we compare the size of the 
projective resolution of the trivial module for the new algebra with that
of the antecedent group algebra.
<P>
<P>
<PRE>
&gt; G := ExtraSpecialGroup(3,1); 
&gt; F := GF(3);
&gt; B := BasicAlgebra(G,F);
&gt; B;
Basic algebra of dimension 27 over GF(3)
Number of projective modules: 1
Number of generators: 4
&gt; s := NonIdempotentGenerators(B)[3];
</PRE>
Now check that cs{s} is in the center.
<P>
<P>
<PRE>
&gt; [s*x eq x*s: x in Generators(B)];
[ true, true, true, true ]
&gt; P := ProjectiveModule(B,1);
&gt; Q := quo&lt;P|P.1*s^2&gt;;
&gt; Q;
AModule Q of dimension 18 over GF(3)
</PRE>
We need to create the path tree for the projective module of the matrix 
algebra of the action on cs{Q}. In this case it is an easy exercise because 
the last 9 element of the basis of the projective module for cs{B} span the 
submodule that we are factoring out. This can actually be seen from the 
path tree for the projective module of cs{B}.
<P>
<P>
<PRE>
&gt; PathTree(B,1);
[ &lt;1, 1&gt;, &lt;1, 2&gt;, &lt;2, 2&gt;, &lt;1, 3&gt;, &lt;2, 3&gt;, &lt;3, 3&gt;, &lt;4, 3&gt;,
&lt;5, 3&gt;, &lt;6, 3&gt;, &lt;1, 4&gt;, &lt;2, 4&gt;, &lt;3, 4&gt;, &lt;4, 4&gt;, &lt;5, 4&gt;,
&lt;6, 4&gt;, &lt;7, 4&gt;, &lt;8, 4&gt;, &lt;9, 4&gt;, &lt;10, 4&gt;, &lt;11, 4&gt;, &lt;12, 4&gt;,
&lt;13, 4&gt;, &lt;14, 4&gt;, &lt;15, 4&gt;, &lt;16, 4&gt;, &lt;17, 4&gt;, &lt;18, 4&gt; ]
</PRE>
So we get the path tree for the new module by truncation. 
<P>
<P>
<PRE>
&gt; PT := [PathTree(B,1)[j]: j in [1 .. 18]];
&gt; PT;
[ &lt;1, 1&gt;, &lt;1, 2&gt;, &lt;2, 2&gt;, &lt;1, 3&gt;, &lt;2, 3&gt;, &lt;3, 3&gt;,
&lt;4, 3&gt;, &lt;5, 3&gt;, &lt;6, 3&gt;, &lt;1, 4&gt;, &lt;2, 4&gt;, &lt;3, 4&gt;,
&lt;4, 4&gt;, &lt;5, 4&gt;, &lt;6, 4&gt;, &lt;7, 4&gt;, &lt;8, 4&gt;, &lt;9, 4&gt; ]
</PRE>
Now form the new basic algebra.
<P>
<P>
<PRE>
&gt; C := BasicAlgebra([&lt;Action(Q),PT&gt;]);
&gt; C;
Basic algebra of dimension 18 over GF(3)
Number of projective modules: 1
Number of generators: 4
&gt; S := SimpleModule(C,1);
&gt; prj := CompactProjectiveResolution(S, 15);
&gt; SimpleHomologyDimensions(S);
[ 92, 77, 70, 57, 51, 40, 35, 26, 22, 15, 12, 7, 5, 2, 1 ]
</PRE>
Now compare this with the projective resolution for the group algebra.
<P>
<P>
<PRE>
&gt; T := SimpleModule(B,1);
&gt; pj2 := CompactProjectiveResolution(T,15);
&gt; SimpleHomologyDimensions(T);
[ 20, 18, 17, 16, 15, 14, 12, 10, 9, 8, 7, 6, 4, 2, 1 ]
</PRE>
<HR>
<PRE></PRE> <A  HREF = "text976.htm">[Next]</A><A  HREF = "text974.htm">[Prev]</A> <A  HREF = "text976.htm">[Right]</A> <A  HREF = "text974.htm">[Left]</A> <A  HREF = "text966.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<br><small>Version: V2.22 of <I>
Thu Jun  9 16:37:49 EST 2016
</I></small>
</body></html>