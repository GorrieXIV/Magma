<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <link rel='stylesheet' href='help.css' type='text/css'>
  <TITLE>Monte Carlo Algorithms for  Subgroups</TITLE>
</head>
<body BGCOLOR="#FFFFFF">

 <A  HREF = "text677.htm">[Next]</A><A  HREF = "text675.htm">[Prev]</A> <A  HREF = "text677.htm">[Right]</A> <A  HREF = "text675.htm">[Left]</A> <A  HREF = "text673.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<PRE></PRE><H3><A NAME = "7749">Monte Carlo Algorithms for  Subgroups</A></H3>



<H5><A NAME = "7750">CentraliserOfInvolution(G, g : parameters) : GrpMat,GrpMatElt -&gt; GrpMat</A></H5>

<PRE>    Central: BoolElt                    Default: <TT>false</TT></PRE>

<PRE>    NumberRandom: RngIntElt             Default: 100</PRE>

<PRE>    CompletionCheck: UserProgram        Default: </PRE>
<BLOCKQUOTE>
Given an involution g in G, this function returns the 
centraliser C of g in G using an algorithm of John Bray <A  HREF = "text672.htm#bib_bray00">[Bra00]</A>.
Since it is Monte Carlo, it may return only a subgroup of the centraliser.
If <TT>Central</TT> is <TT>true</TT>, the projective centraliser of g will be
constructed: its elements commute with g modulo the centre of G.
<P>
The optional argument <TT>CompletionCheck</TT> is a function which can be used 
to determine when we have constructed the centraliser.  It takes the 
following arguments: the parent group G; the proposed centraliser C; 
the involution g.  By default, the algorithm completes when 20 generators
have been found for the centraliser or when <TT>NumberRandom</TT> elements have
been considered.
</BLOCKQUOTE>
<H5><A NAME = "7751">CentraliserOfInvolution(G, g, w : parameters) : GrpMat,GrpMatElt, GrpSLPElt -&gt; GrpMat, []</A></H5>

<PRE>    Randomiser: GrpRandProc             Default: </PRE>

<PRE>    Central: BoolElt                    Default: <TT>false</TT></PRE>

<PRE>    NumberRandom: RngIntElt             Default: 100</PRE>

<PRE>    CompletionCheck: UserProgram        Default: </PRE>
<BLOCKQUOTE>
Given an involution g in a matrix group G together with a SLP w 
corresponding to g, this function returns the centraliser C of g 
in G and SLPs for the generators of C.  The algorithm used is due to 
John Bray <A  HREF = "text672.htm#bib_bray00">[Bra00]</A>.  Since it is Monte Carlo, it may return a proper
subgroup of the centraliser.  If <TT>Central</TT> is <TT>true</TT>, the projective 
centraliser of g is constructed: its elements commute with g modulo 
the centre of G.
<P>
The parameter <TT>Randomiser</TT> specifies the random process that is to be 
used to construct the centraliser.  By default <TT>Randomiser</TT> is the 
value returned by <TT>RandomProcessWithWords (G)</TT>.  The SLP for g 
must lie in the word group of this process.  The optional argument 
<TT>CompletionCheck</TT> is a function which can be used to determine 
when we have constructed the centraliser.  It takes four arguments:  
the parent group G; the proposed centraliser C; the involution g; 
and the list of the SLPs for the generators of C. By default, the 
algorithm completes when 20 generators have been found for the centraliser 
or when <TT>NumberRandom</TT> elements have been considered.
</BLOCKQUOTE>
<H5><A NAME = "7752">AreInvolutionsConjugate(G, x, wx, y, wy : parameters) : GrpMat,GrpMatElt, GrpSLPElt, GrpMatElt, GrpSLPElt -&gt; BoolElt, GrpMatElt, GrpSLPElt</A></H5>

<PRE>    Randomiser: GrpRandProc             Default: </PRE>

<PRE>    MaxTries: RngIntElt                 Default: 100</PRE>
<BLOCKQUOTE>
This Monte Carlo algorithm attempts to construct an element c of 
the group G which conjugates the involution x to the involution y.
The corresponding SLPs for x and y are wx and wy respectively.
If such an element c is found, then three values are returned: 
<TT>true</TT>, c and the SLP for c. Otherwise, the boolean value 
<TT>false</TT> is returned.  At most <TT>MaxTries</TT> random elements are 
considered.
<P>
The parameter <TT>Randomiser</TT> specifies the random process to be used.
By default <TT>Randomiser</TT> is the value returned by 
<TT>RandomProcessWithWords (G)</TT>.  The SLPs for x and y must lie 
in the word group of this process and the SLP for c will also lie in 
this word group.
</BLOCKQUOTE>
<H5><A NAME = "7753">NormalClosureMonteCarlo(G, H ) : GrpMat, GrpMat -&gt; GrpMat</A></H5>
<H5>NormalClosureMonteCarlo(G, H : parameters) : GrpPerm, GrpPerm -&gt; GrpMat</H5>

<PRE>    slpsH: []                           Default: []</PRE>

<PRE>    ErrorProb: FltRatElt                Default: 9/10</PRE>

<PRE>    SubgroupChainLength: RngIntElt      Default: Degree(H)</PRE>
<BLOCKQUOTE>
This Monte Carlo algorithm constructs the normal closure N of H in 
G. If SLPs of the generators of H in the generators of G are 
supplied via the parameter <TT>slpsH</TT>, then the function also returns 
SLPs for the generators of N. The parameter <TT>SubgroupChainLength</TT> 
is used to specify an upper bound on the length of any subgroup chain 
in H. The probability that N is a proper subgroup of the normal 
closure is bounded above by <TT>ErrorProb</TT>, assuming that 
<TT>SubgroupChainLength</TT> is correctly set.
</BLOCKQUOTE>
<H5><A NAME = "7754">DerivedGroupMonteCarlo(G : parameters) : GrpMat -&gt; GrpMat</A></H5>

<PRE>    Randomiser: GrpRandProc             Default: </PRE>

<PRE>    NumberGenerators: RngIntElt         Default: 10</PRE>

<PRE>    MaxGenerators: RngIntElt            Default: 100</PRE>
<BLOCKQUOTE>
Given a matrix group G defined over a finite field, this intrinsic 
returns the derived group of G, and a list of SLPs of its generators 
in the generators of G. The SLPs are elements of the word group of 
the random process.  The algorithm is Monte Carlo and may return a 
proper subgroup of the derived group.  The parameter <TT>Randomiser</TT> 
specifies the random process to be used.  By default <TT>Randomiser</TT> 
is the value returned by <TT>RandomProcessWithWords (G)</TT>.  At least 
<TT>NumberGenerators</TT> and at most <TT>MaxGenerators</TT> will be 
constructed for the derived group.
</BLOCKQUOTE>
<H5><A NAME = "7755">IsProbablyPerfect(G : parameters): Grp -&gt; BoolElt</A></H5>

<PRE>    NumberRandom: RngIntElt             Default: 100</PRE>
<BLOCKQUOTE>
This intrinsic attempts to prove that a matrix or permutation group G 
is perfect by establishing that its generators are in G'.  Since it is
Monte-Carlo, there is a small probability of error.  If the function
returns <TT>true</TT>, then G is perfect; if it returns <TT>false</TT>,
then G might still be perfect.  Each call considers <TT>NumberRandom</TT> 
random elements.
<P>
The algorithm is due to Leedham-Green and O'Brien <A  HREF = "text672.htm#bib_crlg-eaob">[LGO02]</A> and
it uses <TT>NormalSubgroupRandomElement</TT>.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "7756">Example <TT>GrpMatFF_IsProbablyPerfect (H65E1)</TT></A></H3>
We illustrate <TT>IsProbablyPerfect</TT> with a subgroup of GU(4, 9).
<P>
<P>
<P>
<PRE>
&gt; G := GU(4, 9);
&gt; N := sub&lt;G | (G.1, G.2)&gt;;
</PRE>
<P>
The generators of N have been chosen to be a normal generating set 
for the derived group of G.
<P>
<P>
<P>
<PRE>
&gt; IsProbablyPerfect(N);
false
&gt; x := NormalSubgroupRandomElement(G, N);
&gt; x;
[$.1^68 $.1^34 $.1^26 $.1^55]
[$.1^23 $.1^78 $.1^16 $.1^72]
[$.1^42  $.1^2 $.1^24      2]
[$.1^11 $.1^66 $.1^13 $.1^29]
&gt;  L := sub&lt; G | N, x&gt;;
&gt; IsProbablyPerfect(L);
true
</PRE>
<P>
We now consider SO(7, 5) and &Omega;(7, 5).
<P>
<P>
<P>
<PRE>
&gt; G := SO(7, 5);
&gt; IsProbablyPerfect(G);
false
&gt; G := Omega(7, 5);
&gt; IsProbablyPerfect(G);
true
</PRE>
<HR>
<PRE></PRE> <A  HREF = "text677.htm">[Next]</A><A  HREF = "text675.htm">[Prev]</A> <A  HREF = "text677.htm">[Right]</A> <A  HREF = "text675.htm">[Left]</A> <A  HREF = "text673.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<br><small>Version: V2.22 of <I>
Thu Jun  9 16:37:49 EST 2016
</I></small>
</body></html>