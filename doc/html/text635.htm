<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <link rel='stylesheet' href='help.css' type='text/css'>
  <TITLE>Permutations</TITLE>
</head>
<body BGCOLOR="#FFFFFF">

 <A  HREF = "text636.htm">[Next]</A><A  HREF = "text634.htm">[Prev]</A> <A  HREF = "text636.htm">[Right]</A> <A  HREF = "text634.htm">[Left]</A> <A  HREF = "text629.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<PRE></PRE><H3><A NAME = "6950">Permutations</A></H3>




<H5>Subsections</H5>
<UL>
<LI> <A  HREF = "text635.htm#6951">Coercion</A>
<LI> <A  HREF = "text635.htm#6954">Arithmetic with Permutations</A>
<LI> <A  HREF = "text635.htm#6961">Properties of Permutations</A>
<LI> <A  HREF = "text635.htm#6967">Predicates for Permutations</A>
<LI> <A  HREF = "text635.htm#6972">Set Operations</A>
</UL>
<H4><A NAME = "6951">Coercion</A></H4>



<H5><A NAME = "6952">G ! g : GrpPerm, GrpPermElt -&gt; GrpPermElt</A></H5>
<BLOCKQUOTE>
Given a subgroup G of Sym(X) and a permutation g belonging 
to Sym(X) that is contained in G, embed g in G. Thus,
this operator changes the parent of g to be G.
</BLOCKQUOTE>
<H5><A NAME = "6953">G !! H : GrpPerm, GrpPerm -&gt; GrpPerm</A></H5>
<BLOCKQUOTE>
Given a group H whose natural G-set X is a subset of the natural
G-set Y for the group G, embed H as a subgroup of G. The
operator fails if the image of H in Sym(Y) is not a subgroup of G.
</BLOCKQUOTE>
<H4><A NAME = "6954">Arithmetic with Permutations</A></H4>



<H5><A NAME = "6955">g * h : GrpPermElt, GrpPermElt -&gt; GrpPermElt</A></H5>
<BLOCKQUOTE>
Product of permutation g and permutation h, where g and
h belong to the same generic group U. If g and h both
belong to the same proper subgroup G of U, then the result
will be returned as an element of G; if g and h belong to
subgroups H and K of a subgroup G of U, then the product
is returned as an element of G.  Otherwise, the product is
returned as an element of U.
</BLOCKQUOTE>
<H5><A NAME = "6956">g ^ n : GrpPermElt, RngIntElt -&gt; GrpPermElt</A></H5>
<BLOCKQUOTE>
The n-th power of the permutation g, where n is a positive, 
negative or zero integer.
</BLOCKQUOTE>
<H5><A NAME = "6957">g / h : GrpPermElt, GrpPermElt -&gt; GrpPermElt</A></H5>
<BLOCKQUOTE>
Product of the permutation g by the inverse of the permutation h,
i.e. the element g * h<sup> - 1</sup>. Here g and h must belong to the same
generic group U. The rules for determining the parent group of
g / h are the same as for g * h.
</BLOCKQUOTE>
<H5><A NAME = "6958">g ^ h : GrpPermElt, GrpPermElt -&gt; GrpPermElt</A></H5>
<BLOCKQUOTE>
Conjugate of the permutation g by the permutation h, i.e.
the element h<sup> - 1</sup> * g * h. Here g and h must belong to the
same generic group U.  The rules for determining the parent
group of g<sup>h</sup> are the same as for g * h.
</BLOCKQUOTE>
<H5><A NAME = "6959">(g, h) : GrpPermElt, GrpPermElt -&gt; GrpPermElt</A></H5>
<BLOCKQUOTE>
Commutator of the permutations g and h, i.e. the element
g<sup> - 1</sup> * h<sup> - 1</sup> * g * h. Here g and h must belong to the same generic
group U. The rules for determining the parent group of (g, h) are
the same as those for g * h.
</BLOCKQUOTE>
<H5><A NAME = "6960">(g<sub>1</sub>, ..., g<sub>r</sub>) : GrpPermElt, ..., GrpPermElt -&gt; GrpPermElt</A></H5>
<BLOCKQUOTE>
Given r permutations g<sub>1</sub>, ..., g<sub>r</sub> belonging to a common group,
return their commutator. Commutators are <I>left-normed</I>, so they are
evaluated from left to right.
</BLOCKQUOTE>
<H4><A NAME = "6961">Properties of Permutations</A></H4>



<H5><A NAME = "6962">CycleStructure(g) : GrpPermElt -&gt; [ &lt;RngIntElt, RngIntElt&gt; ]</A></H5>
<BLOCKQUOTE>
Given a permutation g belonging to a group of degree n,
return the partition of n corresponding to the cycles of g.
This partition is returned in the form of a sequence Q of
pairs, where the terms of Q correspond to the distinct cycle
lengths of g. The value of the term Q[i] is a tuple &lt; l<sub>i</sub>,
n<sub>i</sub> &gt; belonging to Z x Z. Here l<sub>i</sub> is the length of a
cycle of g and n<sub>i</sub> is the number of cycles of length l<sub>i</sub>.
</BLOCKQUOTE>
<H5><A NAME = "6963">Degree(g) : GrpPermElt -&gt; RngIntElt</A></H5>
<BLOCKQUOTE>
Given a permutation g, return the degree of g, i.e. the number of points
moved by g.
</BLOCKQUOTE>
<H5><A NAME = "6964">IsEven(g) : GrpPermElt -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if the permutation g is an even permutation, <TT>false</TT> otherwise.
</BLOCKQUOTE>
<H5><A NAME = "6965">Sign(g) : GrpPermElt -&gt; RngIntElt</A></H5>
<BLOCKQUOTE>
Return 1 if the permutation g is even, return -1 if g is odd.
</BLOCKQUOTE>
<H5><A NAME = "6966">Order(g) : GrpPermElt -&gt; RngIntElt</A></H5>
<BLOCKQUOTE>
Order of the permutation g.
</BLOCKQUOTE>
<H4><A NAME = "6967">Predicates for Permutations</A></H4>



<H5><A NAME = "6968">g eq h : GrpPermElt, GrpPermElt -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Given permutations g and h belonging to the same generic
group, return <TT>true</TT> if g and h are the same element, <TT>false</TT> otherwise.
</BLOCKQUOTE>
<H5><A NAME = "6969">g ne h : GrpPermElt, GrpPermElt -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Given permutations g and h belonging to the same generic
group, return <TT>true</TT> if g and h are distinct elements, <TT>false</TT> otherwise.
</BLOCKQUOTE>
<H5><A NAME = "6970">IsId(g) : GrpPermElt -&gt; BoolElt</A></H5>
<H5>IsIdentity(g) : GrpPermElt -&gt; BoolElt</H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if the permutation g is the identity permutation.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "6971">Example <TT>GrpPerm_Arithmetic (H63E9)</TT></A></H3>
We illustrate the permutation operations by applying them
to some elements of Sym(9).
<P>
<P>
<PRE>
&gt; G := Sym(9);
&gt; x := G ! (1,2,4)(5,6,8)(3,9,7);
&gt; y := G ! (4,5,6)(7,9,8);
&gt; x*y;
(1, 2, 5, 4)(3, 8, 6, 7)
&gt; x^-1;
(1, 4, 2)(3, 7, 9)(5, 8, 6)
&gt; x^2;
(1, 4, 2)(3, 7, 9)(5, 8, 6)
&gt; x / y;
(1, 2, 6, 9, 8, 4)(3, 7)
&gt; x^y;
(1, 2, 5)(3, 8, 9)(4, 7, 6)
&gt; (x, y);
(1, 7, 3, 6)(4, 5, 9, 8)
&gt; x^y eq y^x;
false
&gt; CycleStructure(x^2*y);
[ &lt;6, 1&gt;, &lt;2, 1&gt;, &lt;1, 1&gt; ]
&gt; Degree(y);
6
&gt; Order(x^2*y);
6
</PRE>
<HR>
<H4><A NAME = "6972">Set Operations</A></H4>

<P>
<P>
The creation of a base and strong generating set (BSGS) for a permutation
group G provides us with a very compact representation of the set of
elements of G.  A particular BSGS imposes an order on the elements of
G (lexicographic ordering of base images). It thus makes sense to
talk about the `number' of a group element relative to a particular
BSGS.


<H5><A NAME = "6973">G * H : GrpPerm, GrpPerm -&gt; { GrpPermElt }</A></H5>
<BLOCKQUOTE>
Given permutation groups G and H, where G and H both
belong to the same generic group, form the set product
{ g * h | g&isin;G, h&isin;H } as a set of group elements.
</BLOCKQUOTE>
<H5><A NAME = "6974">ElementSet(G, H) : GrpPerm, GrpPerm -&gt; { GrpPermElt }</A></H5>
<BLOCKQUOTE>
Given a group G and a subgroup H of G, return the
elements of H in the form of a set of elements of G. This
function is only applicable to very small groups.
</BLOCKQUOTE>
<H5><A NAME = "6975">NumberingMap(G) : GrpPerm -&gt; Map</A></H5>
<BLOCKQUOTE>
A bijective mapping from the group G onto the set of integers
 { 1 ... |G| }. The actual mapping depends upon
the base and strong generating set chosen for G.
</BLOCKQUOTE>
<H5><A NAME = "6976">RandomProcess(G) : GrpPerm -&gt; Process</A></H5>

<PRE>    Slots: RngIntElt                    Default: 10</PRE>

<PRE>    Scramble: RngIntElt                 Default: 20</PRE>
<BLOCKQUOTE>
Create a process to generate randomly chosen elements from the finite
group G. The process is based on the product-replacement algorithm
of <A  HREF = "text628.htm#bib_randomelements">[CLGM+95]</A>, modified by the use of an accumulator.
At all times, N elements are stored where N is the maximum of
the specified value for <TT>Slots</TT>
and <TT>Ngens</TT>(G) + 1. 
Initially, these are just the generators of G.
As well, one extra group element is stored, the accumulator. Initially,
this is the identity.
Random elements are now produced by successive calls to <TT>Random(P)</TT>,
where P is the process created by this function.  Each such call
chooses one of the elements in the slots and multiplies it into the 
accumulator.
The element in that slot is replaced by the product of it and another 
randomly chosen slot. The random value returned is the new accumulator 
value.
Setting <TT>Scramble := m</TT> causes m such operations to be performed
before the process is returned.
</BLOCKQUOTE>
<H5><A NAME = "6977">Random(G: parameters) : GrpPerm -&gt; GrpPermElt</A></H5>

<PRE>    Short: BoolElt                      Default: <TT>false</TT></PRE>
<BLOCKQUOTE>
A randomly chosen element for the group G. If a BSGS is known
for G, then the distribution will be uniform over G. If
no BSGS is known, then the <I>random</I> element is chosen by
multiplying out a <I>random</I> word in the generators. Since it
is usually not practical to choose words long enough to
properly sample the elements of G, the element returned will
usually be biased. The boolean-valued parameter <TT>Short</TT> is
used in this situation to indicate that a short word will
suffice. Thus, if <TT>Random</TT> is invoked with <TT>Short</TT>
assigned the value <TT>true</TT> then the element is constructed
using a short word.
</BLOCKQUOTE>
<H5><A NAME = "6978">Random(P) : Process -&gt; GrpPermElt</A></H5>
<BLOCKQUOTE>
Given a random element process P created by the function
<TT>RandomProcess(G)</TT> for the finite group G,
construct a random element of G by forming a
random product over the expanded generating set constructed when the
process was created. For large degree groups, or groups for which a
BSGS is not known, this function should be used in preference to
<TT>Random(G)</TT>.
</BLOCKQUOTE>
<H5><A NAME = "6979">Representative(G) : GrpPerm -&gt; GrpPermElt</A></H5>
<H5>Rep(G) : GrpPerm -&gt; GrpPermElt</H5>
<BLOCKQUOTE>
An element chosen from the permutation group G.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "6980">Example <TT>GrpPerm_SetOperations (H63E10)</TT></A></H3>
We use the function <TT>NumberingMap</TT> to construct
the multiplication table for the dihedral group of order 12.
<P>
<P>
<PRE>
&gt; G := DihedralGroup(GrpPerm, 6);
&gt; f := NumberingMap(G);
&gt; [ [ f(x*y) : y in G ] : x in G ];
[
    [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 ],
    [ 2, 3, 4, 5, 6, 1, 12, 7, 8, 9, 10, 11 ],
    [ 3, 4, 5, 6, 1, 2, 11, 12, 7, 8, 9, 10 ],
    [ 4, 5, 6, 1, 2, 3, 10, 11, 12, 7, 8, 9 ],
    [ 5, 6, 1, 2, 3, 4, 9, 10, 11, 12, 7, 8 ],
    [ 6, 1, 2, 3, 4, 5, 8, 9, 10, 11, 12, 7 ],
    [ 7, 8, 9, 10, 11, 12, 1, 2, 3, 4, 5, 6 ],
    [ 8, 9, 10, 11, 12, 7, 6, 1, 2, 3, 4, 5 ],
    [ 9, 10, 11, 12, 7, 8, 5, 6, 1, 2, 3, 4 ],
    [ 10, 11, 12, 7, 8, 9, 4, 5, 6, 1, 2, 3 ],
    [ 11, 12, 7, 8, 9, 10, 3, 4, 5, 6, 1, 2 ],
    [ 12, 7, 8, 9, 10, 11, 2, 3, 4, 5, 6, 1 ]
]
</PRE>
<HR>
<H3><A NAME = "6981">Example <TT>GrpPerm_SetOperations-2 (H63E11)</TT></A></H3>
We illustrate the use of the function <TT>Random</TT> using the
wreath product of the symmetric group of degree 4 and the cyclic
group of order 6.
<P>
<P>
<PRE>
&gt; G := WreathProduct( Sym(4), CyclicGroup(GrpPerm, 6));
&gt; G;
Permutation group G acting on a set of cardinality 24
    (1, 5, 9, 13, 17, 21)(2, 6, 10, 14, 18, 22) (3, 7, 11, 15, 19, 23)
        (4, 8, 12, 16, 20, 24)
    (1, 2, 3, 4)
    (1, 2)
&gt; Order(G);
1146617856
&gt; Random(G);
(1, 17, 12, 4, 18, 10, 3, 20, 9, 2, 19, 11)(5, 22, 13, 6, 21, 15)
    (7, 24, 16)(8, 23, 14)
</PRE>
We display the cycle structures of 10 random elements of G.
<P>
<P>
<PRE>
&gt; R := [ CycleStructure(Random(G)) : i in [1..10] ];
&gt; R;
[
    [ &lt;6, 1&gt;, &lt;3, 6&gt; ],
    [ &lt;9, 1&gt;, &lt;6, 2&gt;, &lt;3, 1&gt; ],
    [ &lt;9, 2&gt;, &lt;3, 2&gt; ],
    [ &lt;12, 1&gt;, &lt;9, 1&gt;, &lt;3, 1&gt; ],
    [ &lt;18, 1&gt;, &lt;6, 1&gt; ],
    [ &lt;18, 1&gt;, &lt;6, 1&gt; ],
    [ &lt;12, 1&gt;, &lt;6, 2&gt; ],
    [ &lt;6, 3&gt;, &lt;2, 3&gt; ],
    [ &lt;6, 1&gt;, &lt;4, 3&gt;, &lt;2, 3&gt; ],
    [ &lt;6, 3&gt;, &lt;3, 2&gt; ]
]
</PRE>
<HR>
<PRE></PRE> <A  HREF = "text636.htm">[Next]</A><A  HREF = "text634.htm">[Prev]</A> <A  HREF = "text636.htm">[Right]</A> <A  HREF = "text634.htm">[Left]</A> <A  HREF = "text629.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<br><small>Version: V2.22 of <I>
Thu Jun  9 16:37:49 EST 2016
</I></small>
</body></html>