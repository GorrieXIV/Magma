<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <link rel='stylesheet' href='help.css' type='text/css'>
  <TITLE>p-Quotients (Process Version)</TITLE>
</head>
<body BGCOLOR="#FFFFFF">

 <A  HREF = "text828.htm">[Next]</A><A  HREF = "text826.htm">[Prev]</A> <A  HREF = "text828.htm">[Right]</A> <A  HREF = "text826.htm">[Left]</A> <A  HREF = "text823.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<PRE></PRE><H3><A NAME = "9529">p-Quotients (Process Version)</A></H3>

<P>
<P>
Let F be a finitely presented group, p a prime and c a
positive integer. A p-quotient algorithm constructs a consistent 
power-conjugate presentation for the largest p-quotient of F 
having lower exponent-p class at 
most c. For details of this algorithm, see <A  HREF = "text822.htm#bib_newman_obrien">[NO96]</A>.
<P>
Assume that the p-quotient has order p<sup>n</sup>, 
Frattini rank d, and that its
generators are a<sub>1</sub>, ..., a<sub>n</sub>.
Then the power-conjugate presentation constructed has the following
additional structure. The set {a<sub>1</sub>, ..., a<sub>d</sub>}
is a generating set for G.
For each a<sub>k</sub> in {a<sub>d + 1</sub>, ..., a<sub>n</sub>}, there is
at least one relation whose right hand side is a<sub>k</sub>.
One of these relations is taken as the <I>definition</I> of a<sub>k</sub>.
(The list of definitions is also returned by <TT>pQuotient</TT>.)
The  power-conjugate generators also have a <I>weight</I> associated 
with them: a generator is assigned a weight corresponding to the 
stage at which it is added and this weight is extended to all 
normal words in a natural way.
<P>
<P>
The p-quotient process and its associated commands allows
the user to construct a power-conjugate presentation (pcp)
for a p-group.



<H5>Subsections</H5>
<UL>
<LI> <A  HREF = "text827.htm#9530">The p-Quotient Process</A>
<LI> <A  HREF = "text827.htm#9533">Using p-Quotient Interactively</A>
</UL>
<H4><A NAME = "9530">The p-Quotient Process</A></H4>



<H5><A NAME = "9531"></A><A NAME = "GrpFP_2:pQuotientProcess">pQuotientProcess</A>(F, p, c: parameters) : GrpFP, RngIntElt, RngIntElt -&gt; Process</H5>
<BLOCKQUOTE>
Given an fp-group F, a prime p and a positive integer c,
create a p-quotient process for the group F with the indicated arguments. 
As part of the initialisation of the process, a pcp for the largest 
p-quotient of F having class at most c will be constructed. 
If c is given as 0, then the limit 127 is placed on the class. 
This function supports the same parameters as <TT>pQuotient</TT> 
and returns a process P.
</BLOCKQUOTE>
<H5><A NAME = "9532"></A><A NAME = "GrpFP_2:NextClass">NextClass</A>(~P : parameters) : GrpPCpQuotientProc -&gt;</H5>
<H5>NextClass(~P, k : parameters) : GrpPCpQuotientProc, RngIntElt -&gt;</H5>

<PRE>    Exponent: RngIntElt                 Default: </PRE>

<PRE>    Metabelian: BoolElt                 Default: </PRE>

<PRE>    Print: RngIntElt                    Default: </PRE>

<PRE>    MaxOccurrence: [ RngIntElt ]        Default: []</PRE>
<BLOCKQUOTE>
Assumes that a pcp has already been constructed for the class c quotient 
of F. It seeks to construct a pcp for the class c + 1 p-quotient of F.
If k is supplied, continue to construct until the pcp for 
the largest quotient of class k is constructed. 
<P>
The parameters <TT>Exponent</TT>, <TT>Print</TT>, and <TT>Metabelian</TT>
are used as before. If <TT>MaxOccurrence := Q</TT>, then the 
sequence Q has length equal to the rank of the class 1 quotient 
of F; its entries are integers which specify the maximum number 
of occurrences of the class 1 generators in the definitions of pcp 
generators of F. An entry of 0 for a particular 
generator indicates that no limit is placed on the number of 
occurrences of this generator.
</BLOCKQUOTE>
<P>
<P>
<P>
Care should be exercised when supplying values for parameters. 
Once set, they retain their values until explicitly reassigned.
<H4><A NAME = "9533">Using p-Quotient Interactively</A></H4>

<P>
<P>
We assume that we have constructed a pcp for the largest
class c p-quotient of F and now seek to construct a 
pcp for the largest class c + 1 p-quotient.
<P>
The following options allow the user to construct a pcp for
the next class of the group 
interactively. The steps are laid out in one of a number of natural sequences 
in which they may be executed.  Some of them may be interleaved; however, the
user should pay particular attention to the assumptions mentioned below. 
The procedures that drive the process do not verify that the assumptions 
are satisfied.


<H5><A NAME = "9534">StartNewClass(~P: parameters) : GrpPCpQuotientProc -&gt;</A></H5>
<BLOCKQUOTE>
If P is a process for a class c p-quotient, 
commence construction of class c + 1. 
</BLOCKQUOTE>
<H5><A NAME = "9535">Tails(~P: parameters) : GrpPCpQuotientProc -&gt;</A></H5>
<H5>Tails(~P, k: parameters) : GrpPCpQuotientProc, RngIntElt -&gt;</H5>

<PRE>    Metabelian: BoolElt                 Default: <TT>false</TT></PRE>
<BLOCKQUOTE>
Add tails to the current pcp; default is to add all tails for this class.
If k is supplied, then tails 
for weight k only are added; in this case, it is assumed that the tails for
each of weight c + 1, c, ..., k + 1 have already been added. The valid 
range of k is 2, ..., c + 1.  The one valid parameter is 
<TT>Metabelian</TT>; if <TT>true</TT>, then 
only the tails for the metabelian p-quotient are inserted.
</BLOCKQUOTE>
<H5><A NAME = "9536">Consistency(~P: parameters) : GrpPCpQuotientProc -&gt;</A></H5>
<H5>Consistency(~P, k: parameters) : GrpPCpQuotientProc -&gt;</H5>

<PRE>    Metabelian: BoolElt                 Default: <TT>false</TT></PRE>
<BLOCKQUOTE>
Apply the consistency algorithm to the pcp to compute any redundancies among 
the tails already added. Default is to apply it to all tails; in this case, 
it is assumed that all tails have been added. If 
k is supplied, it is assumed that tails for weight 
k have been added; in this case, the tails added for weight k only 
are checked.  The range of k is 3, ..., c + 1.  The one 
valid parameter is <TT>Metabelian</TT>; if <TT>true</TT>, we assume that the 
tails inserted were those for a metabelian p-quotient and hence 
invoke the (less expensive) metabelian consistency algorithm.  
</BLOCKQUOTE>
<H5><A NAME = "9537">CollectRelations(~P) : GrpPCpQuotientProc -&gt;</A></H5>
<BLOCKQUOTE>
Collect the defining relations (if any) in the current pcp. 
If the tails operation is not complete, then the relations may
be evaluated incorrectly.
</BLOCKQUOTE>
<H5><A NAME = "9538">ExponentLaw(~P : parameters) : GrpPCpQuotientProc -&gt;</A></H5>
<H5>ExponentLaw(~P, Start, Fin: parameters) : GrpPCpQuotientProc, RngIntElt, RngIntElt -&gt;</H5>
<BLOCKQUOTE>
Enforce the supplied exponent law on the current pcp. If 
<TT>Start</TT> and <TT>Fin</TT> are supplied, 
then enforce the law for those weights between 
<TT>Start</TT> and <TT>Fin</TT>; 
otherwise, enforce the law for all weights. 
It is assumed that the 
tails operation is complete. If the display parameter <TT>DisplayLevel</TT> 
(which may be set using <TT>SetDisplayLevel</TT>)
has value 2, those words whose powers are collected and give 
redundancies among the pcp generators are printed out.  If 
<TT>DisplayLevel</TT> has value 3, all words whose powers 
are collected are printed out.
The following additional parameters are available:
<P>
<P>
<P>
<PRE>
     Exponent: RngIntElt                 Default: 0
</PRE>
If <TT>Exponent := m</TT>, enforce the exponent law, x<sup>m</sup> = 1, on the group.
<P>
<P>
<PRE>
     Print: RngIntElt                    Default: 1
</PRE>
As for <TT>pQuotient</TT>.
<P>
<P>
<PRE>
     Trial: BoolElt                      Default: <TT>false</TT>
</PRE>
Generate the list of words used to enforce the exponent law and print 
out statistics but do not power words or echelonise the results.
<P>
<P>
<PRE>
     ShortList: BoolElt                  Default: <TT>false</TT>
</PRE>
Generate the list of enforcement words whose entries have the form w
or 1 ast w where w is an element of the Frattini 
subgroup of F.
<P>
<P>
<PRE>
     DisplayList: BoolElt                Default: <TT>false</TT>
</PRE>
Display the list of all enforcement words generated -- not just 
those which are collected.
<P>
<P>
<PRE>
     IdentifyFilters: BoolElt            Default: <TT>false</TT>
</PRE>
Identify filters used to eliminate words from list.
<P>
<P>
<PRE>
     InitialSegment: [&lt;GrpFPElt, RngIntElt&gt;] Default: []
</PRE>
If <TT>InitialSegment := w</TT>, generate only those enforcement words which 
have w as an initial segment, where w is supplied as a sequence of 
generator-exponent pairs.
<P>
<P>
<PRE>
     Report: RngIntElt                   Default: 0
</PRE>
If <TT>Report := n</TT>, report after computing the powers of each
collection of n enforcement words.
</BLOCKQUOTE>
<H5><A NAME = "9539">EliminateRedundancy(~P) : GrpPCpQuotientProc -&gt;</A></H5>
<BLOCKQUOTE>
Eliminate all redundant generators from the pcp defined by process P.
This operation may be performed at any time.
</BLOCKQUOTE>
<P>
<P>
<P>
We now list the remaining functions which can be applied to a 
pQuotient process.
<H5><A NAME = "9540">Display(P) : GrpPCpQuotientProc -&gt;</A></H5>
<H5>Display(P, DisplayLevel): GrpPCpQuotientProc, RngIntElt -&gt;</H5>
<BLOCKQUOTE>
Display the pcp for the p-quotient G of the fp-group F. The 
argument <TT>DisplayLevel</TT> may be 1, 2, or 3, and is used to control
the amount of information given:
<P>
<DL COMPACT class='compact'>
<DT><TT>1</TT> : </DT><DD>Display order and class of G;
<P>
<DT><TT>2</TT> : </DT><DD>Display non-trivial relations for G;
<P>
<DT><TT>3</TT> : </DT><DD>Display the structure of pcp generators of G, non-trivial 
relations of G, and the map from the defining generators of F to 
the pcp generators of G. 
<P>
</DL>
The presentation displayed by this function is in power-commutator form.   
If <TT>DisplayLevel</TT> is not supplied, the information displayed is 
determined by its existing (or default) value. 
</BLOCKQUOTE>
<H5><A NAME = "9541">RevertClass(~P) : GrpPCpQuotientProc -&gt;</A></H5>
<BLOCKQUOTE>
Given a pcp for the class c + 1 p-quotient of F, this procedure reverts 
to the pcp for the class c p-quotient of F.  Note that this command 
can be applied only <B>once</B> during construction of a single class.
</BLOCKQUOTE>
<H5><A NAME = "9542">pCoveringGroup(~P) : GrpPCpQuotientProc -&gt;</A></H5>
<H5>pCoveringGroup(G) : GrpPC -&gt; GrpPC</H5>
<BLOCKQUOTE>
Given a process or a pcp for a p-group, this procedure computes a 
pcp for the p-covering group of this group. In the process case, it 
is equivalent to <TT>Tails(~P); 
Consistency(~P); EliminateRedundancy(~P)</TT>.
</BLOCKQUOTE>
<H5><A NAME = "9543">GeneratorStructure(P) : GrpPCpQuotientProc -&gt;</A></H5>
<H5>GeneratorStructure(P, Start, Fin) : GrpPCpQuotientProc, RngIntElt, RngIntElt -&gt;</H5>
<BLOCKQUOTE>
Display the structure of the generators in the pcp. If <I>Start</I> and 
<I>Fin</I> are given, then print out the structure of those pcp generators
numbered from <I>Start</I> to <I>Fin</I>.
</BLOCKQUOTE>
<H5><A NAME = "9544">Jacobi(~P, c, b, a, ~r) : GrpPCpQuotientProc, RngIntElt, RngIntElt, RngIntElt -&gt; RngIntElt -&gt;</A></H5>
<H5>Jacobi(~P, c, b, a) : GrpPCpQuotientProc, RngIntElt, RngIntElt, RngIntElt -&gt; RngIntElt -&gt;</H5>
<BLOCKQUOTE>
Calculate the Jacobi c, b, a and echelonise the resulting relation against 
the current pcp. If a redundant generator results from  the echelonisation, 
the optional variable r is the number of that generator; 
otherwise r has value 0.
</BLOCKQUOTE>
<H5><A NAME = "9545">Collect(P, Q) : GrpPCpQuotientProc, [ &lt;RngIntElt, RngIntElt&gt; ] -&gt; [ RngIntElt ] -&gt;</A></H5>
<BLOCKQUOTE>
The sequence Q, consisting of generator-exponent pairs, defines a word w in 
the pcp generators of the group defined by the process P. 
Collect this word and return the resulting 
normal word as an exponent vector.
</BLOCKQUOTE>
<H5><A NAME = "9546">EcheloniseWord(~P, ~r) : GrpPCpQuotientProc -&gt; RngIntElt</A></H5>
<H5>EcheloniseWord(~P) : GrpPCpQuotientProc -&gt; RngIntElt</H5>
<BLOCKQUOTE>
Echelonise the word most recently collected using <TT>Collect</TT>
against the relations of the pcp. If a redundant generator results from
the echelonisation, the optional variable r is the number of that 
generator; otherwise r has value 0.  This function must be called 
immediately after <TT>Collect</TT>. 
</BLOCKQUOTE>
<H5><A NAME = "9547">SetDisplayLevel(~P, Level) : GrpPCpQuotientProc, RngIntElt -&gt;</A></H5>
<BLOCKQUOTE>
This procedure alters the display level for the process to the supplied
value, <TT>Level</TT>.
</BLOCKQUOTE>
<H5><A NAME = "9548">ExtractGroup(P) : GrpPCpQuotientProc -&gt; GrpPC</A></H5>
<BLOCKQUOTE>
Extract the group G defined by the pcp associated with the 
process P, as a member of the category <TT>GrpPC</TT> of finite soluble groups.
The function also returns the natural homomorphism &pi; from the original
group F to G, a sequence S describing the definitions of the
pc-generators of G and a flag indicating whether G is the maximal
p-quotient of F.
<P>
The k-th element of S is a sequence of two integers, describing the
definition of the k-th pc-generator G.k of G as follows.
<P>
<DL COMPACT class='compact'>
<DT>-</DT><DD>If S[k] = [0, r], then G.k is defined via the image of F.r under &pi;.
<P>
<DT>-</DT><DD>If S[k] = [r, 0], then G.k is defined via the power relation for G.r.
<P>
<DT>-</DT><DD>If S[k] = [r, s], then G.k is defined via the conjugate relation involving
G.r<sup>G.s</sup>.</DL>
</BLOCKQUOTE>
<H5><A NAME = "9549">Order(P) : GrpPCpQuotientProc -&gt; RngIntElt</A></H5>
<BLOCKQUOTE>
The order of the group defined by the pcp associated with the process P.
</BLOCKQUOTE>
<H5><A NAME = "9550">FactoredOrder(P) : GrpPCpQuotientProc -&gt; [ &lt;RngIntElt, RngIntElt&gt; ]</A></H5>
<BLOCKQUOTE>
The factored order of the group defined by the pcp associated with the 
process P.
</BLOCKQUOTE>
<H5><A NAME = "9551">NumberOfPCGenerators(P) : GrpPCpQuotientProc -&gt; RngIntElt</A></H5>
<BLOCKQUOTE>
The number of pc-generators of the group defined by the 
pcp associated with the process P.
</BLOCKQUOTE>
<H5><A NAME = "9552">pClass(P) : GrpPCpQuotientProc -&gt; RngIntElt</A></H5>
<BLOCKQUOTE>
The lower exponent-p class of the group defined by the 
pcp associated with the process P.
</BLOCKQUOTE>
<H5><A NAME = "9553">NuclearRank(G) : GrpPC -&gt; RngIntElt</A></H5>
<H5>NuclearRank(P) : GrpPCpQuotientProc -&gt; RngIntElt</H5>
<BLOCKQUOTE>
Return the rank of the p-multiplicator of the p-group G,
where G may be supplied or defined by the process P.
</BLOCKQUOTE>
<H5><A NAME = "9554">pMultiplicatorRank(G) : GrpPC -&gt; RngIntElt</A></H5>
<H5>pMultiplicatorRank(P) : GrpPCpQuotientProc -&gt; RngIntElt</H5>
<BLOCKQUOTE>
Return the rank of the p-multiplicator of the p-group G,
where G may be supplied or defined by the process P.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "9555">Example <TT>GrpFP_2_pQuotient5 (H76E9)</TT></A></H3>
Starting with an exponent 9 group having two generators 
of order 3, we set up the largest class 4 quotient and then interactively 
compute two more classes.
<P>
<P>
<PRE>
&gt; G&lt;a, b&gt; := Group&lt;a, b | a^3, b^3&gt;;
&gt; q := pQuotientProcess(G, 3, 4: Exponent := 9, Print :=1);


Lower exponent-3 central series for G


Group: G to lower exponent-3 central class 1 has order 3^2


Group: G to lower exponent-3 central class 2 has order 3^3


Group: G to lower exponent-3 central class 3 has order 3^5


Group: G to lower exponent-3 central class 4 has order 3^7
&gt; Display(q, 2);


Group: G to lower exponent-3 central class 4 has order 3^7


Non-trivial powers:
 .3^3 = .6^2


Non-trivial commutators:
[ .2, .1 ] = .3
[ .3, .1 ] = .4
[ .3, .2 ] = .5
[ .4, .1 ] = .6
[ .4, .2 ] = .7
[ .5, .1 ] = .7
[ .5, .2 ] = .6
</PRE>
We construct the class 5 quotient using the function <A  HREF = "text827.htm#GrpFP_2:NextClass">NextClass</A>.
<P>
<P>
<PRE>
&gt; NextClass(~q);


Group: G to lower exponent-3 central class 5 has order 3^9
</PRE>
We now construct the class 6 quotient step by step. For this, we set the
output level to 1.
<P>
<P>
<PRE>
&gt; SetDisplayLevel(~q, 1);
</PRE>
Now we start the next class.
<P>
<P>
<PRE>
&gt; StartNewClass(~q);
</PRE>
The first step is to add the tails.
<P>
<P>
<PRE>
&gt; Tails(~q);
</PRE>
After that, we apply the consistency algorithm, ... <PRE>
&gt; Consistency(~q);
</PRE> ... collect the defining relations, ... <PRE>
&gt; CollectRelations(~q);
</PRE> ... and enforce the exponent law.
<P>
<P>
<PRE>
&gt; ExponentLaw(~q);
</PRE>
Finally, we eliminate redundant generators.
<P>
<P>
<PRE>
&gt; EliminateRedundancy(~q);
</PRE>
This results in the following presentation for class 6 quotient.
<P>
<P>
<PRE>
&gt; Display(q, 2);


Group: G to lower exponent-3 central class 6 has order 3^11


Non-trivial powers:
 .3^3 = .6^2 .8^2 .10 .11


Non-trivial commutators:
[ .2, .1 ] = .3
[ .3, .1 ] = .4
[ .3, .2 ] = .5
[ .4, .1 ] = .6
[ .4, .2 ] = .7
[ .4, .3 ] = .8 .10^2 .11^2
[ .5, .1 ] = .7 .8 .9^2 .10^2 .11^2
[ .5, .2 ] = .6 .8 .9^2 .10^2
[ .5, .3 ] = .9^2 .11
[ .5, .4 ] = .10 .11
[ .6, .2 ] = .10^2
[ .7, .1 ] = .8
[ .7, .2 ] = .9
[ .7, .3 ] = .10^2 .11
[ .8, .2 ] = .10
[ .9, .1 ] = .11
</PRE>
<HR>
<H3><A NAME = "9556">Example <TT>GrpFP_2_pQuotient6 (H76E10)</TT></A></H3>
Starting with the free product of two cyclic groups of 
order 5, we bound the number of occurrences of pcp generators of the 
class 1 quotient in definitions of new pcp generators.
<P>
We start with setting up the class 1 quotient of the group.
<P>
<P>
<PRE>
&gt; G := Group&lt;a, b | a^5, b^5&gt;;
&gt; q := pQuotientProcess(G, 5, 1);
&gt; Display(q, 1);

Group: G to lower exponent-5 central class 1 has order 5^2
</PRE>
Now we start the next class, setting bounds on the number of occurrences of
the pcp generators of  the class 1 quotient in the definitions of new
pcp generators.
<P>
<P>
<PRE>
&gt; NextClass(~q, 6: MaxOccurrence := [3, 2]);
Group: G to lower exponent-5 central class 2 has order 5^3
Group: G to lower exponent-5 central class 3 has order 5^5
Group: G to lower exponent-5 central class 4 has order 5^7
Group: G to lower exponent-5 central class 5 has order 5^9

&gt; Display(q, 2);

Group: G to lower exponent-5 central class 5 has order 5^9

Non-trivial powers:

Non-trivial commutators:
[ .2, .1 ] = .3
[ .3, .1 ] = .4
[ .3, .2 ] = .5
[ .4, .1 ] = .6
[ .4, .2 ] = .7
[ .4, .3 ] = .8^4 .9
[ .5, .1 ] = .7 .8^4 .9
[ .6, .2 ] = .8
[ .7, .1 ] = .9
</PRE>
<HR>
<H3><A NAME = "9557">Example <TT>GrpFP_2_pQuotient7 (H76E11)</TT></A></H3>
We construct the class 6 quotient q of R(2, 5) and then 
partially construct the class 7 quotient interactively to find out how 
many normal words having initial segment q.1<sup>2</sup>  need to be considered 
when imposing the exponent law.
<P>
<P>
<P>
<PRE>
&gt; F := FreeGroup(2);
&gt; q := pQuotientProcess(F, 5, 6: Exponent := 5);

Lower exponent-5 central series for F
Group: F to lower exponent-5 central class 1 has order 5^2
Group: F to lower exponent-5 central class 2 has order 5^3
Group: F to lower exponent-5 central class 3 has order 5^5
Group: F to lower exponent-5 central class 4 has order 5^8
Group: F to lower exponent-5 central class 5 has order 5^10
Group: F to lower exponent-5 central class 6 has order 5^14

&gt; StartNewClass(~q);
&gt; Tails(~q);
&gt; Consistency(~q);
&gt; SetDisplayLevel(~q, 3);
&gt; ExponentLaw(~q, 1, 6: InitialSegment := [&lt;1, 2&gt;], Trial := true);
0 Relations of class 1 will be collected 
0 Relations of class 2 will be collected 
Will collect power 5 of the following word: 1^2 2^1 
1 Relation of class 3 will be collected 
Will collect power 5 of the following word: 1^2 2^2 
1 Relation of class 4 will be collected 
Will collect power 5 of the following word: 1^2 2^3 
Will collect power 5 of the following word: 1^2 5^1 
2 Relations of class 5 will be collected 
Will collect power 5 of the following word: 1^2 2^4 
Will collect power 5 of the following word: 1^2 2^1 4^1 
2 Relations of class 6 will be collected 

</PRE>
<HR>
<H3><A NAME = "9558">Example <TT>GrpFP_2_pQuotient8 (H76E12)</TT></A></H3>
We demonstrate several of the remaining procedures in the course
of interactively extending the class 6 quotient of the group
&lt;a, b, c, d | (bc<sup> - 1</sup>d)<sup>7</sup>, (cd<sup> - 1</sup>)<sup>7</sup>, (b, a) = c<sup> - 1</sup>, (c, a) = 1, (c, b) = d<sup> - 1</sup>&gt;
to class 7.
<P>
<P>
<PRE>
&gt; G := Group&lt;a, b, c, d | (b * c^-1 * d)^7, (c * d^-1)^7, (b,a) = c^-1,
&gt;                           (c,a) = 1, (c,b) = d^-1&gt;;
&gt; q := pQuotientProcess(G, 7, 6);

Lower exponent-7 central series for G
Group: G to lower exponent-7 central class 1 has order 7^2
Group: G to lower exponent-7 central class 2 has order 7^4
Group: G to lower exponent-7 central class 3 has order 7^6
Group: G to lower exponent-7 central class 4 has order 7^8
Group: G to lower exponent-7 central class 5 has order 7^11
Group: G to lower exponent-7 central class 6 has order 7^14

&gt; StartNewClass(~q);
&gt; Tails(~q);
&gt; GeneratorStructure(q, 15, 34);

Class 7
15 is defined on [12, 1] = 2 1 2 2 1 2 1 
16 is defined on [12, 2] = 2 1 2 2 1 2 2 
17 is defined on [13, 1] = 2 1 2 2 2 2 1 
18 is defined on [13, 2] = 2 1 2 2 2 2 2 
19 is defined on [14, 1] = 1 1 1 1 1 1 1 
20 is defined on [14, 2] = 1 1 1 1 1 1 2 
21 is defined on 14^7 = 1 1 1 1 1 1 1 
22 is defined on [9, 1] = 2 1 2 2 1 1 
23 is defined on [10, 1] = 2 1 2 2 2 1 
24 is defined on [11, 1] = 1 1 1 1 1 1 
25 is defined on [11, 2] = 1 1 1 1 1 2 
26 is defined on [8, 1] = 1 1 1 1 1 
27 is defined on [8, 2] = 1 1 1 1 2 
28 is defined on [5, 1] = 2 1 2 1 
29 is defined on [6, 1] = 1 1 1 1 
30 is defined on [6, 2] = 1 1 1 2 
31 is defined on [3, 1] = 2 1 1 
32 is defined on [4, 1] = 1 1 1 
33 is defined on [4, 2] = 1 1 2 
34 is defined on 2^7 = 2 2 

&gt; Jacobi(~q, 6, 6, 1);
Generator 26 is trivial
Jacobi was 6 6 1
&gt; Jacobi(~q, 3, 2, 1);
Generator 28 is redundant
Jacobi was 3 2 1
&gt; v := Collect(q,  [&lt;29, 2&gt;, &lt;26, -3&gt;]);
&gt; v;
[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
    0, 0, 0, 4, 0, 0, 2, 0, 0, 0, 0, 0 ]
&gt; EcheloniseWord(~q, ~redgen);
Generator 29 is trivial
&gt; Display(q, 1);

Group: G to lower exponent-7 central class 7 has order 7^34
</PRE>
Now we enforce the relations ... <PRE>
&gt; CollectRelations(~q);
</PRE> ... and apply the consistency algorithm.
<P>
<P>
<PRE>
&gt; Consistency(~q);
&gt; Display(q, 1);

Group: G to lower exponent-7 central class 7 has order 7^36

&gt; EliminateRedundancy(~q);
&gt; Display(q, 1);
Group: G to lower exponent-7 central class 7 has order 7^19
</PRE>
<HR>
<PRE></PRE> <A  HREF = "text828.htm">[Next]</A><A  HREF = "text826.htm">[Prev]</A> <A  HREF = "text828.htm">[Right]</A> <A  HREF = "text826.htm">[Left]</A> <A  HREF = "text823.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<br><small>Version: V2.22 of <I>
Thu Jun  9 16:37:49 EST 2016
</I></small>
</body></html>