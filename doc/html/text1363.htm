<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <link rel='stylesheet' href='help.css' type='text/css'>
  <TITLE>Automorphism Groups of  Curves</TITLE>
</head>
<body BGCOLOR="#FFFFFF">

 <A  HREF = "text1364.htm">[Next]</A><A  HREF = "text1362.htm">[Prev]</A> <A  HREF = "text1364.htm">[Right]</A> <A  HREF = "text1362.htm">[Left]</A> <A  HREF = "text1356.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<PRE></PRE><H3><A NAME = "15052">Automorphism Groups of  Curves</A></H3>

<P>
<P>
Magma  now (V2.13) contains functionality for computing the automorphism
group of a (reduced and irreducible) curve over a variety of base fields.
New structures have been added to aid the user in working with these
groups. An automorphism group is of type <TT>GrpAutCrv</TT> and there may be
several of these associated to a given curve: the full automorphism
group or a subgroup generated by a given set of automorphisms. The
automorphism group structure acts as a container for a permutation
group representation of the group of curve automorphisms along with
the map between the representing group and a list of the actual
automorphisms stored in a compressed format.
<P>
Elements of the group are of type <TT>GrpAutCrvElt</TT>, a subtype of 
<TT>MapAutSch</TT>. For these, all of the usual scheme-map operations are
available. However, a number of these are specially implemented for the
new type and there are also several new operations. In particular, 
composition and powering of elements makes use of the internal group
representation for speed and there are functions for the actions on
points, places, divisors etc. which are more efficient than those for
a general (finite) map between curves. There is also a function to
compute the matrix representation of an automorphism group on the
space of holomorphic differentials of the curve.
<P>
The full automorphism group is computed at function field level.
The algebraic function field versions of some of the functions here
are described in Section <A  HREF = "text449.htm#4622">General Automorphisms</A>.
<P>
It should be stressed that these groups are groups of <I>birational</I>
automorphisms of a curve C, in the usual way. This means that they are 
correspond to
actual automorphisms (ie, everywhere defined with an everywhere defined inverse) 
of the unique normalisation of C and the full automorphism group is the
full automorphism group of this normalisation. However, if C is
singular, then some of these automorphisms may not be defined
at particular singular points. 
<P>
There are also functions for computing isomorphisms between distinct
curves.
<P>
All functions require C to have a function field, whether the full
group of automorphisms is computed or not.
<P>
All of the functions computing the full set of automorphisms require 
the base field to be perfect (characteristic zero or finite).



<H5>Subsections</H5>
<UL>
<LI> <A  HREF = "text1363.htm#15053">Group Creation Functions</A>
<LI> <A  HREF = "text1363.htm#15059">Automorphisms</A>
<LI> <A  HREF = "text1363.htm#15070">Automorphism Group Operations</A>
<LI> <A  HREF = "text1363.htm#15081">Pullbacks and Pushforwards</A>
<LI> <A  HREF = "text1363.htm#15087">Quotients of Curves</A>
</UL>
<H4><A NAME = "15053">Group Creation Functions</A></H4>



<H5><A NAME = "15054">AutomorphismGroup(C) : Crv -&gt; GrpAutCrv</A></H5>
<BLOCKQUOTE>
Given a reduced, irreducible projective curve C, this function returns the 
full automorphism group of C over its base field.
If the genus of C is less than 2, an error 
results unless the base field is finite. Note that the full automorphism
group is cached so is only ever computed once.
</BLOCKQUOTE>
<H5><A NAME = "15055">AutomorphismGroup(C,auts) : Crv, SeqEnum -&gt; GrpAutCrv</A></H5>
<BLOCKQUOTE>
With C as above, this function returns the automorphism 
group of C generated by the sequence of automorphisms auts.
The sequence auts can consist of either scheme automorphisms of C of type
<TT>MapAutSch</TT> or <TT>GrpAutCrvElt</TT> elements lying in a previously
constructed automorphism group of C. The same restrictions on the
genus apply.
</BLOCKQUOTE>
<H5><A NAME = "15056">Automorphisms(C) : Crv -&gt; SeqEnum</A></H5>

<PRE>    Bound: RngIntElt                    Default: &infin;</PRE>
<BLOCKQUOTE>
For C as above, this function computes at most <TT>Bound</TT> 
automorphisms of C over its base field and returns them as a sequence 
of scheme maps (type <TT>MapSch</TT>). If <TT>Bound</TT> is
<TT>Infinity</TT> or at least the order of the full automorphism group, all
automorphisms will be returned.
</BLOCKQUOTE>
<H5><A NAME = "15057">IsIsomorphic(C, D) : Crv, Crv -&gt; BoolElt,MapSch</A></H5>
<BLOCKQUOTE>
Given irreducible curves C and D this function returns <TT>true</TT>
is C and D are isomorphic over their common base field. If so, it 
also returns a scheme map giving an isomorphism between them.  The 
curves C and D must be reduced.  Currently the function requires 
that the curves are not both genus 0 nor both genus 1 unless 
the base field is finite.
</BLOCKQUOTE>
<H5><A NAME = "15058">Isomorphisms(C, D) : Crv, Crv -&gt; SeqEnum</A></H5>

<PRE>    Bound: RngIntElt                    Default: &infin;</PRE>
<BLOCKQUOTE>
Given reduced, irreducible curves C and D this function returns at most 
<TT>Bound</TT> isomorphisms from C to D over their common base field. 
These are returned as a sequence of scheme maps. The genus restrictions
are as for <TT>IsIsomorphic</TT>.
</BLOCKQUOTE>
<H4><A NAME = "15059">Automorphisms</A></H4>



<H5><A NAME = "15060">A . i : GrpAutCrv, RngIntElt -&gt; GrpAutCrvElt</A></H5>
<BLOCKQUOTE>
Let A be a group of automorphisms of curve C and let i be an
integer such that -n &le;i &le;n, where n is the number of
generators of A. This operator returns the i-th generator for A. 
A negative subscript indicates that the inverse of the generator 
is to be created. Finally, A.0 denotes the identity of A.
<P>
Note that if A is an automorphism group that was generated from a
list of specified automorphisms, auts, then the generators of A
will not necessarily be these "user" generators, but will be those
coming from the permutation representation of A.
</BLOCKQUOTE>
<H5><A NAME = "15061">Identity(A) : GrpAutCrv -&gt; GrpAutCrvElt</A></H5>
<H5>Id(A) : GrpAutCrv -&gt; GrpAutCrvElt</H5>
<H5>A ! 1 : GrpAutCrv, RngIntElt -&gt; GrpAutCrvElt</H5>
<BLOCKQUOTE>
The identity element of the automorphism group A.
</BLOCKQUOTE>
<H5><A NAME = "15062">A ! f : GrpAutCrv, MapSch -&gt; GrpAutCrvElt</A></H5>
<H5>A ! f : GrpAutCrv, GrpAutCrvElt -&gt; GrpAutCrvElt</H5>
<BLOCKQUOTE>
Let A be an automorphism group of a curve C.  Given a scheme map 
f from C to C or an element of some (other) automorphism group of
C, this function returns the <TT>GrpAutCrvElt</TT> element 
of A corresponding to f.  An error will result if f is not in A.
</BLOCKQUOTE>
<H5><A NAME = "15063">Order(f) : GrpAutCrvElt -&gt; RngIntElt</A></H5>
<BLOCKQUOTE>
The order of the curve automorphism f.
</BLOCKQUOTE>
<H5><A NAME = "15064">Inverse(f) : GrpAutCrvElt -&gt; GrpAutCrvElt</A></H5>
<BLOCKQUOTE>
The inverse of the curve automorphism f.
</BLOCKQUOTE>
<H5><A NAME = "15065">f * g : GrpAutCrvElt, GrpAutCrvElt -&gt; GrpAutCrvElt</A></H5>
<BLOCKQUOTE>
The product of the curve automorphisms f and g in automorphism group A. 
If f and g are regarded 
as maps, this function returns their composite: first apply f, then apply g.
Note that this composition uses the permutation representation of A and is
generally performed faster than the usual scheme map composition. 
</BLOCKQUOTE>
<H5><A NAME = "15066">f ^ n : GrpAutCrvElt, RngIntElt -&gt; GrpAutCrvElt</A></H5>
<BLOCKQUOTE>
The nth power of the curve automorphism f. The integer n may be
positive or negative. Again, this uses the permutation representation
of A, the parent of f.
</BLOCKQUOTE>
<H5><A NAME = "15067">g eq h : GrpAutoElt, GrpAutoElt -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Given curve automorphisms g and h belonging to automorphism
groups of the same curve C, return <TT>true</TT> if g and h represent
the same automorphism, <TT>false</TT> otherwise. Note that g and h do not
have to belong to the same automorphism group.
</BLOCKQUOTE>
<H5><A NAME = "15068">g ne h : GrpAutoElt, GrpAutoElt -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
The logical negation of the preceding function.
</BLOCKQUOTE>
<H5><A NAME = "15069">SchemeMap(f) : GrpAutCrvElt -&gt; MapAutSch</A></H5>
<BLOCKQUOTE>
It is sometimes useful for the user to convert a curve automorphism back to an object of plain scheme 
isomorphism type. This is a convenience function that simply returns the curve automorphism f as a 
<TT>MapAutSch</TT>.
</BLOCKQUOTE>
<H4><A NAME = "15070">Automorphism Group Operations</A></H4>



<H5><A NAME = "15071">Curve(A) : GrpAutCrv -&gt; Crv</A></H5>
<BLOCKQUOTE>
The curve of which A is a group of automorphisms.
</BLOCKQUOTE>
<H5><A NAME = "15072">Order(A) : GrpAutCrv -&gt; RngIntElt</A></H5>
<BLOCKQUOTE>
The order of A.
</BLOCKQUOTE>
<H5><A NAME = "15073">FactoredOrder(A) : GrpAutCrv -&gt; [ &lt;RngIntElt, RngIntElt&gt; ]</A></H5>
<BLOCKQUOTE>
The factored order of A.
</BLOCKQUOTE>
<H5><A NAME = "15074">NumberOfGenerators(A) : GrpAutCrv -&gt; RngIntElt</A></H5>
<H5>Ngens(A) : GrpAutCrv -&gt; RngIntElt</H5>
<BLOCKQUOTE>
The number of generators of A. If A was defined as the
group generated by a given sequence of automorphisms, this
sequence will not necessarily coincide with the set of generators,
which is determined by the internal permutation representation.
</BLOCKQUOTE>
<H5><A NAME = "15075">Generators(A) : GrpAutCrv -&gt; SeqEnum</A></H5>
<BLOCKQUOTE>
The generators of A - a small set of <TT>GrpAutCrvElt</TT> elements
of A, which generate it as a group - returned in a sequence.
</BLOCKQUOTE>
<H5><A NAME = "15076">PermutationGroup(A) : GrpAutCrv -&gt; GrpPerm</A></H5>
<BLOCKQUOTE>
The permutation group of A which gives the abstract group
representation of the automorphism group.
</BLOCKQUOTE>
<H5><A NAME = "15077">PermutationRepresentation(A) : GrpAutCrv -&gt; GrpPerm, Map</A></H5>
<BLOCKQUOTE>
The permutation group representation of A consisting of
the actual permutation group G and an invertible map
which takes elements of G to the corresponding curve
automorphism (as a <TT>GrpAutCrvElt</TT> element).
</BLOCKQUOTE>
<H5><A NAME = "15078">MatrixRepresentation(A) : GrpAutCrv -&gt; Grpmat, Map, SeqEnum</A></H5>
<BLOCKQUOTE>
For an automorphism group A on a curve C of genus at least 2, computes
the matrix representation of A acting on the space of holomorphic differentials
by pullback. The differentials are represented by row vectors with respect to a
basis B and the matrix associated to g &isin;A gives the pullback action of
g by right multiplication of the row vectors. The (finite) matrix group image G
is returned along with a map from A to G giving the representation and an
enumerated sequence containing the basis of differentials B used.
</BLOCKQUOTE>
<H5><A NAME = "15079">a in A: GrpAutCrvElt, GrpAutCrv -&gt; BoolElt</A></H5>
<H5>phi in A: MapSch, GrpAutCrv -&gt; BoolElt</H5>
<BLOCKQUOTE>
Returns whether a curve automorphism, given as a <TT>GrpAutCrvElt</TT>
or <TT>MapSch</TT>, is equal to an automorphism lying in A.
</BLOCKQUOTE>
<H5><A NAME = "15080">A subset B: GrpAutCrv, GrpAutCrv -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns whether A is actually a subgroup of B as automorphism
groups of the same curve.
</BLOCKQUOTE>
<H4><A NAME = "15081">Pullbacks and Pushforwards</A></H4>

<P>
<P>
<P>
For <TT>GrpAutCrvElt</TT> elements, pullbacks and pushforwards (images)
of functions, places, divisors and differentials of the curve C are
handled more directly than for general curve maps. The functions
to perform these operations use the more direct <TT>f(x)</TT> and
<TT>x @@ f</TT> syntax and these should be used in preference to the
<TT>Pushforward</TT> and <TT>Pullback</TT> functions in 
Section <A  HREF = "text1362.htm#15046">Maps Induced by Morphisms</A>.
<P>
In addition, the computation of images of points on C by a curve
automorphism is handled slightly differently. If the point doesn't
lie in the original domain of definition of the scheme map giving the
automorphism, the image is still computed without extending the 
map (although for some singular points of the curve model, the image may
still not exist for the "birational" automorphism).


<H5><A NAME = "15082">f(X): GrpAutCrvElt, Pt -&gt; Pt</A></H5>
<H5>f(X): GrpAutCrvElt, FldFunFracSchElt -&gt; FldFunFracSchElt</H5>
<H5>f(X): GrpAutCrvElt, PlcCrvElt -&gt; PlcCrvElt</H5>
<H5>f(X): GrpAutCrvElt, DivCrvElt -&gt; DivCrvElt</H5>
<H5>f(X): GrpAutCrvElt, DiffCrvElt -&gt; DiffCrvElt</H5>
<H5>X @ f: Pt, GrpAutCrvElt -&gt; Pt</H5>
<H5>X @ f: FldFunFracSchElt, GrpAutCrvElt -&gt; FldFunFracSchElt</H5>
<H5>X @ f: PlcCrvElt, GrpAutCrvElt -&gt; PlcCrvElt</H5>
<H5>X @ f: DivCrvElt, GrpAutCrvElt -&gt; DivCrvElt</H5>
<H5>X @ f: DiffCrvElt, GrpAutCrvElt -&gt; DiffCrvElt</H5>
<BLOCKQUOTE>
Given a curve automorphism f of curve C and a point, function, differential, place or divisor X on C, this function returns the image
(or pushforward) of X under f.
</BLOCKQUOTE>
<H5><A NAME = "15083">X @@ f: FldFunFracSchElt, GrpAutCrvElt -&gt; FldFunFracSchElt</A></H5>
<H5>X @@ f: PlcCrvElt, GrpAutCrvElt -&gt; PlcCrvElt</H5>
<H5>X @@ f: DivCrvElt, GrpAutCrvElt -&gt; DivCrvElt</H5>
<H5>X @@ f: DiffCrvElt, GrpAutCrvElt -&gt; DiffCrvElt</H5>
<BLOCKQUOTE>
Given a curve automorphism f of curve C and a function, differential, place or divisor X on C, this function returns the inverse image
(or pullback) of X under f.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "15084">Example <TT>Crv_crv_autos (H120E19)</TT></A></H3>
Here are some examples of the above functions applied to the
genus 3 Fermat curve in characteristic 0.
<P>
<P>
<PRE>
&gt; P&lt;x,y,z&gt; := ProjectiveSpace(Rationals(),2);
&gt; C := Curve(P,x^4+y^4+z^4);
&gt; L := Automorphisms(C);
&gt; #L;
24
&gt; // to get all automorphisms, we base change to Q(zeta_8)
&gt; K := CyclotomicField(8);
&gt; C1 := BaseChange(C,K);
&gt; L1 := Automorphisms(C1);
&gt; #L1;
96
&gt; // next, we get the automorphism as a group 
&gt; G := AutomorphismGroup(C1);
&gt; g := G!iso&lt;C1 -&gt; C1 | [y,z,x],[z,x,y]&gt;;
&gt; Gp,rep := PermutationRepresentation(G);
&gt; Gp;
Permutation group Gp acting on a set of cardinality 12
Order = 96 = 2^5 * 3
    (2, 4)(3, 5)(6, 8)(7, 10)
    (2, 5, 10, 8, 4, 3, 7, 6)(11, 12)
    (1, 2, 3)(4, 5, 9)(6, 11, 7)(8, 12, 10)
&gt; rep(g);
(1, 8, 4)(2, 9, 6)(3, 10, 11)(5, 7, 12)
&gt; Inverse(rep)(Gp.2);
Mapping from: CrvPln: C1 to CrvPln: C1
with equations :
zeta_8^2*$.1^3*$.3
$.1^3*$.2
$.2^4 + $.3^4
and inverse
zeta_8^2*$.1^3*$.3
-zeta_8^2*$.1^3*$.2
$.2^4 + $.3^4
&gt; $1 eq G.2;
true
</PRE>
<HR>
<H3><A NAME = "15085">Example <TT>Crv_crv-iso (H120E20)</TT></A></H3>
In the next example we look at a superelliptic curve over GF(7<sup>2</sup>)
with isomorphism group a central extension of PGL<sub>2</sub>(F<sub>7</sub>) by a cyclic
group of order 4.
<P>
<P>
<PRE>
&gt; SetSeed(1);
&gt; k := GF(7^2);
&gt; A&lt;x,y&gt; := AffineSpace(k,2);
&gt; C := ProjectiveClosure(Curve(A,y^4-x^7+x));
&gt; G := AutomorphismGroup(C);
&gt; Gp,rep := PermutationRepresentation(G);
&gt; Gp;
Permutation group G acting on a set of cardinality 192
Order = 1344 = 2^6 * 3 * 7
&gt; [Order(G.i) : i in [1..Ngens(G)]];
[ 7, 24, 2 ]
&gt; Z := Centre(Gp); Z;
Permutation group Z acting on a set of cardinality 192
Order = 4 = 2^2
&gt; (Z.1)@@rep;
Mapping from: CrvPln: C to CrvPln: C
with equations :
$.1
k.1^12*$.2
$.3
and inverse
$.1
k.1^36*$.2
$.3
&gt; Gp1 := quo&lt;Gp|Z&gt;;
&gt; boo := IsIsomorphic(Gp1,PGL(2,GF(7)));
&gt; boo;
true
&gt; // Find the representation on the 176 Weierstrass places.
&gt; // Only need the action of the generators of Gp (or G)
&gt; wpls := WeierstrassPlaces(C);
&gt; wpls_perms := [[Index(wpls,g(w)) : w in wpls]: g in Generators(G)];
&gt; G_wpls := SymmetricGroup(#wpls);
&gt; weier_rep := hom&lt;Gp-&gt;G_wpls|[G_wpls!p : p in wpls_perms]&gt;;
&gt; //Check that its faithful
&gt; K := Kernel(weier_rep);
&gt; #K;
1
</PRE>
<HR>
<H3><A NAME = "15086">Example <TT>Crv_crv-iso (H120E21)</TT></A></H3>
<P>
The next example illustrates the use of <TT>IsIsomorphic</TT> in finding
an isomorphism between the well-known plane model of genus 3 curve X(7) 
and a degree 6 model of it in P<sup>3</sup>. The isomorphism between C and D 
is only computed in one direction, but we can then use <TT>IsInvertible</TT>.
<P>
<P>
<P>
<PRE>
&gt; P2&lt;x,y,z&gt; := ProjectiveSpace(Rationals(),2);
&gt; C := Curve(P2,x^3*y+y^3*z+z^3*x);
&gt; P3&lt;a,b,c,d&gt; := ProjectiveSpace(Rationals(),3);
&gt; D := Curve(P3,[b^2-a*d,a*b*c+b*d^2+c^3]);
&gt; boo,im := IsIsomorphic(C,D);
&gt; boo;
true
&gt; im;
Mapping from: CrvPln: C to Crv: D
with equations :
x^2
x*z
y*z
z^2
&gt; _,imi := IsInvertible(im);
&gt; Inverse(imi);
Mapping from: CrvPln: C to Crv: D
with equations :
x^2
x*z
y*z
z^2
and inverse
b
c
d
</PRE>
<P>
We now compute the automorphism group of C over GF(11<sup>3</sup>) where
the full set of 168 automorphisms exists (the group is isomorphic to
PSL<sub>2</sub>(F<sub>7</sub>)) and generate some subgroups.
<P>
<P>
<P>
<PRE>
&gt; P2&lt;x,y,z&gt; := ProjectiveSpace(GF(11^3),2);
&gt; C := Curve(P2,x^3*y+y^3*z+z^3*x);
&gt; G := AutomorphismGroup(C);
&gt; Order(G);
168
&gt; [Order(g) : g in Generators(G)];
[ 7, 3, 7 ]
&gt; G1 := AutomorphismGroup(C,[G.1,G.2]);
&gt; Order(G1);
21
&gt; PermutationGroup(G1);
Permutation group acting on a set of cardinality 8
Order = 21 = 3 * 7
    (2, 4, 3, 7, 5, 8, 6)
    (3, 5, 4)(6, 8, 7)
&gt; // can also find the normaliser of &lt;G.3&gt; via the 
&gt; // permutation rep
&gt; Gp,rep := PermutationRepresentation(G);
&gt; H := Normaliser(Gp,sub&lt;Gp|Gp.3&gt;);
&gt; #H;
21
&gt; Hgens := [g@@rep : g in Generators(H)];
&gt; [Order(g) : g in Hgens];
[ 3, 7 ]
&gt; h := Hgens[1];
&gt; //check directly that h normalises &lt;g&gt; in G
&gt; g := G.3;
&gt; Index([g^i : i in [1..7]],h*g*(h^-1));
4
</PRE>
<HR>
<H4><A NAME = "15087">Quotients of Curves</A></H4>

<P>
<P>
For G an arbitrary group of automorphisms of a curve C
of genus &gt;= 2, the main intrinsic in this section
computes a model of the quotient curve C/G along with
the explicit projection map C -&gt; C/G.


<H5><A NAME = "15088">CurveQuotient(G): GrpAutCrv -&gt; Crv, MapSch</A></H5>
<BLOCKQUOTE>
The argument G is a group of automorphisms of a curve C/k, which must be
of genus g &gt;= 2. The function computes a projective, non-singular
model of C/G, the scheme theoretic quotient of C by G. This is
returned with the G-invariant projection map from C down to it.
<P>
If k(C) is the function field of C then C/G can be thought of
as the curve with function field k(C)<sup>G<sup> * </sup></sup> where G<sup> * </sup> is the
group of field automorphisms of k(C)/k induced by G under
function pull-back.
<P>
<P>
<P>
The implementation utilises Magma's Function Field and
Invariant Theory functionality and uses a variety of methods.
There is no restriction on the characteristic p and the function
works in positive characteristic as long as the following assumption
is true:
<P>
<P>
<P>
{C -&gt; C/G is tamely ramified 
			when genus(C/G) &gt; 1}
<P>
<P>
<P>
This is equivalent to saying that, for all points P on
(the non-singular, projective model of) C, the subgroup 
G<sub>P</sub> of G fixing P has order prime to p. In practise,
this will only be a problem for very small p &gt; 0 when
p | #G.
<P>
<P>
<P>
The algorithm used is slightly different depending on g<sub>G</sub>,
the genus of the quotient curve.
<P>
When g<sub>G</sub> &gt;= 2 and the quotient is non-hyperelliptic, the
canonical image of C/G is computed and this is the model
returned. This uses function field functionality only.
<P>
The case g<sub>G</sub> &gt;= 2 and the quotient is hyperelliptic is
similar, only extra work is needed to find the "y-coordinate".
Again everything is done purely with function fields. The
model returned is a <TT>CrvHyp</TT> Weierstrass model if the
quotient is hyperelliptic over k, or a bi-quadratic model
in P<sup>3</sup> if it is only geometrically hyperelliptic.
<P>
When g<sub>G</sub> is 0 or 1, the canonical map methodology used in the
above cases fails and we use a combination of Invariant theory
and function field methods instead.
<P>
For g<sub>G</sub> = 0, the model returned for C/G is either the
projective line P<sup>1</sup> or a conic in P<sup>2</sup>.
In this case, the
function does not automatically search for k-rational points
so, if a conic is returned, the quotient may still be
isomorphic to P<sup>1</sup> over k.
<P>
For g<sub>G</sub> = 1, the model returned is a projectively normal
embedding by quadrics in P<sup>n</sup>, n &gt;= 3, or a cubic in P<sup>2</sup>.
Again, the function does not search for k-rational points
in order to try to convert the quotient into elliptic curve
form.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "15089">Example <TT>Crv_crv_quots (H120E22)</TT></A></H3>
We start with our old friend the Klein quartic again - this time over
Q. The quotient by an automorphism of order 3 is a genus 1 curve.
We find this quotient and produce an isomorphism from this to an
elliptic curve using the rational point that is the projection of
(0:0:1).
<P>
<P>
<PRE>
&gt; P2&lt;x,y,z&gt; := ProjectiveSpace(Rationals(),2);
&gt; C := Curve(P2,x^3*y+y^3*z+z^3*x);
&gt; phi := iso&lt;C-&gt;C|[y,z,x],[z,x,y]&gt;;
&gt; // we will take the quotient by phi
&gt; G := AutomorphismGroup(C,[phi]);
&gt; CG,prj := CurveQuotient(G);
&gt; CG;
Curve over Rational Field defined by
x[1]^2 - 13*x[1]*x[2] + 8*x[1]*x[3] + 10*x[2]*x[3] - 6*x[3]^2 + 15*x[1]*x[4] +
    3*x[2]*x[4] - 6*x[3]*x[4] - 6*x[4]^2,
x[1]^2 - 12*x[1]*x[2] + 3*x[2]^2 + 8*x[1]*x[3] + 12*x[1]*x[4]
&gt; Genus(CG);
1
&gt; // find a minimal elliptic Weierstrass model
&gt; ptCG := prj(C![0,0,1]);
&gt; E1, psi1 := EllipticCurve(CG,ptCG);
&gt; E, psi := MinimalModel(E1);
&gt; prj := Expand(prj * psi1 * psi); // get the composite map C -&gt; E
&gt; E;
Elliptic Curve defined by y^2 + x*y = x^3 - x^2 - 2*x - 1 over Rational Field
&gt; prj;
Mapping from: CrvPln: C to CrvEll: E
with equations :
-2*x^2*y^8 + 2*x*y^8*z - 2*y^9*z - 2*x*y^7*z^2 - 2*x^2*y^5*z^3 + 2*x*y^6*z^3 -
    2*y^7*z^3 + 2*x^2*y^4*z^4 - 2*x^2*y^3*z^5 - 2*y^4*z^6 + 2*y^3*z^7 -
    2*y^2*z^8
4*x^2*y^8 - 2*x*y^9 - 2*x^2*y^7*z - 2*x*y^8*z + 4*y^9*z + 2*x^2*y^6*z^2 +
    4*x*y^7*z^2 - 2*y^8*z^2 + 2*x^2*y^5*z^3 - 4*x*y^6*z^3 + 4*y^7*z^3 -
    4*x^2*y^4*z^4 + 2*x*y^5*z^4 - 2*y^6*z^4 + 4*x^2*y^3*z^5 + 2*y^5*z^5 -
    2*x^2*y^2*z^6 + 2*y^4*z^6 - 4*y^3*z^7 + 4*y^2*z^8 - 2*y*z^9
2*x*y^8*z - 2*x^2*y^5*z^3 - 2*y^4*z^6
&gt; Conductor(E);
49
</PRE>
<P>
In fact, C is the modular curve X(7) and E is X<sub>0</sub>(49). That
C/G and E are isogenous elliptic curves also follows from modular
form theory.
<HR>
<H3><A NAME = "15090">Example <TT>Crv_crv_quots (H120E23)</TT></A></H3>
As a second example we consider the genus 4 modular curve X<sub>0</sub>(54) with
the two commuting Atkin-Lehner involutions W<sub>2</sub>, W<sub>27</sub>. We compute the
quotients by &lt;W<sub>2</sub>&gt;, &lt;W<sub>27</sub>&gt; and &lt;W<sub>2</sub>, W<sub>27</sub>&gt; which respectively have
genera 2,1,0.
<P>
<P>
<P>
<PRE>
&gt; P&lt;[x]&gt; := ProjectiveSpace(Rationals(),3);
&gt; X054 := Curve(P,[
&gt;   x[2]*x[3] - x[1]*x[4], 4*x[1]^2*x[2] + 2*x[1]*x[2]^2 +
&gt;       x[2]^3 - x[3]^3 + x[3]^2*x[4] - x[3]*x[4]^2]);
&gt; W2 := iso&lt;X054-&gt;X054|[1/2*x[4],-x[3],-x[2],2*x[1]],
&gt;                 [1/2*x[4],-x[3],-x[2],2*x[1]]&gt;;
&gt; W27 := iso&lt;X054-&gt;X054|
&gt; [
&gt;     -1/3*x[1] - 1/3*x[2] - 1/3*x[3] - 1/3*x[4],
&gt;     -2/3*x[1] - 2/3*x[2] + 1/3*x[3] + 1/3*x[4],
&gt;     -2/3*x[1] + 1/3*x[2] - 2/3*x[3] + 1/3*x[4],
&gt;     -4/3*x[1] + 2/3*x[2] + 2/3*x[3] - 1/3*x[4]
&gt; ],
&gt; [
&gt;     -1/3*x[1] - 1/3*x[2] - 1/3*x[3] - 1/3*x[4],
&gt;     -2/3*x[1] - 2/3*x[2] + 1/3*x[3] + 1/3*x[4],
&gt;     -2/3*x[1] + 1/3*x[2] - 2/3*x[3] + 1/3*x[4],
&gt;     -4/3*x[1] + 2/3*x[2] + 2/3*x[3] - 1/3*x[4]
&gt; ]&gt;;
&gt; // 1. Quotient by &lt;W2&gt;
&gt; G := AutomorphismGroup(X054,[W2]);
&gt; CG,prj := CurveQuotient(G);
&gt; CG;
Hyperelliptic Curve defined by y^2 + (-x^2 - 1)*y = 387*x^6 + 999*x^5 + 785*x^4
    + 294*x^3 + 58*x^2 + 6*x over Rational Field
&gt; Genus(CG);
2
&gt; // 2. Quotient by &lt;W27&gt;
&gt; G := AutomorphismGroup(X054,[W27]);
&gt; CG,prj := CurveQuotient(G);
&gt; CG;
Curve over Rational Field defined by
1878243840*x[1]*x[2] - 68400*x[2]^2 - 680252400*x[1]*x[3] - 774110424*x[2]*x[3]
    + 246079248*x[3]^2 + 1252162560*x[1]*x[4] - 298086240*x[2]*x[4] -
    834823168*x[3]*x[4] - 2254334400*x[1]*x[5] - 447968988*x[2]*x[5] +
    18*x[3]*x[5] + 936*x[4]*x[5] + 346615560*x[1]*x[6] + 63486504*x[2]*x[6] -
    1620*x[5]*x[6] + 14787*x[6]^2,
-4225630080*x[1]*x[2] + 152304*x[2]^2 + 1530412160*x[1]*x[3] +
    1741572584*x[2]*x[3] - 553624072*x[3]^2 - 2817086720*x[1]*x[4] +
    670624096*x[2]*x[4] + 1878164832*x[3]*x[4] + 5071740600*x[1]*x[5] +
    1007828352*x[2]*x[5] - 1824*x[4]*x[5] - 779805580*x[1]*x[6] -
    142830348*x[2]*x[6] + 4*x[3]*x[6] + 3870*x[5]*x[6] - 33021*x[6]^2,
-14377204800*x[1]*x[2] + 512928*x[2]^2 + 5207031920*x[1]*x[3] +
    5925482424*x[2]*x[3] - 1883642044*x[3]^2 - 9584803200*x[1]*x[4] +
    2281707168*x[2]*x[4] + 6390228448*x[3]*x[4] + 64*x[4]^2 +
    17255963160*x[1]*x[5] + 3429009288*x[2]*x[5] - 5472*x[4]*x[5] -
    2653188900*x[1]*x[6] - 485962956*x[2]*x[6] + 14040*x[5]*x[6] -
    111537*x[6]^2,
762945840*x[1]*x[2] - 27648*x[2]^2 - 276319320*x[1]*x[3] - 314444676*x[2]*x[3] +
    99957860*x[3]^2 + 508630560*x[1]*x[4] - 121082832*x[2]*x[4] -
    339106480*x[3]*x[4] - 915713640*x[1]*x[5] - 181965582*x[2]*x[5] +
    360*x[4]*x[5] + 140795640*x[1]*x[6] + 25788312*x[2]*x[6] - 675*x[5]*x[6] +
    5985*x[6]^2,
559393920*x[1]*x[2] - 18864*x[2]^2 - 202594400*x[1]*x[3] - 230548712*x[2]*x[3] +
    73289896*x[3]^2 + 372929280*x[1]*x[4] - 88775136*x[2]*x[4] -
    248632672*x[3]*x[4] - 671395320*x[1]*x[5] - 133415856*x[2]*x[5] +
    103229820*x[1]*x[6] + 18907956*x[2]*x[6] + 16*x[4]*x[6] - 702*x[5]*x[6] +
    4167*x[6]^2,
488083680*x[1]*x[2] - 16272*x[2]^2 - 176767680*x[1]*x[3] - 201158520*x[2]*x[3] +
    63947136*x[3]^2 + 325389120*x[1]*x[4] - 77457888*x[2]*x[4] -
    216937408*x[3]*x[4] - 585806400*x[1]*x[5] - 116408124*x[2]*x[5] + 81*x[5]^2
    + 90070080*x[1]*x[6] + 16497576*x[2]*x[6] - 648*x[5]*x[6] + 3609*x[6]^2,
-103229280*x[1]*x[2] + 3456*x[2]^2 + 37386240*x[1]*x[3] + 42544872*x[2]*x[3] -
    13524760*x[3]^2 - 68819520*x[1]*x[4] + 16382304*x[2]*x[4] +
    45882080*x[3]*x[4] + 123897600*x[1]*x[5] + 24620220*x[2]*x[5] -
    19049760*x[1]*x[6] - 3489228*x[2]*x[6] + 135*x[5]*x[6] - 765*x[6]^2,
5219280*x[1]*x[2] - 216*x[2]^2 - 1890360*x[1]*x[3] - 2151168*x[2]*x[3] +
    683800*x[3]^2 + 3479520*x[1]*x[4] - 828384*x[2]*x[4] - 2319840*x[3]*x[4] -
    6264540*x[1]*x[5] - 1244862*x[2]*x[5] + 963210*x[1]*x[6] + 176418*x[2]*x[6]
    + 45*x[6]^2,
52200*x[1]*x[2] - 18900*x[1]*x[3] - 21510*x[2]*x[3] + 6840*x[3]^2 +
    34800*x[1]*x[4] - 8280*x[2]*x[4] - 23200*x[3]*x[4] - 62640*x[1]*x[5] -
    12447*x[2]*x[5] + 9630*x[1]*x[6] + 1764*x[2]*x[6]
&gt; Genus(CG);
1
&gt; // 3. Quotient by &lt;W2,W27&gt;
&gt; G := AutomorphismGroup(X054,[W2,W27]);
&gt; CG,prj := CurveQuotient(G);
&gt; CG;
Curve over Rational Field defined by
0
&gt; Ambient(CG);
Projective Space of dimension 1
Variables : $.1, $.2
</PRE>
<HR>
<PRE></PRE> <A  HREF = "text1364.htm">[Next]</A><A  HREF = "text1362.htm">[Prev]</A> <A  HREF = "text1364.htm">[Right]</A> <A  HREF = "text1362.htm">[Left]</A> <A  HREF = "text1356.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<br><small>Version: V2.22 of <I>
Thu Jun  9 16:37:49 EST 2016
</I></small>
</body></html>