<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <link rel='stylesheet' href='help.css' type='text/css'>
  <TITLE>Modules over a Matrix Algebra</TITLE>
</head>
<body BGCOLOR="#FFFFFF">

 <A  HREF = "text1026.htm">[Next]</A><A  HREF = "text1024.htm">[Prev]</A> <A  HREF = "text1026.htm">[Right]</A> <A  HREF = "text1024.htm">[Left]</A> <A  HREF = "text1023.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<PRE></PRE><H3><A NAME = "11421">Modules over a Matrix Algebra</A></H3>

<P>
<P>
This section describes function dealing with modules over a matrix
algebra, for which there are the most number of operations available.



<H5>Subsections</H5>
<UL>
<LI> <A  HREF = "text1025.htm#11422">Construction of an A-Module</A>
<LI> <A  HREF = "text1025.htm#11430">Accessing Module Information</A>
<LI> <A  HREF = "text1025.htm#11443">Standard Constructions</A>
<LI> <A  HREF = "text1025.htm#11452">Element Construction and  Operations</A>
<LI> <A  HREF = "text1025.htm#11476">Submodules</A>
<LI> <A  HREF = "text1025.htm#11489">Quotient Modules</A>
<LI> <A  HREF = "text1025.htm#11493">Structure of a Module</A>
<LI> <A  HREF = "text1025.htm#11519">Decomposability and Complements</A>
<LI> <A  HREF = "text1025.htm#11525">Lattice of Submodules</A>
<LI> <A  HREF = "text1025.htm#11553">Homomorphisms</A>
</UL>
<H4><A NAME = "11422">Construction of an A-Module</A></H4>



<H5><A NAME = "11423">General Constructions</A></H5>



<H5><A NAME = "11424">RModule(A) : AlgMat -&gt; ModRng</A></H5>
<BLOCKQUOTE>
Given a subalgebra A of M<sub>n</sub>(K), create the right A-module 
M with underlying vector space K<sup>(n)</sup>, where the action of 
a &isin;A is given by m * a, m &isin;M.
</BLOCKQUOTE>
<H5><A NAME = "11425">RModule(Q) : [ MtrxS ] -&gt; ModTupRng</A></H5>
<BLOCKQUOTE>
Given the subalgebra A of M<sub>n</sub>(K) generated by the terms of
the sequence Q, create the right A-module M with underlying 
vector space K<sup>(n)</sup>, where the action of a &isin;A is given by 
m * a, m &isin;M.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "11426">Example <TT>ModAlg_CreateK6 (H95E1)</TT></A></H3>
We construct the 6-dimensional module over GF(2) with an
action given by the matrices
<PRE>
     [0 1 1 0 1 0]
     [0 0 1 1 1 1]
     [1 0 0 1 0 1]
     [0 0 0 1 0 0]
     [0 0 0 0 1 0]
     [0 0 0 0 0 1],

     [1 0 0 1 0 1]
     [0 1 0 0 1 1]
     [0 1 1 1 1 0]
     [0 0 0 1 1 0]
     [0 0 0 1 0 1]
     [0 1 0 1 0 0]
</PRE>
<P>
<PRE>
&gt; A := MatrixAlgebra&lt;GF(2), 6 |
&gt;   [ 1,0,0,1,0,1, 
&gt;     0,1,0,0,1,1, 
&gt;     0,1,1,1,1,0, 
&gt;     0,0,0,1,1,0, 
&gt;     0,0,0,1,0,1,
&gt;     0,1,0,1,0,0 ],
&gt;   [ 0,1,1,0,1,0,
&gt;     0,0,1,1,1,1,
&gt;     1,0,0,1,0,1,
&gt;     0,0,0,1,0,0,
&gt;     0,0,0,0,1,0,
&gt;     0,0,0,0,0,1 ] &gt;;
&gt; M := RModule(A);
&gt; M;
RModule M of dimension 6 over GF(2)
</PRE>
<HR>
<H5><A NAME = "11427">Constructions for K[G]-Modules</A></H5>

<P>
<P>
<P>
Although K[G]-modules are discussed in the next chapter, it is
convenient to use them as examples in this chapter and so we give
two basic constructions here. The reader is referred to the
K[G]-module chapter for many other techniques for constructing 
these modules.


<H5><A NAME = "11428">GModule(G, Q) : Grp, [ MtrxS ] -&gt; ModGrp</A></H5>

<PRE>    Check: BoolElt                      Default: <TT>true</TT></PRE>
<BLOCKQUOTE>
Let G be a group defined on r generators and let Q be a sequence
of r invertible elements of M<sub>n</sub>(K) or GL(n, K). It is assumed that
the mapping from G to Q defined by
&phi;(G.i) |-&gt; Q[i], for i = 1, ..., r,
is a group homomorphism from G into GL(n, K). The function constructs 
a K[G]-module M of dimension n, where the action of the generators 
of G is given by the terms of Q.
</BLOCKQUOTE>
<H5><A NAME = "11429">PermutationModule(G, K) : GrpPerm, Fld -&gt; ModGrp</A></H5>
<BLOCKQUOTE>
Given a permutation group G and a field K, create the
natural permutation module for G over K.
</BLOCKQUOTE>
<H4><A NAME = "11430">Accessing Module Information</A></H4>

<P>
<P>
<P>
This section deals with the underlying vector space of a module M,
which is a module over the algebra A.


<H5><A NAME = "11431">The Underlying Vector Space</A></H5>



<H5><A NAME = "11432">M . i : ModRng, RngIntElt -&gt; ModElt</A></H5>
<BLOCKQUOTE>
Given an A-module M and a positive integer i, return the i-th 
generator of M.
</BLOCKQUOTE>
<H5><A NAME = "11433">CoefficientRing(M) : ModRng -&gt; Rng</A></H5>
<H5>BaseRing(M) : ModRng -&gt; Rng</H5>
<BLOCKQUOTE>
Given an A-module M, where A is an algebra over the field K,
return K.
</BLOCKQUOTE>
<H5><A NAME = "11434">Generators(M) : ModRng -&gt; { ModRngElt }</A></H5>
<BLOCKQUOTE>
The generators for the A-module M, returned as a set.
</BLOCKQUOTE>
<H5><A NAME = "11435">Parent(u) : ModRngElt -&gt; ModRng</A></H5>
<BLOCKQUOTE>
Given an element u belonging to the A-module M, return M.
</BLOCKQUOTE>
<H5><A NAME = "11436">The Algebra</A></H5>



<H5><A NAME = "11437">Action(M) : ModRng -&gt; AlgMat</A></H5>
<H5>RightAction(M) : ModRng -&gt; AlgMat</H5>
<BLOCKQUOTE>
Given an A-module M, return the matrix algebra A giving the 
action of A on M.
</BLOCKQUOTE>
<H5><A NAME = "11438">MatrixGroup(M) : ModGrp -&gt; GrpMat</A></H5>

<PRE>    Check: BoolElt                      Default: <TT>true</TT></PRE>
<BLOCKQUOTE>
Given an R[G]-module M, return the matrix group whose generators
are the (invertible) generators of the acting algebra of M.
</BLOCKQUOTE>
<H5><A NAME = "11439">ActionGenerator(M, i) : ModRng, RngIntElt -&gt; AlgMatElt</A></H5>
<BLOCKQUOTE>
The i-th generator of the (right) acting matrix algebra for the module M.
</BLOCKQUOTE>
<H5><A NAME = "11440">NumberOfActionGenerators(M) : ModRng -&gt; RngIntElt</A></H5>
<H5>Ngens(M) : ModTupRng -&gt; RngIntElt</H5>
<BLOCKQUOTE>
The number of action generators (the number of generators of the algebra)
for the A-module M.
</BLOCKQUOTE>
<H5><A NAME = "11441">Group(M) : ModGrp -&gt; Grp</A></H5>
<BLOCKQUOTE>
Given an R[G]-module M, return the group G.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "11442">Example <TT>ModAlg_Access (H95E2)</TT></A></H3>
We illustrate the use of several of these access functions 
by applying them to the 6-dimensional representation of a
matrix algebra defined over GF(2).
<P>
<P>
<P>
<PRE>
&gt; F2 := GF(2);
&gt; F := MatrixAlgebra(F2, 6);
&gt; A := sub&lt; F |
&gt;   [ 1,0,0,1,0,1, 
&gt;     0,1,0,0,1,1, 
&gt;     0,1,1,1,1,0, 
&gt;     0,0,0,1,1,0, 
&gt;     0,0,0,1,0,1,
&gt;     0,1,0,1,0,0 ],
&gt;   [ 0,1,1,0,1,0,
&gt;     0,0,1,1,1,1,
&gt;     1,0,0,1,0,1,
&gt;     0,0,0,1,0,0,
&gt;     0,0,0,0,1,0,
&gt;     0,0,0,0,0,1 ] &gt;;
&gt; T := RModule(F2, 6);
&gt; M := RModule(T, A);
&gt; Dimension(M);
6
&gt; BaseRing(M);
Finite field of size 2
</PRE>
<P>
We set R to be the name of the matrix ring associated with M. Using 
the generator subscript notation, we can access the matrices giving the
(right) action of A.
<P>
<P>
<P>
<PRE>
&gt; R := RightAction(M);
&gt; R.1;
[1 0 0 1 0 1]
[0 1 0 0 1 1]
[0 1 1 1 1 0]
[0 0 0 1 1 0]
[0 0 0 1 0 1]
[0 1 0 1 0 0]
&gt; R.2;
[0 1 1 0 1 0]
[0 0 1 1 1 1]
[1 0 0 1 0 1]
[0 0 0 1 0 0]
[0 0 0 0 1 0]
[0 0 0 0 0 1]
</PRE>
<P>
We display full details of the module.
<P>
<P>
<P>
<PRE>
&gt; M: Maximal;
Module M of dimension 6 with base ring GF(2)
Generators of acting algebra:


[1 0 0 1 0 1]
[0 1 0 0 1 1]
[0 1 1 1 1 0]
[0 0 0 1 1 0]
[0 0 0 1 0 1]
[0 1 0 1 0 0]


[0 1 1 0 1 0]
[0 0 1 1 1 1]
[1 0 0 1 0 1]
[0 0 0 1 0 0]
[0 0 0 0 1 0]
[0 0 0 0 0 1]
</PRE>
<HR>
<H4><A NAME = "11443">Standard Constructions</A></H4>

<P>
<P>
Given one or more existing modules, various standard constructions are 
available to construct new modules.


<H5><A NAME = "11444">Changing the Coefficient Ring</A></H5>



<H5><A NAME = "11445">ChangeRing(M, S) : ModRng, Rng -&gt; ModRng, Map</A></H5>
<BLOCKQUOTE>
Given an A-module M with base ring R, together with a ring S, 
such that there is a natural homomorphism from R to S, construct
the module N with base ring S where N is obtained from M by 
coercing the components of the vectors of M into N. The corresponding
homomorphism from M to N is returned as a second value.
</BLOCKQUOTE>
<H5><A NAME = "11446">ChangeRing(M, S, f) : ModRng, Rng, Map -&gt; ModRng, Map</A></H5>
<BLOCKQUOTE>
Given a module M with base ring R, together with a ring S,
and a homomorphism f: R -&gt; S, construct the module N 
with base ring S, where N is obtained from M by applying f 
to the components of the vectors of M. The corresponding 
homomorphism from M to N is returned as a second value.
</BLOCKQUOTE>
<H5><A NAME = "11447">Direct Sum</A></H5>



<H5><A NAME = "11448">DirectSum(M, N) : ModRng, ModRng -&gt; ModRng, Map, Map, Map, Map</A></H5>
<BLOCKQUOTE>
Given R-modules M and N, construct the direct sum D of M and N
as an R-module.  The embedding maps from M into D and from N into
D respectively and the projection maps from D onto M and from D onto
N respectively are also returned.
</BLOCKQUOTE>
<H5><A NAME = "11449">DirectSum(Q) : [ ModRng ] -&gt; ModRng, [ Map ], [ Map ]</A></H5>
<BLOCKQUOTE>
Given a sequence Q of R-modules, construct the direct sum D of these
modules.  The embedding maps from each of the elements of Q into D and
the projection maps from D onto each of the elements of Q are also
returned.
</BLOCKQUOTE>
<H5><A NAME = "11450">Changing Basis</A></H5>



<H5><A NAME = "11451">M ^ T : ModRng, AlgMatElt -&gt; ModRng</A></H5>
<BLOCKQUOTE>
Given a K[G]-module M of dimension n over the field K, and a
nonsingular n x n matrix T over K, construct the
K[G]-module N which corresponds to taking the rows of T as a
basis for M.
</BLOCKQUOTE>
<H4><A NAME = "11452">Element Construction and  Operations</A></H4>



<H5><A NAME = "11453">Construction of Module Elements</A></H5>



<H5><A NAME = "11454">elt&lt; M | a<sub>1</sub>, ..., a<sub>n</sub> &gt; : ModRng, List -&gt; ModRngElt</A></H5>
<BLOCKQUOTE>
Given a module M with underlying vector space K<sup>(n)</sup>, 
and elements a<sub>1</sub>, ..., a<sub>n</sub> belonging to K, construct 
the element m = (a<sub>1</sub>, ..., a<sub>n</sub>) of M. Note that if m is
not an element of M, an error will result.
</BLOCKQUOTE>
<H5><A NAME = "11455">M ! Q : ModRng, [RngElt] -&gt; ModRngElt</A></H5>
<BLOCKQUOTE>
Given the module M with underlying vector space K<sup>n</sup>, and a sequence
Q = [a<sub>1</sub>, ..., a<sub>n</sub>] with universe K, construct the element 
m = (a<sub>1</sub>, ..., a<sub>n</sub>) of M. Note that if m is not an 
element of M, an error will result.
</BLOCKQUOTE>
<H5><A NAME = "11456">Zero(M) : ModRng -&gt; ModRngElt</A></H5>
<H5>M ! 0 : ModRng, RngIntElt -&gt; ModRngElt</H5>
<BLOCKQUOTE>
The zero element for the A-module M.
</BLOCKQUOTE>
<H5><A NAME = "11457">Random(M) : ModRng -&gt; ModRngElt</A></H5>
<BLOCKQUOTE>
Given a module M defined over a finite ring or field,
return a random vector.
</BLOCKQUOTE>
<H5><A NAME = "11458">Deconstruction of Module Elements</A></H5>



<H5><A NAME = "11459">ElementToSequence(u) : ModRngElt -&gt; [RngElt]</A></H5>
<H5>Eltseq(u) : ModRngElt -&gt; [RngElt]</H5>
<BLOCKQUOTE>
Given an element u belonging to the A-module M, return u in 
the form of a sequence Q of elements of K. 
</BLOCKQUOTE>
<H5><A NAME = "11460">Action of the Algebra on the Module</A></H5>



<H5><A NAME = "11461">u * a : ModRngElt, AlgElt -&gt; ModRngElt</A></H5>
<BLOCKQUOTE>
Given a vector u belonging to an A-module M, and an element 
a &isin;A return the image of u under the action of a.
</BLOCKQUOTE>
<H5><A NAME = "11462">u * g : ModGrpElt, GrpElt -&gt; ModGrpElt</A></H5>
<BLOCKQUOTE>
Given a vector u belonging to an K[G]-module M, and an element g 
belonging to the group G, return the image of u under the action of
K[G] on the module M.
</BLOCKQUOTE>
<H5><A NAME = "11463">Arithmetic with Module Elements</A></H5>



<H5><A NAME = "11464">u + v : ModRngElt, ModRngElt -&gt; ModRngElt</A></H5>
<BLOCKQUOTE>
Sum of the elements u and v, where u and v lie in the same 
A-module M.
</BLOCKQUOTE>
<H5><A NAME = "11465">- u : ModRngElt -&gt; ModRngElt</A></H5>
<BLOCKQUOTE>
Additive inverse of the element u.
</BLOCKQUOTE>
<H5><A NAME = "11466">u - v : ModRngElt, ModRngElt -&gt; ModRngElt</A></H5>
<BLOCKQUOTE>
Difference of the elements u and v, where u and v lie in the 
same A-module M.
</BLOCKQUOTE>
<H5><A NAME = "11467">k * u : RngElt, ModRngElt -&gt; ModRngElt</A></H5>
<BLOCKQUOTE>
Given an element u in an A-module M, where A is a K-algebra 
and an element
k &isin;K, return the scalar product 
k * u as an element of M.
</BLOCKQUOTE>
<H5><A NAME = "11468">u * k : ModRngElt, RngElt -&gt; ModRngElt</A></H5>
<BLOCKQUOTE>
Given an element u in an A-module M, where A is a K-algebra 
and an element
k &isin;K, return the scalar product 
u * k as an element of M.
</BLOCKQUOTE>
<H5><A NAME = "11469">u / k : ModRngElt, RngElt -&gt; ModRngElt</A></H5>
<BLOCKQUOTE>
Given an element u in an A-module M, where A is a K-algebra and 
a non-zero element
k &isin;K, return the scalar product 
u * (1/k) as an element of M.
</BLOCKQUOTE>
<H5><A NAME = "11470">Indexing</A></H5>



<H5><A NAME = "11471">u[i] : ModRngElt, RngIntElt -&gt; RngElt</A></H5>
<BLOCKQUOTE>
Given an element u belonging to a submodule M of the R-module 
R<sup>(n)</sup> and a  positive integer i, 1 &le;i&le;n, return the 
i-th component of u (as an element of the ring R).
</BLOCKQUOTE>
<H5><A NAME = "11472">u[i] := x : ModRngElt, RngIntElt, RngElt -&gt; ModRngElt</A></H5>
<BLOCKQUOTE>
Given an element u belonging to a submodule M of the R-module 
T = R<sup>(n)</sup>, a positive integer i, 1 &le;i&le;n, and an 
element x of the ring R, redefine the i-th component of u 
to be x. The parent of u is changed to T (since the modified
element u need not lie in M).
</BLOCKQUOTE>
<H5><A NAME = "11473">Properties of Module Elements</A></H5>



<H5><A NAME = "11474">IsZero(u) : ModRngElt -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if the element u of the A-module M is the zero element.
</BLOCKQUOTE>
<H5><A NAME = "11475">Support(u) : ModRngElt -&gt; { RngIntElt }</A></H5>
<BLOCKQUOTE>
A set of integers giving the positions of the non-zero components
of the vector u.
</BLOCKQUOTE>
<H4><A NAME = "11476">Submodules</A></H4>



<H5><A NAME = "11477">Construction</A></H5>



<H5><A NAME = "11478">sub&lt;M | L&gt; : ModRng, List -&gt; ModRng</A></H5>
<BLOCKQUOTE>
Given an A-module M, construct the submodule N generated by the 
elements of M specified by the list L. Each term L<sub>i</sub> of the list 
L must be an expression defining an object of one of the following 
types:
<P>
<DL COMPACT class='compact'>
<DT>(a)</DT><DD>A sequence of n elements of R defining an element of M;
<DT>(b)</DT><DD>A set or sequence whose terms are elements of M;
<DT>(c)</DT><DD>A submodule of M;
<DT>(d)</DT><DD>A set or sequence whose terms are submodules of M.
<P>
<P>
<P>
</DL>
The generators stored for N consist of the elements specified by 
terms L<sub>i</sub> together with the stored generators for submodules specified 
by terms of L<sub>i</sub>. Repetitions of an element and occurrences of the 
zero element are removed (unless N is trivial).
<P>
The constructor returns the submodule N as an A-module
together with the inclusion homomorphism f : N -&gt; M.
</BLOCKQUOTE>
<H5><A NAME = "11479">ImageWithBasis(X, M) : ModMatRngElt, ModRng -&gt; ModRng</A></H5>

<PRE>    Check: BoolElt                      Default: <TT>true</TT></PRE>
<BLOCKQUOTE>
Given a basis matrix X for a A-submodule of the A-module
M, return the submodule N of M such that the morphism of 
N into M is X.
</BLOCKQUOTE>
<H5><A NAME = "11480">Morphism(M, N) : ModRng, ModRng -&gt; ModMatRngElt</A></H5>
<BLOCKQUOTE>
If the A-module M was created as a submodule of the module N,
return the inclusion homomorphism &phi; : M -&gt; N as an element of
Hom<sub>A</sub>(M, N). Thus, &phi; gives the correspondence between elements of
M (represented with respect to the standard basis of M) and elements
for N.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "11481">Example <TT>ModAlg_Submodule (H95E3)</TT></A></H3>
We construct a submodule of the permutation module for L(3, 4)
in its representation of degree 21.
<P>
<P>
<P>
<PRE>
&gt; G := PSL(3, 4);
&gt; M := PermutationModule(G, GF(2));
&gt; x := M![0,0,0,1,0,1,0,0,0,1,1,0,0,0,1,0,1,1,0,0,1];
&gt; N := sub&lt; M | x &gt;;
&gt; N:Maximal;
GModule N of dimension 9 over GF(2)
Generators of acting algebra:


[1 0 0 0 1 0 1 0 1]
[0 1 0 1 1 1 0 0 0]
[0 0 1 1 1 1 1 0 1]
[0 0 0 0 0 1 1 0 0]
[0 0 0 1 0 0 1 0 0]
[0 0 0 0 1 0 1 0 0]
[0 0 0 1 1 1 0 0 0]
[0 0 0 0 1 1 0 0 1]
[0 0 0 1 0 1 0 1 1]


[0 0 0 0 0 1 0 1 1]
[1 0 0 0 0 0 0 0 1]
[0 1 1 0 0 1 0 0 1]
[0 0 0 0 0 1 0 0 0]
[0 0 1 0 0 1 0 0 0]
[0 0 1 0 1 1 0 0 1]
[0 0 1 1 0 0 0 0 1]
[0 0 1 0 0 0 0 0 1]
[0 0 0 0 0 0 1 0 0]
</PRE>
<P>
Note that as a GF(2)-module V has dimension 1, while 
as a K[G]-module it has dimension 9. The submodule N is defined 
on a reduced basis so we use <TT>Morphism</TT> to see N embedded
in M.
<P>
<P>
<P>
<PRE>
&gt; phi := Morphism(N, M);
&gt; [ phi(x) : x in Basis(N) ];
[
    M: (1 0 0 0 0 0 0 0 0 1 1 1 1 0 0 0 1 0 1 0 1),
    M: (0 1 0 0 0 0 0 0 0 1 0 0 0 1 0 0 1 1 1 1 1),
    M: (0 0 1 0 0 0 0 0 0 1 0 1 1 0 1 0 1 1 0 1 0),
    M: (0 0 0 1 0 0 0 0 0 0 1 0 1 1 0 1 0 1 1 0 1),
    M: (0 0 0 0 1 0 0 0 0 1 1 0 1 1 1 0 0 0 0 1 1),
    M: (0 0 0 0 0 1 0 0 0 1 0 0 1 1 1 1 1 0 1 0 0),
    M: (0 0 0 0 0 0 1 0 0 0 1 0 0 1 1 1 1 1 0 1 0),
    M: (0 0 0 0 0 0 0 1 0 0 0 1 0 0 1 1 1 1 1 0 1),
    M: (0 0 0 0 0 0 0 0 1 1 1 1 0 0 0 1 0 1 0 1 1)
]
</PRE>
<HR>
<H5><A NAME = "11482">Membership and Equality</A></H5>

<P>
<P>
The operators described below refer to the underlying vector space.


<H5><A NAME = "11483">u in M : ModRngElt, ModRng -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if the element u lies in the A-module M.
</BLOCKQUOTE>
<H5><A NAME = "11484">N subset M : ModRng, ModRng -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if the A-module N is contained in the A-module M.
</BLOCKQUOTE>
<H5><A NAME = "11485">N eq M : ModRng, ModRng -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if the A-modules N and M are equal, where N and M 
are contained in a common A-module.	
</BLOCKQUOTE>
<H5><A NAME = "11486">Operations on Submodules</A></H5>



<H5><A NAME = "11487">M + N : ModRng, ModRng -&gt; ModRng</A></H5>
<BLOCKQUOTE>
Sum of the submodules M and N, where M and N belong to a 
a common A-module.
</BLOCKQUOTE>
<H5><A NAME = "11488">M meet N : ModRng, ModRng -&gt; ModRng</A></H5>
<BLOCKQUOTE>
Intersection of the submodules M and N, where M and N belong 
to a common A-module. 
</BLOCKQUOTE>
<H4><A NAME = "11489">Quotient Modules</A></H4>



<H5><A NAME = "11490">quo&lt;M | L&gt; : ModRng, List -&gt; ModRng</A></H5>
<BLOCKQUOTE>
Given an A-module M, construct the quotient module P = M/N as
an A-module, where
N is the submodule generated by the elements of M specified by the 
list L. Each term L<sub>i</sub> of the list L must be an expression defining 
an object of one of the following types:
<P>
<DL COMPACT class='compact'>
<DT>(a)</DT><DD>A sequence of n elements of R defining an element of M;
<P>
<DT>(b)</DT><DD>A set or sequence whose terms are elements of M;
<P>
<DT>(c)</DT><DD>A submodule of M;
<P>
<DT>(d)</DT><DD>A set or sequence whose terms are submodules of M.
<P>
<P>
<P>
</DL>
The generators constructed for N consist of the elements specified by 
terms L<sub>i</sub> together with the stored generators for submodules specified 
by terms of L<sub>i</sub>. 
The constructor returns the quotient module P as an A-module
together with the natural homomorphism f : M -&gt; P.
</BLOCKQUOTE>
<H5><A NAME = "11491">Morphism(M, N) : ModRng, ModRng -&gt; ModMatRngElt</A></H5>
<BLOCKQUOTE>
If the A-module N was created as a quotient module of the module M,
return the natural homomorphism &phi; : M -&gt; N as an element of
Hom<sub>R</sub>(M, N). Thus &phi; gives the correspondence between elements of M
and elements of N (represented with respect to the standard basis for N).
</BLOCKQUOTE>
<HR>
<H3><A NAME = "11492">Example <TT>ModAlg_QuotientModule (H95E4)</TT></A></H3>
We construct a quotient module of the permutation module for L(3, 4)
considered above.
<P>
<P>
<P>
<PRE>
&gt; G := PSL(3, 4);
&gt; M := PermutationModule(G, GF(2));
&gt; x := M![0,0,0,1,0,1,0,0,0,1,1,0,0,0,1,0,1,1,0,0,1];
&gt; N := sub&lt; M | x &gt;;
&gt; N;
GModule N of dimension 9 over GF(2)
&gt; Q, phi := quo&lt; M | x &gt;;
&gt; Q;
GModule Q of dimension 12 over GF(2)
</PRE>
<P>
We locate the kernel of the epimorphism &phi; and check that it is 
the same as N.
<P>
<P>
<P>
<PRE>
&gt; K :=  Kernel(phi);
GModule Ker of dimension 9 over GF(2)
&gt; K eq N;
true
</PRE>
<P>
Given an element x in the codomain Q of the epimorphism &phi;,
the value returned as the preimage of x is a representative element
of the coset of the kernel that is the actual preimage of x. Since 
we are working in a module over a finite field, we can explicitly 
construct the full preimage <TT>PreIm</TT> of x. 
<P>
<P>
<P>
<PRE>
&gt; x := Q![0,0,0,1,1,0,0,0,0,1,0,0];
&gt; PreIm := { x@@phi + k : k in K };
&gt; #PreIm;
512
</PRE>
<HR>
<H4><A NAME = "11493">Structure of a Module</A></H4>

<P>
<P>
Most of the functions described in this section assume that the base
ring is a <B>finite field</B>.


<H5><A NAME = "11494">Reducibility</A></H5>

<P>


<P>
<H5><A NAME = "11495"></A><A NAME = "ModAlg:Meataxe">Meataxe</A>(M) : ModRng -&gt; ModRng, ModRng, AlgMatElt</H5>
<BLOCKQUOTE>
Given an A-module M with base ring a finite field attempt to find 
a proper submodule N of M or else prove that M is irreducible. 
If a splitting of M is found, three values are returned:
<DL COMPACT class='compact'>
<DT>(a)</DT><DD>An A-module N corresponding to the induced action of A on S;
<DT>(b)</DT><DD>An A-module P corresponding to the induced action of A on the
quotient space M/N;
<DT>(c)</DT><DD>Let &rho;, &nu; and &pi; denote the representations of A 
afforded by modules M, N and P, respectively. The third value returned
is an invertible matrix T which conjugates the matrices of &rho;(A) 
into reduced form. Specifically, if a &isin;A, then 
<PRE>
   T * rho(a) * T^-1 = [ nu(a)   0   ]
                       [  *    pi(x) ]
</PRE>If M is proved to be irreducible, the function simply returns M.
The fact that M is irreducible is recorded as part of the data structure
for M.</DL>
</BLOCKQUOTE>
<H5><A NAME = "11496">IsIrreducible(M) : ModRng -&gt; BoolElt, ModRng, ModRng</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if and only if the A-module M is irreducible.  
If M is reducible, a proper submodule S of M together 
with the corresponding quotient module Q = M/S, 
are also returned.
</BLOCKQUOTE>
<H5><A NAME = "11497">IsAbsolutelyIrreducible(M) : ModRng -&gt; BoolElt, AlgMatElt, RngIntElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if and only if the A-module M is absolutely irreducible.  
Return also a matrix algebra generator for the endomorphism 
algebra E of M (a field), as well as the dimension of E.
<P>
</BLOCKQUOTE>
<H5><A NAME = "11498">AbsolutelyIrreducibleModule(M) : ModRng -&gt; ModRng</A></H5>
<BLOCKQUOTE>
Let A be an algebra over a field K.  Given an irreducible 
A-module M that is not absolutely irreducible over K,
return an irreducible module N that is a constituent of the 
module M considered as a module over the splitting field
for M.  Note that the module N, while not unique, is 
absolutely irreducible.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "11499">Example <TT>ModAlg_Meataxe (H95E5)</TT></A></H3>
Consider the group O<sub>5</sub>(3) given as a permutation group of
degree 45. We construct the permutation module,
and we apply the Meataxe manually to find an irreducible constituent.
(The splitting obtained by each application of the meataxe is random,
and running this input repeatedly will produce different results.)
<P>
<P>
<PRE>
&gt; SetSeed(1);
&gt; O53 := PermutationGroup&lt;45 |
&gt;     (2,3)(4,6)(7,9)(8,11)(12,16)(13,14)(15,19)(18,22)(20,25)(21,26)(27,33)
&gt;       (28,35) (29,34)(31,38)(36,43)(39,41),
&gt;     (1,2,4,7,10,14,16,3,5)(6,8,12,17,21,27,34,41,44)(9,13,18,23,29,37,33,40,43)
&gt;       (11,15,20)(19,24,30,25,31,22,28,36,38)(26,32,39)(35,42,45)&gt;;
&gt;
&gt; P := PermutationModule(O53, GF(2));
&gt; A := P;
&gt; while not IsIrreducible(A) do
&gt;     A, B := Meataxe(P); A; B;
&gt; end while;
GModule A of dimension 14 over GF(2)
GModule B of dimension 31 over GF(2)
&gt; A;
GModule A of dimension 14 over GF(2)
&gt; G := MatrixGroup(A); // Get matrix group from representation
&gt; G: Minimal;
MatrixGroup(14, GF(2))
&gt; time #G;
25920
&gt; assert #G eq #O53 or Dimension(A) eq 1 and #G eq 1; // Group is simple
</PRE>
<HR>
<H5><A NAME = "11500">MinimalField(M) : ModRng -&gt; FldFin</A></H5>
<BLOCKQUOTE>
Let A be an algebra over a finite field K.  Given an 
A-module M over K, return the smallest subfield  of
K, over which M can be realised.
</BLOCKQUOTE>
<H5><A NAME = "11501">IsPermutationModule(M) : ModRng -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if and only if the generators of the matrix algebra
A are permutation matrices, for a given A-module M.
</BLOCKQUOTE>
<H5><A NAME = "11502">Composition Series</A></H5>



<P>
<P>
<H5><A NAME = "11503">CompositionSeries(M) : ModRng -&gt; [ ModRng ], [ ModRng ], AlgMatElt</A></H5>
<BLOCKQUOTE>
Given an A-module M, construct a composition series by repeatedly
applying the meataxe. The function returns three values:
<DL COMPACT class='compact'>
<DT>(a)</DT><DD>The composition series as a sequence of A-modules;
<DT>(b)</DT><DD>The composition factors as a sequence of A-modules
in the order determined by the composition series (a);
<DT>(c)</DT><DD>A transformation matrix t such that for each
a &isin;A, t * a * t<sup> - 1</sup> is in reduced form.
 </DL>
</BLOCKQUOTE>
<H5><A NAME = "11504">CompositionFactors(M) : ModRng -&gt; [ ModRng ]</A></H5>
<BLOCKQUOTE>
Given an A-module M, construct the composition factors 
by repeatedly applying the meataxe. The composition factors 
are returned in the form of a sequence of R-modules in the 
order determined by a composition series for M. If M is 
irreducible, the function returns a sequence containing M alone.
<P>
</BLOCKQUOTE>
<H5><A NAME = "11505">Constituents(M) : ModRng -&gt; [ ModRng ], [ RngIntElt ]</A></H5>
<BLOCKQUOTE>
Given an A-module M, construct the constituents C of M, 
i.e., a sequence of representatives for the isomorphism classes 
of composition factors of M.  A sequence I of indices is
also returned, so that i-th element of C is the I[i]-th
composition factor of M.
</BLOCKQUOTE>
<H5><A NAME = "11506">ConstituentsWithMultiplicities(M) : ModRng -&gt; [ &lt;ModRng, RngIntElt&gt; ], [ RngIntElt ]</A></H5>
<BLOCKQUOTE>
Given an A-module M, return the constituents of M, together 
with their multiplicities.
A sequence I of indices is
also returned, so that i-th element of C is the I[i]-th
composition factor of M.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "11507">Example <TT>ModAlg_CompSeries (H95E6)</TT></A></H3>
We continue with the O<sub>5</sub>(3) example from the previous section.
We notice that the constituent
of dimension of 8 is not absolutely irreducible, so we
lift it to over an extension field.
<P>
<P>
<P>
<PRE>
&gt; O53 := PermutationGroup&lt;45 |
&gt;     (2,3)(4,6)(7,9)(8,11)(12,16)(13,14)(15,19)(18,22)(20,25)(21,26)(27,33)
&gt;       (28,35) (29,34)(31,38)(36,43)(39,41),
&gt;     (1,2,4,7,10,14,16,3,5)(6,8,12,17,21,27,34,41,44)(9,13,18,23,29,37,33,40,43)
&gt;       (11,15,20)(19,24,30,25,31,22,28,36,38)(26,32,39)(35,42,45)&gt;;
&gt;
&gt; P := PermutationModule(O53, GaloisField(2));
&gt; Constituents(P);
[
    GModule of dimension 1 over GF(2),
    GModule of dimension 6 over GF(2),
    GModule of dimension 8 over GF(2),
    GModule of dimension 14 over GF(2)
]
&gt; ConstituentsWithMultiplicities(P);
[
    &lt;GModule of dimension 1 over GF(2), 3&gt;,
    &lt;GModule of dimension 6 over GF(2), 1&gt;,
    &lt;GModule of dimension 8 over GF(2), 1&gt;,
    &lt;GModule of dimension 14 over GF(2), 2&gt;
]
&gt; S, F := CompositionSeries(P);
&gt; S, F;
[
    GModule of dimension 14 over GF(2),
    GModule of dimension 20 over GF(2),
    GModule of dimension 21 over GF(2),
    GModule of dimension 29 over GF(2),
    GModule of dimension 30 over GF(2),
    GModule of dimension 31 over GF(2),
    GModule P of dimension 45 over GF(2)
]
[
    GModule of dimension 14 over GF(2),
    GModule of dimension 6 over GF(2),
    GModule of dimension 1 over GF(2),
    GModule of dimension 8 over GF(2),
    GModule of dimension 1 over GF(2),
    GModule of dimension 1 over GF(2),
    GModule of dimension 14 over GF(2)
]
&gt; IndecomposableSummands(P);
[
    GModule of dimension 1 over GF(2),
    GModule of dimension 44 over GF(2)
]
&gt; C := Constituents(P); 
&gt; C;
[
    GModule of dimension 1 over GF(2),
    GModule of dimension 6 over GF(2),
    GModule of dimension 8 over GF(2),
    GModule of dimension 14 over GF(2)
]
&gt; [IsAbsolutelyIrreducible(M): M in C];               
[ true, true, false, true ]
&gt; DimensionOfEndomorphismRing(C[3]);                                           
2
&gt; L := GF(2^2);
&gt; E := ChangeRing(C[3], L);
&gt; E;
GModule E of dimension 8 over GF(2^2)
&gt; CE := CompositionFactors(E);
&gt; CE;
[
    GModule of dimension 4 over GF(2^2),
    GModule of dimension 4 over GF(2^2)
]
&gt; IsAbsolutelyIrreducible(CE[1]);
true
&gt; IsIsomorphic(CE[1], CE[2]);
false
</PRE>
<HR>
<H5><A NAME = "11508">Socle Series</A></H5>

<P>
<P>
<P>
<P>


<P>
<H5><A NAME = "11509">IsSemisimple(M) : ModGrp -&gt; BoolElt</A></H5>
<H5>IsSemisimple(M) : ModAlgBas -&gt; BoolElt</H5>
<BLOCKQUOTE>
Given an A-module M, which is a K[G]-module (<TT>ModGrp</TT>)
for a field K,
return whether M is semisimple.
<P>
If M is a semisimple module defined over a matrix algebra, the function
returns as second return value a list of the ranks of the primitive
idempotents of the algebra. This is also a list of the multiplicities of
the simple modules of the algebra as composition factors in a composition
series for the module.
</BLOCKQUOTE>
<H5><A NAME = "11510">MaximalSubmodules(M) : ModRng -&gt; [ ModRng ], BoolElt</A></H5>
<BLOCKQUOTE>
Given an A-module M, return a sequence containing the maximal
submodules of M.
<P>
<P>
<PRE>
     Limit: RngIntElt                    Default: 0
</PRE>
If a limit L is provided, only up L submodules are calculated, and the
second return value indicates whether all of the submodules are returned.
<P>
</BLOCKQUOTE>
<H5><A NAME = "11511">JacobsonRadical(M) : ModRng -&gt; ModRng, Map</A></H5>
<BLOCKQUOTE>
The Jacobson radical of the A-module M.
<P>
</BLOCKQUOTE>
<H5><A NAME = "11512">MinimalSubmodules(M) : ModRng -&gt; [ ModRng ], BoolElt</A></H5>
<BLOCKQUOTE>
Given an A-module M, return a sequence containing the minimal submodules
of M.
<P>
<P>
<PRE>
     Limit: RngIntElt                    Default: 0
</PRE>
If a limit L is provided, only up L submodules are calculated, and the
second return value indicates whether all of the submodules are returned.
<P>
</BLOCKQUOTE>
<H5><A NAME = "11513">MinimalSubmodules(M, F) : ModRng, ModRng -&gt; [ ModRng ], BoolElt</A></H5>
<BLOCKQUOTE>
Given an A-module M and an irreducible module F, return a sequence 
containing those minimal submodules of M, each of which is isomorphic 
to F.
<P>
<P>
<PRE>
     Limit: RngIntElt                    Default: 0
</PRE>
If a limit L is provided, only up L submodules are calculated, and the
second return value indicates whether all of the submodules are returned.
<P>
</BLOCKQUOTE>
<H5><A NAME = "11514">MinimalSubmodule(M) : ModRng -&gt; ModRng</A></H5>
<BLOCKQUOTE>
Given an A-module M, return a single minimal (or irreducible) submodule
of M; if M is itself irreducible, M is returned.
<P>
</BLOCKQUOTE>
<H5><A NAME = "11515">Socle(M) : ModRng -&gt; ModRng, Map</A></H5>
<BLOCKQUOTE>
Given a A-module M, return its socle, i.e. the sum of the minimal
submodules of M.
<P>
</BLOCKQUOTE>
<H5><A NAME = "11516">SocleSeries(M) : ModRng -&gt; [ ModRng ], [ ModRng ], AlgMatElt</A></H5>
<BLOCKQUOTE>
A socle series S for the A-module M, together with the socle 
factors corresponding to the terms of S and a matrix T giving 
the transformation of M into (semi-simple) reduced form.
The socle series, as returned, does not include the trivial module 
but does include M.
<P>
</BLOCKQUOTE>
<H5><A NAME = "11517">SocleFactors(M) : ModRng -&gt; [ ModRng ]</A></H5>
<BLOCKQUOTE>
The factors corresponding to the terms of a socle series for the 
A-module M.  The factors are returned in the form of a sequence 
of A-modules in the order determined by a socle series for M. 
If M is irreducible, the function returns a sequence containing M
alone.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "11518">Example <TT>ModAlg_Minimals (H95E7)</TT></A></H3>
We continue with the O<sub>5</sub>(3) example from the previous section.
<P>
<P>
<PRE>
&gt; O53 := PermutationGroup&lt;45 |
&gt;   (2,3)(4,6)(7,9)(8,11)(12,16)(13,14)(15,19)(18,22)(20,25)(21,26)(27,33)
&gt;     (28,35) (29,34)(31,38)(36,43)(39,41),
&gt;   (1,2,4,7,10,14,16,3,5)(6,8,12,17,21,27,34,41,44)(9,13,18,23,29,37,33,40,43)
&gt;     (11,15,20)(19,24,30,25,31,22,28,36,38)(26,32,39)(35,42,45)&gt;;
&gt;
&gt; P := PermutationModule(O53, FiniteField(2));
&gt; MaximalSubmodules(P);
[
    GModule of dimension 31 over GF(2),
    GModule of dimension 44 over GF(2)
]
&gt; JacobsonRadical(P);
GModule of dimension 30 over GF(2)
&gt; MinimalSubmodules(P);
[
    GModule of dimension 1 over GF(2),
    GModule of dimension 14 over GF(2)
]
&gt; Soc := Socle(P);
&gt; Soc;
GModule Soc of dimension 15 over GF(2)
&gt; SocleSeries(P);
[
    GModule of dimension 15 over GF(2),
    GModule of dimension 22 over GF(2),
    GModule of dimension 30 over GF(2),
    GModule of dimension 31 over GF(2),
    GModule P of dimension 45 over GF(2)
]
&gt; SocleFactors(P);
[
    GModule of dimension 15 over GF(2),
    GModule of dimension 7 over GF(2),
    GModule of dimension 8 over GF(2),
    GModule of dimension 1 over GF(2),
    GModule of dimension 14 over GF(2)
]
</PRE>
<HR>
<H4><A NAME = "11519">Decomposability and Complements</A></H4>

<P>
<P>
The functions in this section currently apply only in the
case in which A is an algebra over a finite field.
<P>


<H5><A NAME = "11520">IsDecomposable(M) : ModRng -&gt; BoolElt, ModRng, ModRng</A></H5>
<BLOCKQUOTE>
Given an A-module M, return <TT>true</TT> iff M is decomposable.
If M is decomposable and defined over a finite field, the function also
returns proper submodules S and T of M such that M = S direct-sum T.
</BLOCKQUOTE>
<H5><A NAME = "11521">DirectSumDecomposition(M) : ModRng -&gt; [ ModRng ]</A></H5>
<H5>IndecomposableSummands(M) : ModRng -&gt; [ ModRng ]</H5>
<H5>Decomposition(M) : ModRng -&gt; [ ModRng ]</H5>
<BLOCKQUOTE>
Given an A-module M, return a sequence Q of indecomposable summands
of M.  Each element of Q is an indecomposable submodule of M and
M is equal to the (direct) sum of the terms of Q. If M is indecomposable,
the sequence Q consists of M alone.
</BLOCKQUOTE>
<H5><A NAME = "11522">HasComplement(M, S) : ModGrp, ModGrp -&gt; BoolElt, ModGrp</A></H5>
<H5>HasComplement(M, S) : ModRng, ModRng -&gt; BoolElt, ModRng</H5>
<H5>IsDirectSummand(M, S) : ModGrp, ModGrp -&gt; BoolElt, ModGrp</H5>
<H5>IsDirectSummand(M, S) : ModRng, ModRng -&gt; BoolElt, ModRng</H5>
<BLOCKQUOTE>
Given an A-module M and a submodule S of M, determine 
whether S has a A-invariant complement in M.  If this
is the case, the value <TT>true</TT> is returned together with a 
submodule T of M such that M = S direct-sum T; otherwise the 
value <TT>false</TT> is returned.
</BLOCKQUOTE>
<H5><A NAME = "11523">Complements(M, S) : ModGrp, ModGrp -&gt; [ ModGrp ]</A></H5>
<H5>Complements(M, S) : ModRng, ModRng -&gt; [ ModRng ]</H5>
<BLOCKQUOTE>
Given an A-module M and a submodule S of M, return 
all A-invariant complements of S in M.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "11524">Example <TT>ModAlg_Decomposable (H95E8)</TT></A></H3>
<P>
<P>
<P>
<PRE>
&gt; A := MatrixAlgebra&lt;GF(2), 6 |
&gt;   [ 1,0,0,1,0,1,  
&gt;     0,1,0,0,1,1,  
&gt;     0,1,1,1,1,0,  
&gt;     0,0,0,1,1,0,  
&gt;     0,0,0,1,0,1,
&gt;     0,1,0,1,0,0 ],
&gt;   [ 0,1,1,0,1,0,
&gt;     0,0,1,1,1,1,
&gt;     1,0,0,1,0,1,
&gt;     0,0,0,1,0,0,
&gt;     0,0,0,0,1,0,
&gt;     0,0,0,0,0,1 ] &gt;;

&gt; M := RModule(RSpace(GF(2), 6), A);
&gt; M;
RModule M of dimension 6 over GF(2)
&gt; IsDecomposable(M);
false
&gt; MM := DirectSum(M, M);
&gt; MM;
RModule MM of dimension 12 over GF(2)
&gt; l, S, T := IsDecomposable(MM);
&gt; l;
true;
&gt; S;
RModule S of dimension 6 over GF(2)
&gt; HasComplement(MM, S);
true
&gt; Complements(MM, S);
[
    RModule of dimension 6 over GF(2),
    RModule of dimension 6 over GF(2)
]
&gt; IndecomposableSummands(MM);
[
    RModule of dimension 6 over GF(2),
    RModule of dimension 6 over GF(2)
]
&gt; Q := IndecomposableSummands(MM); 
&gt; Q;
[
    RModule of dimension 6 over GF(2),
    RModule of dimension 6 over GF(2)
]
&gt; Q[1] meet Q[2];                 
RModule of dimension 0 over GF(2)
&gt; Q[1] + Q[2];
RModule MM of dimension 12 over GF(2)
</PRE>
<HR>
<H4><A NAME = "11525">Lattice of Submodules</A></H4>

<P>
<P>
<P>
Let M be an A-module.  Magma can construct the lattice L of
all submodules of M if this is not too large.  Various properties of
the lattice L may then be examined.  The elements of L are called <I>submodule-lattice elements</I> and are numbered from 1 to n where n is
the cardinality of L.  Once the lattice has been constructed, the result 
of various lattice operations, such as meet and intersection, are
available without the need for any module-theoretic calculation.  Certain
information about M and its submodules may then be obtained by analyzing 
L.  Given an element of L, one can easily create the submodule 
N of M corresponding to it and one can also create the element of 
L corresponding to any submodule of M.
<P>
The functions is this section currently apply only in the
case in which A is an algebra over a finite field.
<P>


<H5><A NAME = "11526">Creating Lattices</A></H5>



<H5><A NAME = "11527">SubmoduleLattice(M) : ModRng -&gt; SubModLat, BoolElt</A></H5>

<PRE>    Limit: RngIntElt                    Default: 0</PRE>

<PRE>    CodimensionLimit: RngIntElt         Default: </PRE>
<BLOCKQUOTE>
Given an A-module M, construct the lattice L of submodules of M.
If a limit n is provided, at most n submodules are calculated, and 
the second return value indicates whether the returned lattice L 
is the full lattice of submodules of M.
</BLOCKQUOTE>
<H5><A NAME = "11528">SubmoduleLatticeAbort(M, n) : ModRng, RngIntElt -&gt; BoolElt, SubModLat</A></H5>
<BLOCKQUOTE>
Given an A-module M and a positive integer n, construct the lattice 
L of submodules of M, provided that the number of submodule does not
exceed n. In this case the value <TT>true</TT> and the lattice L are returned.
If M has more than n submodules, the function aborts and returns the
value <TT>false</TT>.
</BLOCKQUOTE>
<H5><A NAME = "11529">SetVerbose("SubmoduleLattice", i) : MonStgElt, RngIntElt -&gt;</A></H5>
<BLOCKQUOTE>
Control verbose printing for the submodule lattice algorithm.  The level
i can be 2 for maximal printing or 1 for moderate printing.  The
algorithm works down a composition series of the module and a 
summary is printed for each level.
</BLOCKQUOTE>
<H5><A NAME = "11530"></A><A NAME = "RepThy:Submodules">Submodules</A>(M) : ModRng -&gt; [ModRng]</H5>

<PRE>    CodimensionLimit: RngIntElt         Default: Dimension(M)</PRE>
<BLOCKQUOTE>
Given an A-module M, return a sequence containing all submodules of M
sorted by dimension.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "11531">Example <TT>ModAlg_CreateLattice (H95E9)</TT></A></H3>
<P>
We create the lattice of submodules for the A-module GF(3)[Z<sub>6</sub>]
with level 1 verbose printing turned on.
<P>
<P>
<P>
<PRE>
&gt; M := PermutationModule(CyclicGroup(6), GF(3));
&gt; SetVerbose("SubmoduleLattice", 1);
&gt; L := SubmoduleLattice(M);
Submodule Lattice; Dimension: 6, Composition length: 6
Starting level 4; Current number of modules: 2
Starting level 3; Current number of modules: 3
Starting level 2; Current number of modules: 6
Starting level 1; Current number of modules: 9
Starting level 0; Current number of modules: 12
Change basis time: 0.010
Jacobson radical time: 0.060
Complement time: 0.070
Total time: 0.250
&gt; #L;
16
</PRE>
<HR>
<H5><A NAME = "11532">Operations on Lattices</A></H5>

<P>
<P>
In the following, L is the lattice of submodules for a module M.


<H5><A NAME = "11533"># L : SubModLat -&gt; RngIntElt</A></H5>
<BLOCKQUOTE>
The cardinality of L, i.e. the number of submodules of M.
</BLOCKQUOTE>
<H5><A NAME = "11534">L ! i: SubModLat, RngIntElt -&gt; SubModLatElt</A></H5>
<BLOCKQUOTE>
Create the i-th element of the lattice L.  The number i is insignificant
(i.e. the elements of L are not numbered in any special way), but this
allows one to uniquely identify each element of the lattice L.
</BLOCKQUOTE>
<H5><A NAME = "11535">L ! S: SubModLat, ModRng -&gt; SubModLatElt</A></H5>
<BLOCKQUOTE>
Create the element of the lattice L corresponding to the submodule S of M.
</BLOCKQUOTE>
<H5><A NAME = "11536">Bottom(L): SubModLat -&gt; SubModLatElt</A></H5>
<BLOCKQUOTE>
Create the bottom of the lattice L, i.e. the element of L corresponding
to the zero-submodule of M.  If the lattice was created with a limit on
the number of submodules and the lattice is partial, the bottom of the lattice
may not be the zero submodule.
</BLOCKQUOTE>
<H5><A NAME = "11537">Random(L): SubModLat -&gt; SubModLatElt</A></H5>
<BLOCKQUOTE>
Create a random element of L.
</BLOCKQUOTE>
<H5><A NAME = "11538">Top(L): SubModLat -&gt; SubModLatElt</A></H5>
<BLOCKQUOTE>
Create the top of the lattice L, i.e. the element of L corresponding
to M.
</BLOCKQUOTE>
<H5><A NAME = "11539">Operations on Lattice Elements</A></H5>

<P>
<P>
In the following, L is the lattice of submodules for a module M.
Elements of L are identified with the integers [1..#L] but not in
any particular order.


<H5><A NAME = "11540">IntegerRing() ! e : RngInt, SubModLatElt -&gt; RngIntElt</A></H5>
<BLOCKQUOTE>
The integer corresponding to lattice element e.
</BLOCKQUOTE>
<H5><A NAME = "11541">e + f : SubModLatElt, SubModLatElt -&gt; SubModLatElt</A></H5>
<BLOCKQUOTE>
The sum of lattice elements e and f, i.e. the lattice element corresponding
to the sum of the modules corresponding to e and f.
</BLOCKQUOTE>
<H5><A NAME = "11542">e meet f : SubModLatElt, SubModLatElt -&gt; SubModLatElt</A></H5>
<BLOCKQUOTE>
The intersection of lattice elements e and f.
</BLOCKQUOTE>
<H5><A NAME = "11543">e eq f : SubModLatElt, SubModLatElt -&gt; SubModLatElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if and only if lattice elements e and f are equal.
</BLOCKQUOTE>
<H5><A NAME = "11544">e subset f : SubModLatElt, SubModLatElt -&gt; SubModLatElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if and only if e is under f in the lattice L, 
i.e. the submodule corresponding to e is a submodule of 
the submodule corresponding to f.
</BLOCKQUOTE>
<H5><A NAME = "11545">MaximalSubmodules(e) : SubModLatElt -&gt; { SubModLatElt }</A></H5>
<BLOCKQUOTE>
The maximal submodules of e, returned as a set of lattice elements.
</BLOCKQUOTE>
<H5><A NAME = "11546">MinimalSupermodules(e) : SubModLatElt -&gt; { SubModLatElt }</A></H5>
<BLOCKQUOTE>
The minimal supermodules of e, returned as a set of lattice elements.
</BLOCKQUOTE>
<H5><A NAME = "11547">Module(e) : SubModLatElt -&gt; ModRng</A></H5>
<BLOCKQUOTE>
The submodule of M corresponding to the element e of the lattice L.
</BLOCKQUOTE>
<H5><A NAME = "11548">Properties of Lattice Elements</A></H5>



<H5><A NAME = "11549">Dimension(e) : SubModLatElt -&gt; RngIntElt</A></H5>
<BLOCKQUOTE>
The dimension of the submodule of M corresponding to e.
</BLOCKQUOTE>
<H5><A NAME = "11550">JacobsonRadical(e) : SubModLatElt -&gt; SubModLatElt</A></H5>
<BLOCKQUOTE>
The Jacobson radical of e, i.e. the lattice element corresponding to
the Jacobson radical of the submodule corresponding to e.
</BLOCKQUOTE>
<H5><A NAME = "11551">Morphism(e) : SubModLatElt -&gt; ModMatRngElt</A></H5>
<BLOCKQUOTE>
The morphism from the module corresponding to e to M.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "11552">Example <TT>ModAlg_LatticeOps (H95E10)</TT></A></H3>
We create the lattice of submodules for the A-module GF(3)[Z<sub>6</sub>].
<P>
<P>
<P>
<PRE>
&gt; SetSeed(1);
&gt; M := PermutationModule(CyclicGroup(6), GF(3));
&gt; L := SubmoduleLattice(M);
&gt; #L;
16
&gt; T := Top(L);
&gt; B := Bottom(L);
&gt; T;
16
&gt; B;
1
&gt; // Check that element of L corresponding to M is T
&gt; L ! M;
1
&gt; (L ! M) eq T;
true
&gt; // Check that module corresponding to B is zero-submodule of M
&gt; Module(B);
GModule of dimension 0 with base ring GF(3)
</PRE>
<P>
We next find the minimal supermodules (immediate parents) of B in L and 
then determine the actual A-submodules to which they correspond.
<P>
<P>
<P>
<PRE>
&gt; S := MinimalSupermodules(B);
&gt; S;
{ 2, 3 }
&gt; Module(L ! 2);
GModule of dimension 1 with base ring GF(3)
&gt; Module(L ! 3);
GModule of dimension 1 with base ring GF(3)
&gt; Dimension(L ! 2);
1
&gt; Morphism(L ! 2);
[1 1 1 1 1 1]
&gt; Morphism(L ! 3);
[1 2 1 2 1 2]
&gt; // Set A to the sum of these elements
&gt; A := L!2 + L!3;
&gt; A;
5;
&gt; // Note that A has dimension 2 and its morphism is the sum of the previous
&gt; Dimension(A);
2
&gt; Morphism(A);
[1 0 1 0 1 0]
[0 1 0 1 0 1]
&gt; MaximalSubmodules(A);
{ 2, 3}
&gt; S!2 subset A;
true
</PRE>
<P>
We now find the maximal submodules of L, and examine one, S, in detail.
<P>
<P>
<P>
<PRE>
&gt; MaximalSubmodules(T);  
{ 14, 15 }
&gt; A := L ! 14;
&gt; Dimension(A);   
5
&gt; Morphism(A);
[1 0 0 0 0 1]
[0 1 0 0 0 2]
[0 0 1 0 0 1]
[0 0 0 1 0 2]
[0 0 0 0 1 1]
&gt; S := Module(A);
&gt; S;
GModule S of dimension 5 with base ring GF(3)
</PRE>
<P>
Finally, we compute the Jacobson radical of S directly, and also
obtain it from the lattice, checking that the two methods match.
<P>
<P>
<P>
<PRE>
&gt; J := JacobsonRadical(S);
&gt; J;
GModule J of dimension 3 with base ring GF(3)
&gt; L ! J;
8
&gt; JacobsonRadical(A);
8
</PRE>
<HR>
<H4><A NAME = "11553">Homomorphisms</A></H4>

<P>
<P>
Let M and N be A-modules where A is an algebra defined over
a field K.  Then Hom<sub>A</sub>(M, N) consists of all K-homomorphisms 
from M to N which commute with the action of A.  The type of such 
(matrix) homomorphisms, called <I>A-homs</I>, is <TT>ModMatGrpElt</TT>.
<P>
<P>
The functions is this section currently apply only in the
case in which A is an algebra over a finite field.


<H5><A NAME = "11554">Creating Homomorphisms</A></H5>



<H5><A NAME = "11555">hom&lt; M -&gt; N | X &gt; : ModRng, ModRng, ModMatElt -&gt; Map</A></H5>
<BLOCKQUOTE>
Given A-modules M and N, create the (map) homomorphism from M to N
given by matrix X.
</BLOCKQUOTE>
<H5><A NAME = "11556">H ! f : ModMatRng, Map -&gt; ModMatRngElt</A></H5>
<BLOCKQUOTE>
Given matrix space H, which is Hom<sub>A</sub>(M, N) for A-modules M and N,
together with a homomorphism f from M to N, create the matrix
corresponding to the map f.
</BLOCKQUOTE>
<H5><A NAME = "11557">IsModuleHomomorphism(X) : ModMatFldElt -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Given a matrix X belonging to Hom<sub>K</sub>(M, N), where M and N 
are A-modules, return <TT>true</TT> if X is an A-homomorphism.
</BLOCKQUOTE>
<H5><A NAME = "11558">Hom(M, N)</A></H5>



<H5><A NAME = "11559">Hom(M, N) : ModRng, ModRng -&gt; ModMatRng</A></H5>
<BLOCKQUOTE>
Given A-modules M and N, construct the vector space of 
homomorphisms, Hom<sub>K</sub>(M, N), where K is the field over 
which A is defined.
</BLOCKQUOTE>
<H5><A NAME = "11560">AHom(M, N) : ModRng, ModRng -&gt; ModMatRng</A></H5>
<BLOCKQUOTE>
Given A-modules M and N, construct the vector space of 
homomorphisms, Hom<sub>A</sub>(M, N), as a submodule of Hom<sub>K</sub>(M, N).
</BLOCKQUOTE>
<H5><A NAME = "11561">GHomOverCentralizingField(M, N) : ModGrp, ModGrp -&gt; ModMatGrp</A></H5>
<H5>GHomOverCentralizingField(M, N) : ModRng, ModRng -&gt; ModRng</H5>
<BLOCKQUOTE>
Given A-modules M and N, construct Hom<sub>L[G]</sub>(M, N) as
a subspace of Hom<sub>K</sub>(M, N) where L is the centralizing field of
M.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "11562">Example <TT>ModAlg_EndoRing (H95E11)</TT></A></H3>
We construct a 12-dimensional module M and a 9-dimensional 
submodule P of M for a soluble group of order 648 over GF(3). 
We then construct H = Hom<sub>A</sub>(M, N) and perform map operations on
elements of H.
<P>
<P>
<P>
<PRE>
&gt; G := PermutationGroup&lt; 12 |
&gt;         (1,6,7)(2,5,8,3,4,9)(11,12),
&gt;         (1,3)(4,9,12)(5,8,10,6,7,11) &gt;;
&gt; K := GF(3);
&gt; P := PermutationModule(G, K);
&gt; M := sub&lt; P | [1,0,0,0,0,1,0,0,1,0,0,1] &gt;;
&gt; M;
GModule M of dimension 9 over GF(3)
&gt; H := AHom(P, M);
&gt; H: Maximal;
KMatrixSpace of 12 by 9 GHom matrices and dimension 2 over GF(3)
Echelonized basis:
[1 1 1 0 0 0 0 0 0]
[1 1 1 0 0 0 0 0 0]
[1 1 1 0 0 0 0 0 0]
[0 0 0 1 1 0 0 0 0]
[0 0 0 1 1 0 0 0 0]
[0 0 0 1 1 0 0 0 0]
[0 0 0 0 0 1 1 0 0]
[0 0 0 0 0 1 1 0 0]
[0 0 0 0 0 1 1 0 0]
[0 0 0 0 0 0 0 1 1]
[0 0 0 0 0 0 0 1 1]
[0 0 0 0 0 0 0 1 1]


[0 0 0 1 1 1 1 1 1]
[0 0 0 1 1 1 1 1 1]
[0 0 0 1 1 1 1 1 1]
[1 1 1 0 0 1 1 1 1]
[1 1 1 0 0 1 1 1 1]
[1 1 1 0 0 1 1 1 1]
[1 1 1 1 1 0 0 1 1]
[1 1 1 1 1 0 0 1 1]
[1 1 1 1 1 0 0 1 1]
[1 1 1 1 1 1 1 0 0]
[1 1 1 1 1 1 1 0 0]
[1 1 1 1 1 1 1 0 0]
&gt; // We write down a random homomorphism from M to P.
&gt; f := 2*H.1 + H.2;
&gt; f;
[2 2 2 1 1 1 1 1 1]
[2 2 2 1 1 1 1 1 1]
[2 2 2 1 1 1 1 1 1]
[1 1 1 2 2 1 1 1 1]
[1 1 1 2 2 1 1 1 1]
[1 1 1 2 2 1 1 1 1]
[1 1 1 1 1 2 2 1 1]
[1 1 1 1 1 2 2 1 1]
[1 1 1 1 1 2 2 1 1]
[1 1 1 1 1 1 1 2 2]
[1 1 1 1 1 1 1 2 2]
[1 1 1 1 1 1 1 2 2]
&gt; Ker := Kernel(f);
&gt; Ker;
GModule Ker of dimension 8 with base ring GF(3)
</PRE>
<P>
If we print the morphism associated with Ker, we see generators
for Ker as a submodule of P.
<P>
<P>
<P>
<PRE>
&gt; Morphism(Ker, P);
[1 0 2 0 0 0 0 0 0 0 0 0]
[0 1 2 0 0 0 0 0 0 0 0 0]
[0 0 0 1 0 2 0 0 0 0 0 0]
[0 0 0 0 1 2 0 0 0 0 0 0]
[0 0 0 0 0 0 1 0 2 0 0 0]
[0 0 0 0 0 0 0 1 2 0 0 0]
[0 0 0 0 0 0 0 0 0 1 0 2]
[0 0 0 0 0 0 0 0 0 0 1 2]
&gt; // Examine the image of f and its morphism to P.
&gt; Im := Image(f);
&gt; Im;
GModule Im of dimension 4 with base ring GF(3)
&gt; Morphism(Im, P);
[1 1 1 0 0 0 0 0 0 0 0 0]
[0 0 0 1 1 1 0 0 0 0 0 0]
[0 0 0 0 0 0 1 1 1 0 0 0]
[0 0 0 0 0 0 0 0 0 1 1 1]
</PRE>
<HR>
<H3><A NAME = "11563">Example <TT>ModAlg_CreateHomGHom (H95E12)</TT></A></H3>
We construct a G-homomorphism module H<sub>1</sub> for a G-module and then
the homomorphism module H = Hom(H<sub>1</sub>, H<sub>1</sub>) with right matrix action
which is equivalent to (the right representation of) the endomorphism module
of H.
<P>
<P>
<PRE>
&gt; P := GModule(CyclicGroup(11), GF(3));
&gt; F := Constituents(P);
&gt; F;
[
    GModule of dimension 1 over GF(3),
    GModule of dimension 5 over GF(3),
    GModule of dimension 5 over GF(3)
]
&gt; H1 := GHom(P, F[2]);
&gt; H1;
KMatrixSpace of 2 by 3 matrices and dimension 1 over Rational Field
&gt; H := Hom(H1, H1, "right");
&gt; H: Maximal;
KMatrixSpace of 5 by 5 matrices and dimension 5 over GF(3)
Echelonized basis:


[1 0 0 0 0]
[0 1 0 0 0]
[0 0 1 0 0]
[0 0 0 1 0]
[0 0 0 0 1]


[0 1 0 0 0]
[1 1 1 2 1]
[2 0 2 1 1]
[2 1 0 0 0]
[0 2 1 0 0]


[0 0 1 0 0]
[2 0 2 1 1]
[2 2 2 2 2]
[2 0 1 0 2]
[1 0 1 2 1]


[0 0 0 1 0]
[2 1 0 0 0]
[2 0 1 0 2]
[2 2 1 2 2]
[2 1 1 0 1]


[0 0 0 0 1]
[0 2 1 0 0]
[1 0 1 2 1]
[2 1 1 0 1]
[2 1 0 0 2]
</PRE>
<HR>
<H5><A NAME = "11564">Endo-- and Automorphisms</A></H5>



<H5><A NAME = "11565">EndomorphismAlgebra(M) : ModRng -&gt; AlgMat</A></H5>
<H5>EndomorphismRing(M) : ModRng -&gt; AlgMat</H5>

<PRE>    Direct: BoolElt                     Default: <TT>false</TT></PRE>
<BLOCKQUOTE>
Given a A-module M with base ring K, construct E=End<sub>A</sub>(M) as a 
subring E of the complete matrix ring K<sup>(n x n)</sup>.
</BLOCKQUOTE>
<H5><A NAME = "11566">CentreOfEndomorphismRing(M) : ModRng -&gt; AlgMat</A></H5>
<BLOCKQUOTE>
Given a A-module M with base ring K, construct the centre
of End<sub>A</sub>(M) as a subring Z of the complete matrix ring K<sup>(n x n)</sup>.
This is equivalent to <TT>Centre(EndomorphismRing(M))</TT> but will often
be much faster.
</BLOCKQUOTE>
<H5><A NAME = "11567">AutomorphismGroup(M) : ModRng -&gt; GrpMat</A></H5>
<BLOCKQUOTE>
Given a A-module M with base ring K, construct Aut(M) as a 
subgroup G of the general linear group GL(n, K). Thus, G is
the group of units of End(M).
</BLOCKQUOTE>
<H5><A NAME = "11568">IsIsomorphic(M, N) : ModRng, ModRng -&gt; BoolElt, AlgMatElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if the A-modules M and N are isomorphic, <TT>false</TT>
otherwise.  If M and N are isomorphic, the function also returns a
matrix T such that M<sup>T</sup> = N.  Note that the action generators
of M and N must match, so the function effectively determines
whether there is an invertible matrix T such that
<TT>T^-1*ActionGenerator(M, i)*T</TT> equals
<TT>ActionGenerator(N, i)</TT> for each i.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "11569">Example <TT>ModAlg_EndoRing (H95E13)</TT></A></H3>
<P>
We construct the endomorphism ring for a permutation module
over GF(3) for a soluble group of order 648.
<P>
<P>
<P>
<PRE>
&gt; G := PermutationGroup&lt; 12 |
&gt;         (1,6,7)(2,5,8,3,4,9)(11,12),
&gt;         (1,3)(4,9,12)(5,8,10,6,7,11) &gt;;
&gt; P := PermutationModule(G, GF(3));
&gt; time End := EndomorphismAlgebra(P);
Time: 0.000
&gt; End;
Matrix Algebra of degree 12 and dimension 3 over GF(3)
</PRE>
Thus, the permutation module P has 27 endomorphisms.
<P>
<P>
<PRE>
&gt; time Aut := AutomorphismGroup(P);
Time: 0.010
&gt; Aut;
MatrixGroup(12, GF(3))
Generators:
    [1 0 0 1 1 1 1 1 1 1 1 1]
    [0 1 0 1 1 1 1 1 1 1 1 1]
    [0 0 1 1 1 1 1 1 1 1 1 1]
    [1 1 1 1 0 0 1 1 1 1 1 1]
    [1 1 1 0 1 0 1 1 1 1 1 1]
    [1 1 1 0 0 1 1 1 1 1 1 1]
    [1 1 1 1 1 1 1 0 0 1 1 1]
    [1 1 1 1 1 1 0 1 0 1 1 1]
    [1 1 1 1 1 1 0 0 1 1 1 1]
    [1 1 1 1 1 1 1 1 1 1 0 0]
    [1 1 1 1 1 1 1 1 1 0 1 0]
    [1 1 1 1 1 1 1 1 1 0 0 1]


    [2 1 1 0 0 0 0 0 0 0 0 0]
    [1 2 1 0 0 0 0 0 0 0 0 0]
    [1 1 2 0 0 0 0 0 0 0 0 0]
    [0 0 0 2 1 1 0 0 0 0 0 0]
    [0 0 0 1 2 1 0 0 0 0 0 0]
    [0 0 0 1 1 2 0 0 0 0 0 0]
    [0 0 0 0 0 0 2 1 1 0 0 0]
    [0 0 0 0 0 0 1 2 1 0 0 0]
    [0 0 0 0 0 0 1 1 2 0 0 0]
    [0 0 0 0 0 0 0 0 0 2 1 1]
    [0 0 0 0 0 0 0 0 0 1 2 1]
    [0 0 0 0 0 0 0 0 0 1 1 2]


    [0 1 1 0 0 0 0 0 0 0 0 0]
    [1 0 1 0 0 0 0 0 0 0 0 0]
    [1 1 0 0 0 0 0 0 0 0 0 0]
    [0 0 0 0 1 1 0 0 0 0 0 0]
    [0 0 0 1 0 1 0 0 0 0 0 0]
    [0 0 0 1 1 0 0 0 0 0 0 0]
    [0 0 0 0 0 0 0 1 1 0 0 0]
    [0 0 0 0 0 0 1 0 1 0 0 0]
    [0 0 0 0 0 0 1 1 0 0 0 0]
    [0 0 0 0 0 0 0 0 0 0 1 1]
    [0 0 0 0 0 0 0 0 0 1 0 1]
    [0 0 0 0 0 0 0 0 0 1 1 0]
&gt; #Aut;
18
&gt; IsAbelian(Aut);
true
&gt; AbelianInvariants(Aut);
[ 3, 6 ]
</PRE>
<P>
The module has 18 automorphisms. The automorphism group is
isomorphic to the abelian group Z<sub>2</sub> x Z<sub>3</sub> x Z<sub>3</sub>.
<HR>
<PRE></PRE> <A  HREF = "text1026.htm">[Next]</A><A  HREF = "text1024.htm">[Prev]</A> <A  HREF = "text1026.htm">[Right]</A> <A  HREF = "text1024.htm">[Left]</A> <A  HREF = "text1023.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<br><small>Version: V2.22 of <I>
Thu Jun  9 16:37:49 EST 2016
</I></small>
</body></html>