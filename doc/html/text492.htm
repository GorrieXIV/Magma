<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <link rel='stylesheet' href='help.css' type='text/css'>
  <TITLE>Polynomials</TITLE>
</head>
<body BGCOLOR="#FFFFFF">

 <A  HREF = "text493.htm">[Next]</A><A  HREF = "text491.htm">[Prev]</A> <A  HREF = "text493.htm">[Right]</A> <A  HREF = "text491.htm">[Left]</A> <A  HREF = "text481.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<PRE></PRE><H3><A NAME = "5379">Polynomials</A></H3>

<P>
<P>
Various simple operations for polynomials as well as root finding and 
factorization functions have been implemented for polynomials over local 
rings and fields.



<H5>Subsections</H5>
<UL>
<LI> <A  HREF = "text492.htm#5380">Operations for Polynomials</A>
<LI> <A  HREF = "text492.htm#5384">Roots of Polynomials</A>
<LI> <A  HREF = "text492.htm#5395">Factorization</A>
</UL>
<H4><A NAME = "5380">Operations for Polynomials</A></H4>

<P>
<P>
A number of functions for polynomials in general are applicable for polynomials 
over local rings and fields. Arithmetic functions, including <TT>div</TT> and <TT>mod</TT> can be used with such polynomials (though there may be some precision
loss), as well as all the elementary functions to access coefficients and so
forth. Derivatives can be taken and polynomials over local rings and
fields can be evaluated at elements coercible into the coefficient ring.
Along with GCD for these polynomials, the LCM of two polynomials
can also be found.
<P>
Although the ring of polynomials over a local ring is not a principal ideal
domain, it is useful to have a GCD function available.  For example, for
polynomials which are coprime over the local field, the ideal generated by the
two polynomials contains some power of the uniformizing element of the local
ring. This power determines whether an approximate factorization can be lifted
to a proper factorization.


<H5>f div g : RngUPolElt, RngUPolElt -&gt; RngUPolElt</H5>

<H5>f mod g : RngUPolElt, RngUPolElt -&gt; RngUPolElt</H5>

<H5>LeastCommonMultiple(f, g) : RngUPolElt, RngUPolElt -&gt; RngUPolElt</H5><P>


<H5>Coefficient(f, i) : RngUPolElt, RngIntElt -&gt; RngElt</H5>

<H5>LeadingCoefficient(f) : RngUPolElt -&gt; RngElt</H5><P>


<H5>Derivative(f) : RngUPolElt -&gt; RngUPolElt</H5>

<H5>Evaluate(f, x) : RngUPolElt, RngElt -&gt; RngElt</H5><P>


<H5><A NAME = "5381">GreatestCommonDivisor(f, g) : RngUPolElt, RngUPolElt -&gt; RngUPolElt</A></H5>
<H5>Gcd(f, g) : RngUPolElt, RngUPolElt -&gt; RngUPolElt</H5>
<H5>GCD(f, g) : RngUPolElt, RngUPolElt -&gt; RngUPolElt</H5>
<BLOCKQUOTE>
Determine the greatest common divisor of polynomials f and g where f and
g are over a free precision local ring or field.
The GCD returned is such that the cofactors of the polynomials will have
coefficients in the ring (if the polynomial is not over a field).
The process of computing the GCD of two polynomials may result in some 
inaccuracy.  The GCD is computed by echelonizing the Sylvester matrix of
f and g.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "5382">Example <TT>RngLoc_gcd (H47E16)</TT></A></H3>
This example illustrates the usage and results of the GCD functions.  Note
the precision loss in the answer.
<P>
<P>
<PRE>
&gt; L := pAdicRing(5, 20);
&gt; R&lt;x&gt; := PolynomialRing(L);
&gt; elts := [Random(L) : i in [1..3]];
&gt; f := (x - elts[1])^3 * (x - elts[2])^2 * (x - elts[3]);
&gt; f;
x^6 + 31722977012336*x^5 - 34568128687249*x^4 + 
    4655751767246*x^3 + 11683626356181*x^2 - 
    29833674388290*x + 32360011367900
&gt; GCD(f, Derivative(f));
(1 + O(5^18))*x^3 - (934087632277 + O(5^18))*x^2 - 
    (89130566204 + O(5^18))*x + 1178670674955 + O(5^18)
&gt; f mod $1;
O(5^18)*x^5 + O(5^18)*x^4 + O(5^18)*x^3 + O(5^18)*x^2 +
    O(5^18)*x + O(5^19)
&gt; (x - elts[1])^2 * (x - elts[2]);
x^3 + 14324701430223*x^2 + 26613750293171*x + 
    31696248799955
&gt; ChangePrecision($1, 18);
(1 + O(5^18))*x^3 - (934087632277 + O(5^18))*x^2 - 
    (89130566204 + O(5^18))*x + 1178670674955 + O(5^18)
</PRE>
<HR>
<H5><A NAME = "5383">ShiftValuation(f, n) : RngUPolElt, RngIntElt -&gt; RngUPolElt</A></H5>
<BLOCKQUOTE>
Shifts the valuation of each coefficient of f by n, ie. scales
the polynomial by &pi;<sup>n</sup>.
</BLOCKQUOTE>
<H4><A NAME = "5384">Roots of Polynomials</A></H4>



<H5><A NAME = "5385">Hensel Lifting of Roots</A></H5>

<P>
<P>
<P>
Roots of a polynomial f defined over a local ring or field can be found by
first determining their valuation (using the Newton polygon),
 finding a first approximation over the finite field and
finally improving this approximation until the Hensel condition
 v(f(a)) &gt; 2v(f'(a)) is satisfied.


<H5><A NAME = "5386">NewtonPolygon(f) : RngUPolElt -&gt; NwtnPgon</A></H5>
<BLOCKQUOTE>
The Newton polygon of a polynomial f = &sum;<sub>i=0</sub><sup>n</sup> c<sub>i</sub> x<sup>i</sup> (over a local
ring or field) is the lower convex hull of the points (i, v(c<sub>i</sub>)). The
slopes of the Newton polygon determine the valuations of the roots of f in a
splitting ring and the number of roots with that valuation.  The faces of the
Newton polygon can be determined using the function <TT>Faces</TT> which returns
the faces expressed as the line mx + ny = c which coincides with the face.
The function <TT>GradientVector</TT> will return the m and n values from the
line so that the valuation (gradient) can be calculated.  The function <TT>EndVertices</TT> will return the end points of the face, the x coordinates of
which will give the number of roots with valuation equal to the gradient of the
face.
<P>
Newton polygons are discussed in greater detail in Chapter <A  HREF = "text548.htm#5802">NEWTON POLYGONS</A> and
are illustrated below.
</BLOCKQUOTE>
<H5><A NAME = "5387">ValuationsOfRoots(f) : RngUPolElt -&gt; SeqEnum[&lt;FldRatElt, RngIntElt&gt;]</A></H5>
<BLOCKQUOTE>
Return a sequence containing pairs which are valuations of roots of f and
the number of roots of f which have that valuation.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "5388">Example <TT>RngLoc_newton-polygon (H47E17)</TT></A></H3>
For a polynomial of the form g := &prod;(x - r<sub>i</sub>) we demonstrate that
the Newton polygon determines the valuations of the roots of g.
<P>
<P>
<PRE>
&gt; Z3 := pAdicRing(3, 30);
&gt; R&lt;y&gt; := PolynomialRing(Z3);
&gt; pi := UniformizingElement(Z3);
&gt; roots := [ pi^Random([0..3]) * Random(Z3) : i in [1..10] ];
&gt; [ Valuation(r) : r in roots ];
[ 3, 1, 6, 3, 0, 3, 2, 3, 3, 2 ]
&gt; g := &amp;* [ y - r : r in roots ];
&gt; N := NewtonPolygon(g);
&gt; N;
Newton Polygon of y^10 + 44594997030169*y^9 - 85346683389318*y^8 + 
    76213593390537*y^7 + 74689026811236*y^6 - 48671968754502*y^5 - 
    58608670426020*y^4 - 63609139981179*y^3 + 77334553491246*y^2 + 
    39962036019861*y - 94049035648173 over pAdicRing(3, 30)
&gt; F := Faces(N);
&gt; F;
[ &lt;6, 1, 26&gt;, &lt;3, 1, 23&gt;, &lt;2, 1, 17&gt;, &lt;1, 1, 9&gt;, &lt;0, 1, 0&gt; ]
&gt; [GradientVector(F[i]) : i in [1 .. #F]];
[ &lt;6, 1&gt;, &lt;3, 1&gt;, &lt;2, 1&gt;, &lt;1, 1&gt;, &lt;0, 1&gt; ]
&gt; [$1[i][1]/$1[i][2] : i in [1 ..#$1]];
[ 6, 3, 2, 1, 0 ]
&gt; [EndVertices(F[i]) : i in [1 .. #F]];
[
    [ &lt;0, 26&gt;, &lt;1, 20&gt; ],
    [ &lt;1, 20&gt;, &lt;6, 5&gt; ],
    [ &lt;6, 5&gt;, &lt;8, 1&gt; ],
    [ &lt;8, 1&gt;, &lt;9, 0&gt; ],
    [ &lt;9, 0&gt;, &lt;10, 0&gt; ]
]
&gt; [$1[i][2][1] - $1[i][1][1] : i in [1 .. #$1]];
[ 1, 5, 2, 1, 1 ]
</PRE>
So there is one root of valuation 6, five of valuation 3, two of valuation
2, one of valuation 1 and one root with valuation zero. This information 
could also have been gained using <TT>ValuationsOfRoots</TT>.
<P>
<P>
<PRE>
&gt; ValuationsOfRoots(g);
[ &lt;6, 1&gt;, &lt;3, 5&gt;, &lt;2, 2&gt;, &lt;1, 1&gt;, &lt;0, 1&gt; ]
</PRE>
<HR>
<H5><A NAME = "5389">HenselLift(f, x) : RngUPolElt, RngPadElt -&gt; RngPadElt</A></H5>
<H5>HenselLift(f, x) : RngUPolElt, RngPadResElt -&gt; RngPadResElt</H5>
<H5>HenselLift(f, x) : RngUPolElt, RngPadResExtElt -&gt; RngPadResExtElt</H5>
<H5>HenselLift(f, x) : RngUPolElt, FldPadElt -&gt; FldPadElt</H5>
<H5>HenselLift(f, x, k) : RngUPolElt, RngPadElt, RngIntElt -&gt; RngPadElt</H5>
<H5>HenselLift(f, x, k) : RngUPolElt, RngPadResElt, RngIntElt -&gt; RngPadResElt</H5>
<H5>HenselLift(f, x, k) : RngUPolElt, RngPadResExtElt, RngIntElt -&gt; RngPadResExtElt</H5>
<H5>HenselLift(f, x, k) : RngUPolElt, FldPadElt, RngIntElt -&gt; FldPadElt</H5>
<BLOCKQUOTE>
Return a root of the polynomial f over a local ring or field by lifting the 
approximate root x to a root with precision k (or the default precision of
the structure if not specified).
This results in an error, if the Hensel condition 
v(f(x)) &gt; 2v(f'(x)) is not satisfied.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "5390">Example <TT>RngLoc_Hensel (H47E18)</TT></A></H3>
This examples illustrates how Hensel lifting is used to compute square roots.
<P>
<P>
<PRE>
&gt; Zx&lt;x&gt; := PolynomialRing(Integers());
&gt; L1&lt;a&gt; := ext&lt;pAdicRing(3, 20) | 2&gt;;
&gt; L2&lt;b&gt; := ext&lt;L1 | x^2 + 3*x + 3&gt;;
&gt; R&lt;y&gt; := PolynomialRing(L2);
&gt; c := (a+b)^42;
&gt; r := L2 ! Sqrt(ResidueClassField(L2) ! c);
&gt; r;
a
&gt; rr := HenselLift(y^2-c, r);
&gt; rr;
(-1513703643*a - 1674232545)*b - 1219509587*a + 760894776
&gt; Valuation(rr^2 - c);
40
&gt; ChangePrecision(rr, 1);
a + O(b)
</PRE>
For p=2 the situation is a bit more difficult, since the derivative of y<sup>2</sup> -
c is not a unit at this point.
<P>
<P>
<PRE>
&gt; Zx&lt;x&gt; := PolynomialRing(Integers());
&gt; L1&lt;a&gt; := ext&lt;pAdicRing(2, 20) | 2&gt;;
&gt; L2&lt;b&gt; := ext&lt;L1 | x^2 + 2*x + 2&gt;;
&gt; R&lt;y&gt; := PolynomialRing(L2);
&gt; c := (a+b)^42;
&gt; r := L2 ! Sqrt(ResidueClassField(L2) ! c);
&gt; r;
1
&gt; HenselLift(y^2-c, r);

&gt;&gt; HenselLift(y^2-c, r);
             ^
Runtime error in 'HenselLift': Hensel lift condition is not satisfied
</PRE>
We have to find a better approximation for the square root first.
<P>
<P>
<PRE>
&gt; for d in GF(2,2) do
&gt;     if Valuation((r + b*L2!d)^2 - c) gt 4 then
&gt;         print L2!d;
&gt;     end if;
&gt; end for;
a + 1
&gt; r +:= b * (a+1);
&gt; HenselLift( y^2-c, r );
(-199021*a + 100463)*b + 204032*a - 31859 + O(b^38)
&gt; ChangePrecision($1, 1);
1 + O(b)
&gt; ChangePrecision($2, 2);
(a + 1)*b + 1 + O(b^2)
</PRE>
The square root is an element of reduced precision, since the proper root
is only guaranteed to coincide with the approximation up to valuation 18.
<HR>
<H5><A NAME = "5391">Functions returning Roots</A></H5>

<P>
<P>
<P>
These functions determine the roots of a polynomial from the factorization
of the polynomial.


<H5><A NAME = "5392">Roots(f) : RngUPolElt -&gt; [ &lt;RngPadElt, RngIntElt&gt; ]</A></H5>
<H5>Roots(f, R) : RngUPolElt, RngPad -&gt; [ &lt;RngPadElt, RngIntElt&gt; ]</H5>

<PRE>    IsSquarefree: BoolElt               Default: <TT>false</TT></PRE>
<BLOCKQUOTE>
Return the roots of the polynomial f over a local ring or field R as a
sequence of tuples of elements in R and multiplicities. If R is not
specified it is taken to be the coefficient ring of f.  If the polynomial is
known to be squarefree, the root-finding algorithm may run considerably faster.
</BLOCKQUOTE>
<H5><A NAME = "5393">HasRoot(f) : RngUPolElt -&gt; BoolElt, RngPadElt</A></H5>
<BLOCKQUOTE>
Try to find a root of the polynomial f over a local ring or field. 
If a root is found, this function
returns <TT>true</TT> and a root as a second value; otherwise it returns <TT>false</TT>.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "5394">Example <TT>RngLoc_ramified-ext (H47E19)</TT></A></H3>
We generate the ramified extensions of Z<sub>2</sub> of degree 2 by looping over
some Eisenstein polynomials with small coefficients and checking whether a new
polynomial has a root in one of the already known rings.
<P>
<P>
<PRE>
&gt; Zx&lt;x&gt; := PolynomialRing(Integers());
&gt; RamExt := [];
&gt; for c0 in [2, -2, 6, -6] do
&gt; for c1 in [0, 2, -2, 4, -4, 6, -6] do
&gt;     g := x^2 + c1*x + c0;
&gt;     new := true;
&gt;     for L in RamExt do
&gt;         if HasRoot(PolynomialRing(L)!g) then
&gt;             new := false;
&gt;             break L;
&gt;         end if;
&gt;     end for;
&gt;     if new then
&gt;         print "new field with polynomial", g;
&gt;         Append(~RamExt, ext&lt;pAdicRing(2, 20) | g&gt;);
&gt;     end if;
&gt; end for;
&gt; end for;
new field with polynomial x^2 + 2
new field with polynomial x^2 + 2*x + 2
new field with polynomial x^2 + 4*x + 2
new field with polynomial x^2 + 2*x - 2
new field with polynomial x^2 + 4*x - 2
new field with polynomial x^2 + 6
</PRE>
These are all such extensions, since the extensions of Q<sub>2</sub> of degree 2 are
in bijection to the 7 non-trivial classes of Q<sub>2</sub><sup> * </sup> / (Q<sub>2</sub><sup> * </sup>)<sup>2</sup> and one
of these classes yields the unramified extension.
<HR>
<H4><A NAME = "5395">Factorization</A></H4>

<P>
<P>
<P>
It is possible to factorize (to some precision) polynomials over a local ring
or field.  Approximate factorizations can also be lifted to a factorization to
greater precision.


<H5><A NAME = "5396">HenselLift(f, s) : RngUPolElt, [RngUPolElt] -&gt; [RngUPolElt]</A></H5>
<BLOCKQUOTE>
Given a sequence s of polynomials with coefficients
that can be coerced into the coefficient ring of f such that f &equiv; &prod;<sub>i=1</sub><sup>#s</sup> s[i] modulo &pi;, s[i] and [j] are co--prime modulo
&pi; for all i and j, and s[i] is monic for all i, find a more
accurate factorization t[1], t[2], ... t[#s] such that f &equiv; &prod;<sub>i=1</sub><sup>#s</sup> t[i] modulo &pi;<sup>k</sup>, where k is the minimum precision of
the coefficients of f.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "5397">Example <TT>RngLoc_Poly-Hensel (H47E20)</TT></A></H3>
If the reduction of a polynomial over the residue class field is not a power
of an irreducible polynomial, the factorization into powers of different
irreducibles can be lifted to a factorization over the local ring.
<P>
<P>
<PRE>
&gt; Z2 := pAdicRing(2, 25);
&gt; R&lt;x&gt; := PolynomialRing(Z2);
&gt; f := &amp;* [ x - i : i in [1..8] ];
&gt; F2 := ResidueClassField(Z2);
&gt; Factorization( PolynomialRing(F2)!f );
[
    &lt;$.1, 4&gt;,
    &lt;$.1 + 1, 4&gt;
]
&gt; h1 := x^4;
&gt; h2 := (x+1)^4;
&gt; h := HenselLift(f, [h1, h2]);
&gt; h[1], h[2], f - h[1]*h[2];
x^4 - 20*x^3 + 140*x^2 - 400*x + 384
x^4 - 16*x^3 + 86*x^2 - 176*x + 105
0
</PRE>
<HR>
<H5><A NAME = "5398">IsIrreducible(f) : RngUPolElt -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Given a polynomial f with coefficients lying in a local ring or field L,
return <TT>true</TT> if and only if f is irreducible over L.
Currently, this only works over p-adic rings, unramified extensions of
p-adic rings, totally ramified extensions of p-adic rings, and totally
ramified extension of unramified extensions of p-adic rings.
</BLOCKQUOTE>
<H5><A NAME = "5399">SquareFreeFactorization(f) : RngUPolElt -&gt; [ &lt; RngUPolElt, RngIntElt &gt; ]</A></H5>
<BLOCKQUOTE>
Return a sequence of tuples of polynomials and multiplicities
where the polynomials are not divisible by any square of a polynomial.
The product of the polynomials to the corresponding multiplicities is
the polynomial f (to some precision).
Currently, this only works over p-adic rings, unramified extensions of
p-adic rings, totally ramified extensions of p-adic rings, and totally
ramified extension of unramified extensions of p-adic rings.
</BLOCKQUOTE>
<H5><A NAME = "5400">Factorization(f) : RngUPolElt -&gt; [ &lt; RngUPolElt, RngIntElt &gt; ]</A></H5>
<H5>LocalFactorization(f) : RngUPolElt -&gt; [ &lt; RngUPolElt, RngIntElt &gt;]</H5>

<PRE>    Certificates: BoolElt               Default: <TT>false</TT></PRE>

<PRE>    IsSquarefree: BoolElt               Default: <TT>false</TT></PRE>

<PRE>    Ideals: BoolElt                     Default: <TT>false</TT></PRE>

<PRE>    Extensions: BoolElt                 Default: <TT>false</TT></PRE>
<BLOCKQUOTE>
Return the factorization of the polynomial f over a local ring or field into 
irreducible factors as a sequence of pairs, the first entry giving the 
irreducible factor and the second its multiplicity. 
<P>
Precision is important since for polynomials over rings of relatively small
precision a correct factorization may not be possible and an error will
result. 
A lower bound on the precision needed for the factorization to succeed
is given by <TT>SuggestedPrecision</TT>; this precision may still be
insufficient, however.
<P>
The precision the factorization is returned to is reduced for multiple factors.
<P>
The optional parameter <TT>IsSquarefree</TT> can be set to <TT>true</TT>, if the
polynomial is known to be square-free. The <TT>Certificates</TT> parameter
can be set to
<TT>true</TT> to compute certificates for the irreducibility of the individual
factors returned. This information can be used to compute the
p-maximal order of the equation order defined by the factor.
If the <TT>Extensions</TT> parameter is set to <TT>true</TT> then certificates
will be returned which will include an extension given by each factor.
</BLOCKQUOTE>
<H5><A NAME = "5401">SuggestedPrecision(f) : RngUPolElt -&gt; RngIntElt</A></H5>
<BLOCKQUOTE>
For a polynomial f over a local ring or field, return a precision at which
the factorization of f as given by <TT>Factorization(f)</TT> will be Hensel
liftable to the correct factorization.
<P>
The precision returned is not guaranteed to be enough to obtain a factorization
of the polynomial. It may be that a correct factorization cannot be found at 
that precision but may be possible with a little more precision.
<P>
Currently, this only works over p-adic rings, unramified extensions of
p-adic rings, totally ramified extensions of p-adic rings, and totally
ramified extension of unramified extensions of p-adic rings.
</BLOCKQUOTE>
<H5><A NAME = "5402">IsIsomorphic(f, g) : RngUPolElt, RngUPolElt -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Given two irreducible polynomials over the same  p-adic field,
test if the extensions defined by them are isomorphic.
</BLOCKQUOTE>
<H5><A NAME = "5403">Distance(f, g) : RngUPolElt, RngUPolElt -&gt; RngIntElt</A></H5>
<BLOCKQUOTE>
Given two Eisenstein polynomials of the same degree and discriminant
compute their distance, i.e. the minimal weighted valuation of the 
difference of the coefficients.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "5404">Example <TT>RngLoc_factors-precision (H47E21)</TT></A></H3>
The use of <TT>SuggestedPrecision</TT> along with <TT>Factorization</TT> is
illustrated below for a few different cases.
<P>
<P>
<PRE>
&gt; L&lt;b&gt; := ext&lt;ext&lt;pAdicRing(5, 20) | 2&gt; |  y^2 + 5*y + 5&gt;;
&gt; R&lt;x&gt; := PolynomialRing(L);
&gt; f := (x - 1)^3*(x - b)^2*(x - b^2 + b - 1);
&gt; SuggestedPrecision(f);
80
&gt; Factorization(f);
[
    &lt;x - b + O(b^40), 2&gt;,
    &lt;x - 1 + O(b^40), 3&gt;,
    &lt;x + 6*b + 4 + O(b^40), 1&gt;
]
1 + O(b^40) 
&gt; f := (x + 2)^3*(x + b)*(x + 3)^4;
&gt; f;
x^8 + (b + 18 + O(b^40))*x^7 + (18*b + 138 + O(b^40))*x^6 + (138*b + 584 +
    O(b^40))*x^5 + (584*b + 1473 + O(b^40))*x^4 + (1473*b + 2214 + O(b^40))*x^3
    + (2214*b + 1836 + O(b^40))*x^2 + (1836*b + 648 + O(b^40))*x + 648*b +
    O(b^40)
&gt; SuggestedPrecision(f);
80
&gt; Precision(L);
80
&gt; P&lt;y&gt; := PolynomialRing(Integers());
&gt; R&lt;b&gt; := ext&lt;ext&lt;pAdicRing(3, 20) | 2&gt; |  y^2 + 3*y + 3&gt;;
&gt; P&lt;x&gt; := PolynomialRing(R);
&gt; f := x^12 + 100*x^11 + 4050*x^10 + 83700*x^9 + 888975*x^8 + 3645000*x^7 - 
&gt; 10570500*x^6 - 107163000*x^5 + 100875375*x^4 + 1131772500*x^3 - 
&gt; 329614375*x^2 + 1328602500*x + 332150625;
&gt; SuggestedPrecision(f);
48
&gt; Factorization(f);
[
    &lt;x + 153560934 + O(b^40), 1&gt;,
    &lt;x - 1595360367 + O(b^40), 1&gt;,
    &lt;x + 1273329451*$.1 - 1037496066 + O(b^40), 1&gt;,
    &lt;x + -1273329451*$.1 - 97370567 + O(b^40), 1&gt;,
    &lt;x^4 + (-1598252738*$.1 - 309919655 + O(b^40))*x^3 + (-280421715*$.1 -
        102998055 + O(b^40))*x^2 + (1263867503*$.1 + 923047935 + O(b^40))*x +
        -1252549104*$.1 - 786365260 + O(b^40), 1&gt;,
    &lt;x^4 + (1598252738*$.1 - 600198580 + O(b^40))*x^3 + (280421715*$.1 +
        457845375 + O(b^40))*x^2 + (-1263867503*$.1 - 1604687071 + O(b^40))*x +
        1252549104*$.1 + 1718732948 + O(b^40), 1&gt;
]
1 + O(b^40) 
&gt; R&lt;b&gt; := ext&lt;ext&lt;pAdicRing(3, 25) | 2&gt; |  y^2 + 3*y + 3&gt;;
&gt; P&lt;x&gt; := PolynomialRing(R);
&gt; f := x^12 + 100*x^11 + 4050*x^10 + 83700*x^9 + 888975*x^8 + 3645000*x^7 -
&gt; 10570500*x^6 - 107163000*x^5 + 100875375*x^4 + 1131772500*x^3 -
&gt; 329614375*x^2 + 1328602500*x + 332150625;
&gt; Factorization(f);
[
    &lt;x + 143905694229 + O(b^50), 1&gt;,
    &lt;x - 399882754935 + O(b^50), 1&gt;,
    &lt;x + 46601526664*$.1 + 229090274400 + O(b^50), 1&gt;,
    &lt;x + -46601526664*$.1 + 135887221072 + O(b^50), 1&gt;,
    &lt;x^4 + (242476655332*$.1 + 187976437999 + O(b^50))*x^3 + (372805509192*$.1 -
        38457626466 + O(b^50))*x^2 + (126788105939*$.1 + 60198382752 +
        O(b^50))*x + 347425890996*$.1 + 215394267602 + O(b^50), 1&gt;,
    &lt;x^4 + (-242476655332*$.1 - 296976872665 + O(b^50))*x^3 + (-372805509192*$.1
        + 63219964593 + O(b^50))*x^2 + (-126788105939*$.1 - 193377829126 +
        O(b^50))*x + -347425890996*$.1 + 367831095053 + O(b^50), 1&gt;
]
1 + O(b^50) 
</PRE>
Note that the polynomial itself must have coefficients with precision at 
least that given by <TT>SuggestedPrecision</TT> (and not just the coefficient
ring) for <TT>Factorization</TT> to succeed. Sometimes this will not be
possible if the coefficients of the polynomial are not known to sufficient
precision.
<HR>
<H3><A NAME = "5405">Example <TT>RngLoc_Factors (H47E22)</TT></A></H3>
In this example we demonstrate how factorizations of a rational polynomial
over some local rings can give information on the Galois group.
<P>
<P>
<PRE>
&gt; Zx&lt;x&gt; := PolynomialRing(Integers());
&gt; g := x^5 - x + 1;
&gt; Factorization(Discriminant(g));
[ &lt;19, 1&gt;, &lt;151, 1&gt; ]
&gt; g2 := Factorization( PolynomialRing(pAdicRing(2, 10)) ! g );
&gt; g2;
[
    &lt;$.1^2 + 367*$.1 - 93, 1&gt;,
    &lt;$.1^3 - 367*$.1^2 - 386*$.1 + 11, 1&gt;
]
&gt; g3 := Factorization( PolynomialRing(pAdicRing(3, 10)) ! g );
&gt; g3;
[
    &lt;$.1^5 - $.1 + 1, 1&gt;
]
&gt; g7 := Factorization( PolynomialRing(pAdicRing(7, 10)) ! g );
&gt; g7;
[
    &lt;$.1^2 + 138071312*$.1 + 2963768, 1&gt;,
    &lt;$.1^3 - 138071312*$.1^2 + 132202817*$.1 - 84067650, 1&gt;
]
</PRE>
This shows that the Galois group of g contains elements of orders 2, 3, 5
and 6, and therefore is isomorphic to S<sub>5</sub>.
<HR>
<H5><A NAME = "5406">SplittingField(f) : RngUPolElt[FldPad] -&gt; FldPad, SeqEnum</A></H5>
<H5>SplittingField(f) : RngUPolElt[RngPad] -&gt; FldPad, SeqEnum</H5>

<PRE>    Std: BoolElt                        Default: true</PRE>
<BLOCKQUOTE>
Splitting field F of a squarefree polynomial f over a p-adic ring or 
field K, and the roots of f in F. The optional parameter <TT>Std</TT> 
(true by default) specifies whether F/K should be converted to a standard 
form --- at most one ramified extension over one unramified extension of K. 
</BLOCKQUOTE>
<HR>
<H3><A NAME = "5407">Example <TT>RngLoc_rngloc-splittingfield (H47E23)</TT></A></H3>
<P>
<P>
<PRE>
&gt; K:=pAdicField(3,20);
&gt; R&lt;x&gt;:=PolynomialRing(K);
&gt; F:=SplittingField(x^9-3);
&gt; Degree(F,K), RamificationDegree(F,K), InertiaDegree(F,K);
54 54 1
</PRE>
<HR>
<PRE></PRE> <A  HREF = "text493.htm">[Next]</A><A  HREF = "text491.htm">[Prev]</A> <A  HREF = "text493.htm">[Right]</A> <A  HREF = "text491.htm">[Left]</A> <A  HREF = "text481.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<br><small>Version: V2.22 of <I>
Thu Jun  9 16:37:49 EST 2016
</I></small>
</body></html>