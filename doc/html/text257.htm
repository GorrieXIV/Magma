<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <link rel='stylesheet' href='help.css' type='text/css'>
  <TITLE>Determinant and Other Properties</TITLE>
</head>
<body BGCOLOR="#FFFFFF">

 <A  HREF = "text258.htm">[Next]</A><A  HREF = "text256.htm">[Prev]</A> <A  HREF = "text258.htm">[Right]</A> <A  HREF = "text256.htm">[Left]</A> <A  HREF = "text247.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<PRE></PRE><H3><A NAME = "2388">Determinant and Other Properties</A></H3>



<H5><A NAME = "2389">Determinant(A: parameters) : Mtrx -&gt; RngElt</A></H5>

<PRE>    MonteCarloLevel: RngIntElt          Default: 0</PRE>

<PRE>    Proof: BoolElt                      Default: <TT>true</TT></PRE>

<PRE>    pAdic: BoolElt                      Default: <TT>true</TT></PRE>

<PRE>    Divisor: RngIntElt                  Default: 0</PRE>
<BLOCKQUOTE>
Given a square matrix A over the ring R, return the
determinant of A as an element of R.
R may be any commutative ring.
The determinant of the 0 x 0 matrix over R is defined to be <TT>R!1</TT>.
<P>
If the coefficient ring is the integer ring Z or the rational field
Q then a modular algorithm based on that of
Abbott et al. <A  HREF = "text246.htm#bib_ABM_Det">[ABM99]</A> is
used, which first computes a divisor d of the determinant D using a fast
p-adic nullspace computation, and then computes the quotient D/d
by computing the determinant D modulo enough small primes to cover
the Hadamard bound divided by d.  This always yields a correct answer.
<P>
If the parameter <TT>MonteCarloLevel</TT> is set to a small positive 
integer s, then a probabilistic Monte-Carlo modular technique is
used.  Rather than using sufficient primes to cover the Hadamard bound divided
by the divisor d,
this version of the algorithm terminates when the constructed residue 
remains constant for s steps.  The probability of this being wrong is
non-zero but extremely small, even if s is only 1 or 2.
If the level is set to 0, then the normal deterministic algorithm
is used.  Setting the parameter <TT>Proof</TT> to <TT>false</TT> is equivalent
to setting <TT>MonteCarloLevel</TT> to 2.
<P>
If the coefficient ring is Z and the parameter <TT>Divisor</TT>
is set to an integer d, then d must be a known exact divisor of the
determinant (the sign does not matter), and the algorithm may be
sped up because of this knowledge.
</BLOCKQUOTE>
<H5><A NAME = "2390">Trace(A) : Mtrx -&gt; RngElt</A></H5>
<BLOCKQUOTE>
Given a square matrix A over the ring R, return the trace of A
as an element of R, which is simply the sum of the diagonal elements
of A.
</BLOCKQUOTE>
<H5><A NAME = "2391">TraceOfProduct(A, B) : Mtrx, Mtrx -&gt; RngElt</A></H5>
<BLOCKQUOTE>
Given square matrices A and B over the ring R, with the same size,
return the trace of A.B as an element of R.  This is in general
much faster than the call <TT>Trace(A*B)</TT>.
</BLOCKQUOTE>
<H5><A NAME = "2392">Rank(A) : Mtrx -&gt; RngIntElt</A></H5>
<BLOCKQUOTE>
Given an m x n matrix A over a ring R, return the rank
of A.  This is defined to be the largest r such that there
exists a non-zero r x r subdeterminant of A, so r&le;m and
r &le;n.  The rank may have to be obtained by computing the Smith
form or echelon form of A, and this computation may be quite expensive
over some rings.
</BLOCKQUOTE>
<H5><A NAME = "2393">Minor(M, i, j) : Mtrx, RngIntElt, RngIntElt -&gt; RngElt</A></H5>
<BLOCKQUOTE>
The determinant of the submatrix of M (which must be square) formed
by removing the i-th row and j-th column.
</BLOCKQUOTE>
<H5><A NAME = "2394">Minor(M, I, J) : Mtrx, [RngIntElt], [RngIntElt] -&gt; RngElt</A></H5>
<BLOCKQUOTE>
The determinant of the submatrix of M given by the row indices in I
and the column indices in J.
</BLOCKQUOTE>
<H5><A NAME = "2395">Minors(M, r) : Mtrx, RngIntElt -&gt; SeqEnum</A></H5>
<BLOCKQUOTE>
Returns a sequence of all the r by r minors of the matrix M.
</BLOCKQUOTE>
<H5><A NAME = "2396">Cofactor(M, i, j) : Mtrx, RngIntElt, RngIntElt -&gt; RngElt</A></H5>
<BLOCKQUOTE>
The appropriate cofactor of M, equal to ( - 1)<sup>i + j</sup> times the
corresponding minor.
</BLOCKQUOTE>
<H5><A NAME = "2397">Cofactors(M) : Mtrx -&gt; SeqEnum</A></H5>
<BLOCKQUOTE>
Returns a sequence of all the cofactors of the matrix M.
</BLOCKQUOTE>
<H5><A NAME = "2398">Cofactors(M, r) : Mtrx, RngIntElt -&gt; SeqEnum</A></H5>
<BLOCKQUOTE>
Returns a sequence of all the r by r cofactors of the matrix M.
</BLOCKQUOTE>
<H5><A NAME = "2399">Pfaffian(M) : Mtrx -&gt; RngElt</A></H5>
<H5>Pfaffian(M, I, J) : Mtrx, [RngIntElt], [RngIntElt] -&gt; RngElt</H5>
<H5>Pfaffians(M, r) : Mtrx, RngIntElt -&gt; SeqEnum</H5>
<BLOCKQUOTE>
Let M be an anti-symmetric square matrix. Then its determinant is always
a square and a particular square-root of this, which can be
described by a universal polynomial in its entries, is called the
Pfaffian of M. The first function returns this.
The second function returns the Pfaffian of the submatrix of M described
by the indices in I and J.  The third function
returns the sequence of Pfaffians of the (n choose r) principal
r by r submatrices of M (n= the number of rows of M).
<P>
These are primarily convenience functions and are computed naively by
Pfaffian row-expansion.
</BLOCKQUOTE>
<PRE></PRE> <A  HREF = "text258.htm">[Next]</A><A  HREF = "text256.htm">[Prev]</A> <A  HREF = "text258.htm">[Right]</A> <A  HREF = "text256.htm">[Left]</A> <A  HREF = "text247.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<br><small>Version: V2.22 of <I>
Thu Jun  9 16:37:49 EST 2016
</I></small>
</body></html>