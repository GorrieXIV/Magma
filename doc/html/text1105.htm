<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <link rel='stylesheet' href='help.css' type='text/css'>
  <TITLE>Operations on Coxeter Groups</TITLE>
</head>
<body BGCOLOR="#FFFFFF">

 <A  HREF = "text1106.htm">[Next]</A><A  HREF = "text1104.htm">[Prev]</A> <A  HREF = "text1106.htm">[Right]</A> <A  HREF = "text1104.htm">[Left]</A> <A  HREF = "text1101.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<PRE></PRE><H3><A NAME = "12361">Operations on Coxeter Groups</A></H3>

<P>
<P>
<P>
<P>
See Chapter <A  HREF = "text808.htm#9089">FINITELY PRESENTED GROUPS</A> for general functions for finitely presented
groups, or
Chapter <A  HREF = "text629.htm#6871">PERMUTATION GROUPS</A> for general functions for permutation
groups.


<H5><A NAME = "12362">IsIsomorphic(W1, W2) : GrpPermCox, GrpPermCox -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if, and only if, W<sub>1</sub> and W<sub>2</sub> are isomorphic as
abstract groups.
This is only implemented for permutation Coxeter groups.
</BLOCKQUOTE>
<H5><A NAME = "12363">IsCoxeterIsomorphic(W1, W2) : GrpFPCox, GrpFPCox -&gt; BoolElt</A></H5>
<H5>IsCoxeterIsomorphic(W1, W2) : GrpPermCox, GrpPermCox -&gt; BoolElt</H5>
<BLOCKQUOTE>
Tests if W<sub>1</sub> and W<sub>2</sub> are isomorphic as Coxeter systems.
If <TT>true</TT>, a sequence giving the permutation of the generators which 
takes W<sub>1</sub> to W<sub>2</sub> is also returned.
</BLOCKQUOTE>
<H5><A NAME = "12364">IsCartanEquivalent(W1, W2) : GrpPermCox, GrpPermCox -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if and only if the crystallographic Coxeter groups 
W<sub>1</sub> and W<sub>2</sub> have Cartan equivalent Cartan matrices.
This only makes sense for permutation Coxeter groups.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "12365">Example <TT>GrpCox_CoxeterIsomorphism (H104E6)</TT></A></H3>
<P>
<P>
<PRE>
&gt; W1 := CoxeterGroup(GrpFPCox, "B4");
&gt; W2 := CoxeterGroup(GrpFPCox, "C4");
&gt; IsCoxeterIsomorphic(W1, W2);
true [ 1, 2, 3, 4 ]
</PRE>
An example of abstractly isomorphic Coxeter groups whose Coxeter systems
not isomorphic:
<P>
<P>
<PRE>
&gt; W1 := CoxeterGroup("G2");
&gt; W2 := CoxeterGroup("A1A2");
&gt; IsIsomorphic(W1, W2);
true
&gt; IsCoxeterIsomorphic(W1, W2);
false
</PRE>
An example of Coxeter isomorphic groups which are not Cartan equivalent:
<P>
<P>
<PRE>
&gt; W1 := CoxeterGroup("B3");
&gt; W2 := CoxeterGroup("C3");
&gt; IsIsomorphic(W1, W2);
true
&gt; IsCoxeterIsomorphic(W1, W2);
true [ 1, 2, 3 ]
&gt; IsCartanEquivalent(W1, W2);
false
</PRE>
<HR>
<H5><A NAME = "12366">RootSystem(W) : GrpPermCox -&gt; RootDtm</A></H5>
<BLOCKQUOTE>
The underlying root system of the permutation Coxeter groupW.
</BLOCKQUOTE>
<H5><A NAME = "12367">RootDatum(W) : GrpPermCox -&gt; RootDtm</A></H5>
<BLOCKQUOTE>
The root datum of the permutation Coxeter groupW.
If W does not have a root datum, an error is flagged.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "12368">Example <TT>GrpCox_GroupToRoot (H104E7)</TT></A></H3>
<P>
<P>
<PRE>
&gt; W := CoxeterGroup("C5");
&gt; RootSystem(W);
Root system of type C5
&gt; RootDatum(W);
Root datum of type C5
&gt; 
&gt; W := CoxeterGroup("H4");
&gt; RootSystem(W);
Root system of type H4
&gt; RootDatum(W);
Error: This group does not have a root datum
</PRE>
<HR>
<H5><A NAME = "12369">CartanName(W) : GrpFPCox -&gt; List</A></H5>
<H5>CartanName(W) : GrpPermCox -&gt; MonStgElt</H5>
<BLOCKQUOTE>
The Cartan name of the finite or affine Coxeter group W 
(Section <A  HREF = "text1074.htm#11954">Finite and Affine Coxeter  Groups</A>).
</BLOCKQUOTE>
<H5><A NAME = "12370">CoxeterDiagram(W) : GrpFPCox -&gt;</A></H5>
<H5>CoxeterDiagram(W) : GrpPermCox -&gt;</H5>
<BLOCKQUOTE>
Print the Coxeter diagram of the finite or affine 
Coxeter group W 
(Section <A  HREF = "text1074.htm#11954">Finite and Affine Coxeter  Groups</A>).
</BLOCKQUOTE>
<H5><A NAME = "12371">DynkinDiagram(W) : GrpPermCox -&gt;</A></H5>
<BLOCKQUOTE>
Print the Dynkin diagramof the permutation Coxeter group W.
If W is not crystallographic, an error is flagged.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "12372">Example <TT>GrpCox_NamesDiagrams (H104E8)</TT></A></H3>
<P>
<P>
<PRE>
&gt; W := CoxeterGroup("F4");
&gt; CartanName(W);
F4
&gt; DynkinDiagram(W);

F4    1 - 2 =&gt;= 3 - 4
&gt; CoxeterDiagram(W);

F4    1 - 2 === 3 - 4
</PRE>
<HR>
<H5><A NAME = "12373">CoxeterMatrix(W) : GrpFPCox -&gt; AlgMatElt</A></H5>
<H5>CoxeterMatrix(W) : GrpPermCox -&gt; AlgMatElt</H5>
<BLOCKQUOTE>
The Coxeter matrix of the Coxeter group W.
</BLOCKQUOTE>
<H5><A NAME = "12374">CoxeterGraph(W) : GrpFPCox -&gt; GrphUnd</A></H5>
<H5>CoxeterGraph(W) : GrpPermCox -&gt; GrphUnd</H5>
<BLOCKQUOTE>
The Coxeter graph of the Coxeter group W.
</BLOCKQUOTE>
<H5><A NAME = "12375">CartanMatrix(W) : GrpPermCox -&gt; AlgMatElt</A></H5>
<BLOCKQUOTE>
The Cartan matrix of the permutation Coxeter group W.
</BLOCKQUOTE>
<H5><A NAME = "12376">DynkinDigraph(W) : GrpPermCox -&gt; GrphDir</A></H5>
<BLOCKQUOTE>
The Dynkin digraph of the permutation Coxeter group W.
</BLOCKQUOTE>
<H5><A NAME = "12377">Rank(W) : GrpFPCox -&gt; RngIntElt</A></H5>
<H5>Rank(W) : GrpPermCox -&gt; RngIntElt</H5>
<H5>NumberOfGenerators(W) : GrpFPCox -&gt; RngIntElt</H5>
<H5>NumberOfGenerators(W) : GrpPermCox -&gt; RngIntElt</H5>
<BLOCKQUOTE>
The rank of the Coxeter group W.
</BLOCKQUOTE>
<H5><A NAME = "12378">NumberOfPositiveRoots(W) : GrpFPCox -&gt; RngIntElt</A></H5>
<H5>NumberOfPositiveRoots(W) : GrpPermCox -&gt; RngIntElt</H5>
<H5>NumPosRoots(W) : GrpFPCox -&gt; RngIntElt</H5>
<H5>NumPosRoots(W) : GrpPermCox -&gt; RngIntElt</H5>
<BLOCKQUOTE>
The number of positive roots of the Coxeter group W.
</BLOCKQUOTE>
<H5><A NAME = "12379">Dimension(W) : GrpPermCox -&gt; RngIntElt</A></H5>
<BLOCKQUOTE>
The dimension of the permutation Coxeter group W, 
ie. the dimension of the root space.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "12380">Example <TT>GrpCox_RankDimension (H104E9)</TT></A></H3>
<P>
<P>
<PRE>
&gt; R := StandardRootSystem("A", 4);
&gt; W := CoxeterGroup(R);
&gt; Rank(W);
4
&gt; Dimension(W);
5
</PRE>
<HR>
<H5><A NAME = "12381">ConjugacyClasses(W) : GrpFPCox -&gt; [GrpFPCoxElt]</A></H5>
<H5>ConjugacyClasses(W) : GrpPermCox -&gt; [GrpPermElt]</H5>
<BLOCKQUOTE>
The conjugacy classes of the finite Coxeter group W.
This uses the algorithm of <A  HREF = "text1100.htm#bib_GeckPfeiffer">[GP00]</A>.
</BLOCKQUOTE>
<H5><A NAME = "12382">FundamentalGroup(W) : GrpPermCox -&gt; GrpAb</A></H5>
<BLOCKQUOTE>
The fundamental groupof the permutation 
Coxeter
group W. 
The roots and coroots of W must have integral components.
</BLOCKQUOTE>
<H5><A NAME = "12383">IsogenyGroup(W) : GrpPermCox -&gt; GrpAb</A></H5>
<BLOCKQUOTE>
The isogeny groupof the permutation Coxeter group W.
The roots and coroots of W must have integral components.
</BLOCKQUOTE>
<H5><A NAME = "12384">CoisogenyGroup(W) : GrpPermCox -&gt; GrpAb</A></H5>
<BLOCKQUOTE>
The coisogeny groupof the permutation Coxeter group W.
The roots and coroots of W must have integral components.
</BLOCKQUOTE>
<H5><A NAME = "12385">BasicDegrees(W) : GrpFPCox -&gt; RngIntElt</A></H5>
<H5>BasicDegrees(W) : GrpPermCox -&gt; RngIntElt</H5>
<BLOCKQUOTE>
The degrees of the basic invariant polynomials of the Coxeter group
W.  
These are computed using the table in <A  HREF = "text1100.htm#bib_Carter-small">[Car72, page 155]</A>.
</BLOCKQUOTE>
<H5><A NAME = "12386">BasicCodegrees(W) : GrpFPCox -&gt; RngIntElt</A></H5>
<H5>BasicCodegrees(W) : GrpPermCox -&gt; RngIntElt</H5>
<BLOCKQUOTE>
The basic codegrees of the Coxeter group W.  
These are computed using the algorithm in <A  HREF = "text1100.htm#bib_LehrerTaylor">[LT09]</A>.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "12387">Example <TT>GrpCox_BasicDegrees (H104E10)</TT></A></H3>
The product of the basic degrees is the order of the Coxeter
group; the sum of the basic degrees is the sum of the rank and the
number of positive roots.
<P>
<P>
<PRE>
&gt; W := CoxeterGroup("E6");
&gt; degs := BasicDegrees(W);
&gt; degs;
[ 2, 5, 6, 8, 9, 12 ]
&gt; &amp;*degs eq #W;
true
&gt; &amp;+degs eq NumPosRoots(W) + Rank(W);
true
</PRE>
<HR>
<H5><A NAME = "12388"></A><A NAME = "bruhatlessorequal">BruhatLessOrEqual</A>(x, y) : GrpPermElt, GrpPermElt -&gt; BoolElt</H5>
<BLOCKQUOTE>
If Coxeter group element x is less than or equal to y in the Bruhat
order <A  HREF = "text1100.htm#bib_Deodhar">[Deo77]</A>. 
Suppose x is an element of the Coxeter group W.
The Bruhat order is the partial order generated by the relations: 
x &le;xw if l(x) &lt; l(xw), and xw &le;x if l(xw) &lt; l(x), for x&isin;W and w a reflection. 
If l(xw) =
l(x) + 1, then x is called a <I>Bruhat descendant</I> of xw.  
The algorithm used is a straightforward recursive procedure.
</BLOCKQUOTE>
<H5><A NAME = "12389"></A><A NAME = "bruhatdescendants">BruhatDescendants</A>(x) : GrpPermElt -&gt; SetEnum</H5>

<PRE>    z: GrpPermElt                       Default: </PRE>
<BLOCKQUOTE>
Let x be an element of the Coxeter group W, then the returned set S
contains the Bruhat descendants of x.
If l(yw) = l(y) + 1, then y is called a <I>Bruhat descendant</I> of yw.  
If the optional parameter z is set, only those descendants y with z
&le;y are returned. 
Algorithm: For each fundamental reflection in x it is tested whether leaving 
it out decreases the length of x by exactly 1. If so, it is included in the result. 
In particular, this algorithm does not use <A  HREF = "text1105.htm#bruhatlessorequal">BruhatLessOrEqual</A>.
</BLOCKQUOTE>
<H5><A NAME = "12390">BruhatDescendants(X) : SetEnum -&gt; SetEnum</A></H5>

<PRE>    z: GrpPermElt                       Default: </PRE>
<BLOCKQUOTE>
Let X consist of elements of the Coxeter group W, then the returned set S contains the Bruhat descendants of every element of X. 
<P>
If the optional parameter z is set, only those w are returned for which z &le;w in the Bruhat ordering.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "12391">Example <TT>GrpCox_BruhatDescendants (H104E11)</TT></A></H3>
Bruhat descendants:
<P>
<P>
<PRE>
&gt; R := RootDatum("D4" : Isogeny := "SC");
&gt; W := CoxeterGroup(GrpPermCox, R);
&gt; Wfp,phi := CoxeterGroup(GrpFPCox, W);
&gt; x := W.1*W.3*W.2*W.4*W.2*W.2*W.2*W.1;
&gt; Eltseq(phi(x));
[ 1, 3, 2, 4, 2, 1 ]
&gt; S := BruhatDescendants(x);
&gt; { Eltseq(phi(w)) : w in S };
{
     [ 1, 3, 2, 4, 2 ],
     [ 3, 2, 4, 2, 1 ],
     [ 1, 2, 4, 2, 1 ],
     [ 1, 3, 2, 1, 4 ],
     [ 1, 3, 4, 2, 1 ]
}
</PRE>
<HR>
<PRE></PRE> <A  HREF = "text1106.htm">[Next]</A><A  HREF = "text1104.htm">[Prev]</A> <A  HREF = "text1106.htm">[Right]</A> <A  HREF = "text1104.htm">[Left]</A> <A  HREF = "text1101.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<br><small>Version: V2.22 of <I>
Thu Jun  9 16:37:49 EST 2016
</I></small>
</body></html>