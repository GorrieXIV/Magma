<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <link rel='stylesheet' href='help.css' type='text/css'>
  <TITLE>Construction of New Lattices</TITLE>
</head>
<body BGCOLOR="#FFFFFF">

 <A  HREF = "text312.htm">[Next]</A><A  HREF = "text310.htm">[Prev]</A> <A  HREF = "text312.htm">[Right]</A> <A  HREF = "text310.htm">[Left]</A> <A  HREF = "text305.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<PRE></PRE><H3><A NAME = "2918">Construction of New Lattices</A></H3>




<H5>Subsections</H5>
<UL>
<LI> <A  HREF = "text311.htm#2919">Sub- and Superlattices and Quotients</A>
<LI> <A  HREF = "text311.htm#2929">Standard Constructions of New Lattices</A>
</UL>
<H4><A NAME = "2919">Sub- and Superlattices and Quotients</A></H4>



<H5><A NAME = "2920">sub&lt;L | S&gt; : Lat, List -&gt; Lat</A></H5>
<BLOCKQUOTE>
Given a lattice L and a list S, construct the sublattice L' of L
generated by the elements specified by the list S.
Each term S<sub>i</sub> of the list S must be an
expression defining an object of one of the following types:
<DL COMPACT class='compact'>
<DT>(a)</DT><DD>an element of L or coercible into L,
<DT>(b)</DT><DD>a set or sequence of elements coercible into L,
<DT>(c)</DT><DD>a sublattice of L,
<DT>(d)</DT><DD>a set or sequence of sublattices of L.
<P>
<P>
</DL>
The constructor returns the sublattice L' and the inclusion homomorphism
from L' into L.
</BLOCKQUOTE>
<H5><A NAME = "2921">ext&lt; L | S &gt; : Lat, List -&gt; Lat</A></H5>
<BLOCKQUOTE>
Given a lattice L lying inside V=R<sup>n</sup> and a list S, construct the
superlattice L' of L generated by L together with the elements
specified by the list S.
Each term S<sub>i</sub> of the list S must be an
expression defining an object of one of the following types:
<DL COMPACT class='compact'>
<DT>(a)</DT><DD>an element of V or coercible into V,
<DT>(b)</DT><DD>a set or sequence of elements coercible into V,
<DT>(c)</DT><DD>a sublattice of V,
<DT>(d)</DT><DD>a set or sequence of sublattices of V.
<P>
<P>
</DL>
The constructor returns the superlattice L' and the inclusion homomorphism
from L into L'.
</BLOCKQUOTE>
<H5><A NAME = "2922">T * L : AlgMatElt, Lat -&gt; Lat</A></H5>
<H5>T * L : ModMatRng, Lat -&gt; Lat</H5>
<BLOCKQUOTE>
Given a lattice L of rank m and an l x m integer matrix,
construct the sublattice of L
defined by the transformation matrix T, i.e., the lattice generated by the
rows of the matrix obtained by multiplying the basis matrix of L from the 
left by T.  The resulting lattice will have rank less than or equal
to l.
</BLOCKQUOTE>
<H5><A NAME = "2923">s * L : RngElt, Lat -&gt; Lat</A></H5>
<H5>L * s : Lat, RngElt -&gt; Lat</H5>
<BLOCKQUOTE>
Given a lattice L and a scalar s, construct the sublattice or superlattice
of L obtained by multiplying the basis matrix of L by the scalar s.
</BLOCKQUOTE>
<H5><A NAME = "2924">L / s : Lat, RngElt -&gt; Lat</A></H5>
<BLOCKQUOTE>
Given a lattice L and a scalar s, construct the sublattice or superlattice
of L obtained by multiplying the basis matrix of L by the scalar 1/s.
</BLOCKQUOTE>
<H5><A NAME = "2925">quo&lt; L | S &gt; : Lat, List -&gt; GrpAb, Map</A></H5>
<BLOCKQUOTE>
Given a lattice L and a list S, construct the quotient L/L', where
L' is the sublattice of L generated by the elements of the list S.
The elements of S must be the same as for the <TT>sub&lt;&gt;</TT> constructor.
The quotient Q := L / L' is constructed as an abelian group.
As a second value the function returns the natural epimorphism
L -&gt; Q.
</BLOCKQUOTE>
<H5><A NAME = "2926">L / S : Lat, Lat -&gt; GrpAb, Map</A></H5>
<BLOCKQUOTE>
Given two lattices L and S such that S is a sublattice of L, construct
the quotient Q := L / S as an abelian group. As a second value the 
function returns the natural epimorphism L -&gt; Q.
</BLOCKQUOTE>
<H5><A NAME = "2927">Index(L, S): Lat, Lat -&gt; RngInt</A></H5>
<BLOCKQUOTE>
Given a lattice L and a sublattice S of L, return the index of
S in L.  This is the cardinality of the quotient L/S.  If the
index is infinite, zero is returned.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "2928">Example <TT>Lat_SubSuperQuo (H30E5)</TT></A></H3>
We demonstrate simple uses of the <TT>sub</TT>-, <TT>ext</TT>- and
<TT>quo</TT>-constructors.
<P>
<P>
<PRE>
&gt; L := LatticeWithBasis(4, [1,2,3,4, 0,1,1,1, 0,1,3,5]);
&gt; L;
Lattice of rank 3 and degree 4
Basis:
(1 2 3 4)
(0 1 1 1)
(0 1 3 5)
&gt; E := ext&lt;L | [1,0,0,0]&gt;;
&gt; E;
Lattice of rank 3 and degree 4
Basis:
( 1  0  0  0)
( 0  1  0 -1)
( 0  1  1  1)
&gt; Index(E, L);
2
&gt; Q, f := quo&lt;E | L&gt;;
&gt; Q;
Abelian Group isomorphic to Z/2
Defined on 1 generator
Relations:
    2*Q.1 = 0
&gt; f(E.1);
Q.1
</PRE>
<HR>
<H4><A NAME = "2929">Standard Constructions of New Lattices</A></H4>

<P>
<P>
<P>
The functions in this section enable one to construct new lattices from
old ones using standard operations. Note that the functions will
preserve the basis matrices of their arguments if possible
(e.g., <TT>DirectSum</TT>), but if this is not possible the basis of the
resulting lattice will be LLL-reduced (e.g., <TT>+</TT>, <TT>meet</TT>).


<H5><A NAME = "2930">Dual(L) : Lat -&gt; Lat</A></H5>

<PRE>    Rescale: BoolElt                    Default: <TT>true</TT></PRE>
<BLOCKQUOTE>
Let L be a lattice in R<sup>n</sup> and let V := R tensor <sub>Z</sub> L be the real vector
space generated by L. Then the dual lattice L^# of L is defined 
by L^# := { v &isin;V | (v, l) &isin;Z  forall l &isin;L }.
For an integral lattice L one always has L &sube;L^#.
This function returns a rescaled version L' of the dual L^# by default
so that the basis of L' is LLL-reduced and L' is an integral lattice and
its Gram matrix is primitive (its entries are coprime).
By setting the parameter <TT>Rescale</TT> to {<TT>false</TT>}, the rescaling can be
suppressed and the proper dual lattice is returned.
</BLOCKQUOTE>
<H5><A NAME = "2931">PartialDual(L, n) : Lat, RngIntElt -&gt; Lat</A></H5>

<PRE>    Rescale: BoolElt                    Default: <TT>true</TT></PRE>
<BLOCKQUOTE>
Given an integral lattice L and a positive integer n that divides
the exponent e of the <TT>DualQuotient</TT> group of L, this function
computes the nth partial dual of L. This is defined by pulling back
(e/n).g for generators g of the <TT>DualQuotient</TT> and intersecting
with the lattice itself.
</BLOCKQUOTE>
<H5><A NAME = "2932">DualBasisLattice(L) : Lat -&gt; Lat</A></H5>
<BLOCKQUOTE>
Let L be a lattice in R<sup>n</sup> and let V := R tensor <sub>Z</sub> L be the real vector
space generated by L, then
L^# := { v &isin;V | (v, l) &isin;Z  forall l &isin;L } is the dual lattice
of L.
Let B be the basis matrix of L, M the inner product matrix of L,
and F the Gram matrix of L.
This function returns the dual L^# as the lattice with basis matrix
F<sup> - 1</sup>B and inner product matrix M (so that its Gram matrix is F<sup> - 1</sup>).
</BLOCKQUOTE>
<H5><A NAME = "2933">DualQuotient(L) : Lat -&gt; GrpAb, Lat, Map</A></H5>
<BLOCKQUOTE>
Given an integral lattice L, construct the dual quotient Q of L, which
is defined to be the finite
abelian group L^# / L of order <TT>Determinant(L)</TT>, where L^# is the
unscaled dual lattice of L (the lattice returned by <TT>Dual</TT> with the
<TT>Rescale</TT> parameter set to <TT>false</TT>).
This function returns three values:
<DL COMPACT class='compact'>
<DT>(a)</DT><DD>The dual quotient Q.
<DT>(b)</DT><DD>The unscaled dual lattice L^#.
<DT>(c)</DT><DD>The natural epimorphism &phi;: L^# -&gt; Q whose kernel
           is L.</DL>
</BLOCKQUOTE>
<H5><A NAME = "2934">EvenSublattice(L) : Lat -&gt; Lat, Map</A></H5>
<BLOCKQUOTE>
Given an integral lattice L, construct its maximal even sublattice 
together with the natural embedding into L.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "2935">Example <TT>Lat_dual (H30E6)</TT></A></H3>
<P>
<P>
<PRE>
&gt; L := Lattice(LatticeDatabase(),"LAMBDA29");
&gt; Dimension(L);
29
&gt; IsEven(L);
true
&gt; IsEven(Dual(L));
false;
&gt; G := DualQuotient(L); 
&gt; Exponent(G);
8
&gt; Factorization(Determinant(L));
[ &lt;2, 31&gt; ]
&gt; PartialDual(L,1) eq L;
true
&gt; Factorization(Determinant(PartialDual(L, 2)));
[ &lt;2, 54&gt; ]
&gt; Factorization(Determinant(PartialDual(L, 4)));
[ &lt;2, 73&gt; ]
&gt; Factorization(Determinant(PartialDual(L, 8)));
[ &lt;2, 56&gt; ]
&gt; Factorization(Determinant(Dual(L)));
[ &lt;2, 56&gt; ]
</PRE>
<HR>
<H5><A NAME = "2936">L + M : Lat, Lat -&gt; Lat</A></H5>
<BLOCKQUOTE>
Given compatible lattices L and M, construct the lattice generated by their
union.
</BLOCKQUOTE>
<H5><A NAME = "2937">L meet M : Lat, Lat -&gt; Lat</A></H5>
<BLOCKQUOTE>
Given compatible lattices L and M, construct their intersection L&cap;M.
</BLOCKQUOTE>
<H5><A NAME = "2938">DirectSum(L, M) : Lat, Lat -&gt; Lat</A></H5>
<H5>OrthogonalSum(L, M) : Lat, Lat -&gt; Lat</H5>
<BLOCKQUOTE>
Given lattices L and M, construct their orthogonal sum which is their
direct sum with inner product being the orthogonal sum of the inner products of
L and M.
</BLOCKQUOTE>
<H5><A NAME = "2939">OrthogonalDecomposition(L) : Lat -&gt; [Lat]</A></H5>
<H5>OrthogonalDecomposition(L, F) : Lat, [Mtrx] -&gt; [Lat]</H5>
<BLOCKQUOTE>
Given a lattice L, construct the sequence of indecomposable orthogonal 
summands composing L.
Additional bilinear forms can be given in F. In this case the decomposition
will be orthogonal wrt. these forms as well.
</BLOCKQUOTE>
<H5><A NAME = "2940">OrthogonalDecomposition(F) : [Mtrx] -&gt; [* Mtrx *], [* [Mtrx] *]</A></H5>

<PRE>    Optimize: BoolElt                   Default: <TT>false</TT></PRE>
<BLOCKQUOTE>
Given a sequence of bilinear forms F, where the first form is positive
definite, returns the basis matrices B<sub>1</sub>, ..., B<sub>s</sub> of the indecomposable
orthogonal summands of the standard lattice Z<sup>n</sup> wrt. the forms in F.
The second return value is a list of s sequences. The i-th sequence
contains the forms of F wrt. to basis described by B<sub>i</sub>.
If <TT>Optimize</TT> is set, then the basis matrices will be LLL reduced wrt.
the first form in F.
</BLOCKQUOTE>
<H5><A NAME = "2941">TensorProduct(L, M) : Lat, Lat -&gt; Lat</A></H5>
<BLOCKQUOTE>
Given two lattices L and M, construct their tensor product with inner
product given by the Kronecker product of the matrices defining the inner
products of L and M.
</BLOCKQUOTE>
<H5><A NAME = "2942">ExteriorSquare(L) : Lat -&gt; Lat</A></H5>
<BLOCKQUOTE>
Given a lattice L, construct its exterior square, generated
by the skew tensors in L tensor L. The inner product is inherited from
the inner product of the tensor square of the vector space containing L
and the exterior square lattice lies inside the tensor square of the lattice.
</BLOCKQUOTE>
<H5><A NAME = "2943">SymmetricSquare(L) : Lat -&gt; Lat</A></H5>
<BLOCKQUOTE>
Given a lattice L, construct its symmetric square, generated
by the symmetric tensors in L tensor L. The inner product is inherited from
the inner product of the tensor square of the vector space containing L
and the symmetric square lattice lies inside the tensor square of the lattice.
</BLOCKQUOTE>
<H5><A NAME = "2944">PureLattice(L) : Lat -&gt; Lat</A></H5>
<BLOCKQUOTE>
Given a lattice L of degree n with integral or rational entries, return
the pure lattice P=(Q tensor L) &cap;Z<sup>n</sup> of L.  The pure lattice
P generates the same subspace in Q<sup>n</sup> over Q that L does but the
elementary divisors of its basis matrix are trivial.
</BLOCKQUOTE>
<H5><A NAME = "2945">IntegralBasisLattice(L) : Lat -&gt; Lat, RngIntElt</A></H5>
<BLOCKQUOTE>
Given an exact lattice L, return the lattice obtained from L by
multiplying the basis by the smallest positive scalar S so that the resulting
basis is integral, and S.
</BLOCKQUOTE>
<PRE></PRE> <A  HREF = "text312.htm">[Next]</A><A  HREF = "text310.htm">[Prev]</A> <A  HREF = "text312.htm">[Right]</A> <A  HREF = "text310.htm">[Left]</A> <A  HREF = "text305.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<br><small>Version: V2.22 of <I>
Thu Jun  9 16:37:49 EST 2016
</I></small>
</body></html>