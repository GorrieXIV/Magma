<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <link rel='stylesheet' href='help.css' type='text/css'>
  <TITLE>Tensors</TITLE>
</head>
<body BGCOLOR="#FFFFFF">

 <A  HREF = "text606.htm">[Next]</A><A  HREF = "text604.htm">[Prev]</A> <A  HREF = "text606.htm">[Right]</A> <A  HREF = "text604.htm">[Left]</A> <A  HREF = "text603.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<PRE></PRE><H3><A NAME = "6393">Tensors</A></H3>

<P>
<P>
A tensor has the following information associated with it:-
<DL COMPACT class='compact'>
<DT>*</DT><DD>A commutative ring K of coefficients.
<DT>*</DT><DD>A valence v indicating the number of variables to include in its 
associated multilinear map.
<DT>*</DT><DD>A list [U<sub>v</sub>, ..., U<sub>0</sub>] of K-modules called the <I>frame</I>.
<DT>*</DT><DD>A function U<sub>v</sub> x ... x U<sub>1</sub>to U<sub>0</sub> that is K-linear in 
each U<sub>i</sub>.
Tensors have type <TT>TenSpcElt</TT> and are formally elements of a tensor space 
(type <TT>TenSpc</TT>).  By default a tensor's parent space is a universal tensor space:
	hom<sub>K</sub>(U<sub>v</sub>, ..., hom<sub>K</sub>(U<sub>1</sub>, U<sub>0</sub>) ... ) isomorphic to hom<sub>K</sub>(U<sub>v</sub> tensor <sub>K</sub> ... tensor <sub>K</sub> U<sub>1</sub>, U<sub>0</sub>).
The left hand module is used primarily as it avoids the need to work with 
the equivalence classes of a tensor product.
Operations such as linear combinations of tensors take place within a  
tensor space.
A tensor space has attributes such as coefficients, valence, and frame. 
<P>
</DL>
When necessary, the user may further direct the operations on tensors to 
appropriate tensor categories 
(type <TT>TenCat</TT>).  For instance covariant and contravariant variables can 
be specified and symmetry conditions can be imposed.  If no tensor category 
is prescribed then a default tensor category is selected based on the method 
of creation.



<H5>Subsections</H5>
<UL>
<LI> <A  HREF = "text605.htm#6394">Creating Tensors</A>
<LI> <A  HREF = "text605.htm#6402">Bilinear Tensors</A>
<LI> <A  HREF = "text605.htm#6421">Operations with Tensors</A>
<LI> <A  HREF = "text605.htm#6474">Invariants of Tensors</A>
</UL>
<H4><A NAME = "6394">Creating Tensors</A></H4>



<H5><A NAME = "6395">Black-box Tensors</A></H5>

<P>
<P>
<P>
A user can specify a tensor by a black-box function that evaluates the required
multilinear map.


<H5><A NAME = "6396">Tensor(S, F) : SeqEnum, UserProgram -&gt; TenSpcElt</A></H5>
<H5>Tensor(S, F) : List, UserProgram -&gt; TenSpcElt</H5>
<H5>Tensor(S, F, Cat) : SeqEnum, UserProgram, TenCat -&gt; TenSpcElt</H5>
<H5>Tensor(S, F, Cat) : List, UserProgram, TenCat -&gt; TenSpcElt</H5>
<BLOCKQUOTE>
Returns the tensor having the frame S and the tensor category Cat. 
The last entry is assumed to be the codomain of the multilinear map. 
The user-defined function F should take as input a tuple of elements 
of the domain and return an element of the codomain.  If no tensor 
category is provided, then Albert's homotopism category is used.
</BLOCKQUOTE>
<H5><A NAME = "6397">Tensor(D, C, F) : SeqEnum, Any, UserProgram -&gt; TenSpcElt</A></H5>
<H5>Tensor(D, C, F) : List, Any, UserProgram -&gt; TenSpcElt</H5>
<H5>Tensor(D, C, F, Cat) : SeqEnum, Any, UserProgram, TenCat -&gt; TenSpcElt</H5>
<H5>Tensor(D, C, F, Cat) : List, Any, UserProgram, TenCat -&gt; TenSpcElt</H5>
<BLOCKQUOTE>
Returns the tensor with tensor category Cat and frame specified by D and 
C, where D is a sequence of spaces in the domain and C the codomain. 
The user-defined function F should take as input a tuple of elements of D 
and return an element of C.  If no tensor category is provided, then Albert's 
homotopism category is used.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "6398">Example <TT>Multilinear_Ten_Tripl_Product (H61E1)</TT></A></H3>
Tensors make it easy to create algebras that do not fit into traditional
categories, such as algebras with triple products.
<P>
<P>
<PRE>
&gt; K := GF(541);
&gt; U := KMatrixSpace(K,2,3);
&gt; my_prod := func&lt; x | x[1]*Transpose(x[2])*x[3] &gt;;
&gt; T := Tensor([U,U,U,U], my_prod );
&gt; T;
Tensor of valence 3, U3 x U2 x U1 &gt;-&gt; U0
U3 : Full KMatrixSpace of 2 by 3 matrices over GF(541)
U2 : Full KMatrixSpace of 2 by 3 matrices over GF(541)
U1 : Full KMatrixSpace of 2 by 3 matrices over GF(541)
U0 : Full KMatrixSpace of 2 by 3 matrices over GF(541)
&gt; A := U![1,0,0,0,0,0];
&gt; &lt;A,A,A&gt;@T;  // A is a generalized idempotent
[  1   0   0]
[  0   0   0]
</PRE>
We can experiment to see if this triple product is left associative.
<P>
<P>
<PRE>
&gt; X := [Random(U) : i  in [1..5]];
&gt; &lt;&lt;X[1],X[2],X[3]&gt;@T,X[4],X[5]&gt;@T eq  
&gt;    &lt;X[1],&lt;X[4],X[3],X[2]&gt;@T,X[5]&gt;@T;
true
</PRE>
To confirm this we can create a new tensor for the left 
triple-associators and check that its image is 0.
<P>
<P>
<PRE>
&gt; my_left_asct := func&lt;X|&lt;&lt;X[1],X[2],X[3]&gt;@T,X[4],X[5]&gt;@T
&gt;     - &lt;X[1],&lt;X[4],X[3],X[2]&gt;@T,X[5]&gt;@T &gt;;
&gt; LT := Tensor([U: i in [0..5]], my_left_asct);
&gt; I := Image(LT);
&gt; Dimension(I);
0
</PRE>
<HR>
<H5><A NAME = "6399">Tensors with Structure Constant Sequences</A></H5>

<P>
<P>
<P>
Most computations with tensors T will be carried out using structure constants
T<sub>j<sub>v</sub> ... j<sub>0</sub></sub>&isin;K.  Here T is framed by free K-modules [U<sub>v</sub>, ..., U<sub>0</sub>] 
with each U<sub>i</sub> having an ordered bases (B)<sub>i</sub>=[e<sub>i1</sub>, ..., e<sub>id<sub>i</sub></sub>].
The interpretation of structure constants is that the associated multilinear function 
[x<sub>v</sub>, ..., x<sub>1</sub>] from U<sub>v</sub> x ... x U<sub>1</sub> into U<sub>0</sub> is determined on 
bases (B)<sub>i</sub> as follows:
	[e<sub>vj<sub>v</sub></sub>, ..., e<sub>1j<sub>1</sub></sub> ] = &sum;<sub>k=1</sub><sup>d<sub>0</sub></sup> T<sub>j<sub>v</sub> ... j<sub>0</sub></sub> e<sub>0k</sub>.
Structure constants are input and stored as sequences S in K according to the
following assignment. Set f:Z<sup>v + 1</sup>to Z to be:
		 f(j<sub>v</sub>, ..., j<sub>0</sub>) = 1 + &sum;<sub>s=0</sub><sup>v</sup> (j<sub>s</sub> - 1)&prod;<sub>t=0</sub><sup>s - 1</sup> d<sub>t</sub>.
So S[f(j<sub>v</sub>, ..., j<sub>0</sub>)]=T<sub>j<sub>v</sub> ... j<sub>0</sub></sub> specifies the structure constants as a sequence.  
<P>
<P>
<P>
<B>Notes.</B>
<DL COMPACT class='compact'>
<DT>*</DT><DD>Magma does not currently support the notion of a sparse sequence of 
structure constants.  A user can provide this functionality by specifying the
multilinear function associated with a tensor by means of a user program rather
than by structure constants. 
<P>
<DT>*</DT><DD>Some routines in Magma require structure constant sequences.  If they 
are not provided, Magma may compute and store a structure constant representation
with the tensor.
<P>
<DT>*</DT><DD>Magma does not separate structure constant indices that are contravariant.  
Instead contravariant variables are signaled by tensor categories.  So Ricci-styled 
tensors T<sub>a<sub>p</sub> ... a<sub>1</sub></sub><sup>b<sub>q</sub> ... b<sub>1</sub></sup> should be input as 
T_(a<sub>p + q</sub> ... a<sub>1 + q</sub> b<sub>q</sub> ... b<sub>1</sub>) and the tensor category changed to mark 
{q..1} as contravariant. Intrinsics are provided to facilitate this approach.</DL>


<H5><A NAME = "6400">Tensor(R, D, S) : Rng, [RngElt], SeqEnum -&gt; TenSpcElt</A></H5>
<H5>Tensor(D, S) : [RngElt], SeqEnum -&gt; TenSpcElt</H5>
<H5>Tensor(R, D, S, Cat) : Rng, [RngElt], SeqEnum, TenCat -&gt; TenSpcElt</H5>
<H5>Tensor(D, S, Cat) : [RngElt], SeqEnum, TenCat -&gt; TenSpcElt</H5>
<BLOCKQUOTE>
Let R be a commutative unital ring and D a sequence [d<sub>v</sub>, ..., d<sub>0</sub>]
giving the dimensions of the R-modules U<sub>v</sub>, ..., U<sub>0</sub>. The
intrinsic returns the tensor with frame { U<sub>v</sub>, ..., U<sub>1</sub> },
codomain U<sub>0</sub> and multilinear map defined by the structure constant 
sequence S.  If R is not specified then the parent ring of the first 
element of S is used.  The default tensor category Cat is the homotopism 
category.
</BLOCKQUOTE>
<H5><A NAME = "6401">StructureConstants(T) : TenSpcElt -&gt; SeqEnum</A></H5>
<H5>Eltseq(T) : TenSpcElt -&gt; SeqEnum</H5>
<BLOCKQUOTE>
Returns the sequence of structure constants of the given tensor T. 
</BLOCKQUOTE>
<H4><A NAME = "6402">Bilinear Tensors</A></H4>

<P>
<P>
<P>
In the special case of bilinear maps U<sub>2</sub> x U<sub>1</sub> &#8611; U<sub>0</sub>,
the structure constant sequences may be presented as lists [M<sub>1</sub>, ..., M<sub>a</sub>] 
of matrices.  This can be considered as a left (resp. right) representation
U<sub>2</sub>to hom<sub>K</sub>(U<sub>1</sub>, U<sub>0</sub>), (resp.U<sub>1</sub>to hom<sub>K</sub>(U<sub>2</sub>, U<sub>0</sub>)).  
Alternatively, bilinear maps can be treated as <I>systems of bilinear forms</I> 
[M<sub>1</sub>, ..., M<sub>a</sub>] where the matrices are the Gram matrices of bilinear forms 
&phi;<sub>i</sub>:U<sub>2</sub> x U<sub>1</sub> &#8611; K.  Here the associated bilinear map 
U<sub>2</sub> x U<sub>1</sub> &#8611; U<sub>0</sub> is specified by
	(u<sub>2</sub>, u<sub>1</sub>) |-&gt; ( &phi;<sub>1</sub>(u<sub>2</sub>, u<sub>1</sub>), ..., &phi;<sub>a</sub>(u<sub>2</sub>, u<sub>1</sub>)).


<H5><A NAME = "6403">Tensor(M, s, t) : [Mtrx], RngIntElt, RngIntElt -&gt; TenSpcElt</A></H5>
<H5>Tensor(M, s, t, C) : [Mtrx], RngIntElt, RngIntElt, TenCat -&gt; TenSpcElt</H5>
<BLOCKQUOTE>
Given a sequence of matrices M, the bilinear tensor specified by M is 
returned.  The interpretation of the matrices as structure constant
sequences is determined by the coordinates s and t which must be 
integers from the set {2, 1, 0}.  Optionally a tensor category C 
can be specified.
</BLOCKQUOTE>
<H5><A NAME = "6404">AsMatrices(T, s, t) : TenSpcElt, RngIntElt, RngIntElt -&gt; SeqEnum</A></H5>
<H5>SystemOfForms(T) : TenSpcElt -&gt; SeqEnum</H5>
<BLOCKQUOTE>
For a tensor T with frame [K<sup>d<sub>v</sub></sup>, ..., K<sup>d<sub>0</sub></sup>], 
a list [M<sub>1</sub>, ..., M<sub>d</sub>], d=(d<sub>v</sub> ... d<sub>0</sub>)/d<sub>s</sub> d<sub>t</sub>, 
of (d<sub>s</sub> x d<sub>t</sub>)-matrices in K representing the tensor
as an element of hom<sub>K</sub>(K<sup>d<sub>s</sub></sup> tensor <sub>K</sub> K<sup>d<sub>t</sub></sup>, K<sup>d</sup>)
is returned.
For the intrinsic <TT>SystemOfForms</TT>, T must have valence 
2 and the implied values are s=2 and t=1.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "6405">Example <TT>Multilinear_Ten_StrConst (H61E2)</TT></A></H3>
<P>
<P>
<PRE>
&gt; T := Tensor(GF(3), [2 ,2 ,2], [1 ,0 ,0 ,1 ,0 ,1 , -1 ,0]);
&gt; T;
Tensor of valence 2, U2 x U1 &gt;-&gt; U0
U2 : Full Vector space of degree 2 over GF(3)
U1 : Full Vector space of degree 2 over GF(3)
U0 : Full Vector space of degree 2 over GF(3)
&gt; StructureConstants(T);
[ 1, 0, 0, 1, 0, 1, 2, 0 ]
</PRE>
Systems of forms can be useful in providing some visually useful 
information such as symmetry.
The choice of coordinates influences the resulting list of matrices.
<P>
<P>
<PRE>
&gt; AsMatrices(T,1,0);
[
    [1 0]
    [0 1],

    [0 1]
    [2 0]
]
&gt; SystemOfForms (T);
[
    [1 0]
    [0 2],

    [0 1]
    [1 0]
]
&gt; IsSymmetric (T);
true
</PRE>
<HR>
<H3><A NAME = "6406">Example <TT>Multilinear_Ten_SysForms (H61E3)</TT></A></H3>
Systems of forms will always produce tensors of valance 2.  In particular
two tensors with a common structure constant sequence can be treated differently by
changing the dimensions that frame the data.  Thus a tensor is more than a list of coefficients.
<P>
<P>
<PRE>
&gt; F := [ RandomMatrix(GF(2),2,3) : i in [1..4]];
&gt; T := Tensor(F,2,1);
&gt; T;
Tensor U2 x U1 &gt;-&gt; U0
U2 : Full Vector space of degree 2 over GF(2)
U1 : Full Vector space of degree 3 over GF(2)
U0 : Full Vector space of degree 4 over GF(2)
&gt; T2 := Tensor( [2,2,2,2], [1..16] );
&gt; F2 := AsMatrices(T2,3,2);
&gt; T3 := Tensor(F2, 2, 1);
&gt; Eltseq(T2) eq Eltseq(T3); 
true
&gt; T2 eq T3;  
false
&gt; Valence(T2);
3
&gt; Valence(T3);
2
</PRE>
<HR>
<H5><A NAME = "6407">Tensors from Algebraic Objects</A></H5>

<P>
<P>
<P>
A natural source of tensors is an algebraic object with a distributive 
property.
Each tensor is assigned a category relevant to its origin. 


<H5><A NAME = "6408">Tensor(A): Alg -&gt; TenSpcElt</A></H5>
<BLOCKQUOTE>
Given an algebra A with an element product that satisfies an appropriate
distributive law, return the bilinear tensor given by the product in A.
</BLOCKQUOTE>
<H5><A NAME = "6409">CommutatorTensor(A) : Alg -&gt; TenSpcElt</A></H5>
<BLOCKQUOTE>
Given an algebra A return the tensor corresponding to the bilinear 
commutator map [a, b]=ab - ba on the algebra A.
</BLOCKQUOTE>
<H5><A NAME = "6410">AssociatorTensor(A) : Alg -&gt; TenSpcElt</A></H5>
<BLOCKQUOTE>
Given an algebra A return the tensor corresponding to the trilinear 
associator map [a, b, c]=(ab)c - a(bc) on the algebra A.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "6411">Example <TT>Multilinear_Ten_Alg (H61E4)</TT></A></H3>
<P>
<P>
<PRE>
&gt; A := MatrixAlgebra( Rationals () , 5 );
&gt; AC := CommutatorTensor( A );
&gt; IsAlternating( AC ); // [X, X] = 0?
true
</PRE>
Do three random octonions satisfy the associate law? Hardly ever.
<P>
<P>
<PRE>
&gt; O := OctonionAlgebra ( GF (541) , -1 , -1 , -1);
&gt; T := AssociatorTensor ( O );
&gt; &lt; Random ( O ) , Random ( O ) , Random ( O ) &gt; @ T eq 0;
false
</PRE>
But the left alternative law, (aa)b=a(ab) is always satisfied, as 
octonions are alternative algebras.
<P>
<P>
<PRE>
&gt; a := Random ( O ); 
&gt; b := Random ( O ); 
&gt; &lt;a ,a ,b &gt; @ T eq 0;
true
&gt; IsAlternating ( T );
true
</PRE>
<HR>
<H5><A NAME = "6412">pCentralTensor(G, s, t) : GrpPC, RngIntElt, RngIntElt -&gt; TenSpcElt</A></H5>
<H5>pCentralTensor(G, p, s, t) : Grp, RngIntElt, RngIntElt, RngIntElt -&gt; TenSpcElt</H5>
<BLOCKQUOTE>
Returns the bilinear map of commutation from the associated graded Lie 
algebra of the lower exponent-p central
series &eta; of G.  The bilinear map pairs &eta;<sub>s</sub>/&eta;<sub>s + 1</sub> with 
&eta;<sub>t</sub>/&eta;<sub>t + 1</sub> into &eta;<sub>s + t</sub>/&eta;<sub>s + t + 1</sub>.  If s=t the tensor 
category is set to force U<sub>2</sub>=U<sub>1</sub>; 
otherwise it is the general homotopism category.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "6413">Example <TT>Multilinear_Ten_Grp (H61E5)</TT></A></H3>
Groups have a single binary operation. So even when groups are built from
rings it can be difficult to recover the ring from the group operations.  
Tensors supply one approach for that task.
<P>
<P>
<PRE>
&gt; P := ClassicalSylow(SL(3,125), 5);
&gt; Q := PCGroup(P);	// The group Q wont have explicit knowledge of GF(125).
&gt; Q;
GrpPC : Q of order 1953125 = 5^9
PC-Relations:
    Q.4^Q.1 = Q.4 * Q.7^4, 
    Q.4^Q.2 = Q.4 * Q.8^4, 
    Q.4^Q.3 = Q.4 * Q.9^4, 
    Q.5^Q.1 = Q.5 * Q.8^4, 
    Q.5^Q.2 = Q.5 * Q.9^4, 
    Q.5^Q.3 = Q.5 * Q.7^3 * Q.8^3, 
    Q.6^Q.1 = Q.6 * Q.9^4, 
    Q.6^Q.2 = Q.6 * Q.7^3 * Q.8^3, 
    Q.6^Q.3 = Q.6 * Q.8^3 * Q.9^3
&gt; T := pCentralTensor(Q,1,1);
&gt; F := Centroid(T);  // Recover GF(125)
&gt; Dimension(F);
3
&gt; IsSimple(F);
true
&gt; IsCommutative(F);
true
</PRE>
<HR>
<H5><A NAME = "6414">Polarisation(f) : MPolElt -&gt; TenSpcElt, MPolElt</A></H5>
<H5>Polarization(f) : MPolElt -&gt; TenSpcElt, MPolElt</H5>
<BLOCKQUOTE>
Returns the polarization of the homogeneous multivariate polynomial 
f as a tensor and as a multivariate polynomial.  Note that the
intrinsic does not normalize by 1/d!, where d is the degree of f.  
</BLOCKQUOTE>
<HR>
<H3><A NAME = "6415">Example <TT>Multilinear_Ten_Polar (H61E6)</TT></A></H3>
The polarization intrinsic is applied to the polynomial f = x<sup>2</sup> * y.
Because f is homogeneous of degree 3 with 2 variables, it is expected 
that the polarization will have 6 variables and that the corresponding 
multilinear form will be K<sup>2</sup> x K<sup>2</sup> x K<sup>2</sup> &#8611; K.
The polarization of f is given by 
P(x<sub>1</sub>, x<sub>2</sub>, y<sub>1</sub>, y<sub>2</sub>, z<sub>1</sub>, z<sub>2</sub> ) = 2 (x<sub>1</sub>y<sub>1</sub>z<sub>2</sub> + x<sub>1</sub>y<sub>2</sub>z<sub>1</sub> + x<sub>2</sub>y<sub>1</sub>z<sub>1</sub>).
<P>
<P>
<PRE>
&gt; K&lt;x,y&gt; := PolynomialRing(Rationals(), 2);
&gt; T,p := Polarization(x^2*y);
&gt; p;
2*$.1*$.3*$.6 + 2*$.1*$.4*$.5 + 2*$.2*$.3*$.5
&gt; T;
Tensor of valence 3, U3 x U2 x U1 &gt;-&gt; U0
U3 : Full Vector space of degree 2 over Rational Field
U2 : Full Vector space of degree 2 over Rational Field
U1 : Full Vector space of degree 2 over Rational Field
U0 : Full Vector space of degree 1 over Rational Field
&gt; &lt;[1,0],[1,0],[1,0]&gt; @ T;
(0)
&gt; &lt;[1,0],[1,0],[0,1]&gt; @ T;
(2)
</PRE>
<HR>
<H5><A NAME = "6416">New Tensors from Old</A></H5>

<P>
<P>
<P>
A number of new tensors may be constructed from a given tensor. 


<H5><A NAME = "6417">AlternatingTensor(T) : TenSpcElt -&gt; TenSpcElt</A></H5>
<BLOCKQUOTE>
Returns the alternating tensor induced by the given tensor T. If 
the tensor is already alternating, then the given tensor is returned.
</BLOCKQUOTE>
<H5><A NAME = "6418">AntisymmetricTensor(T) : TenSpcElt -&gt; TenSpcElt</A></H5>
<BLOCKQUOTE>
Returns the antisymmetric tensor induced by the given tensor T. If 
the tensor is already antisymmetric, then the given tensor is returned.
</BLOCKQUOTE>
<H5><A NAME = "6419">SymmetricTensor(T) : TenSpcElt -&gt; TenSpcElt</A></H5>
<BLOCKQUOTE>
Returns the symmetric tensor induced by the given tensor T. If the tensor is 
already symmetric, then the given tensor is returned.
</BLOCKQUOTE>
<H5><A NAME = "6420">Shuffle(T, g) : TenSpcElt, SeqEnum -&gt; TenSpcElt</A></H5>
<BLOCKQUOTE>
Given a tensor T in hom(U<sub>v</sub>, ..., hom(U<sub>1</sub>, U<sub>0</sub>) ... ), this intrinsic
generates the representation of T in 
hom(U<sub>v<sup>g</sup></sub>, ..., hom(U<sub>1<sup>g</sup></sub>, U<sub>0<sup>g</sup></sub>) ... ),
where g is a permutation of {0..v}.  The permutation g may be given
as an element of a permutation group or as a sequence.  Both the image and 
pre-image of 0 under g will be replaced by their K-dual space.  For 
cotensors, g must permute {1..v}.
</BLOCKQUOTE>
<H4><A NAME = "6421">Operations with Tensors</A></H4>

<P>
<P>
<P>
Magma supports two perspectives for operations with tensors. 
Firstly, tensors determine multilinear maps and so behave as
functions.  Secondly, tensors are elements of a tensor space and 
so behave as elements of a module.  


<H5><A NAME = "6422">Elementary Operations</A></H5>

<P>
<P>
<P>
Treating the tensor space as a K-module, we have the standard operations.


<H5><A NAME = "6423">S + T : TenSpcElt, TenSpcElt -&gt; TenSpcElt</A></H5>
<H5>k * T : RngElt, TenSpcElt -&gt; TenSpcElt</H5>
<BLOCKQUOTE>
Given tensors S and T belonging to the same tensor space V, and an 
element k belonging to the coefficient ring K, this intrinsic returns 
the sum or scalar multiple of S and T  as elements of v. The 
corresponding multilinear maps are the sum or scalar multiple of the 
multilinear maps.
</BLOCKQUOTE>
<H5><A NAME = "6424">TensorOnVectorSpaces(T) : TenSpcElt -&gt; TenSpcElt, Hmtp</A></H5>
<BLOCKQUOTE>
Returns the tensor on vector spaces and an isotopism from the given tensor. 
This is a forgetful functor that forces all domain and codomain terms to be 
vector spaces.
</BLOCKQUOTE>
<H5><A NAME = "6425">AssociatedForm(T) : TenSpcElt -&gt; TenSpcElt</A></H5>
<BLOCKQUOTE>
For a tensor T with multilinear maps U<sub>v</sub> x ... x U<sub>1</sub> &#8611; U<sub>0</sub>,
this intrinsic creates the associated multilinear form
U<sub>v</sub> x ... x U<sub>1</sub> x U<sub>0</sub><sup> * </sup> &#8611; K.  The valence is increased
by 1.
</BLOCKQUOTE>
<H5><A NAME = "6426">Compress(T) : TenSpcElt -&gt; TenSpcElt</A></H5>
<BLOCKQUOTE>
Returns the compression of the tensor T. This removes all 1-dimensional spaces 
in the domain.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "6427">Example <TT>Multilinear_Ten_VS_Cmp (H61E7)</TT></A></H3>
The forgetful functor is illustrated using the tensor corresponding to
multiplication of elements in the Lie Algebra D4 defined over GF(5).
Applying the forgetful functor to this tensor has the effect of replacing 
the algebra structures by their underlying vector spaces.  However, it is
still possible to use this new tensor on vector spaces to evaluate products
of Lie algebra elements.
<P>
<P>
<PRE>
&gt; L := LieAlgebra("D4",GF(5));
&gt; T := Tensor(L);
&gt; T;
Tensor of valence 2, U2 x U1 &gt;-&gt; U0
U2 : Lie Algebra of dimension 28 with base ring GF(5)
U1 : Lie Algebra of dimension 28 with base ring GF(5)
U0 : Lie Algebra of dimension 28 with base ring GF(5)
&gt; &lt; L.2, L.11 &gt; @ T;
(1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)
&gt; 
&gt; S := TensorOnVectorSpaces(T);
&gt; S;
Tensor of valence 2, U2 x U1 &gt;-&gt; U0
U2 : Full Vector space of degree 28 over GF(5)
U1 : Full Vector space of degree 28 over GF(5)
U0 : Full Vector space of degree 28 over GF(5)
&gt; V := Domain(S)[1];
&gt; &lt; L.2, L.11 &gt; @ S eq &lt; V.2, V.11 &gt; @ S;
true
</PRE>
Now we compute the forms associated to S to get a trilinear map. 
We shuffle it by the permutation (0, 3) and compress it.
The result is just the shuffle of the original bilinear map S by (0, 2, 1).
<P>
<P>
<PRE>
&gt; AF := AssociatedForm(S);
&gt; AF;
Tensor of valence 3, U3 x U2 x U1 &gt;-&gt; U0
U3 : Full Vector space of degree 28 over GF(5)
U2 : Full Vector space of degree 28 over GF(5)
U1 : Full Vector space of degree 28 over GF(5)
U0 : Full Vector space of degree 1 over GF(5)
&gt; Eltseq(AF) eq Eltseq(S);
true
&gt; &lt; L.2, L.11, L.1 &gt; @ AF;
(1)
&gt; &lt; L.2, L.11, L.2 &gt; @ AF;
(0)
&gt; 
&gt; U := Shuffle(AF,[3,1,2,0]);
&gt; U;
Tensor of valence 3, U3 x U2 x U1 &gt;-&gt; U0
U3 : Full Vector space of degree 1 over GF(5)
U2 : Full Vector space of degree 28 over GF(5)
U1 : Full Vector space of degree 28 over GF(5)
U0 : Full Vector space of degree 28 over GF(5)
&gt; 
&gt; Cmp := Compress(U);
&gt; Shf := Shuffle(S,[2,0,1]);
&gt; Cmp eq Shf;
true
</PRE>
<HR>
<H5><A NAME = "6428">General Properties</A></H5>



<H5><A NAME = "6429">Parent(T) : TenSpcElt -&gt; TenSpc</A></H5>
<BLOCKQUOTE>
Returns the tensor space that contains tensor T. The default 
space is the universal tensor space.
</BLOCKQUOTE>
<H5><A NAME = "6430">Domain(T) : TenSpcElt -&gt; List</A></H5>
<BLOCKQUOTE>
Returns the domain of the tensor T as a list of modules.
</BLOCKQUOTE>
<H5><A NAME = "6431">Codomain(T) : TenSpcElt -&gt; Any</A></H5>
<BLOCKQUOTE>
Returns the codomain of the tensor T.
</BLOCKQUOTE>
<H5><A NAME = "6432">Valence(T) : TenSpcElt -&gt; RngIntElt</A></H5>
<BLOCKQUOTE>
Returns the valence of the tensor T.
</BLOCKQUOTE>
<H5><A NAME = "6433">Frame(T) : TenSpcElt -&gt; List</A></H5>
<BLOCKQUOTE>
Returns the modules in the frame of tensor T in the form of 
a list containing the domain modules and the codomain.
</BLOCKQUOTE>
<H5><A NAME = "6434">TensorCategory(T) : TenSpcElt -&gt; TenCat</A></H5>
<BLOCKQUOTE>
Returns the underlying tensor category of tensor T.
</BLOCKQUOTE>
<H5><A NAME = "6435">ChangeTensorCategory(T, C) : TenSpcElt, TenCat -&gt; TenSpcElt</A></H5>
<H5>ChangeTensorCategory( T, C) : TenSpcElt, TenCat -&gt;</H5>
<BLOCKQUOTE>
Returns the tensor T with the given category.
</BLOCKQUOTE>
<H5><A NAME = "6436">IsCovariant(T) : TenSpcElt -&gt; BoolElt</A></H5>
<H5>IsContravariant(T) : TenSpcElt -&gt; BoolElt</H5>
<BLOCKQUOTE>
Decides if the underlying category of tensor T is covariant 
or contravariant.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "6437">Example <TT>Multilinear_Ten_Prop1 (H61E8)</TT></A></H3>
<P>
<P>
<PRE>
&gt; T := RandomTensor(GF(3),[3,4,5,6]);
&gt; T;
Tensor of valence 3, U3 x U2 x U1 &gt;-&gt; U0
U3 : Full Vector space of degree 3 over GF(3)
U2 : Full Vector space of degree 4 over GF(3)
U1 : Full Vector space of degree 5 over GF(3)
U0 : Full Vector space of degree 6 over GF(3)
&gt; Valence(T);
3
&gt; 
&gt; BaseRing(T);
Finite field of size 3
&gt; 
&gt; Frame(T);
[*
    Full Vector space of degree 3 over GF(3),

    Full Vector space of degree 4 over GF(3),

    Full Vector space of degree 5 over GF(3),

    Full Vector space of degree 6 over GF(3)
*]
&gt; 
&gt; Domain(T);
[*
    Full Vector space of degree 3 over GF(3),

    Full Vector space of degree 4 over GF(3),

    Full Vector space of degree 5 over GF(3)
*]
&gt; 
&gt; Codomain(T);
Full Vector space of degree 6 over GF(3)
&gt; 
&gt; Parent(T); // Universal tensor space
Tensor space of dimension 360 over GF(3) with valence 3
U3 : Full Vector space of degree 3 over GF(3)
U2 : Full Vector space of degree 4 over GF(3)
U1 : Full Vector space of degree 5 over GF(3)
U0 : Full Vector space of degree 6 over GF(3)
&gt; 
&gt; TensorCategory(T);
Tensor category of Valence 3 (-&gt;,-&gt;,-&gt;,-&gt;) ({ 1 },{ 2 }, { 0 },{ 3 })
&gt; 
&gt; Cat := TensorCategory([-1,-1,1,1],{{i} : i in [0..3]});
&gt; ChangeTensorCategory(~T, Cat);
&gt; TensorCategory(T);
Tensor category of Valence 3 (&lt;-,&lt;-,-&gt;,-&gt;) ({ 1 },{ 2 }, { 0 },{ 3 })
</PRE>
<HR>
<H5><A NAME = "6438">Image(T) : TenSpcElt -&gt; ModTupRng, Map</A></H5>
<BLOCKQUOTE>
Returns the (categorical) image of the tensor T along with a map to the vector space.
Thus, if the type of the codomain of T is not <TT>ModTupRng</TT>, the returned map
is an isomorphism from the codomain of T to the free R-module R<sup>d<sub>0</sub></sup>. 
</BLOCKQUOTE>
<H5><A NAME = "6439">BaseRing(T) : TenSpcElt -&gt; Rng</A></H5>
<H5>BaseField(T) : TenSpcElt -&gt; Fld</H5>
<BLOCKQUOTE>
Returns the base ring or field of the tensor.
</BLOCKQUOTE>
<H5><A NAME = "6440">NondegenerateTensor(T) : TenSpcElt -&gt; TenSpcElt, Hmtp</A></H5>
<BLOCKQUOTE>
Returns the nondegenerate multilinear map associated to T along with a homotopism 
from the given tensor to the returned nondegenerate tensor.
</BLOCKQUOTE>
<H5><A NAME = "6441">IsNondegenerate(T) : TenSpcElt -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Decides whether T is a nondegenerate multilinear map.
</BLOCKQUOTE>
<H5><A NAME = "6442">FullyNondegenerateTensor(T) : TenSpcElt -&gt; TenSpcElt, Hmtp</A></H5>
<BLOCKQUOTE>
Returns the fully nondegenerate multilinear map associated to tensor T along with a
cohomotopism from the given tensor to the returned tensor.
</BLOCKQUOTE>
<H5><A NAME = "6443">IsFullyNondegenerate(T) : TenSpcElt -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Return <TT>true</TT> if the tensor T is a fully nondegenerate multilinear map.
</BLOCKQUOTE>
<H5><A NAME = "6444">IsAlternating(T) : TenSpcElt -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Return <TT>true</TT> if the tensor T is an alternating tensor.
</BLOCKQUOTE>
<H5><A NAME = "6445">IsAntisymmetric(T) : TenSpcElt -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Return <TT>true</TT> if the tensor T is an antisymmetric tensor.
</BLOCKQUOTE>
<H5><A NAME = "6446">IsSymmetric(T) : TenSpcElt -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Return <TT>true</TT> if the tensor T is a symmetric tensor.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "6447">Example <TT>Multilinear_Ten_Prop2 (H61E9)</TT></A></H3>
<P>
<P>
<PRE>
&gt; J := Matrix(GF(9),[[0,1,-1],[1,-1,-1],[-1,-1,1]]);
&gt; M := DiagonalJoin(J,ZeroMatrix(GF(9),3,3));
&gt; M;
[    0     1     2     0     0     0]
[    1     2     2     0     0     0]
[    2     2     1     0     0     0]
[    0     0     0     0     0     0]
[    0     0     0     0     0     0]
[    0     0     0     0     0     0]
&gt; 
&gt; T := Tensor([M,-M],2,1);
&gt; T;
Tensor of valence 2, U2 x U1 &gt;-&gt; U0
U2 : Full Vector space of degree 6 over GF(3^2)
U1 : Full Vector space of degree 6 over GF(3^2)
U0 : Full Vector space of degree 2 over GF(3^2)
&gt; 
&gt; Image(T);
Vector space of degree 2, dimension 1 over GF(3^2)
Generators:
(    1     2)
Echelonized basis:
(    1     2)
Mapping from: Full Vector space of degree 2 over GF(3^2) to 
Full Vector space of degree 2 over GF(3^2) given by a rule
&gt; 
&gt; Radical(T);
&lt;
    Vector space of degree 6, dimension 3 over GF(3^2)
    Echelonized basis:
    (    0     0     0     1     0     0)
    (    0     0     0     0     1     0)
    (    0     0     0     0     0     1),

    Vector space of degree 6, dimension 3 over GF(3^2)
    Echelonized basis:
    (    0     0     0     1     0     0)
    (    0     0     0     0     1     0)
    (    0     0     0     0     0     1)
&gt;
</PRE>
The tensor we built above is degenerate because it has a nontrivial radical. 
We will construct the nondegenerate tensor as well as the fully nondegenerate tensor.
<P>
<P>
<PRE>
&gt; ND := NondegenerateTensor(T);
&gt; ND;
Tensor of valence 2, U2 x U1 &gt;-&gt; U0
U2 : Full Vector space of degree 3 over GF(3^2)
U1 : Full Vector space of degree 3 over GF(3^2)
U0 : Full Vector space of degree 2 over GF(3^2)
&gt; 
&gt; FN := FullyNondegenerateTensor(T);
&gt; FN;
Tensor of valence 2, U2 x U1 &gt;-&gt; U0
U2 : Full Vector space of degree 3 over GF(3^2)
U1 : Full Vector space of degree 3 over GF(3^2)
U0 : Vector space of degree 2, dimension 1 over GF(3^2)
Generators:
(    1     2)
Echelonized basis:
(    1     2)
</PRE>
<HR>
<H5><A NAME = "6448">As Multilinear Maps</A></H5>

<P>
<P>
<P>
Regarding tensors as multilinear maps makes it possible to define 
the operations of composition and evaluation for tensors.


<H5><A NAME = "6449">x @ T : Tup, TenSpcElt -&gt; Any</A></H5>
<BLOCKQUOTE>
Evaluates the tensor T at x&isin;U<sub>v</sub> x ... x U<sub>1</sub>.
</BLOCKQUOTE>
<H5><A NAME = "6450">T * f : TenSpcElt, Map -&gt; TenSpcElt</A></H5>
<BLOCKQUOTE>
The tensor formed by composing the tensor T with the map f
is constructed.
</BLOCKQUOTE>
<H5><A NAME = "6451">S eq T : TenSpcElt, TenSpcElt -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if the tensors S and T have the same multilinear map.
</BLOCKQUOTE>
<H5><A NAME = "6452">Operations with Bilinear Maps</A></H5>

<P>
<P>
<P>
Tensors of valence 2, also known as bilinear tensors, or as bilinear maps,  
are commonly described as distributive products.  Examples include the product 
of two elements of an algebra, the action of a ring on a module, or an inner 
product.  Magma supports this interpretation by permitting an infix x * y 
notation for the evaluation of bilinear tensors.  This is achieved by creating 
special types <TT>BmpU[Elt]</TT>, <TT>BmpV[Elt]</TT>, and <TT>BmpW[Elt]</TT> 
for the terms of the frame of a bilinear tensor.


<H5><A NAME = "6453">x * y : BmpUElt, BmpVElt -&gt; Any</A></H5>
<H5>x * y : BmpU, BmpV -&gt; Any</H5>
<H5>x * y : BmpUElt, BmpV -&gt; Any</H5>
<H5>x * y : BmpU, BmpVElt -&gt; Any</H5>
<BLOCKQUOTE>
If x and y are associated to the bilinear map B, these operations return 
<TT>&lt;x,y&gt; @ B</TT>.
</BLOCKQUOTE>
<H5><A NAME = "6454">x * B : Any, TenSpcElt -&gt; TenSpcElt</A></H5>
<H5>B * y : TenSpcElt, Any -&gt; TenSpcElt</H5>
<BLOCKQUOTE>
Given a bilinear tensor B with frame [U<sub>2</sub>, U<sub>1</sub>, U<sub>0</sub>], x * B returns 
the action on the right as a linear map L : U<sub>1</sub> -&gt; U<sub>0</sub> given 
by vL = x * v, where x is an element of U<sub>2</sub>. 
If x is a subspace of U<sub>2</sub>, then this returns a sequence of 
maps, one for each element in the basis for x.
The left-hand action is given by B * y.
If B is valence 1, then the image of either x or y is returned.
</BLOCKQUOTE>
<H5><A NAME = "6455">Parent(x) : BmpUElt -&gt; BmpU</A></H5>
<H5>Parent(x) : BmpVElt -&gt; BmpV</H5>
<BLOCKQUOTE>
The parent space of the bilinear map element x is returned.
</BLOCKQUOTE>
<H5><A NAME = "6456">Parent(X) : BmpU -&gt; TenSpcElt</A></H5>
<H5>Parent(X) : BmpV -&gt; TenSpcElt</H5>
<BLOCKQUOTE>
The original bilinear map from which the space X originated
is returned.
</BLOCKQUOTE>
<H5><A NAME = "6457">LeftDomain(B) : TenSpcElt -&gt; BmpU</A></H5>
<BLOCKQUOTE>
The left domain U<sub>2</sub> of the bilinear map B with frame 
[U<sub>2</sub>, U<sub>1</sub>, U<sub>0</sub>] is returned. This operation is used when 
enabling the use of infix notation.
</BLOCKQUOTE>
<H5><A NAME = "6458">RightDomain(B) : TenSpcElt -&gt; BmpV</A></H5>
<BLOCKQUOTE>
The right domain U<sub>1</sub> of the bilinear map B with frame 
[U<sub>2</sub>, U<sub>1</sub>, U<sub>0</sub>] is returned This operation is used when  
enabling the use of infix notation. 
</BLOCKQUOTE>
<H5><A NAME = "6459">IsCoercible(S,x) : BmpU, Any -&gt; BoolElt, BmpUElt</A></H5>
<H5>IsCoercible(S,x) : BmpV, Any -&gt; BoolElt, BmpVElt</H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if x can be coerced the left domain (right 
domain) S of a bilinear map. If successful it returns the coerced 
element.
</BLOCKQUOTE>
<H5><A NAME = "6460">u1 eq u2 : BmpUElt, BmpUElt -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if the elements u1 and u2 from the left domain of
a bilinear map are equal.
</BLOCKQUOTE>
<H5><A NAME = "6461">v1 eq v2 : BmpUElt, BmpUElt -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if the elements v1 and v2 from the right domain of
a bilinear map are equal.
</BLOCKQUOTE>
<H5><A NAME = "6462">U1 eq U2 : BmpU, BmpU -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if the subspaces U1 and U2 of the left domain of
a bilinear map are equal.
</BLOCKQUOTE>
<H5><A NAME = "6463">V1 eq V2 : BmpV, BmpV -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if the subspaces V1 and V2 of the right domain of
a bilinear map are equal.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "6464">Example <TT>Multilinear_Bimap_Infix (H61E10)</TT></A></H3>
If B : U<sub>2</sub> x U<sub>1</sub> &#8611; U<sub>0</sub> is a tensor, then for x&isin;U<sub>2</sub>, 
x * B : U<sub>1</sub> -&gt; U<sub>0</sub> is a valence 1 tensor.
Similarly, for y&isin;U<sub>1</sub>, B * y : U<sub>2</sub> -&gt; U<sub>0</sub>. Furthermore, 
x * B * y can be used in place of &lt;x, y&gt; @B.
<P>
<P>
<P>
<PRE>
&gt; B := RandomTensor(GF(5),[4,3,5]);
&gt; B;
Tensor of valence 2, U2 x U1 &gt;-&gt; U0
U2 : Full Vector space of degree 4 over GF(5)
U1 : Full Vector space of degree 3 over GF(5)
U0 : Full Vector space of degree 5 over GF(5)
&gt; [3,2,0,1]*B*[1,1,2];
(2 1 1 3 4)
&gt; [1,0,0,0]*B;
Tensor of valence 1, U1 &gt;-&gt; U0
U1 : Full Vector space of degree 3 over GF(5)
U0 : Full Vector space of degree 5 over GF(5)
&gt; B*[0,2,0];
Tensor of valence 1, U1 &gt;-&gt; U0
U1 : Full Vector space of degree 4 over GF(5)
U0 : Full Vector space of degree 5 over GF(5)
</PRE>
<HR>
<H3><A NAME = "6465">Example <TT>Multilinear_Bimap_Product (H61E11)</TT></A></H3>
Suppose G is a p-group and B : U<sub>2</sub> x U<sub>1</sub> &#8611; U<sub>0</sub> 
is the tensor given by commutation where U<sub>2</sub>=U<sub>1</sub>=G/&Phi;(G) and U<sub>0</sub> 
is the next factor of the exponent-p central series of G.
<P>
<P>
<PRE>
&gt; G := SmallGroup(512,10^6);
&gt; B := pCentralTensor(G,2,1,1);
&gt; B;
Tensor of valence 2, U2 x U1 &gt;-&gt; U0
U2 : Full Vector space of degree 5 over GF(2)
U1 : Full Vector space of degree 5 over GF(2)
U0 : Full Vector space of degree 4 over GF(2)
&gt; U := LeftDomain(B);   //U2
&gt; V := RightDomain(B);  //U1
&gt; U![0,1,0,1,0] * V![1,0,0,0,0];
(1 0 0 1)
&gt; U!(G.2*G.4) * V!G.1;
(1 0 0 1)
</PRE>
This notation can be used to evaluate subspaces.
<P>
<P>
<PRE>
&gt; H := sub&lt; G | G.2,G.4 &gt;;
&gt; U!H * V!G.1;
Vector space of degree 4, dimension 2 over GF(2)
Generators:
(0 0 0 1)
(1 0 0 0)
Echelonized basis:
(1 0 0 0)
(0 0 0 1)
&gt; U!H * V!G;
Vector space of degree 4, dimension 3 over GF(2)
Generators:
(1 0 0 0)
(0 0 1 0)
(0 0 0 1)
(1 0 0 0)
(1 0 0 0)
Echelonized basis:
(1 0 0 0)
(0 0 1 0)
(0 0 0 1)
</PRE>
<HR>
<H5><A NAME = "6466">Manipulating Tensor Data</A></H5>

<P>
<P>
<P>
The data associated with a tensor can be accessed in different ways.   
In the case of tensors given by structure constants this access is
the multidimensional analog of choosing a row or column of a matrix.
Other operations are a generalization of the transpose of a matrix.
Magma does these operations with a degree of efficiency, that is, 
it may not physically move the values in a structure constant 
sequence but instead permute the lookup coordinates of the values.


<H5><A NAME = "6467">Slice(T, grid) : TenSpcElt, [SetEnum] -&gt; SeqEnum</A></H5>
<H5>InducedTensor(T, grid) : TenSpcElt, [SetEnum] -&gt; TenSpcElt</H5>
<BLOCKQUOTE>
Returns the slice of the structure constants running through the given grid. 
For a tensor framed by free modules [U<sub>v</sub>, ..., U<sub>0</sub>] with d<sub>i</sub>=dim U<sub>i</sub>, 
a grid is a sequence [G<sub>v</sub>, ..., G<sub>0</sub>] of subsets G<sub>i</sub>&sube;{1..d<sub>i</sub>}.
The slice is the list of entries in the structure constants of the tensor
indexed by G<sub>v</sub> x ... x G<sub>0</sub>. <TT>Slice</TT> returns the structure
constants whereas <TT>InducedTensor</TT> produces a tensor with these
structure constants. 
</BLOCKQUOTE>
<HR>
<H3><A NAME = "6468">Example <TT>Multilinear_Ten_Foliation (H61E12)</TT></A></H3>
<P>
<P>
<PRE>
&gt; U := VectorSpace(Rationals(),4);
&gt; V := VectorSpace(Rationals(),3);
&gt; W := VectorSpace(Rationals(),2);
&gt; TS := TensorSpace([U,V,W]);
&gt; T := TS![ i : i in [1..24] ];
&gt; Slice(T,[{1..4},{1..3},{1..2}]);  // structure constants
[ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17,
18, 19, 20, 21, 22, 23, 24 ]
</PRE>
The data <TT>Slice</TT> extracts from the structure constants of tensor T 
can be used as the structure constants for a new tensor.
<P>
<P>
<PRE>
&gt; Slice(T,[{1..4},{2},{1}]); 
[ 3, 9, 15, 21 ]
&gt; 
&gt; W1 := VectorSpace(Rationals(),1);
&gt; pi := hom&lt; W -&gt; W1 | &lt;W.1,W1.1&gt;, &lt;W.2,W1!0&gt; &gt;; // project
&gt; Eltseq( (T*V.2)*pi );
[ 3, 9, 15, 21 ]
</PRE>
However, in this example, the tensors are not the same. 
If the induced tensor is compressed, then they become equal.
<P>
<P>
<PRE>
&gt; T_ind := InducedTensor(T,[{1..4},{2},{1}]);
&gt; T_ind;
Tensor of valence 2, U2 x U1 &gt;-&gt; U0
U2 : Full Vector space of degree 4 over Rational Field
U1 : Full Vector space of degree 1 over Rational Field
U0 : Full Vector space of degree 1 over Rational Field
&gt; S := (T*V.2)*pi;
&gt; S;
Tensor of valence 1, U1 &gt;-&gt; U0
U1 : Full Vector space of degree 4 over Rational Field
U0 : Full Vector space of degree 1 over Rational Field
&gt; 
&gt; Compress(T_ind) eq S;
true
</PRE>
<HR>
<H5><A NAME = "6469">Foliation(T, i) : TenSpcElt, RngIntElt -&gt; Mtrx</A></H5>
<BLOCKQUOTE>
If T is a tensor contained in hom(U<sub>v</sub> tensor ... tensor U<sub>1</sub>, U<sub>0</sub>),
and i is the index of some term of the frame of T, this intrinsic returns 
the matrix representing the linear map 
U<sub>i</sub> -&gt; hom(bigotimes<sub>j&ne;i</sub>U<sub>i</sub>, U<sub>0</sub>) using the bases of each U<sub>j</sub>.
If i=0, then the returned matrix is given by the representation 
U<sub>0</sub><sup> * </sup> -&gt; hom(bigotimes U<sub>i</sub>, K).
</BLOCKQUOTE>
<H5><A NAME = "6470">AsTensorSpace(T, i) : TenSpcElt, RngIntElt -&gt; TenSpc, Mtrx</A></H5>
<BLOCKQUOTE>
If T is a tensor contained in hom(U<sub>v</sub> tensor ... tensor U<sub>1</sub>, U<sub>0</sub>),
and i is the index of some term of the frame of T, this intrinsic returns 
the associated tensor space of T at i&gt;0 together with a matrix given by
the foliation of T at i.  The returned tensor space is framed by 
U<sub>v</sub> x ... x U<sub>i + 1</sub> x U<sub>i - 1</sub> x ... x U<sub>1</sub> &#8611; U<sub>0</sub>
and is generated by the tensors T<sub>u</sub> for each u in the basis of U<sub>i</sub>.
</BLOCKQUOTE>
<H5><A NAME = "6471">AsCotensorSpace(T) : TenSpcElt -&gt; TenSpc, Mtrx</A></H5>
<BLOCKQUOTE>
Given a tensor T, this intrinsic returns the associated cotensor space of T 
together with a matrix given by the foliation of T at 0.  The returned 
cotensor space has frame U<sub>v</sub> x ... x U<sub>1</sub> &#8611; K
and is generated by the tensors Tf for each f in the basis of U<sub>0</sub><sup> * </sup>.
</BLOCKQUOTE>
<H5><A NAME = "6472">AsTensor(S) : TenSpc -&gt; TenSpcElt</A></H5>
<BLOCKQUOTE>
Given a tensor space S, this intrinsic returns a tensor belonging to S. 
If S is contravariant, then the returned tensor has the frame 
U<sub>v</sub> x ... x U<sub>1</sub> &#8611; T.
If S is covariant, then the returned tensor has the frame 
T x U<sub>v</sub> x ... x U<sub>1</sub> &#8611; U<sub>0</sub>.
Note that <TT>AsTensor</TT> is "inverse" to <TT>AsCotensorSpace</TT> and 
<TT>AsTensorSpace</TT> when i=v.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "6473">Example <TT>Multilinear_Ten_Slice (H61E13)</TT></A></H3>
<P>
<P>
<PRE>
&gt; T := RandomTensor( GF(7), [2,3,4] );
&gt; Foliation(T,0);
[3 4 3 3 6 4]
[0 6 4 3 3 4]
[0 0 6 2 3 3]
[4 6 4 0 0 3]
&gt; 
&gt; Slice(T,[{1,2},{1..3},{3}]); // row 3
[ 0, 0, 6, 2, 3, 3 ]
&gt; 
&gt; Slice(T,[{2},{1},{1..4}]); // col 4
[ 3, 3, 2, 0 ]
</PRE>
The cotensor space associated to a tensor is the subcotensor space spanned by 
multilinear forms obtained from T.  For a fixed basis of U<sub>0</sub>, we get a 
basis for the cotensor space by projecting onto various basis vectors of U<sub>0</sub>.
<P>
<P>
<PRE>
&gt; CT := AsCotensorSpace(T);
&gt; CT;
Cotensor space of dimension 4 over GF(7) with valence 1
U2 : Full Vector space of degree 2 over GF(7)
U1 : Full Vector space of degree 3 over GF(7)
&gt; 
&gt; S := Random(CT);
&gt; MS := KMatrixSpace(GF(7),2,3);
&gt; SystemOfForms(S) subset sub&lt;MS|SystemOfForms(T)&gt;;
true
</PRE>
The same applies for the associated tensor space to a tensor, where a basis
is obtained by projecting onto the basis vectors of U<sub>i</sub>.
<P>
<P>
<PRE>
&gt; TS := AsTensorSpace(T,1);
&gt; TS;
Tensor space of dimension 3 over GF(7) with valence 1
U1 : Full Vector space of degree 2 over GF(7)
U0 : Full Vector space of degree 4 over GF(7)
&gt; 
&gt; S := Random(TS);
&gt; MS := KMatrixSpace(GF(7),2,4);
&gt; AsMatrices(S,1,0) subset sub&lt;MS|AsMatrices(T,2,0)&gt;;
true
</PRE>
<HR>
<H4><A NAME = "6474">Invariants of Tensors</A></H4>

<P>
<P>
<P>
To access the projections or the objects acting on a specific factor, the 
following should be used.


<H5><A NAME = "6475">Induce(X, i) : AlgMat, RngIntElt -&gt; AlgMat, Map</A></H5>
<H5>Induce(X, i) : AlgMatLie, RngIntElt -&gt; AlgMatLie, Map</H5>
<H5>Induce(X, i) : GrpMat, RngIntElt -&gt; GrpMat, Map</H5>
<BLOCKQUOTE>
Returns the induced sub-object associated to the ith factor of the 
associated 
tensor and a projection from the given object to the returned sub-object.
</BLOCKQUOTE>
<H5><A NAME = "6476">Standard Invariants</A></H5>

<P>
<P>
<P>
We integrate the invariant theory associated to bilinear and multilinear maps
into the realm of tensors. 


<H5><A NAME = "6477">Radical(T, s) : TenSpcElt, RngIntElt -&gt; ModTupRng, Map</A></H5>
<BLOCKQUOTE>
Returns the sth (categorical) radical as a subspace of U<sub>s</sub> along with an isomorphism from U<sub>s</sub> to K<sup>d<sub>s</sub></sup>.
If U<sub>s</sub> is already a vector space, then the returned map is the identity.
</BLOCKQUOTE>
<H5><A NAME = "6478">Radical(T) : TenSpcElt -&gt; Tup</A></H5>
<BLOCKQUOTE>
Returns the tuple of all the s-radicals for each s&isin;{1, ..., v}.
</BLOCKQUOTE>
<H5><A NAME = "6479">Coradical(T) : TenSpcElt -&gt; ModTupRng, Map</A></H5>
<BLOCKQUOTE>
Returns the (categorical) coradical of T and a vector space surjection from 
the codomain to the coradical.
</BLOCKQUOTE>
<H5><A NAME = "6480">Invariants for Bilinear Tensors</A></H5>

<P>
<P>
<P>
The following are used only for tensors of valence 2.


<H5><A NAME = "6481">AdjointAlgebra(B) : TenSpcElt -&gt; AlgMat</A></H5>
<BLOCKQUOTE>
Returns the adjoint *-algebra of the given bilinear map. 
</BLOCKQUOTE>
<HR>
<H3><A NAME = "6482">Example <TT>Multilinear_Ten_Adj_Alg (H61E14)</TT></A></H3>
<P>
<P>
<PRE>
&gt; V := VectorSpace( GF(5), 10 );
&gt; E := ExteriorCotensorSpace( V, 2 );
&gt; E;
Cotensor space of dimension 45 over GF(5) with valence 1
U2 : Full Vector space of degree 10 over GF(5)
U1 : Full Vector space of degree 10 over GF(5)
&gt; 
&gt; T := Random(E);
&gt; S := Random(E);
&gt; CT := SubtensorSpace(E,[T,S]);
&gt; T2 := AsTensor(CT);
&gt; T2;
Tensor of valence 2, U2 x U1 &gt;-&gt; U0
U2 : Full Vector space of degree 10 over GF(5)
U1 : Full Vector space of degree 10 over GF(5)
U0 : Full Vector space of degree 2 over GF(5)
&gt; 
&gt; A := AdjointAlgebra(T2);
&gt; RecognizeStarAlgebra(A);
true
&gt; Star(A);
Mapping from: AlgMat: A to AlgMat: A given by a rule [no 
inverse]
</PRE>
<HR>
<H5><A NAME = "6483">LeftNucleus(B) : TenSpcElt -&gt; AlgMat</A></H5>
<BLOCKQUOTE>
Returns the left nucleus of the bilinear map B as a subalgebra of (End)<sub>K</sub>(U<sub>2</sub>) x (End)<sub>K</sub>(U<sub>0</sub>).
</BLOCKQUOTE>
<H5><A NAME = "6484">MidNucleus(B) : TenSpcElt -&gt; AlgMat</A></H5>
<BLOCKQUOTE>
Returns the mid nucleus of the bilinear map B as a subalgebra of (End)<sub>K</sub>(U<sub>2</sub>) x (End)<sub>K</sub>(U<sub>1</sub>).
</BLOCKQUOTE>
<H5><A NAME = "6485">RightNucleus(B) : TenSpcElt -&gt; AlgMat</A></H5>
<BLOCKQUOTE>
Returns the right nucleus of the bilinear map B as a subalgebra of (End)<sub>K</sub>(U<sub>1</sub>) x (End)<sub>K</sub>(U<sub>0</sub>).
</BLOCKQUOTE>
<H5><A NAME = "6486">Invariants of General Multilinear Maps</A></H5>

<P>
<P>
<P>
The following functions can be used for general multilinear maps.


<P>
If the centroid of a tensor is a commutative local ring, we can rewrite a tensor over its centroid.
We employ the algorithms developed by Brooksbank and Wilson <A  HREF = "text602.htm#bib_BW_Module-iso">[BW15]</A> to efficiently determine if a matrix algebra is cyclic.
<P>
We include some well-known polynomial invariants for bilinear maps.
<H5><A NAME = "6487">Centroid(T) : TenSpcElt -&gt; AlgMat</A></H5>
<BLOCKQUOTE>
Returns the centroid of the tensor as a subalgebra of &prod;<sub>i=0</sub><sup>v</sup>(End)<sub>K</sub>(U<sub>i</sub>).
</BLOCKQUOTE>
<HR>
<H3><A NAME = "6488">Example <TT>Multilinear_Ten_Centroid (H61E15)</TT></A></H3>
<P>
<P>
<PRE>
&gt; A := MatrixAlgebra(GF(3),25);
&gt; f := RandomIrreduciblePolynomial(GF(3),25);
&gt; S := sub&lt; A | CompanionMatrix(f) &gt;; // GF(3^25) inside A
&gt; T := Tensor(S);
&gt; T;
Tensor of valence 2, U2 x U1 &gt;-&gt; U0
U2 : Matrix Algebra of degree 25 with 1 generator over GF(3)
U1 : Matrix Algebra of degree 25 with 1 generator over GF(3)
U0 : Matrix Algebra of degree 25 with 1 generator over GF(3)
&gt; C := Centroid(T);
&gt; Dimension(C);
25
&gt; Ngens(C);
1
</PRE>
<HR>
<H5><A NAME = "6489">DerivationAlgebra(T) : TenSpcElt -&gt; AlgMatLie</A></H5>
<BLOCKQUOTE>
Given a tensor T, returns the derivation Lie algebra of the tensor as a Lie subalgebra of &prod;<sub>i=0</sub><sup>v</sup>(End)<sub>K</sub>(U<sub>i</sub>).
</BLOCKQUOTE>
<H5><A NAME = "6490">Nucleus(T, s, t) : TenSpcElt, RngIntElt, RngIntElt -&gt; AlgMat</A></H5>
<BLOCKQUOTE>
Returns the st-nucleus (s&ne;t) of the tensor as a subalgebra of (End)<sub>K</sub>(U<sub>i</sub>) x (End)<sub>K</sub>(U<sub>j</sub>), 
where i=max(s, t) and j=min(s, t).
</BLOCKQUOTE>
<HR>
<H3><A NAME = "6491">Example <TT>Multilinear_Ten_Der_Nuc (H61E16)</TT></A></H3>
<P>
<P>
<PRE>
&gt; H := QuaternionAlgebra(Rationals(),-1,-1);
&gt; T := Tensor(H);                           
&gt; T;
Tensor of valence 2, U2 x U1 &gt;-&gt; U0
U2 : Quaternion Algebra with base ring Rational Field, 
defined by i^2 = -1, j^2 = -1
U1 : Quaternion Algebra with base ring Rational Field, 
defined by i^2 = -1, j^2 = -1
U0 : Quaternion Algebra with base ring Rational Field, 
defined by i^2 = -1, j^2 = -1
&gt; D := DerivationAlgebra(T);
&gt; SemisimpleType(D);
A1
</PRE>
Now we verify that the mid nucleus of T is the quaternion algebra.
<P>
<P>
<PRE>
&gt; ChangeTensorCategory(~T,HomotopismCategory(2));
&gt; N := Nucleus(T,2,1);
&gt; Dimension(N);
4
&gt; N.1^2 eq N!-1;
true
&gt; N.2^2 eq N!-1;
true
&gt; N.1*N.2 eq -N.2*N.1;
true
</PRE>
<HR>
<H5><A NAME = "6492">TensorOverCentroid(T) : TenSpcElt -&gt; TenSpcElt, Hmtp</A></H5>
<BLOCKQUOTE>
If the given tensor T is framed by K-vector spaces, then the returned tensor is framed by E-vector spaces where E is the residue field of the centroid. 
The returned homotopism is an isotopism of the K-tensors.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "6493">Example <TT>Multilinear_Ten_Over_Cen (H61E17)</TT></A></H3>
This will "forget" the field structure of our group, so that the tensor given by the commutator will be over F<sub>2</sub>.
We will use the centroid to rewrite our tensor as an alternating form over F<sub>1024</sub>.
<P>
<P>
<PRE>
&gt; G := ClassicalSylow( GL(3,1024), 2 );
&gt; P := PCPresentation( UnipotentMatrixGroup(G) );
&gt; T := pCentralTensor(P,1,1);
&gt; T;
Tensor of valence 2, U2 x U1 &gt;-&gt; U0
U2 : Full Vector space of degree 20 over GF(2)
U1 : Full Vector space of degree 20 over GF(2)
U0 : Full Vector space of degree 10 over GF(2)
&gt; TC := TensorOverCentroid(T);
&gt; TC;
Tensor of valence 2, U2 x U1 &gt;-&gt; U0
U2 : Full Vector space of degree 2 over GF(2^10)
U1 : Full Vector space of degree 2 over GF(2^10)
U0 : Full Vector space of degree 1 over GF(2^10)
&gt; IsAlternating(TC);
true
</PRE>
<HR>
<H5><A NAME = "6494">Discriminant(B) : TenSpcElt -&gt; RngMPolElt</A></H5>
<BLOCKQUOTE>
Returns the discriminant of the bilinear map.
</BLOCKQUOTE>
<H5><A NAME = "6495">Pfaffian(B) : TenSpcElt -&gt; RngMPolElt</A></H5>
<BLOCKQUOTE>
Returns the Pfaffian of the antisymmetric bilinear map.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "6496">Example <TT>Multilinear_Ten_Disc_Pfaff (H61E18)</TT></A></H3>
<P>
<P>
<PRE>
&gt; J := Matrix(GF(7),[[0,1],[-1,0]]);
&gt; J;
[0 1]
[6 0]
&gt; M := [ InsertBlock(ZeroMatrix(GF(7),4,4),J,i,i) 
&gt; : i in [1..3] ]; 
&gt; M;
[
    [0 1 0 0]
    [6 0 0 0]
    [0 0 0 0]
    [0 0 0 0],

    [0 0 0 0]
    [0 0 1 0]
    [0 6 0 0]
    [0 0 0 0],

    [0 0 0 0]
    [0 0 0 0]
    [0 0 0 1]
    [0 0 6 0]
]
&gt; T := Tensor(M,2,1);
&gt; T;
Tensor of valence 2, U2 x U1 &gt;-&gt; U0
U2 : Full Vector space of degree 4 over GF(7)
U1 : Full Vector space of degree 4 over GF(7)
U0 : Full Vector space of degree 3 over GF(7)
&gt; Discriminant(T);
$.1^2*$.3^2
&gt; Pfaffian(T);
$.1*$.3
</PRE>
<HR>
<PRE></PRE> <A  HREF = "text606.htm">[Next]</A><A  HREF = "text604.htm">[Prev]</A> <A  HREF = "text606.htm">[Right]</A> <A  HREF = "text604.htm">[Left]</A> <A  HREF = "text603.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<br><small>Version: V2.22 of <I>
Thu Jun  9 16:37:49 EST 2016
</I></small>
</body></html>