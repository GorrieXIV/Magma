<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <link rel='stylesheet' href='help.css' type='text/css'>
  <TITLE>Connectedness</TITLE>
</head>
<body BGCOLOR="#FFFFFF">

 <A  HREF = "text1796.htm">[Next]</A><A  HREF = "text1794.htm">[Prev]</A> <A  HREF = "text1796.htm">[Right]</A> <A  HREF = "text1794.htm">[Left]</A> <A  HREF = "text1782.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<PRE></PRE><H3><A NAME = "19878">Connectedness</A></H3>




<H5>Subsections</H5>
<UL>
<LI> <A  HREF = "text1795.htm#19879">Connectedness in a Graph</A>
<LI> <A  HREF = "text1795.htm#19887">Connectedness in a Digraph</A>
<LI> <A  HREF = "text1795.htm#19892">Graph Triconnectivity</A>
<LI> <A  HREF = "text1795.htm#19897">Maximum Matching in Bipartite Graphs</A>
<LI> <A  HREF = "text1795.htm#19900">General Vertex and Edge Connectivity in Graphs and Digraphs</A>
</UL>
<H4><A NAME = "19879">Connectedness in a Graph</A></H4>



<H5><A NAME = "19880">IsConnected(G) : GrphUnd -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT>  if and only if the graph G is connected.
</BLOCKQUOTE>
<H5><A NAME = "19881">Components(G) : GrphUnd -&gt; [ { GrphVert } ]</A></H5>
<BLOCKQUOTE>
The connected components of the graph G. These are returned in the
form of a sequence of subsets of the vertex-set of G.
</BLOCKQUOTE>
<H5><A NAME = "19882">Component(u) : GrphVert -&gt; Grph</A></H5>
<BLOCKQUOTE>
The subgraph corresponding to the connected component of the graph
G containing vertex u.
The support and vertex/edge decorations are <I>not</I> retained 
  in the resulting (structural) subgraph.
</BLOCKQUOTE>
<H5><A NAME = "19883">IsSeparable(G) : GrphUnd -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if and only if the graph G is connected and has at least
  one cut vertex.
</BLOCKQUOTE>
<H5><A NAME = "19884">IsBiconnected(G) : GrphUnd -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if and only if the graph G is biconnected.
</BLOCKQUOTE>
<H5><A NAME = "19885">CutVertices(G) : Grph -&gt; { GrphVert }</A></H5>
<BLOCKQUOTE>
The set of cut vertices for the connected graph G (a set of vertices).
</BLOCKQUOTE>
<H5><A NAME = "19886">Bicomponents(G) : GrphUnd -&gt; [GrphUnd]</A></H5>
<BLOCKQUOTE>
The biconnected components of the graph G. These are returned in the
form of a sequence of subsets of the vertex-set of G.
The graph may be disconnected.
</BLOCKQUOTE>
<H4><A NAME = "19887">Connectedness in a Digraph</A></H4>



<H5><A NAME = "19888">IsStronglyConnected(G) : GrphDir -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if and only if the digraph G is strongly connected.
</BLOCKQUOTE>
<H5><A NAME = "19889">IsWeaklyConnected(G) : GrphDir -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if and only if the digraph G is weakly connected.
</BLOCKQUOTE>
<H5><A NAME = "19890">StronglyConnectedComponents(G) : GrphDir -&gt; [ { GrphVert } ]</A></H5>
<BLOCKQUOTE>
The strongly connected components of the digraph G. 
These are returned in the
form of a sequence of subsets of the vertex-set of G.
</BLOCKQUOTE>
<H5><A NAME = "19891">Component(u) : GrphVert -&gt; Grph</A></H5>
<BLOCKQUOTE>
The subgraph corresponding to the connected component of the digraph
G containing vertex u.
The support and vertex/edge decorations are <I>not</I> retained 
  in the resulting (structural) subgraph.
</BLOCKQUOTE>
<H4><A NAME = "19892">Graph Triconnectivity</A></H4>

<P>
<P>
<P>
<P>
<P>
<P>
The linear-time triconnectivity algorithm by Hopcroft and 
  Tarjan <A  HREF = "text1781.htm#bib_HopTar73">[HT73]</A> has been implemented with corrections 
  of our own and from C. Gutwenger and P. Mutzel <A  HREF = "text1781.htm#bib_GutMut01">[GM01]</A>.
This algorithm requires that the graph has a sparse 
  representation.
The input graph may be disconnected or have cut vertices.
<P>
The algorithm completely splits the graph into components that 
  can later be reconstructed as triconnected graphs:
It is our belief that the word "tricomponents" is misused 
  in all the papers discussing Hopcroft and Tarjan's algorithm,
  including <A  HREF = "text1781.htm#bib_HopTar73">[HT73]</A> and  <A  HREF = "text1781.htm#bib_GutMut01">[GM01]</A>.
Let us clarify this point.
<P>
<P>
<P>
Assume that G is a biconnected but not triconnected graph 
  with vertex-set V and with one separation
  pair (a, b) which  splits V - {a, b} into  V<sub>1</sub> and
  V<sub>2</sub>.
That is, for any vertices      u&isin;V<sub>1</sub> and v&isin;V<sub>2</sub>, every path 
  from u to v in G contains  at least           one of a or b.
<P>
Now, the algorithm will correctly find the separation pair 
  (a, b) and 
  return the two subsets of V, V<sub>1</sub> + {a, b}
  and V<sub>2</sub> + {a, b}.
Let G<sub>1</sub> and G<sub>2</sub> be the subgraphs of G induced by 
  V<sub>1</sub> + {a, b} and V<sub>2</sub> + {a, b} respectively.
We say that the algorithm <I>splits</I> G into G<sub>1</sub> and G<sub>2</sub>.
<P>
<P>
<P>
But G<sub>1</sub> and G<sub>2</sub> are  triconnected if and only if 
  there is an edge (a, b) in G.
We call G<sub>1</sub> and G<sub>2</sub> the <I>split components</I> of G.
<P>
More generally, if G<sub>1</sub>, ..., G<sub>m</sub> are the split 
   components of a graph G, one can make the G<sub>i</sub>
   triconnected by adding the edges (a, b) to them
   for all the separation pairs (a, b)
   of G with a, b&isin;G<sub>i</sub> for some i.
<P>
<P>
<P>
The algorithm finds all the cut vertices and/or the separation
  pairs of a graph, unless only the boolean test is applied.
When this is the case the algorithm stops as soon as a cut vertex
  or separation pair is found.
<P>
The triconnectivity algorithm only applies to undirected graphs.


<H5><A NAME = "19893">IsTriconnected(G) : GrphUnd -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if and only if the graph G is triconnected. 
</BLOCKQUOTE>
<H5><A NAME = "19894">Splitcomponents(G) : GrphUnd -&gt; [ { GrphVert } ], [ [ GrphVert ]]</A></H5>
<BLOCKQUOTE>
The split components of the graph G. These are returned in the
form of a sequence of subsets of the vertex-set of G.
The graph may be disconnected.
The second return value returns the cut vertices and the separation
pairs.
</BLOCKQUOTE>
<H5><A NAME = "19895">SeparationVertices(G) : GrphUnd -&gt; [ [ GrphVert ]], [ { GrphVert } ]</A></H5>
<BLOCKQUOTE>
The cut vertices and/or the separation pairs of the graph G as 
a sequence of vertices or pairs of vertices of G.
The graph may be disconnected.
The second return value returns G's split components.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "19896">Example <TT>Graph_Triconnectivity (H155E12)</TT></A></H3>
<P>
<P>
<PRE>
&gt; G := Graph&lt; 11 |
&gt; {1, 3}, {1, 4}, {1, 7}, {1, 11}, {1, 2},
&gt; {2, 4}, {2, 3},
&gt; {3, 4},
&gt; {4, 7}, {4, 11}, {4, 7}, {4, 5},
&gt; {5, 10}, {5, 9}, {5, 8}, {5, 6},
&gt; {6, 8}, {6, 7},
&gt; {7, 8},
&gt; {9, 11}, {9, 10},
&gt; {10, 11}: SparseRep := true &gt;;
&gt; TS, PS := Splitcomponents(G);
&gt; TS;
[
  { 5, 6, 7, 8 },
  { 5, 9, 10, 11 },
  { 1, 4, 5, 7, 11 },
  { 1, 4 },
  { 1, 2, 3, 4 }
]
&gt; PS;
[
  [ 5, 7 ],
  [ 5, 11 ],
  [ 1, 4 ]
]
</PRE>
Let <TT>G1</TT> be the subgraph induced by <TT>TS[1]</TT>.
We will verify that it is not triconnected and
  we make it triconnected by adding the edge <TT>[5, 7]</TT>,
  since <TT>[5, 7]</TT> is a separation pair of <TT>G</TT> whose vertices 
  belong to <TT>G1</TT>.
<P>
<P>
<PRE>
&gt; G1 := sub&lt; G | TS[1] &gt;;
&gt; IsTriconnected(G1);
false
&gt; AddEdge(~G1, Index(VertexSet(G1)!VertexSet(G)!5), 
&gt;       Index(VertexSet(G1)!VertexSet(G)!7));
&gt; IsTriconnected(G1);
true
</PRE>
<HR>
<H4><A NAME = "19897">Maximum Matching in Bipartite Graphs</A></H4>

<P>
<P>
<P>
<P>
<P>
<P>
The maximum matching algorithm is a flow-based algorithm.
We have implemented two maximum flow algorithms, the Dinic algorithm,
   and a push-relabel algorithm. 
The latter is almost always the most efficient, it may be outperformed
  by Dinic only in the case of very sparse graphs.
For a full discussion of these algorithms, the reader is referred
  to Section <A  HREF = "text1828.htm#20291">Maximum Flow and Minimum Cut</A> in Chapter <A  HREF = "text1809.htm#20036">MULTIGRAPHS</A>.
Example <A  HREF = "text1828.htm#20298">H157E4</A> in this same chapter actually 
  is an implementation in Magma code of the maximum matching algorithm.


<H5><A NAME = "19898"></A><A NAME = "Graph:MaximumMatching">MaximumMatching</A>(G) : GrphUnd -&gt; [ { GrphEdge } ]</H5>

<PRE>    Al: MonStgElt                       Default: "PushRelabel"</PRE>
<BLOCKQUOTE>
A maximum matching in the bipartite graph G. 
The matching is returned as  a sequence of edges of G.
The parameter <TT>Al</TT> enables the user to select the algorithm
  which is to be used:
<TT>Al := "PushRelabel"</TT> or <TT>Al := "Dinic"</TT>.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "19899">Example <TT>Graph_MaxMatching (H155E13)</TT></A></H3>
We begin by creating a random bipartite graph.
The matching algorithm is flow-based and is one of the algorithms which 
  deals with graphs as adjacency lists.
For this reason we might as well create the graph with a 
  sparse representation
  (see Section <A  HREF = "text1785.htm#19713">Graphs with a Sparse Representation</A>).
<P>
<P>
<PRE>
&gt; n := 5;
&gt; m := 7;
&gt; d := 3;
&gt; G := EmptyGraph(n);
&gt; H := EmptyGraph(m);
&gt; G := G join H;
&gt; for u in [1..n] do
&gt;     t := Random(0, d);
&gt;     for tt in [1..t] do
&gt;         v := Random(n+1, n+m); 
&gt;         AddEdge(~G, u, v);
&gt;     end for;
&gt; end for;
&gt; G := Graph&lt; Order(G) | G : SparseRep := true &gt;;
&gt; 
&gt; IsBipartite(G);
true
&gt; Bipartition(G);
[
  { 1, 12, 2, 3, 4, 5, 7 },
  { 11, 6, 8, 9, 10 }
]
&gt; MaximumMatching(G);
[ {1, 11}, {4, 10}, {2, 9}, {5, 8}, {3, 6} ]
</PRE>
<HR>
<H4><A NAME = "19900">General Vertex and Edge Connectivity in Graphs and Digraphs</A></H4>

<P>
<P>
<P>
<P>
<P>
<P>
As for the maximum matching algorithm 
   (Subsection <A  HREF = "text1795.htm#19897">Maximum Matching in Bipartite Graphs</A>)
  the vertex and edge connectivity algorithms are flow-based 
  algorithms.
We have implemented two flow algorithms, Dinic and a push relabel
   method.
In general Dinic outperforms the push relabel method only in 
  the case of very sparse graphs.
This is particularly visible when computing 
  the edge connectivity of a graph.
For full details on those flow algorithms, refer to 
   Section <A  HREF = "text1828.htm#20291">Maximum Flow and Minimum Cut</A> in Chapter <A  HREF = "text1809.htm#20036">MULTIGRAPHS</A>.
For details on how vertex and edge connectivity are implemented, 
  see <A  HREF = "text1781.htm#bib_even">[Eve79]</A>.
<P>
The general connectivity algorithms apply to both undirected and 
  directed graphs.


<H5><A NAME = "19901">VertexSeparator(G) : Grph -&gt; [ GrphVert ]</A></H5>

<PRE>    Al: MonStgElt                       Default: "PushRelabel"</PRE>
<BLOCKQUOTE>
If G is an undirected graph, a <I>vertex separator</I> for G is a smallest
set of vertices S such that for any u, v&isin;V(G), every path 
connecting u and v passes through at least one vertex of S.
<P>
If G is a directed graph, a vertex separator for G is a smallest
set of vertices S such that for any u, v&isin;V(G), every directed
path from u to v passes through at least one vertex of S.
<P>
<TT>VertexSeparator</TT> returns the vertex separator of G as a sequence
of vertices of G.
The parameter <TT>Al</TT> enables the user to select the algorithm
  which is to be used:
<TT>Al := "PushRelabel"</TT> or <TT>Al := "Dinic"</TT>.
</BLOCKQUOTE>
<H5><A NAME = "19902">VertexConnectivity(G) : Grph -&gt; RngIntElt, [ GrphVert ]</A></H5>

<PRE>    Al: MonStgElt                       Default: "PushRelabel"</PRE>
<BLOCKQUOTE>
Returns the vertex connectivity of the graph G, the size of a minimum
  vertex separator of G.
Also returns a vertex separator for G as the
  second value.
The parameter <TT>Al</TT> enables the user to select the algorithm
  which is to be used:
<TT>Al := "PushRelabel"</TT> or <TT>Al := "Dinic"</TT>.
</BLOCKQUOTE>
<H5><A NAME = "19903">IsKVertexConnected(G, k) : Grph, RngIntElt -&gt; BoolElt</A></H5>

<PRE>    Al: MonStgElt                       Default: "PushRelabel"</PRE>
<BLOCKQUOTE>
Returns <TT>true</TT> if the graph G's vertex connectivity is at least k, <TT>false</TT> 
otherwise.
The parameter <TT>Al</TT> enables the user to select the algorithm
  which is to be used:
<TT>Al := "PushRelabel"</TT> or <TT>Al := "Dinic"</TT>.
</BLOCKQUOTE>
<H5><A NAME = "19904">EdgeSeparator(G) : Grph -&gt; [ GrphEdge ]</A></H5>

<PRE>    Al: MonStgElt                       Default: "PushRelabel"</PRE>
<BLOCKQUOTE>
If G is an undirected graph, an <I>edge separator</I> for G is a smallest
set of edges T such that for any u, v&isin;V(G), every path 
connecting u and v passes through at least one edge of T.
<P>
If G is a directed graph, an edge separator for G is a smallest
set of edges T such that for any u, v&isin;V(G), every directed
path from u to v passes through at least one edge of T.
<P>
<TT>EdgeSeparator</TT> returns the edge separator of G as a sequence
of edges of G.
The parameter <TT>Al</TT> enables the user to select the algorithm
  which is to be used:
<TT>Al := "PushRelabel"</TT> or <TT>Al := "Dinic"</TT>.
</BLOCKQUOTE>
<H5><A NAME = "19905">EdgeConnectivity(G) : Grph -&gt; RngIntElt, [ GrphEdge ]</A></H5>

<PRE>    Al: MonStgElt                       Default: "PushRelabel"</PRE>
<BLOCKQUOTE>
Returns the edge connectivity of the graph G, the size of a minimum
  edge separator of G.
Also returns as the second value an edge separator for G.
The parameter <TT>Al</TT> enables the user to select the algorithm
  which is to be used:
<TT>Al := "PushRelabel"</TT> or <TT>Al := "Dinic"</TT>.
</BLOCKQUOTE>
<H5><A NAME = "19906">IsKEdgeConnected(G, k) : Grph, RngIntElt -&gt; BoolElt</A></H5>

<PRE>    Al: MonStgElt                       Default: "PushRelabel"</PRE>
<BLOCKQUOTE>
Returns <TT>true</TT> if the graph G's edge connectivity is at least k, <TT>false</TT> 
otherwise.
The parameter <TT>Al</TT> enables the user to select the algorithm
  which is to be used:
<TT>Al := "PushRelabel"</TT> or <TT>Al := "Dinic"</TT>.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "19907">Example <TT>Graph_Connectivity (H155E14)</TT></A></H3>
We compute the vertex and edge connectivity for a small undirected
  graph and we perform a few checks.
The connectivity algorithm is one of the algorithms which 
  deals with graphs as adjacency lists.
For this reason we might as well create the graph with a 
  sparse representation
  (see Section <A  HREF = "text1785.htm#19713">Graphs with a Sparse Representation</A>).
<P>
<P>
<PRE>
&gt; G := Graph&lt; 4 | {1, 2}, {1, 3}, {2, 3}, {2, 4}, {3, 4}
&gt; : SparseRep := true &gt;;
&gt; IsConnected(G);
true
&gt;
&gt; vc := VertexConnectivity(G);
&gt; S := VertexSeparator(G);
&gt; vc;
2
&gt; S;
[ 3, 2 ]
&gt;
&gt; H := G;
&gt; vs := [ Integers() | Index(x) : x in S ];
&gt; RemoveVertices(~H, vs);
&gt; IsConnected(H);
false
&gt; for k in [0..vc] do
&gt;     IsKVertexConnected(G, k);
&gt; end for;
true
true
true
&gt; for k in [vc+1..Order(G)-1] do
&gt;     IsKVertexConnected(G, k);
&gt; end for;
false
&gt;
&gt;
&gt;
&gt; ec := EdgeConnectivity(G);
&gt; T :=  EdgeSeparator(G);
&gt; ec;
2
&gt; T;
[ {1, 2}, {1, 3} ]
&gt;
&gt; H := G;
&gt; M := [ { Index(e[1]), Index(e[2]) }
&gt; where e := SetToSequence(EndVertices(e)) : e in T ];
&gt; RemoveEdges(~H, M);
&gt; IsConnected(H);
false
&gt; for k in [0..ec] do
&gt;     IsKEdgeConnected(G, k);
&gt; end for;
true
true
true
&gt; for k in [ec+1..Order(G)-1] do
&gt;     IsKEdgeConnected(G, k);
&gt; end for;
false
</PRE>
<HR>
<PRE></PRE> <A  HREF = "text1796.htm">[Next]</A><A  HREF = "text1794.htm">[Prev]</A> <A  HREF = "text1796.htm">[Right]</A> <A  HREF = "text1794.htm">[Left]</A> <A  HREF = "text1782.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<br><small>Version: V2.22 of <I>
Thu Jun  9 16:37:49 EST 2016
</I></small>
</body></html>