<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <link rel='stylesheet' href='help.css' type='text/css'>
  <TITLE>Operations on Weight  Multisets</TITLE>
</head>
<body BGCOLOR="#FFFFFF">

 <A  HREF = "text1197.htm">[Next]</A><A  HREF = "text1195.htm">[Prev]</A> <A  HREF = "text1197.htm">[Right]</A> <A  HREF = "text1195.htm">[Left]</A> <A  HREF = "text1192.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<PRE></PRE><H3><A NAME = "13321">Operations on Weight  Multisets</A></H3>




<H5>Subsections</H5>
<UL>
<LI> <A  HREF = "text1196.htm#13322">Basic Operations</A>
<LI> <A  HREF = "text1196.htm#13343">Conversion Functions</A>
<LI> <A  HREF = "text1196.htm#13347">Calculating with Representations</A>
</UL>
<H4><A NAME = "13322">Basic Operations</A></H4>

<P>
<P>
<P>
<P>
In this section, basic access and arithmetic operations for weight multisets
are described.
Addition generally corresponds to direct sum of representations.
The other arithmetic operations do not necessarily correspond to meaningful
operations on the corresponding representation.


<H5><A NAME = "13323">RootDatum(D) : LieRepDec -&gt; RootDtm</A></H5>
<BLOCKQUOTE>
The Root datum over which the weight multiset D is defined.
</BLOCKQUOTE>
<H5><A NAME = "13324">Weights(D) : LieRepDec -&gt; SeqEnum, SeqEnum</A></H5>
<H5>WeightsAndMultiplicities(D) : LieRepDec -&gt; SeqEnum, SeqEnum</H5>
<BLOCKQUOTE>
The sequences of weights and multiplicities in the weight multiset D.
</BLOCKQUOTE>
<H5><A NAME = "13325">Multiset(D) : LieRepDec -&gt; SetMulti</A></H5>
<BLOCKQUOTE>
The weights and multiplicities of the weight multiset D as a normal
multiset consisting of vectors.
</BLOCKQUOTE>
<H5><A NAME = "13326">Multiplicity(D, v) : LieRepDec, ModTupRngElt -&gt; RngIntElt</A></H5>
<H5>Multiplicity(D, v) : LieRepDec, SeqEnum -&gt; RngIntElt</H5>
<BLOCKQUOTE>
The multiplicity of the weight v in the weight multiset D.
</BLOCKQUOTE>
<H5><A NAME = "13327">D eq E : LieRepDec, LieRepDec -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if, and only if, the weight multisets D and E are 
identical, i.e. they are defined over identical root data, with equal
weights and multiplicities. 
</BLOCKQUOTE>
<H5><A NAME = "13328">D + E : LieRepDec, LieRepDec -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
The sum (union) of weight multisets D and E, i.e. this corresponds to the direct 
sum of the two decomposition multisets.
The underlying root data must be the same.
<P>
Add V<sub>v</sub> to D. The length of v must be equal to dim(R<sub>D</sub>).
</BLOCKQUOTE>
<H5><A NAME = "13329">D +:= E : LieRepDec, LieRepDec -&gt;</A></H5>
<BLOCKQUOTE>
Add the weight multiset E to D. R<sub>D</sub> must be equal to R<sub>E</sub>.
</BLOCKQUOTE>
<H5><A NAME = "13330">AddRepresentation(~D, E, c) : LieRepDec, LieRepDec, RngIntElt -&gt;</A></H5>
<H5>AddRepresentation(~D, E) : LieRepDec, LieRepDec -&gt;</H5>
<BLOCKQUOTE>
Add c times the weight multiset E to D. The integer c may
be omitted, in which case it is assumed to be equal to 1. 
The root data of D and E must be identical.
</BLOCKQUOTE>
<H5><A NAME = "13331">D + v : LieRepDec, ModTupRngElt -&gt; BoolElt</A></H5>
<H5>D + v : LieRepDec, SeqEnum -&gt; BoolElt</H5>
<BLOCKQUOTE>
Add the weight v to the multiset D.
The weight v must be a sequence of length d or an element of Z<sup>d</sup>,
where d is the dimension of the root datum R.
</BLOCKQUOTE>
<H5><A NAME = "13332">AddRepresentation(~D, v, c) : LieRepDec, ModTupRngElt, RngIntElt -&gt;</A></H5>
<H5>AddRepresentation(~D, v, c) : LieRepDec, SeqEnum, RngIntElt -&gt;</H5>
<H5>AddRepresentation(~D, v) : LieRepDec, ModTupRngElt -&gt;</H5>
<H5>AddRepresentation(~D, v) : LieRepDec, SeqEnum -&gt;</H5>
<BLOCKQUOTE>
Add c times the weight v to the multiset D.
The integer c may be omitted, in which case it is
assumed to be equal to 1. 
The length of v must be equal to the dimension of the root datum of D.
</BLOCKQUOTE>
<H5><A NAME = "13333">D +:= v : LieRepDec, ModTupRngElt -&gt;</A></H5>
<H5>D +:= v : LieRepDec, SeqEnum -&gt;</H5>
<BLOCKQUOTE>
Add the weight v to the multiset D.
The length of v must be equal to 
the dimension of the root datum of D.
</BLOCKQUOTE>
<H5><A NAME = "13334">D * c : LieRepDec, RngIntElt -&gt; LieRepDec</A></H5>
<BLOCKQUOTE>
The multiset whose weights are equal to those of D, and whose
multiplicities are c times the multiplicities of D. 
</BLOCKQUOTE>
<H5><A NAME = "13335">D / c : LieRepDec, RngIntElt -&gt; LieRepDec</A></H5>
<BLOCKQUOTE>
The multiset whose weights are equal to those of D, and whose
multiplicities are the multiplicities of D divided by c. 
An error is flagged if any of the multiplicities of D is not divisible by
c. 
</BLOCKQUOTE>
<H5><A NAME = "13336">D *:= c : LieRepDec, RngIntElt -&gt;</A></H5>
<BLOCKQUOTE>
Multiply all multiplicities of the weight multiset D by c.
</BLOCKQUOTE>
<H5><A NAME = "13337">D /:= c : LieRepDec, RngIntElt -&gt;</A></H5>
<BLOCKQUOTE>
Divide all multiplicities of the weight multiset D by c. 
An error is flagged if a
multiplicity of D is not divisible by c.
</BLOCKQUOTE>
<H5><A NAME = "13338">D * E : LieRepDec, LieRepDec -&gt; LieRepDec</A></H5>
<H5>ProductRepresentation(D, E) : LieRepDec, LieRepDec -&gt; LieRepDec</H5>
<BLOCKQUOTE>
The product of the two weight multisets D and E, viewed as polynomials as
in the LiE package <A  HREF = "text1191.htm#bib_leeuwen-cohen-lisser">[vLCL92]</A>.
The root datum of
the resulting decomposition is the direct sum of the root data of D and E. 
Note that this is does not correspond to the direct sum or tensor product of
representations.
</BLOCKQUOTE>
<H5><A NAME = "13339">ProductRepresentation(D, E, R) : LieRepDec, LieRepDec, RootDtm -&gt; LieRepDec</A></H5>
<BLOCKQUOTE>
The product of the two weight multisets D and E, viewed as polynomials as
in the LiE package <A  HREF = "text1191.htm#bib_leeuwen-cohen-lisser">[vLCL92]</A>.
The product is interpreted as a weight multiset over the root datum R.
An error is flagged if the dimension of R is not the sum of the dimensions of
the root data of D and E.
</BLOCKQUOTE>
<H5><A NAME = "13340">SubWeights(D, Q, S) : LieRepDec, SeqEnum, RootDtm -&gt; LieRepDec</A></H5>
<BLOCKQUOTE>
Let k be the length of the sequence Q. The resulting decomposition E has
Root datum S, and to each highest weight of D corresponds a highest weight
w' of E, with w'<sub>i</sub> = w<sub>Q[i]</sub>, where i = 1, ..., k. The
multiplicities of E are equal to the multiplicities of D, but one should
note that E might in fact have fewer unique highest weights than D,
especially if k &lt; dim(R<sub>D</sub>). 
The dimension of the root datum S must be equal to k.
</BLOCKQUOTE>
<H5><A NAME = "13341">PermuteWeights(D, pi, S) : LieRepDec, GrpPermElt, RootDtm -&gt; LieRepDec</A></H5>
<BLOCKQUOTE>
Permute the components  of the weights in the multiset D by the permutation
&pi; and interpret the result as a weight multiset over the root datum S.
If the underlying root datum of D has dimension d, then S must also have
dimension d and &pi; must be an element of Sym(d).
</BLOCKQUOTE>
<HR>
<H3><A NAME = "13342">Example <TT>LieReps_DecompArithmetic (H110E6)</TT></A></H3>
Arithmetic with decompositions:
<P>
<P>
<PRE>
&gt; R := RootDatum("A2" : Isogeny := "SC");
&gt; D := LieRepresentationDecomposition(R, [[2,3],[4,3]], [1,3]);
&gt; D:Maximal;
Highest weight decomposition of representation of:
     R: Simply connected root datum of dimension 2 of type A2
     Dimension of weight space:2
     Weights:
          [
               (2 3),
               (4 3)
          ]
     Multiplicities:
          [ 1, 3 ]
&gt; E := D + [5,2];
&gt; E:Maximal;
Highest weight decomposition of representation of:
     R: Simply connected root datum of dimension 2 of type A2
     Dimension of weight space:2
     Weights:
          [
               (2 3),
               (4 3),
               (5 2)
          ]
     Multiplicities:
          [ 1, 3, 1 ]
&gt; PermuteWeights(E, Sym(2)!(1,2), R):Maximal;
Highest weight decomposition of representation of:
     R: Simply connected root datum of dimension 2 of type A2
     Dimension of weight space:2
     Weights:
          [
               (3 2),
               (3 4),
               (2 5)
          ]
     Multiplicities:
          [ 1, 3, 1 ]
&gt; S := RootDatum("A1" : Isogeny := "SC");
&gt; SubWeights(E, [2], S):Maximal;
Highest weight decomposition of representation of:
     S: Simply connected root datum of dimension 1 of type A1
     Dimension of weight space:1
     Weights:
          [
               (3),
               (2)
          ]
     Multiplicities:
          [ 4, 1 ]
</PRE>
<HR>
<H4><A NAME = "13343">Conversion Functions</A></H4>

<P>
<P>
<P>
<P>
Functions for converting between different kinds of weight multiset
(decomposition, character, and dominant character multisets).
Note that it is the users responsibility to keep track of what kind of multiset
they are using.
If a function that expects one kind of set receives another, the output is
likely to be meaningless.


<H5><A NAME = "13344">VirtualDecomposition(C) : LieRepDec -&gt; LieRepDec</A></H5>
<H5>VirtualDecomposition(R, v) : RootDtm, Any -&gt; LieRepDec</H5>
<BLOCKQUOTE>
The virtual decomposition multiset of the virtual module with dominant
character multiset C. The second version is provided for convenience, and equivalent to
<TT>VirtualDecomposition(LieRepresentationDecomposition(R,v))</TT>. 
</BLOCKQUOTE>
<H5><A NAME = "13345">DecomposeCharacter(C) : LieRepDec -&gt; LieRepDec</A></H5>
<BLOCKQUOTE>
The decomposition multiset of the module with dominant character multiset C. 
An error is flagged if D is virtual, i.e. if dominant weights occur with
negative multiplicities. 
</BLOCKQUOTE>
<H5><A NAME = "13346">DominantCharacter(D) : LieRepDec -&gt; LieRepDec</A></H5>
<BLOCKQUOTE>
Returns the dominant character multiset with decomposition D.  
</BLOCKQUOTE>
<H4><A NAME = "13347">Calculating with Representations</A></H4>

<P>
<P>
<P>
<P>
As described earlier, many operations on representations carry over naturally to
operations on their decompositions. This section describes the various functions
for this purpose that were ported from LiE.
<P>
Note that many functions in this sections have two variants: one that takes
decompositions as an argument and one that takes a root datum and a highest
weight.


<H5><A NAME = "13348">RepresentationDimension(D) : LieRepDec -&gt; RngIntElt</A></H5>
<BLOCKQUOTE>
The dimension of the module with decomposition polynomial D. 
The algorithm used is described in <A  HREF = "text1191.htm#bib_leeuwen-cohen-lisser">[vLCL92]</A>.
</BLOCKQUOTE>
<H5><A NAME = "13349"></A><A NAME = "RepresentationDimensionRv">RepresentationDimension</A>(R, v) : RootDtm, SeqEnum -&gt; RngIntElt</H5>
<H5>RepresentationDimension(R, v) : RootDtm, ModTupRngElt -&gt; RngIntElt</H5>
<BLOCKQUOTE>
The dimension of the module with highest weight v over the root datum R.
The algorithm used is described in <A  HREF = "text1191.htm#bib_leeuwen-cohen-lisser">[vLCL92]</A>.
</BLOCKQUOTE>
<H5><A NAME = "13350">CasimirValue(R, w) : RootDtm, ModTupRngElt -&gt; FldRatElt</A></H5>
<H5>CasimirValue(R, w) : RootDtm, SeqEnum[RngIntElt] -&gt; FldRatElt</H5>
<BLOCKQUOTE>
The value of the quadratic Casimir on representation with highest weight w, 
normalised to take the value 2 on the
highest weight of the adjoint representation.
This function is due to Dr. Bruce Westbury, University of Warwick.
</BLOCKQUOTE>
<H5><A NAME = "13351">QuantumDimension(R, w) : RootDtm, ModTupRngElt -&gt; SetMulti</A></H5>
<H5>QuantumDimension(R, w) : RootDtm, SeqEnum[RngIntElt] -&gt; SetMulti</H5>
<BLOCKQUOTE>
Two Multisets of positive integers, Num and Den, which should be read as follows. Take the product of the integers in Num and divide
by the product of the integers in Den to get the ordinary dimension. 
Replacing each integer by the quantum integer will give
the quantum dimension.
This function is due to Dr. Bruce Westbury, University of Warwick.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "13352">Example <TT>LieReps_QuantumDimension (H110E7)</TT></A></H3>
Dimensions:
<P>
<P>
<PRE>
&gt; R := RootDatum("D4" : Isogeny := "SC");
&gt; D := AdjointRepresentationDecomposition(R);
&gt; RepresentationDimension(D);
28
&gt; wts, mps := WeightsAndMultiplicities(D); wts,mps;
[
    (0 1 0 0)
]
[ 1 ]
&gt; num,den := QuantumDimension(R, wts[1]); num,den;
{* 4^^2, 7 *}
{* 1, 2^^2 *}
&gt; &amp;*num/&amp;*den;
28
</PRE>
<HR>
<H5><A NAME = "13353"></A><A NAME = "BranchFrTovM">Branch</A>(FromGrp, ToGrp, v, M) : RootDtm, RootDtm, ModTupRngElt, AlgMatElt -&gt; LieRepDec</H5>
<H5>Branch(FromGrp, ToGrp, v, M) : RootDtm, RootDtm, SeqEnum, AlgMatElt -&gt; LieRepDec</H5>

<PRE>    Virtual: BoolElt                    Default: <TT>false</TT></PRE>
<BLOCKQUOTE>
The decomposition polynomial of the restriction to ToGrp of the irreducible
module V<sub>v</sub> with respect to the restriction matrix M.
The matrix M must have dim(FromGrp) rows and Dim(ToGrp) columns.
<P>
The matrix M is used in such a way that any weight v' (expressed on the basis of
fundamental weights for g), when restricted to a torus of ToGrp, 
becomes the weight v'M (expressed on the basis of fundamental weights for ToGrp).
A suitable restriction matrix can often be obtained by use of <A  HREF = "text1198.htm#LieRepDecRestrictionMatrix">RestrictionMatrix</A>.
The algorithm used is described in <A  HREF = "text1191.htm#bib_leeuwen-cohen-lisser">[vLCL92]</A>.
<P>
The optional argument <TT>Virtual</TT> may be set to <TT>true</TT> to allow occurrence of 
virtual weights.
</BLOCKQUOTE>
<H5><A NAME = "13354"></A><A NAME = "BranchToDM">Branch</A>(ToGrp, D, M) : RootDtm, LieRepDec, AlgMatElt -&gt; LieRepDec</H5>

<PRE>    Virtual: BoolElt                    Default: <TT>false</TT></PRE>
<BLOCKQUOTE>
As <A  HREF = "text1196.htm#BranchFrTovM">Branch</A><TT>(FromGrp, ToGrp, v, M)</TT> but with the irreducible
module v replaced by the module with decomposition D.
</BLOCKQUOTE>
<H5><A NAME = "13355"></A><A NAME = "Collect">Collect</A>(R, D, M) : RootDtm, LieRepDec, AlgMatElt -&gt; LieRepDec</H5>
<BLOCKQUOTE>
This function attempts to perform the inverse operation of <A  HREF = "text1196.htm#BranchToDM">Branch</A>,
namely to reconstruct
an R-module from its restriction to R<sub>D</sub>.
<P>
Please note that in LiE one must supply the inverse of the matrix used in
Branch. 
Magma, however, is able to compute inverses itself, so one needs to provide the
matrix 
used in Branch, and not its inverse.
<P>
M must be a square matrix whose dimension is equal to the dimension of R<sub>D</sub>.
The dimension of R must be equal to the dimension of R<sub>D</sub> as well.
The algorithm used is described in <A  HREF = "text1191.htm#bib_leeuwen-cohen-lisser">[vLCL92]</A>.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "13356">Example <TT>LieReps_BranchCollect (H110E8)</TT></A></H3>
Branch and Collect: 
<P>
<P>
<PRE>
&gt; R := RootDatum("D4" : Isogeny := "SC");
&gt; S := RootDatum("A3T1" : Isogeny := "SC");
&gt; M := RestrictionMatrix(R, S);
&gt; br := Branch(R, S, [1,0,0,0], M);
&gt; br;
Highest weight decomposition of representation of:
     S: Simply connected root datum of dimension 4 of type A3
     Number of terms: 2
&gt; cl := Collect(R, br, M);
&gt; cl:Maximal;
Highest weight decomposition of representation of:
     R: Simply connected root datum of dimension 4 of type D4
     Dimension of weight space:4
     Weights:
          [
               (1 0 0 0)
          ]
     Multiplicities:
          [ 1 ]
</PRE>
<HR>
<H5><A NAME = "13357"></A><A NAME = "tensorRvw">TensorProduct</A>(R, v, w) : RootDtm, ModTupRngElt, ModTupRngElt -&gt; .</H5>
<H5>TensorProduct(R, v, w) : RootDtm, SeqEnum, SeqEnum -&gt; .</H5>

<PRE>    Goal: Any                           Default: </PRE>
<BLOCKQUOTE>
The decomposition multiset of the tensor product of the representations with
highest weights v and w over the root datum R.
<P>
If the optional parameter <TT>Goal</TT> is set, only
the multiplicity of the irreducible module with highest weight <TT>Goal</TT> is
returned.
This does not greatly speed up the process, as the same computational steps need
to be made, but it will significantly reduce memory consumption.
The algorithm used is described in <A  HREF = "text1191.htm#bib_leeuwen-cohen-lisser">[vLCL92]</A>.
</BLOCKQUOTE>
<H5><A NAME = "13358"></A><A NAME = "tensorDE">TensorProduct</A>(D, E) : LieRepDec, LieRepDec -&gt; .</H5>

<PRE>    Goal: Any                           Default: </PRE>
<BLOCKQUOTE>
The decomposition multiset of the tensor product of the representations with
decomposition multisets D and E.
<P>
If the optional parameter <TT>Goal</TT> is set, only
the multiplicity of the irreducible module with highest weight <TT>Goal</TT> is
returned.
This does not greatly speed up the process, as the same computational steps need
to be made, but it will significantly reduce memory consumption.
The algorithm used is described in <A  HREF = "text1191.htm#bib_leeuwen-cohen-lisser">[vLCL92]</A>.
</BLOCKQUOTE>
<H5><A NAME = "13359"></A><A NAME = "tensorDE">TensorProduct</A>(Q) : [LieRepDec] -&gt; LieRepDec</H5>

<PRE>    Goal: Any                           Default: </PRE>
<BLOCKQUOTE>
The decomposition multiset of the tensor product of the representations with
decomposition multisets in the sequence Q.
<P>
If the optional parameter <TT>Goal</TT> is set, only
the multiplicity of the irreducible module with highest weight <TT>Goal</TT> is
returned.
This does not greatly speed up the process, as the same computational steps need
to be made, but it will significantly reduce memory consumption.
The algorithm used is described in <A  HREF = "text1191.htm#bib_leeuwen-cohen-lisser">[vLCL92]</A>.
</BLOCKQUOTE>
<H5><A NAME = "13360">TensorPower(R, n, v) : RootDtm, RngIntElt, ModTupRngElt -&gt; LieRepDec</A></H5>
<H5>TensorPower(R, n, v) : RootDtm, RngIntElt, SeqEnum -&gt; LieRepDec</H5>
<H5>TensorPower(D, n) : LieRepDec, RngIntElt -&gt; LieRepDec</H5>
<BLOCKQUOTE>
The decomposition of the n-th tensor power of V<sup>R</sup><sub>v</sub> or D.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "13361">Example <TT>LieReps_TensorPower (H110E9)</TT></A></H3>
Taking tensor powers nicely shows how rapidly the complexity of 
representations increases, especially if we have a reasonably high 
weight as highest weight:
<P>
<P>
<PRE>
&gt; R := RootDatum("D4" : Isogeny := "SC");
&gt; DAd := AdjointRepresentationDecomposition(R);
&gt; pwrs := function(D, n)
&gt;   Q := [D];
&gt;   for i in [2..n] do
&gt;     Q[i] := Tensor(Q[1], Q[i-1]);
&gt;   end for;
&gt;   return Q;
&gt; end function;
&gt; time Q := pwrs(DAd, 7);
Time: 4.900
&gt; [ #q : q in Q ];
[ 1, 7, 15, 30, 54, 91, 143 ]
&gt; DH := LieRepresentationDecomposition(R, [2,2,0,0]);
&gt; time Q := pwrs(DH, 4); [ #q : q in Q ];
Time: 99.070
[ 1, 105, 390, 1017 ]
</PRE>
<HR>
<H5><A NAME = "13362">AdamsOperator(R, n, v) : RootDtm, RngIntElt, ModTupRngElt -&gt; LieRepDec</A></H5>
<H5>AdamsOperator(R, n, v) : RootDtm, RngIntElt, SeqEnum -&gt; LieRepDec</H5>
<H5>AdamsOperator(D, n) : LieRepDec, RngIntElt -&gt; LieRepDec</H5>
<BLOCKQUOTE>
The decomposition polynomial of the virtual module obtained by applying
the n-th Adams operator to V<sup>R</sup><sub>v</sub> or D. 
The algorithm used is described in <A  HREF = "text1191.htm#bib_leeuwen-cohen-lisser">[vLCL92]</A>.
</BLOCKQUOTE>
<H5><A NAME = "13363">SymmetricPower(R, n, v) : RootDtm, RngIntElt, ModTupRngElt -&gt; LieRepDec</A></H5>
<H5>SymmetricPower(R, n, v) : RootDtm, RngIntElt, SeqEnum -&gt; LieRepDec</H5>
<H5>SymmetricPower(D, n) : LieRepDec, RngIntElt -&gt; LieRepDec</H5>
<BLOCKQUOTE>
The decomposition polynomial of S<sup>n</sup>(V<sup>R</sup><sub>v</sub>), the n-th symmetric tensor
power of V<sup>R</sup><sub>v</sub>.
<P>
In the second form the irreducible module V<sup>R</sup><sub>v</sub> is replaced by the 
module with decomposition D.
The algorithm used is described in <A  HREF = "text1191.htm#bib_leeuwen-cohen-lisser">[vLCL92]</A>.
</BLOCKQUOTE>
<H5><A NAME = "13364">AlternatingPower(R, n, v) : RootDtm, RngIntElt, ModTupRngElt -&gt; LieRepDec</A></H5>
<H5>AlternatingPower(R, n, v) : RootDtm, RngIntElt, SeqEnum -&gt; LieRepDec</H5>
<H5>AlternatingPower(D, n) : LieRepDec, RngIntElt -&gt; LieRepDec</H5>
<BLOCKQUOTE>
The decomposition polynomial of (Alt)<sup>n</sup>(V<sup>R</sup><sub>v</sub>), the n-th 
alternating tensor power of V<sup>R</sup><sub>v</sub>.
<P>
In the second form the irreducible module V<sup>R</sup><sub>v</sub> is replaced by the 
module with decomposition D.
The algorithm used is described in <A  HREF = "text1191.htm#bib_leeuwen-cohen-lisser">[vLCL92]</A>.
</BLOCKQUOTE>
<H5><A NAME = "13365">Plethysm(R, lambda, v) : RootDtm, SeqEnum, ModTupRngElt -&gt; LieRepDec</A></H5>
<H5>Plethysm(R, lambda, v) : RootDtm, SeqEnum, SeqEnum -&gt; LieRepDec</H5>
<H5>Plethysm(D, lambda) : LieRepDec, SeqEnum -&gt; LieRepDec</H5>
<BLOCKQUOTE>
The decomposition multiset of the R<sub>D</sub>-module of the plethysm of V<sup>R</sup><sub>v</sub> 
corresponding to the partition &lambda;. Here &lambda; should be a partition
of d= dim V<sup>R</sup><sub>v</sub>, i.e., a non-increasing sequence consisting of positive
integers
with sum d. 
The value returned is the decomposition multiset 
of the representation of R<sub>D</sub> that
is obtained by composing the representation of R<sub>D</sub> afforded by V<sup>R</sup><sub>v</sub>, with
the representation of (GL)(V<sup>R</sup><sub>v</sub>) corresponding to the partition
&lambda;.
The classical Frobenius formula is used (see <A  HREF = "text1191.htm#bib_andersen">[And77]</A> and
<A  HREF = "text1191.htm#bib_james-kerber">[JK81]</A>).
<P>
In the second form the irreducible module V<sup>R</sup><sub>v</sub> is replaced by the module with
decomposition D.
</BLOCKQUOTE>
<H5><A NAME = "13366"></A><A NAME = "spectrumRvt">Spectrum</A>(R, v, t) : RootDtm, ModTupRngElt, SeqEnum -&gt; SeqEnum</H5>
<H5>Spectrum(R, v, t) : RootDtm, SeqEnum, SeqEnum -&gt; SeqEnum</H5>
<H5><A NAME = "spectrumDT">Spectrum</A>(D, t) : LieRepDec, SeqEnum -&gt; SeqEnum</H5>
<BLOCKQUOTE>
Let n be the last entry of the sequence t; 
the toral element t &isin;T will act in any representation of R as a
diagonalisable transformation, all of whose eigenvalues are n-th roots of
unity. 
This function returns a sequence in which the i-th entry is the multiplicity
of the eigenvalue &zeta;<sup>i</sup> in the action of the toral element t on the
irreducible module V<sup>R</sup><sub>v</sub> (or the module with decomposition D, in the second
case). 
Here &zeta; is the complex number e<sup>2 &pi; i /n</sup>.
<P>
See Section <A  HREF = "text1193.htm#13293">Toral Elements</A> for a description of the format of
t.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "13367">Example <TT>LieReps_Spectrum (H110E10)</TT></A></H3>
<P>
Spectrum provides a means to recognise toral elements in a more natural form.
<A  HREF = "text1191.htm#bib_leeuwen-cohen-lisser">[vLCL92, Section 5.7.3]</A>.
<P>
<P>
<PRE>
&gt; R := RootDatum("A4" : Isogeny := "SC");
&gt; stdrep := [1,0,0,0];
&gt; t := [1,0,0,0,2];
&gt; stdrep := [1,0,0,0];
&gt; Spectrum(R, stdrep, t);
[ 3, 2 ]
/* Showing that t has 3 eigenvalues 1 (1st root of unity), 
   and 2 eigenvalues -1 (2nd root of unity) */
/* We may use the following function for constructing 
   toral elements of A_n in the LiE format: */
&gt; mktoral := function(b, d)
&gt;     r := [ (i eq 1)
&gt;               select b[i]
&gt;               else b[i-1]+b[i] mod d
&gt; : i in [1..(#b-1)]
&gt;          ];
&gt;     r[#b] := d;
&gt;     return r;
&gt; end function;
&gt; t2 := mktoral([0,0,0,1,1], 2); t2;
[ 0, 0, 0, 1, 2 ]
/* We restrict to a one parameter subgroup */
&gt; RM := Transpose(Matrix([[0,0,0,1]]));
&gt; T1 := RootDatum("T1" : Isogeny := "SC");
&gt; Branch(R, T1, stdrep, RM):Maximal;
Highest weight decomposition of representation of:
     T1: Toral root datum of dimension 1
     Dimension of weight space:1
     Weights:
          [
               (1),
               (0),
               (-1)
          ]
     Multiplicities:
          [ 1, 3, 1 ]
/* Indicating that the element of that one parameter
   subgroup parametrised by some complex number z has
   one eigenvalue z^-1, three eigenvalues 1, and one
   eigenvalue z in the standard representation. */
</PRE>
<HR>
<H5><A NAME = "13368"></A><A NAME = "DemazureRvw">Demazure</A>(R, v, w) : RootDtm, ModTupRngElt, GrpPermElt -&gt; LieRepDec</H5>
<H5>Demazure(R, v, w) : RootDtm, SeqEnum, GrpPermElt -&gt; LieRepDec</H5>
<H5><A NAME = "DemazureD">Demazure</A>(D, w) : LieRepDec, GrpPermElt -&gt; LieRepDec</H5>
<BLOCKQUOTE>
Starting with the highest weight v of R, or the decomposition D,
repeatedly apply the
Demazure operator M<sub>&alpha;<sub>i</sub></sub>, taking for i the successive entries of the
Weyl word w 
(viewed as product of simple reflections).
</BLOCKQUOTE>
<H5><A NAME = "13369">Demazure(R, v) : RootDtm, ModTupRngElt -&gt; LieRepDec</A></H5>
<H5>Demazure(R, v) : RootDtm, SeqEnum -&gt; LieRepDec</H5>
<H5>Demazure(D) : LieRepDec -&gt; LieRepDec</H5>
<BLOCKQUOTE>
Equivalent to <A  HREF = "text1196.htm#DemazureRvw">Demazure</A><TT>(R, v, w)</TT> or <A  HREF = "text1196.htm#DemazureD">Demazure</A><TT>(D,
w)</TT> where w
is the longest word of the Coxeter group of R or R<sub>D</sub>.
<P>
If D is a decomposition polynomial, then the result E is the character
polynomial of
this decomposition. This is not the most efficient way to compute characters,
but it can be
very useful in checking other algorithms, since only the most elementary
manipulations 
are involved.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "13370">Example <TT>LieReps_BranchCollect (H110E11)</TT></A></H3>
The Demazure operator:
<P>
<P>
<PRE>
&gt; R := RootDatum("D4" : Isogeny := "SC");
&gt; DAd := AdjointRepresentationDecomposition(R);
&gt; DAdCp := Demazure(DAd); DAdCp;
Highest weight decomposition of representation of:
     R: Simply connected root datum of dimension 4 of type D4
     Number of terms: 25
&gt; DAd2 := AlternatingDominant(DAdCp); DAd2;
Highest weight decomposition of representation of:
     R: Simply connected root datum of dimension 4 of type D4
     Number of terms: 1
&gt; DAd2 eq DAd;
true
</PRE>
<HR>
<H5><A NAME = "13371"></A><A NAME = "LittlewoodRichardsonTensor_pq">LittlewoodRichardsonTensor</A>(p, q) : ModTupRngElt, ModTupRngElt -&gt; SeqEnum, SeqEnum[RngIntElt]</H5>
<H5>LittlewoodRichardsonTensor(p, q) : SeqEnum, SeqEnum -&gt; SeqEnum, SeqEnum[RngIntElt]</H5>
<H5>LittlewoodRichardsonTensor(P, M, Q, N) : SeqEnum, SeqEnum[RngIntElt], SeqEnum, SeqEnum[RngIntElt] -&gt; SeqEnum, SeqEnum[RngIntElt]</H5>
<H5>LittlewoodRichardsonTensor(R, v, w) : RootDtm, ModTupRngElt, ModTupRngElt -&gt; LieRepDec</H5>
<H5>LittlewoodRichardsonTensor(R, v, w) : RootDtm, SeqEnum, SeqEnum -&gt; LieRepDec</H5>
<H5>LittlewoodRichardsonTensor(D, E) : LieRepDec, LieRepDec -&gt; LieRepDec</H5>
<BLOCKQUOTE>
In the first form, compute the tensor product of the irreducible A<sub>n</sub> representations
with highest weights v and w using the Littlewood-Richardson rule. In the second
form, compute the tensor product of the representations with decompositions D and E.
<P>
This procedure converts the weights to partitions, computes the tensor product using
the Littlewood-Richardson rule (as described above, see <A  HREF = "text1196.htm#LittlewoodRichardsonTensor_pq">LittlewoodRichardsonTensor</A>), 
and converts the result back to a weight multiset.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "13372">Example <TT>LieReps_LRTensor (H110E12)</TT></A></H3>
We compare the Littlewood-Richardson tensor and the normal tensor:
<P>
<P>
<PRE>
&gt; R := RootDatum("A2" : Isogeny := "SC");
&gt; v := [1,2];
&gt; w := [1,1];
&gt; D1 := Tensor(R, v, w); 
&gt; D1;
Highest weight decomposition of representation of:
    R: Simply connected root datum of dimension 2 of type A2
    Weights:
        [
            (0 1),
            (2 0),
            (0 4),
            (3 1),
            (2 3),
            (1 2)
        ]
    Multiplicities:
        [ 1, 1, 1, 1, 1, 2 ]
&gt; D2 := LittlewoodRichardsonTensor(R, v, w);
&gt; D2;
Highest weight decomposition of representation of:
    R: Simply connected root datum of dimension 2 of type A2
    Weights:
        [
            (1 2),
            (2 3),
            (2 0),
            (0 4),
            (0 1),
            (3 1)
        ]
    Multiplicities:
        [ 2, 1, 1, 1, 1, 1 ]
&gt; D1 eq D2;
true
</PRE>
So the results are identical, as they should be. We could also convert
the weights to partitions by hand, directly compute the Littlewood-
Richardson tensor, and compare that to the previous result:
<P>
<P>
<PRE>
&gt; vp := WeightToPartition(v); wp := WeightToPartition(w); 
&gt; vp, wp;
[ 3, 2, 0 ]
[ 2, 1, 0 ]
&gt; parts, mps := LittlewoodRichardsonTensor(vp, wp); 
&gt; parts, mps;
[
    (4 4 0),
    (4 3 1),
    (3 3 2),
    (5 3 0),
    (5 2 1),
    (4 2 2)
]
[ 1, 2, 1, 1, 1, 1 ]
&gt; [ PartitionToWeight(p) : p in parts ];
[
    (0 4),
    (1 2),
    (0 1),
    (2 3),
    (3 1),
    (2 0)
]
</PRE>
So that again gives the same representation.
Finally, note that in some cases computing tensor products using the 
Littlewood-Richardson rule may be faster than computing them in the 
normal way:
<P>
<P>
<PRE>
&gt; R := RootDatum("A8" : Isogeny := "SC");
&gt; v := [0,0,2,0,1,0,1,2];
&gt; w := [0,2,1,2,0,0,1,0];
&gt; time _ := Tensor(R, v, w);
Time: 2.630
&gt; time _ := LittlewoodRichardsonTensor(R, v, w);
Time: 0.210
</PRE>
<HR>
<H5><A NAME = "13373"></A><A NAME = "altdomDw">AlternatingDominant</A>(D, w) : LieRepDec, GrpPermElt -&gt; LieRepDec</H5>
<H5><A NAME = "altdomRwtw">AlternatingDominant</A>(R, wt, w) : RootDtm, ModTupRngElt, GrpPermElt -&gt; LieRepDec</H5>
<H5>AlternatingDominant(R, wt, w) : RootDtm, SeqEnum, GrpPermElt -&gt; LieRepDec</H5>
<BLOCKQUOTE>
Alternating Dominant of the representation with decomposition D or the
irreducible representation V<sub>wt</sub>, with respect to Weyl group element w.
Starting with D, the following operation is repeatedly applied, taking for i
the successive entries of w (viewed as reflection). For any (weight,
multiplicity) pair (v, c) of D let v<sub>i</sub> = &lt; v, &alpha;<sub>i</sub> &gt; be
its coefficient of w<sub>i</sub>; the term is 
<DL COMPACT class='compact'>
<DT>-- </DT><DD>unaltered if v<sub>i</sub> &ge;0,
<DT>-- </DT><DD>removed if v<sub>i</sub> = - 1, and
<DT>-- </DT><DD>replaced by ((v + w<sub>i</sub>)r<sub>i</sub> - w<sub>i</sub>, - c) if v<sub>i</sub> = - 2.
As a result of the operation for i, the coefficient v<sub>i</sub> is made non-negative
without affecting the image M<sub>&alpha;<sub>i</sub></sub>(D) under the Demazure operator, and
hence also without changing the value of its alternating Weyl sum
<A  HREF = "text1196.htm#alternatingweylsumRv">AlternatingWeylSum</A>.</DL>
</BLOCKQUOTE>
<H5><A NAME = "13374">AlternatingDominant(D) : LieRepDec -&gt; LieRepDec</A></H5>
<H5>AlternatingDominant(R, wt) : RootDtm, ModTupRngElt -&gt; LieRepDec</H5>
<H5>AlternatingDominant(R, wt) : RootDtm, SeqEnum -&gt; LieRepDec</H5>
<BLOCKQUOTE>
Equivalent to (but somewhat faster than) the previous <A  HREF = "text1196.htm#altdomDw">AlternatingDominant</A>(D, w)
and <A  HREF = "text1196.htm#altdomRwtw">AlternatingDominant</A>(R, wt, w), with w the longest element of the
corresponding Weyl group. 
If D is interpreted as dominant weights with multiplicities, then the result
E contains highest weights and multiplicities.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "13375">Example <TT>LieReps_AlternatingDominant (H110E13)</TT></A></H3>
Example of the alternating dominant:
<P>
<P>
<PRE>
&gt; R := RootDatum("D4" : Isogeny := "SC");
&gt; v := [1,5,2,1];
&gt; Dec1 := LieRepresentationDecomposition(R, v);
&gt; // First, we construct the character polynomial for the
&gt; // module with highest weight lambda
&gt; Dom := DominantCharacter(Dec1 : InBasis := "Weight"); Dom;
Highest weight decomposition of representation of:
     R: Simply connected root datum of dimension 4 of type D4
     Number of terms: 176
&gt; W := CoxeterGroup(R); #W; act := RootAction(W);
192
&gt; domwts, dommps := WeightsAndMultiplicities(Dom);
&gt; CP := LieRepresentationDecomposition(R);
&gt; for i in [1..#domwts] do
&gt;   wt := domwts[i]; mp := dommps[i];
&gt;   wtor := WeightOrbit(W, wt : Basis := "Weight");
&gt;   for wti in wtor do
&gt;     AddRepresentation(~CP, wti, mp);
&gt;   end for;
&gt; end for;
&gt; CP;
Highest weight decomposition of representation of:
     R: Simply connected root datum of dimension 4 of type D4
     Number of terms: 17712
&gt; time ad := AlternatingDominant(CP); ad:Maximal;
Time: 54.200
Highest weight decomposition of representation of:
     R: Simply connected root datum of dimension 4 of type D4
     Dimension of weight space:4
     Weights:
          [
               (1 5 2 1)
          ]
     Multiplicities:
          [ 1 ]
&gt; time adalt := AlternatingDominant(CP, LongestElement(W)); 
Time: 8.330
&gt; ad eq adalt;
true
</PRE>
<HR>
<H5><A NAME = "13376"></A><A NAME = "alternatingweylsumRv">AlternatingWeylSum</A>(R, v) : RootDtm, ModTupRngElt -&gt; LieRepDec</H5>
<H5>AlternatingWeylSum(R, v) : RootDtm, SeqEnum -&gt; LieRepDec</H5>
<H5><A NAME = "alternatingweylsumD">AlternatingWeylSum</A>(D) : LieRepDec -&gt; LieRepDec</H5>
<BLOCKQUOTE>
The alternating Weyl sum of V<sup>R</sup><sub>v</sub> or D. Useful for demonstration
purposes, but the fact that the number of terms in the result is
a multiple of the order of the CoxeterGroup of R makes it impractical
for most groups.
</BLOCKQUOTE>
<PRE></PRE> <A  HREF = "text1197.htm">[Next]</A><A  HREF = "text1195.htm">[Prev]</A> <A  HREF = "text1197.htm">[Right]</A> <A  HREF = "text1195.htm">[Left]</A> <A  HREF = "text1192.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<br><small>Version: V2.22 of <I>
Thu Jun  9 16:37:49 EST 2016
</I></small>
</body></html>