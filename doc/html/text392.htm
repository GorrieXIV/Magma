<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <link rel='stylesheet' href='help.css' type='text/css'>
  <TITLE>Unit Groups</TITLE>
</head>
<body BGCOLOR="#FFFFFF">

 <A  HREF = "text393.htm">[Next]</A><A  HREF = "text391.htm">[Prev]</A> <A  HREF = "text393.htm">[Right]</A> <A  HREF = "text391.htm">[Left]</A> <A  HREF = "text383.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<PRE></PRE><H3><A NAME = "3896">Unit Groups</A></H3>

<P>
<P>
<P>
For most number fields, the algorithm used to compute the unit group 
involves computing the class group and obtaining units from the
`class group relations'.  If a class group has already been computed
for the field, these `unit relations' are already stored; otherwise, 
the standard class group computation will be performed first.  
<P>
The unit group routine is fully rigorous, even when the class group
computation is not.  For details see <A  HREF = "text392.htm#RngOrd:UnitGroup">UnitGroup</A> and
<TT>IndependentUnits</TT> below.
<P>
Some of the algorithms are described in <A  HREF = "text382.htm#bib_pohst1">[PZ89]</A>, (pp. 343--344), 
and in <A  HREF = "text382.htm#bib_pohst2">[Poh93]</A>.


<H5><A NAME = "3897">UnitRank(O) : RngOrd -&gt; RngIntElt</A></H5>
<H5>UnitRank(K) : FldAlg -&gt; RngIntElt</H5>
<BLOCKQUOTE>
The free rank of the group of units in the ring of integers O 
(of a number field K).
</BLOCKQUOTE>
<H5><A NAME = "3898">TorsionUnitGroup(O) : RngOrd -&gt; GrpAb, Map</A></H5>
<H5>TorsionUnitGroup(K) : FldNum -&gt; GrpAb, Map</H5>
<BLOCKQUOTE>
The torsion subgroup of the unit group of the order O, or, in case of
a number field K, of its maximal order O. The torsion subgroup
is returned as an abelian group T, together with a map
m from the group to the order O. The torsion subgroup will be cyclic,
and is generated by <TT>m(T.1)</TT>.
</BLOCKQUOTE>
<H5><A NAME = "3899"></A><A NAME = "RngOrd:UnitGroup">UnitGroup</A>(O) : RngOrd -&gt; GrpAb, Map</H5>
<H5>MultiplicativeGroup(O) : RngOrd -&gt; GrpAb, Map</H5>

<PRE>    Al: MonStgElt                       Default: "Automatic"</PRE>

<PRE>    SetVerbose("UnitGroup", n):         Maximum: 6</PRE>
<BLOCKQUOTE>
Given an order O in a number field, this function returns
an (abstract) abelian group U, as well as a bijection m
between U and the units of the order. The unit group consists of the torsion
subgroup, generated by the image <TT>m(U.1)</TT> and a free part,
generated in O by the images <TT>m(U.i)</TT> for 2&le;i&le;r<sub>1</sub> + r<sub>2</sub>.
<P>
<TT>UnitGroup</TT> always performs a proof phase, to verify rigorously
that the unit group returned is the full unit group rather than a
finite index subgroup.  This is done even when the class group computation
was only heuristic.  It is done by a different method than the proof phase
for the class group (and it does not prove the class group).
If one wants to skip the proof phase, one should first compute a class group,
specifying the rigour of that computation (see <A  HREF = "text391.htm#3872">Ideal Class Groups</A>), and then
call <TT>IndependentUnits</TT> (see below).
</BLOCKQUOTE>
<H5><A NAME = "3900">UnitGroup(K) : FldNum -&gt; GrpAb, Map</A></H5>
<H5>MultiplicativeGroup(K) : FldNum -&gt; GrpAb, Map</H5>
<BLOCKQUOTE>
This is identical to <TT>UnitGroup(MaximalOrder(K))</TT>.
</BLOCKQUOTE>
<H5><A NAME = "3901">IndependentUnits(O) : RngOrd -&gt; GrpAb, Map</A></H5>
<H5>IndependentUnits(K) : FldNum -&gt; GrpAb, Map</H5>

<PRE>    Al: MonStgElt                       Default: "Automatic"</PRE>

<PRE>    SetVerbose("UnitGroup", n):         Maximum: 6</PRE>
<BLOCKQUOTE>
This function is an alternative to <TT>UnitGroup</TT> which returns a
subgroup of finite index in the unit group.  The arguments and
return values are the same as for <TT>UnitGroup</TT>.
<P>
In the current implementation, <TT>IndependentUnits</TT> returns the 
full unit group whenever the class group computation is correct.
This is always the case if the GRH holds.
<P>
After calling <TT>IndependentUnits(O)</TT>, if
<A  HREF = "text389.htm#RngOrd:SetOrderUnitsAreFundamental">SetOrderUnitsAreFundamental</A><TT>(O)</TT> is invoked Magma
will assume this unit group is the full unit group in all subsequent
calculations with the same number field.
</BLOCKQUOTE>
<H5><A NAME = "3902">pFundamentalUnits(O, p) : RngOrd, RngIntElt -&gt; GrpAb, Map</A></H5>
<H5>pFundamentalUnits(K, p) : FldNum, RngIntElt -&gt; GrpAb, Map</H5>

<PRE>    Al: MonStgElt                       Default: "Automatic"</PRE>

<PRE>    SetVerbose("UnitGroup", n):         Maximum: 6</PRE>
<BLOCKQUOTE>
Given an order O in a number field, this function returns
an (abstract) abelian group U, as well as a map m
from U to the order. 
U will be a subgroup (of finite index) of the unit group G such that p 
does not divide the index (G:U)
where p is the prime number given.
If a field K is given rather than an order, the above is computed for
the maximal order of K.
</BLOCKQUOTE>
<H5><A NAME = "3903">UnitGroupAsSubgroup(O) : RngOrd -&gt; GrpAb</A></H5>
<BLOCKQUOTE>
For a (possibly non-maximal) order O in some absolute field K,
return the unit group of O as a subgroup of the unit group of the 
maximal order of O. The algorithm and its implementation is due to 
Kl&uuml;ners and Pauli, <A  HREF = "text382.htm#bib_KluenersPauli2005">[PK05]</A>.
</BLOCKQUOTE>
<H5><A NAME = "3904">MergeUnits(K, a) : FldNum, FldNumElt -&gt; BoolElt</A></H5>
<H5>MergeUnits(O, a) : RngOrd, RngOrdElt -&gt; BoolElt</H5>

<PRE>    SetVerbose("UnitGroup", n):         Maximum: 6</PRE>
<BLOCKQUOTE>
This function is largely irrelevant in the current implementation.
<P>
For an order O or a number field with maximal order O 
and a unit a&isin;O, add the unit to the already 
known subgroup of U<sub>O</sub> that is stored in O.
Returns <TT>true</TT> if and only if the rank of the currently known unit group of 
O or K increases when a is merged with it.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "3905">Example <TT>RngOrd_UnitGroup (H38E20)</TT></A></H3>
In our field defined by  x<sup>4</sup> - 420 * x<sup>2</sup> + 40000, we obtain the
class and unit groups as follows.
<P>
<P>
<PRE>
&gt; R&lt;x&gt; := PolynomialRing(Integers());
&gt; f := x^4 - 420*x^2 + 40000;
&gt; K&lt;y&gt; := NumberField(f);
&gt; C := ClassGroup(K);
&gt; C;
Abelian Group of order 1
&gt; U := UnitGroup(K);
&gt; U;
Abelian Group isomorphic to Z/2 + Z + Z + Z
Defined on 4 generators
Relations:
      2*U.1 = 0
&gt; T := TorsionUnitGroup(K);
&gt; T;
Abelian Group isomorphic to Z/2
Defined on 1 generator
Relations:
    2*T.1 = 0
</PRE>
<HR>
<H5><A NAME = "3906">IsExceptionalUnit(u) : RngOrdElt -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
An element x of an order O is an exceptional unit if both x and x - 1
are units in O.  This function returns <TT>true</TT> if and only if the order
element u is an 
exceptional unit.
</BLOCKQUOTE>
<H5><A NAME = "3907">ExceptionalUnitOrbit(u) : RngOrdElt -&gt; [ RngOrdElt ]</A></H5>
<BLOCKQUOTE>
If u is an exceptional unit of an order O, then all of the units
u<sub>1</sub>=u, u<sub>2</sub>=(1/u), u<sub>3</sub>=1 - u, u<sub>4</sub>=(1/(1 - u)),
u<sub>5</sub>=((u - 1)/u), u<sub>6</sub>=(u/(u - 1)) are exceptional.
The set &Omega;(u) formed by u<sub>1</sub>, ..., u<sub>6</sub> is called the <I>orbit</I>
of u.  Usually it will have 6 elements.
This function returns a sequence containing the elements of &Omega;(u).
</BLOCKQUOTE>
<H5><A NAME = "3908">ExceptionalUnits(O) : RngOrd -&gt; [ RngOrdElt ]</A></H5>

<PRE>    SetVerbose("UnitEq", n):            Maximum: 5</PRE>
<BLOCKQUOTE>
This function returns a sequence S of units of the order O such that any
exceptional unit u of O is either in S or is in the orbit of
some element of S.
</BLOCKQUOTE>
<PRE></PRE> <A  HREF = "text393.htm">[Next]</A><A  HREF = "text391.htm">[Prev]</A> <A  HREF = "text393.htm">[Right]</A> <A  HREF = "text391.htm">[Left]</A> <A  HREF = "text383.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<br><small>Version: V2.22 of <I>
Thu Jun  9 16:37:49 EST 2016
</I></small>
</body></html>