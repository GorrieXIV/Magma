<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <link rel='stylesheet' href='help.css' type='text/css'>
  <TITLE>New Codes from Existing</TITLE>
</head>
<body BGCOLOR="#FFFFFF">

 <A  HREF = "text1842.htm">[Next]</A><A  HREF = "text1840.htm">[Prev]</A> <A  HREF = "text1842.htm">[Right]</A> <A  HREF = "text1840.htm">[Left]</A> <A  HREF = "text1831.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<PRE></PRE><H3><A NAME = "20517">New Codes from Existing</A></H3>

<P>
<P>
The operations described here produce a new code by modifying
in some way the codewords of a given code.



<H5>Subsections</H5>
<UL>
<LI> <A  HREF = "text1841.htm#20518">Standard Constructions</A>
<LI> <A  HREF = "text1841.htm#20538">Changing the Alphabet of a Code</A>
<LI> <A  HREF = "text1841.htm#20546">Combining Codes</A>
</UL>
<H4><A NAME = "20518">Standard Constructions</A></H4>



<H5><A NAME = "20519">AugmentCode(C) : Code -&gt; Code</A></H5>
<BLOCKQUOTE>
Given an [n, k] binary code C, construct a new code
C' by including the all-ones vector with the words of C
(provided that it is not already in C).
</BLOCKQUOTE>
<H5><A NAME = "20520">CodeComplement(C, C1) : Code, Code -&gt; Code</A></H5>
<BLOCKQUOTE>
Given a subcode C1 of C, return a code C2 such that C=C1 +  C2.
</BLOCKQUOTE>
<H5><A NAME = "20521">DirectSum(C, D) : Code, Code -&gt; Code</A></H5>
<BLOCKQUOTE>
Given an [n<sub>1</sub>, k<sub>1</sub>] code C and an [n<sub>2</sub>, k<sub>2</sub>] code
D, both over the same field F, construct the direct sum of
C and D. The direct sum consists of all vectors u|v, where
u &isin;C and v &isin;D.
</BLOCKQUOTE>
<H5><A NAME = "20522">DirectSum(Q) : [Code] -&gt; Code</A></H5>
<BLOCKQUOTE>
Given a sequence of codes Q = [C<sub>1</sub>, ..., C<sub>r</sub>], all defined 
over the same field F, construct the direct sum of the C<sub>i</sub>. 
</BLOCKQUOTE>
<H5><A NAME = "20523">DirectProduct(C, D) : Code, Code -&gt; Code</A></H5>
<H5>ProductCode(C, D) : Code, Code -&gt; Code</H5>
<BLOCKQUOTE>
Given an [n<sub>1</sub>, k<sub>1</sub>] code C and an [n<sub>2</sub>, k<sub>2</sub>] code
D, both over the same ring R, construct the direct product of
C and D. The direct product has length n<sub>1</sub>.n<sub>2</sub>, dimension
k<sub>1</sub>.k<sub>2</sub>, and its
generator matrix is the Kronecker product of the basis matrices
of C and D.
</BLOCKQUOTE>
<H5><A NAME = "20524">ExtendCode(C) : Code -&gt; Code</A></H5>
<BLOCKQUOTE>
Given an [n, k, d] code C
form a new code C' from C by adding the appropriate extra coordinate
to each vector of C such that the sum of the coordinates of the extended
vector is zero.  (Thus if C is a binary code, the construction will add
a 0 at the
end of every codeword having even weight, and a 1 at the end
of every codeword having odd weight.)
</BLOCKQUOTE>
<H5><A NAME = "20525">ExtendCode(C, n) : Code, RngIntElt -&gt; Code</A></H5>
<BLOCKQUOTE>
Return the code C extended n times.
</BLOCKQUOTE>
<H5><A NAME = "20526">PadCode(C, n) : Code, RngIntElt -&gt; Code</A></H5>
<BLOCKQUOTE>
Add n zeros to the end of each codeword of C.
</BLOCKQUOTE>
<H5><A NAME = "20527">ExpurgateCode(C) : Code -&gt; Code</A></H5>
<BLOCKQUOTE>
Construct a new code by deleting  
all the code words of C having odd weight.
</BLOCKQUOTE>
<H5><A NAME = "20528">ExpurgateCode(C, L) : Code,[ModTupFldElt] -&gt; Code</A></H5>
<BLOCKQUOTE>
The sequence L consists of codewords from C. The result is obtained by
deleting the words in L from C.
</BLOCKQUOTE>
<H5><A NAME = "20529">ExpurgateWeightCode(C, w) : Code, RngIntElt -&gt; Code</A></H5>
<BLOCKQUOTE>
Delete a subspace generated by a word of weight w.
</BLOCKQUOTE>
<H5><A NAME = "20530">LengthenCode(C) : Code -&gt; Code</A></H5>
<BLOCKQUOTE>
Given an [n, k] binary code C, construct a new code
by first adding the all-ones codeword, and then extending
it by adding an overall parity check.
</BLOCKQUOTE>
<H5><A NAME = "20531">PlotkinSum(C1, C2) : Code, Code -&gt; Code</A></H5>
<BLOCKQUOTE>
Given two codes over the same alphabet, return the code consisting
of all vectors of the form u|u + v, where u &isin;C1 and v &isin;C2.
Zeros are appended where needed to make up any length differences
in the two codes.
The result is a [n<sub>1</sub> + max{n<sub>1</sub>, n<sub>2</sub>}, k<sub>1</sub> + k<sub>2</sub>, min{2 * d<sub>1</sub>, d<sub>2</sub>}] code.
</BLOCKQUOTE>
<H5><A NAME = "20532">PlotkinSum(C1, C2, C3: parameters) : Code, Code, Code -&gt; Code</A></H5>

<PRE>    a: FldFinElt                        Default: -1</PRE>
<BLOCKQUOTE>
Given three codes over the same alphabet, return the code consisting
of all vectors of the form u|u + a * v|u + v + w, where u &isin;C1, v &isin;C2
and w &isin;C3.
Zeros are appended where needed to make up any length differences
in the three codes.
The result for the default case of <TT>a := -1</TT> is a 
[n<sub>1</sub> + max{n<sub>1</sub>, n<sub>2</sub>} + max{n<sub>1</sub>, n<sub>2</sub>, n<sub>3</sub>}, k<sub>1</sub> + k<sub>2</sub> + k<sub>3</sub>, 
min{3 * d<sub>1</sub>, 2 * d<sub>2</sub>, d<sub>3</sub>}] code.
</BLOCKQUOTE>
<H5><A NAME = "20533">PunctureCode(C, i) : Code, RngIntElt -&gt; Code</A></H5>
<BLOCKQUOTE>
Given an [n, k] code C, and an integer i,
1 &le;i &le;n, construct a new code C' by deleting
the i-th coordinate from each code word of C.
</BLOCKQUOTE>
<H5><A NAME = "20534">PunctureCode(C, S) : Code, { RngIntElt } -&gt; Code</A></H5>
<BLOCKQUOTE>
Given an [n, k] code C and a set S of distinct integers
{ i<sub>1</sub>, ..., i<sub>r</sub> } each of which lies in the range [1, n],
construct a new code C' by deleting the components
i<sub>1</sub>, ..., i<sub>r</sub> from each code word of C.
</BLOCKQUOTE>
<H5><A NAME = "20535">ShortenCode(C, i) : Code, RngIntElt -&gt; Code</A></H5>
<BLOCKQUOTE>
Given an [n, k] code C and an integer i,
1 &le;i &le;n, construct a new code from C by selecting
only those codewords of C having a zero as their i-th    
component and deleting the i-th component from these
codewords.  Thus, the resulting code will have length n - 1.
</BLOCKQUOTE>
<H5><A NAME = "20536">ShortenCode(C, S) : Code, { RngIntElt } -&gt; Code</A></H5>
<BLOCKQUOTE>
Given an [n, k] code C and a set S of distinct integers
{ i<sub>1</sub>, ..., i<sub>r</sub>}, each of which lies in the range [1, n],
construct a new code from C by selecting only those codewords
of C having zeros in each of the coordinate positions
i<sub>1</sub>, ..., i<sub>r</sub>, and deleting these components. Thus, the 
resulting code will have length n - r.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "20537">Example <TT>CodeFld_Make12-8-4Code (H158E31)</TT></A></H3>
Using only two simple <TT>RepetitionCode</TT>'s and several standard
constructions, we create a [12, 4, 6] code. This is the best 
possible minimum weight for a code of this length and dimension, 
as is the minimum weight for all
codes produced in this example. 
<P>
Instead of printing each individual code out,
the codes are named by convention as c_n_k_d, where
n, k, d represent the <TT>Length</TT>,<TT>Dimension</TT> and <TT>MinimumWeight</TT>
respectively.
<P>
<P>
<P>
<PRE>
&gt; c_4_1_4 := RepetitionCode(GF(2),4);
&gt; c_6_1_6 := RepetitionCode(GF(2),6);
&gt; c_4_3_2 := Dual( c_4_1_4 );
&gt; c_8_4_4 := PlotkinSum( c_4_3_2 , c_4_1_4 );
&gt; c_7_4_3 := PunctureCode( c_8_4_4 , 8 );
&gt; c_6_3_3 := ShortenCode(  c_7_4_3 , 7 );
&gt; c_12_4_6 := PlotkinSum( c_6_3_3 , c_6_1_6 );
&gt; c_12_4_6;
[12, 4, 6] Linear Code over GF(2)
Generator matrix:
[1 0 0 1 1 0 0 1 1 0 0 1]
[0 1 0 1 0 1 0 1 0 1 0 1]
[0 0 1 1 1 1 0 0 1 1 1 1]
[0 0 0 0 0 0 1 1 1 1 1 1]
</PRE>
<HR>
<H4><A NAME = "20538">Changing the Alphabet of a Code</A></H4>



<H5><A NAME = "20539">ExtendField(C, L) : Code, FldFin -&gt; Code, Map</A></H5>
<BLOCKQUOTE>
Given an [n, k, d] code C defined over the finite field K,
and an extension
field L of K, construct the code C' over L corresponding to C.
The function also returns the embedding map from C into C'.
</BLOCKQUOTE>
<H5><A NAME = "20540">LinearCode(C, S) : Code, FldFin -&gt; Code, Map</A></H5>
<BLOCKQUOTE>
Given an [n, k, d] code C defined over the finite field K, and a subfield
S of K such that the degree of K over S is m, construct a new
[N = mn, k, D &ge;d] code C' over S by replacing each component of
each codeword of C by its representation as a vector over S.
The function also returns the isomorphism from C onto C'.
</BLOCKQUOTE>
<H5><A NAME = "20541">SubfieldRepresentationCode(C, K) : Code, FldFin -&gt; Code</A></H5>
<BLOCKQUOTE>
Given a linear code over GF(q<sup>m</sup>), return a code whose codewords are obtained
from those of C by expanding each coordinate in GF(q<sup>m</sup>) as a vector of
dimension m over K = GF(q).
</BLOCKQUOTE>
<H5><A NAME = "20542">SubfieldRepresentationParityCode(C, K) : Code, FldFin -&gt; Code</A></H5>
<BLOCKQUOTE>
Given a linear code over GF(q<sup>m</sup>), return a code whose codewords are
obtained from those of C by expanding each coordinate in GF(q<sup>m</sup>) as a
vector of dimension m + 1 over K = GF(q), including a parity check bit.
</BLOCKQUOTE>
<H5><A NAME = "20543">SubfieldSubcode(C, S) : Code, FldFin -&gt; Code, Map</A></H5>
<H5>RestrictField(C, S) : Code, FldFin -&gt; Code, Map</H5>
<H5>SubfieldSubcode(C) : Code -&gt; Code, Map</H5>
<H5>RestrictField(C) : Code -&gt; Code, Map</H5>
<BLOCKQUOTE>
Given an [n, k, d] code C defined over the field K, and a subfield
S of K, construct a new [n, K &le;k, D &ge;d] code C' over
S consisting of the codewords of C which have all their components
in S.  If S is omitted, it is taken to be the prime subfield of K.
The function also returns the restriction map from C to the
subfield subcode C'.
</BLOCKQUOTE>
<H5><A NAME = "20544">SubfieldCode(C, S) : Code, FldFin -&gt; Code</A></H5>
<BLOCKQUOTE>
Given an [n, k] code C defined over the field K, and a subfield
S of K, such that K is a degree m extension of S, 
construct a new [n, k'] code over S by expanding each element of K
as a column vector over S. The new code will have k'&le;km. 
</BLOCKQUOTE>
<H5><A NAME = "20545">Trace(C, F) : Code, FldFin -&gt; Code</A></H5>
<H5>Trace(C) : Code -&gt; Code</H5>
<BLOCKQUOTE>
Given a code C defined over the field K, and a subfield
F of K, construct a new code C' over F consisting of 
the traces with respect to F of each of the codewords of
L. If F is omitted, it is taken to be the prime subfield of K.
</BLOCKQUOTE>
<H4><A NAME = "20546">Combining Codes</A></H4>



<H5><A NAME = "20547">C1 cat C2 : Code, Code -&gt; Code</A></H5>
<BLOCKQUOTE>
Given codes C1 and C2, both defined over the same field K,
return the concatenation C of C1 and C2. If A and B are the   
generator matrices of C1 and C2, respectively, the concatenation
of C1 and C2 is the code with generator matrix whose rows consist
of each row of A concatenated with each row of B.
</BLOCKQUOTE>
<H5><A NAME = "20548">Juxtaposition(C1, C2) : Code, Code -&gt; Code</A></H5>
<BLOCKQUOTE>
Given an [n<sub>1</sub>, k, d<sub>1</sub>] code C1 and an [n<sub>2</sub>, k, d<sub>2</sub>] code C2 
of the same dimension, where both codes are defined over the same 
field K, the function returns a [n<sub>1</sub> + n<sub>2</sub>, k, &ge;d<sub>1</sub> + d<sub>2</sub>] code
whose generator matrix is <TT>HorizontalJoin(A, B)</TT>, where A and B 
are the generator matrices for codes C1 and C2, respectively.  
</BLOCKQUOTE>
<H5><A NAME = "20549">ConcatenatedCode(O, I) : Code, Code -&gt; Code</A></H5>
<BLOCKQUOTE>
Given a [N, K, D]-code O defined over GF(q<sup>k</sup>) and a [n, k, d]-code I
defined over GF(q), construct the [Nn, Kk, &delta; &ge;dD] concatenated 
code by taking O as outer code and I as inner code.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "20550">Example <TT>CodeFld_ConcatenatedCode (H158E32)</TT></A></H3>
We use the function <TT>ConcatenatedCode</TT> to construct a [69, 19, 22]
code over GF(2), this being the best known code for this length and
dimension.  While it is theoretically possible for a code of minimum
weight up to 24 to exist, the best binary [69, 19] code at the time
of writing (July 2001) has minimum weight 22.
<P>
<P>
<P>
<PRE>
&gt; C1 := ShortenCode( QRCode(GF(4),29) , {24..29} );
&gt; C1:Minimal;
[23, 9] Linear Code over GF(2^2)
&gt; C2 := ConcatenatedCode( C1 , CordaroWagnerCode(3) );
&gt; C2:Minimal;
[69, 18] Linear Code over GF(2)
&gt; res := C2 + RepetitionCode(GF(2),69);
&gt; res:Minimal;
[69, 19] Linear Code over GF(2)
&gt; MinimumWeight(res);
22
&gt; res:Minimal;
[69, 19, 22] Linear Code over GF(2)
</PRE>
<HR>
<H5><A NAME = "20551">ConstructionX(C1, C2, C3) : Code, Code, Code -&gt; Code</A></H5>
<BLOCKQUOTE>
Let C<sub>1</sub>, C<sub>2</sub> and C<sub>3</sub> be codes with parameters [n<sub>1</sub>, k<sub>1</sub>, d<sub>1</sub>],
[n<sub>2</sub>, k<sub>2</sub>, d<sub>2</sub>] and [n<sub>3</sub>, k<sub>3</sub>, d<sub>3</sub>], respectively, where C2 is 
a union of b cosets of C1, (so n<sub>1</sub>=n<sub>2</sub> and k<sub>2</sub> &le;k<sub>1</sub>) and 
k<sub>1</sub> = k<sub>2</sub> + k<sub>3</sub>.  The construction divides C2 into a union of cosets 
of C1 and attaches a different codeword of C3 to each coset.
The new code has parameters [n<sub>1</sub> + n<sub>3</sub>, k<sub>1</sub>, &ge;min{ d<sub>2</sub>, d<sub>1</sub> + d<sub>3</sub>  } ].
For further details see <A  HREF = "text1830.htm#bib_sloane">[MS78, p.581]</A>.
</BLOCKQUOTE>
<H5><A NAME = "20552">ConstructionXChain(S, C) : [Code], Code -&gt; [Code]</A></H5>
<BLOCKQUOTE>
Given a sequence of codes S where all codes are subcodes of the first one,
apply <TT>ConstructionX</TT> to S[1], S[2] and C. 
Then compute the resulting subcodes from the other codes in S.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "20553">Example <TT>CodeFld_constructionX (H158E33)</TT></A></H3>
We create a [161, 29, 53] code by applying construction X to two BCH 
codes of length 127. To maximise the resulting minimum weight we take 
the best known [34, 14] code as C<sub>3</sub>.  The construction sets a lower 
bound on the minimum weight, making the calculation of the true
minimum weight much faster. 
<P>
<P>
<PRE>
&gt; SetPrintLevel("Minimal");
&gt;  
&gt; C1 := BCHCode(GF(2), 127, 43);
&gt; C2 := BCHCode(GF(2), 127, 55);
&gt; C3 := BKLC(GF(2), 34, 14);
&gt; C1; C2; C3;
[127, 29, 43] BCH code (d = 43, b = 1) over GF(2)
[127, 15, 55] BCH code (d = 55, b = 1) over GF(2)
[34, 14, 10] Linear Code over GF(2)
&gt; CX := ConstructionX(C1, C2, C3);
&gt; CX;
[161, 29] Linear Code over GF(2)
&gt; time MinimumWeight(CX);
53
Time: 0.010
</PRE>
<HR>
<H5><A NAME = "20554">ConstructionX3(C1, C2, C3, D1, D2) : Code, Code, Code, Code, Code -&gt; Code, Map</A></H5>
<BLOCKQUOTE>
Given a chain of codes C1=[n, k<sub>1</sub>, d<sub>1</sub>], C2=[n, k<sub>2</sub>, d<sub>2</sub>], 
and C3=[n, k<sub>3</sub>, d<sub>3</sub>] with
k<sub>3</sub> &lt; k<sub>2</sub> &lt; k<sub>1</sub>, and suffix codes D1=[n<sub>1</sub>, k<sub>1</sub> - k<sub>2</sub>, e<sub>1</sub>] and 
D2=[n<sub>2</sub>, k<sub>3</sub> - k<sub>2</sub>, e<sub>2</sub>], 
construct a code C=[n + n<sub>1</sub> + n<sub>2</sub>, k<sub>1</sub>, &ge;min{d<sub>3</sub>, d<sub>1</sub> + e<sub>1</sub>, d<sub>2</sub> + e<sub>2</sub>}.
For further details see <A  HREF = "text1830.htm#bib_sloane">[MS78, p.583]</A>.
</BLOCKQUOTE>
<H5><A NAME = "20555">ConstructionX3u(C1, C2, C3, D1, D2) : Code, Code, Code, Code, Code -&gt; Code, Code</A></H5>
<BLOCKQUOTE>
Given two chains of codes C1=[n, k<sub>1</sub>] &sub;C2=[n, k<sub>2</sub>] &sub;C3=[n, k<sub>3</sub>] 
and D1=[n', k<sub>1</sub> - k<sub>3</sub>] &sub;D2=[n', k<sub>2</sub> - k<sub>3</sub>], 
return the codes C=[n + n', k<sub>1</sub>] &sub;C'=[n + n', k<sub>2</sub>] using Construction X
with C1, C3 and D1 resp. C2, C3 and D2.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "20556">Example <TT>CodeFld_X3 (H158E34)</TT></A></H3>
We construct a best known [74, 43, 11] code using 
construction X3. From a chain of BCH subcodes, we take an
subcode to get the appropriate length, then use 
construction X3 with the best possible codes D1, D2.
Because the construction algorithm sets a lower bound on
the minimum weight, then it is quick to calculate afterwards.
<P>
<P>
<PRE>
&gt; SetPrintLevel("Minimal");
&gt; C1 := ExtendCode( BCHCode(GF(2), 63, 7) );
&gt; C2 := ExtendCode( BCHCode(GF(2), 63, 9) );
&gt; C3 := ExtendCode( BCHCode(GF(2), 63, 11) );
&gt; C1; C2; C3;
[64, 45, 8] Linear Code over GF(2)
[64, 39, 10] Linear Code over GF(2)
[64, 36, 12] Linear Code over GF(2)
&gt; CC := SubcodeBetweenCode(C1, C2, 43);
&gt; CC;
[64, 43] Linear Code over GF(2)
&gt; MinimumWeight(CC);
8
&gt; CX3 := ConstructionX3(CC, C2, C3, 
&gt;                 BKLC(GF(2), 7, 4), BKLC(GF(2), 3, 3));
&gt; CX3;
[74, 43] Linear Code over GF(2)
&gt; time MinimumWeight(CX3);
11
Time: 0.000
</PRE>
<HR>
<H5><A NAME = "20557">ConstructionXX(C1, C2, C3, D2, D3) : Code, Code, Code, Code, Code -&gt; Code</A></H5>
<BLOCKQUOTE>
Let the parameters of codes C<sub>1</sub>, C<sub>2</sub>, C<sub>3</sub> be
[n<sub>1</sub>, k, d<sub>1</sub>], [n<sub>1</sub>, k - l<sub>2</sub>, d<sub>2</sub>] and [n<sub>1</sub>, k - l<sub>3</sub>, d<sub>3</sub>] respectively,
where C<sub>2</sub> and C<sub>3</sub> are subcodes of C<sub>1</sub>. Codes D<sub>2</sub>, D<sub>3</sub> must have
dimensions l<sub>2</sub>, l<sub>3</sub>, with parameters [n<sub>2</sub>, l<sub>2</sub>, &delta;<sub>2</sub>], [n<sub>3</sub>, l<sub>3</sub>, &delta;<sub>3</sub>]
 say.
The construction breaks C<sub>1</sub> up into cosets of C<sub>2</sub> and C<sub>3</sub> with 
the relevant tails added from D<sub>2</sub> and D<sub>3</sub>. If the intersection of 
C<sub>1</sub> and C<sub>2</sub> has minimum distance d<sub>0</sub> then the newly constructed 
code will have parameters
 [n<sub>1</sub> + n<sub>2</sub> + n<sub>3</sub>, k, min{d<sub>0</sub>, d<sub>2</sub> + &delta;<sub>2</sub>, d<sub>3</sub> + &delta;<sub>3</sub>, d<sub>1</sub> + &delta;<sub>2</sub> + &delta;<sub>3</sub>}]. 
For further details see <A  HREF = "text1830.htm#bib_AlltopXX">[All84]</A>.  
</BLOCKQUOTE>
<HR>
<H3><A NAME = "20558">Example <TT>CodeFld_XX (H158E35)</TT></A></H3>
We construct a best known [73, 38, 13] code C using construction XX. 
For C<sub>1</sub>, C<sub>2</sub>, C<sub>3</sub> we take three cyclic (or BCH) codes of
length 63, while for D<sub>1</sub>, D<sub>2</sub> we use two Best Known Codes.
<P>
<P>
<PRE>
&gt; SetPrintLevel("Minimal");
&gt; C1 := BCHCode(GF(2),63,10,57);
&gt; P&lt;x&gt; := PolynomialRing(GF(2));
&gt; p := x^28 + x^25 + x^22 + x^21 + x^20 + x^17 + x^16
&gt;      + x^15 + x^9 + x^8 + x^6 + x^5 + x + 1;
&gt; C2 := CyclicCode(63, p);
&gt; C3 := BCHCode(GF(2), 63, 10, 58);
&gt; C1; C2; C3;
[63, 38] BCH code (d = 10, b = 57) over GF(2)
[63, 35] Cyclic Code over GF(2)
[63, 32] BCH code (d = 10, b = 58) over GF(2)
&gt; MinimumDistance(C1 meet C2);
12
</PRE>
<P>
So the minimum distance of the code produced by Construction XX must be at
least 12.
<P>
<P>
<P>
<PRE>
&gt; C := ConstructionXX(C1, C2, C3, BKLC(GF(2),3,3), BKLC(GF(2),7,6) );
&gt; C;
[73, 38] Linear Code over GF(2)
MinimumDistance(C);
13
</PRE>
<P>
Thus the actual minimum distance is one greater than the lower bound 
guaranteed by Construction XX.
<HR>
<H5><A NAME = "20559">ZinovievCode(I, O) : [Code], [Code] -&gt; Code</A></H5>
<BLOCKQUOTE>
The arguments are as follows: The first argument must be a sequence I 
containing an increasing chain of r codes with parameters,
[n, k<sub>1</sub>, d<sub>1</sub>]<sub>q</sub> &sub;[n, k<sub>2</sub>, d<sub>2</sub>]<sub>q</sub> &sub; ... &sub;[n, k<sub>r</sub>, d<sub>r</sub>]<sub>q</sub>
where 0=k<sub>0</sub>&lt;k<sub>1</sub>&lt;k<sub>2</sub>&lt; ... &lt; k<sub>r</sub>, (the <I>inner codes</I>). The second argument
must be a sequence O of r codes with parameters [N, K<sub>i</sub>, D<sub>i</sub>]<sub>Q<sub>i</sub></sub>, 
where Q<sub>i</sub> = q<sup>e<sub>i</sub></sup> and e<sub>i</sub> = k<sub>i</sub> - k<sub>i - 1</sub> for i = 1 ... r 
(the <I>outer codes</I>). The function constructs a generalised concatenated 
[n * N, K, D]<sub>q</sub> code is constructed, where K=e<sub>1</sub>K<sub>1</sub> + ... + e<sub>r</sub>K<sub>r</sub> and 
D = min(d<sub>1</sub>D<sub>1</sub>, ... , d<sub>r</sub>D<sub>r</sub>).  For further details see <A  HREF = "text1830.htm#bib_sloane">[MS78, p.590]</A>.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "20560">Example <TT>CodeFld_Zinoviev (H158E36)</TT></A></H3>
We create a [72, 41, 12] code over GF(2) using the <TT>ZinovievCode</TT>
function, which is the best known code for this length and dimension.
While it is theoretically possible for a [72, 41] code to have minimum
weight up to 14, at the time of writing (July 2001) the best known
code has minimum weight 12.
The minimum weight is not calculated since it is a lengthy calculation.
<P>
<P>
<P>
<PRE>
&gt; I1 := RepetitionCode(GF(2),8);
&gt; I2 := I1 + LinearCode( KMatrixSpace(GF(2),3,8) !
&gt;                 [0,1,0,0,0,1,1,1,0,0,1,0,1,0,1,1,0,0,0,1,1,1,0,1]
&gt;                      );
&gt; I3 := Dual(I1);
&gt; Inner := [I1, I2, I3];
&gt; Inner:Minimal;
[
    [8, 1, 8] Cyclic Code over GF(2),
    [8, 4, 4] Linear Code over GF(2),
    [8, 7, 2] Cyclic Code over GF(2)
]
&gt; 
&gt; O1 := Dual(RepetitionCode(GF(2),9));
&gt; O2 := BCHCode(GF(8),9,3,4);
&gt; O3 := BCHCode(GF(8),9,6,7);
&gt; Outer := [O1, O2, O3];
&gt; Outer:Minimal;
[
    [9, 8, 2] Cyclic Code over GF(2),
    [9, 7, 3] BCH code (d = 3, b = 4) over GF(2^3),
    [9, 4, 6] BCH code (d = 6, b = 7) over GF(2^3)
]
&gt; 
&gt; C := ZinovievCode(Inner, Outer);
&gt; C:Minimal;
[72, 41] Linear Code over GF(2)
</PRE>
<HR>
<H5><A NAME = "20561">ConstructionY1(C) : Code -&gt; Code</A></H5>
<BLOCKQUOTE>
Apply construction Y1 to the code C. This construction applies the
shortening operation at the positions in the support of a word of minimal 
weight in the dual of C.  If C is a [n, k, d] code, whose dual code 
has minimum weight d', then the returned code has parameters 
[n - d', k - d' + 1, &ge;d].  For further details see <A  HREF = "text1830.htm#bib_sloane">[MS78, p.592]</A>.
</BLOCKQUOTE>
<H5><A NAME = "20562">ConstructionY1(C, w) : Code, RngIntElt -&gt; Code</A></H5>
<BLOCKQUOTE>
Apply construction Y1 to the code C. This construction applies the
shortening operation at the positions in the support of a word of 
weight w in the dual of C.  If C is a [n, k, d] code, 
then the returned code has parameters [n - w, k - w + 1, &ge;d]. 
</BLOCKQUOTE>
<PRE></PRE> <A  HREF = "text1842.htm">[Next]</A><A  HREF = "text1840.htm">[Prev]</A> <A  HREF = "text1842.htm">[Right]</A> <A  HREF = "text1840.htm">[Left]</A> <A  HREF = "text1831.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<br><small>Version: V2.22 of <I>
Thu Jun  9 16:37:49 EST 2016
</I></small>
</body></html>