<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <link rel='stylesheet' href='help.css' type='text/css'>
  <TITLE>Divisors</TITLE>
</head>
<body BGCOLOR="#FFFFFF">

 <A  HREF = "text457.htm">[Next]</A><A  HREF = "text455.htm">[Prev]</A> <A  HREF = "text457.htm">[Right]</A> <A  HREF = "text455.htm">[Left]</A> <A  HREF = "text442.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<PRE></PRE><H3><A NAME = "4917">Divisors</A></H3>




<H5>Subsections</H5>
<UL>
<LI> <A  HREF = "text456.htm#4918">Creation of Structures</A>
<LI> <A  HREF = "text456.htm#4920">Creation of Elements</A>
<LI> <A  HREF = "text456.htm#4929">Related Structures</A>
<LI> <A  HREF = "text456.htm#4933">Structure Invariants</A>
<LI> <A  HREF = "text456.htm#4936">Structure Predicates</A>
<LI> <A  HREF = "text456.htm#4937">Element Operations</A>
<LI> <A  HREF = "text456.htm#4975">Functions related to Divisor Class Groups of Global Function Fields</A>
</UL>
<H4><A NAME = "4918">Creation of Structures</A></H4>



<H5><A NAME = "4919">DivisorGroup(F) : FldFun -&gt; DivFun</A></H5>
<BLOCKQUOTE>
Create the group of divisors of the algebraic function field F/k.
</BLOCKQUOTE>
<H4><A NAME = "4920">Creation of Elements</A></H4>



<H5><A NAME = "4921">Divisor(P) : PlcFunElt -&gt; DivFunElt</A></H5>
<H5>Div ! P : DivFun, PlcFunElt -&gt; DivFunElt</H5>
<H5>1 * P : PlcFunElt -&gt; DivFunElt</H5>
<BLOCKQUOTE>
Given a place P in a function field, return the prime divisor 1 * P. 
</BLOCKQUOTE>
<H5><A NAME = "4922">Div ! a : DivFun, RngElt -&gt; DivFunElt</A></H5>
<H5>Divisor(a) : FldFunElt -&gt; DivFunElt</H5>
<H5>Divisor(a) : RngFunOrdElt -&gt; DivFunElt</H5>
<BLOCKQUOTE>
Given an algebraic function a, return the principal divisor (a).
</BLOCKQUOTE>
<H5><A NAME = "4923">Div ! I : DivFun, RngFunOrdIdl -&gt; DivFunElt</A></H5>
<H5>Divisor(I) : RngFunOrdIdl -&gt; DivFunElt</H5>
<BLOCKQUOTE>
The divisor corresponding to the factorization of the ideal I.
</BLOCKQUOTE>
<H5><A NAME = "4924">Divisor(I, J) : RngFunOrdIdl, RngFunOrdIdl -&gt; DivFunElt</A></H5>
<BLOCKQUOTE>
The divisor corresponding to the ideal factorization of the ideals I and
J belonging to the `finite' and `infinite' maximal order.
</BLOCKQUOTE>
<H5><A NAME = "4925">Identity(G) : DivFun -&gt; DivFunElt</A></H5>
<H5>Id(G) : DivFun -&gt; DivFunElt</H5>
<BLOCKQUOTE>
Given the group G of divisors of a function field, return
the zero divisor.
</BLOCKQUOTE>
<H5><A NAME = "4926">CanonicalDivisor(F) : FldFunG -&gt; DivFunElt</A></H5>
<BLOCKQUOTE>
A canonical divisor of the function field F/k.
</BLOCKQUOTE>
<H5><A NAME = "4927">DifferentDivisor(F) : FldFunG -&gt; DivFunElt</A></H5>
<BLOCKQUOTE>
The different divisor of the underlying extension of the function
field F/k(x).
</BLOCKQUOTE>
<H5><A NAME = "4928">AssignNames(~D, s) : DivFunElt, [ MonStgElt ] -&gt;</A></H5>
<BLOCKQUOTE>
Change the print name employed when displaying D to be
the contents of s which must have length 1 in this case.
</BLOCKQUOTE>
<H4><A NAME = "4929">Related Structures</A></H4>



<H5><A NAME = "4930">Parent and Category</A></H5>

<P>
<P>
<P>
The group of divisors form the Magma category <TT>DivFun</TT>. The
notional power structure exists as parent but allows no operations.


<H5><A NAME = "4931">FunctionField(G) : DivFun -&gt; FldFun</A></H5>
<BLOCKQUOTE>
Given the group G of divisors of a function field F/k, return F.
</BLOCKQUOTE>
<H5><A NAME = "4932">Places(F) : FldFun -&gt; PlcFun</A></H5>
<BLOCKQUOTE>
The set of places of the algebraic function field F/k.
</BLOCKQUOTE>
<H4><A NAME = "4933">Structure Invariants</A></H4>



<H5><A NAME = "4934">NumberOfSmoothDivisors(n, m, P) : RngIntElt, RngIntElt, SeqEnum[RngElt] -&gt; RngElt</A></H5>
<BLOCKQUOTE>
The number of effective divisors of degree less equal n who consist
of places of degree less equal m only. The sequence element
P[i] contains the (generic)
 number of
places of degree 1 &le;i &le;min { n, m }. The formula used is
described in <A  HREF = "text441.htm#bib_He2">[He&szlig;99]</A>.
</BLOCKQUOTE>
<H5><A NAME = "4935">DivisorOfDegreeOne(F) : FldFunG -&gt; DivFunElt</A></H5>
<BLOCKQUOTE>
A divisor of degree one over the exact constant field of the
global function field F/k.
</BLOCKQUOTE>
<H4><A NAME = "4936">Structure Predicates</A></H4>



<H5>Div1 eq Div2 : DivFun, DivFun -&gt; BoolElt</H5> 

<H5>Div1 ne Div2 : DivFun, DivFun -&gt; BoolElt</H5><P>



<H4><A NAME = "4937">Element Operations</A></H4>



<H5><A NAME = "4938">Arithmetic Operators</A></H5>



<H5>- D : DivFunElt -&gt; DivFunElt</H5><P>

<H5>D1 + D2 : DivFunElt, DivFunElt -&gt; DivFunElt</H5>

<H5>D1 - D2 : DivFunElt, DivFunElt -&gt; DivFunElt</H5>

<H5>k * D : RngIntElt, DivFunElt -&gt; DivFunElt</H5>

<H5>D div k : DivFunElt, RngIntElt -&gt; DivFunElt</H5>

<H5>D mod k : DivFunElt, RngIntElt -&gt; DivFunElt</H5>
<P>

<H5>P + D : PlcFunElt, DivFunElt -&gt; DivFunElt</H5>

<H5>D + P : DivFunElt, PlcFunElt -&gt; DivFunElt</H5>

<H5>D - P : DivFunElt, PlcFunElt -&gt; DivFunElt</H5>

<H5>P - D : PlcFunElt, DivFunElt -&gt; DivFunElt</H5><P>




<H5><A NAME = "4939">Quotrem(D, k) : DivFunElt, RngIntElt -&gt; DivFunElt, DivFunElt</A></H5>
<BLOCKQUOTE>
Returns divisors D<sub>1</sub>, D<sub>2</sub> such that the divisor D = kD<sub>1</sub> + D<sub>2</sub> and the
exponents in D<sub>2</sub> are of absolute value less than |k|. The
operations <TT>div</TT> and <TT>mod</TT> yield D<sub>1</sub> resp. D<sub>2</sub>.
</BLOCKQUOTE>
<H5><A NAME = "4940">GCD(D1, D2) : DivFunElt, DivFunElt -&gt; DivFunElt</A></H5>
<H5>Gcd(D1, D2) : DivFunElt, DivFunElt -&gt; DivFunElt</H5>
<H5>GreatestCommonDivisor(D1, D2) : DivFunElt, DivFunElt -&gt; DivFunElt</H5>
<BLOCKQUOTE>
The greatest common divisor of the divisors D1 and D2.
</BLOCKQUOTE>
<H5><A NAME = "4941">LCM(D1, D2) : DivFunElt, DivFunElt -&gt; DivFunElt</A></H5>
<H5>Lcm(D1, D2) : DivFunElt, DivFunElt -&gt; DivFunElt</H5>
<H5>LeastCommonMultiple(D1, D2) : DivFunElt, DivFunElt -&gt; DivFunElt</H5>
<BLOCKQUOTE>
The least common multiple of the divisors D1 and D2.
</BLOCKQUOTE>
<H5><A NAME = "4942">Equality, Comparison and Membership</A></H5>

<P>
<P>
<P>
<P>
<P>
<P>


<H5>D1 eq D2 : DivFunElt, DivFunElt -&gt; BoolElt</H5>

<H5>D1 ne D2 : DivFunElt, DivFunElt -&gt; BoolElt</H5>





<H5>D1 le D2 : DivFunElt, DivFunElt -&gt; BoolElt</H5>

<H5>D1 lt D2 : DivFunElt, DivFunElt -&gt; BoolElt</H5>

<H5>D1 ge D2 : DivFunElt, DivFunElt -&gt; BoolElt</H5>

<H5>D1 gt D2 : DivFunElt, DivFunElt -&gt; BoolElt</H5>





<H5>D in Div : DivFunElt, DivFun -&gt; BoolElt</H5>

<H5>D notin Div : DivFunElt, DivFun -&gt; BoolElt</H5>




<H5><A NAME = "4943">Predicates on Elements</A></H5>



<H5>IsZero(D) : DivFunElt -&gt; BoolElt</H5>
<P>


<H5>IsEffective(D) : DivFunElt -&gt; BoolElt</H5>

<H5>IsPositive(D) : DivFunElt -&gt; BoolElt</H5>
<P>


<H5>IsSpecial(D) : DivFunElt -&gt; BoolElt</H5>

<H5>IsPrincipal(D) : DivFunElt -&gt; BoolElt, FldFunElt</H5>



<H5><A NAME = "4944">IsCanonical(D) : DivFunElt -&gt; BoolElt, DiffFunElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> iff the divisor D is canonical and a differential having
D as its divisor.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "4945">Example <TT>FldFunG_divisors-simple_rel (H44E35)</TT></A></H3>
We show some simple creations and operations on divisors.
<P>
<P>
<PRE>
&gt; PF&lt;x&gt; := PolynomialRing(GF(13, 2));
&gt; P&lt;y&gt; := PolynomialRing(PF);
&gt; FF1&lt;b&gt; := ext&lt;FieldOfFractions(PF) | y^2 - x&gt;;
&gt; P&lt;y&gt; := PolynomialRing(FF1);
&gt; FF2&lt;d&gt; := ext&lt;FF1 | y^3 - b&gt;;
&gt; CanonicalDivisor(FF2);
Complementary divisor of Divisor in ideal representation:
Ideal of Maximal Equation Order of FF2 over Maximal Equation Order of FF1 over 
Univariate Polynomial Ring in x over GF(13^2)
Generator:
1, Fractional ideal of Maximal Order of FF2 over Maximal Equation Order of FF1 
over Valuation ring of Univariate rational function field over GF(13^2) with 
generator 1/x
Generator:
x^2
&gt; IsCanonical($1);
true
&gt; D := Divisor(b) + Divisor(d);
&gt; E := Divisor(Random(FF2, 2)*MaximalOrderFinite(FF2), 
&gt; Random(FF2, 2)*MaximalOrderInfinite(FF2));
&gt; d := D + E;
&gt; d;
Divisor in reduced representation: 
Dtilde :
Divisor in ideal representation:
Fractional ideal of Maximal Equation Order of FF2 over Maximal Equation Order of
FF1 over Univariate Polynomial Ring in x over GF(13^2)
Basis:
Pseudo-matrix over Maximal Equation Order of FF1 over Univariate Polynomial Ring
in x over GF(13^2)
Ideal of Maximal Equation Order of FF1 over Univariate Polynomial Ring in x over
GF(13^2)
Generator:
1 * ( 1 0 0 ) 
Ideal of Maximal Equation Order of FF1 over Univariate Polynomial Ring in x over
GF(13^2)
Generator:
1 * ( 0 1 0 ) 
Fractional ideal of Maximal Equation Order of FF1 over Univariate Polynomial 
Ring in x over GF(13^2)
Generators:
1
($.1^137*x^12 + $.1^80*x^11 + $.1^22*x^10 + $.1^79*x^9 + $.1^88*x^8 + 
   $.1^138*x^7 + $.1^130*x^6 + $.1^127*x^5 + $.1^163*x^4 + $.1^78*x^3 + 6*x^2 +
   $.1^41*x + $.1^146)/(x^12 + $.1^166*x^11 + $.1^50*x^10 + $.1^136*x^9 + 
   $.1^32*x^8 + $.1^46*x^7 + $.1^134*x^6 + $.1^64*x^5 + 8*x^4 + $.1^93*x^3 + 
   $.1^153*x^2 + $.1^162*x)*b + ($.1^24*x + $.1^153)/(x^11 + $.1^166*x^10 + 
   $.1^50*x^9 + $.1^136*x^8 + $.1^32*x^7 + $.1^46*x^6 + $.1^134*x^5 + 
   $.1^64*x^4 + 8*x^3 + $.1^93*x^2 + $.1^153*x + $.1^162) * ( $.1^161*x^11 + 
   $.1^74*x^10 + $.1^145*x^9 + $.1^72*x^8 + $.1^122*x^7 + $.1^123*x^6 + 3*x^5 +
   $.1^133*x^4 + 2*x^3 + $.1^105*x^2 + $.1^102*x $.1^48*x^11 + $.1^82*x^10 + 
   4*x^9 + $.1^102*x^8 + $.1^145*x^7 + $.1^118*x^6 + $.1^129*x^5 + $.1^102*x^4 
   + $.1^138*x^3 + $.1^146*x^2 + $.1^134*x 1 ) , Ideal of Maximal Order of FF2 
over Maximal Equation Order of FF1 over Valuation ring of Univariate rational 
function field over GF(13^2) with generator 1/x
Basis:
Pseudo-matrix over Maximal Equation Order of FF1 over Valuation ring of 
Univariate rational function field over GF(13^2) with generator 1/x
Ideal of Maximal Equation Order of FF1 over Valuation ring of Univariate 
rational function field over GF(13^2) with generator 1/x
Generator:
1/x^2 * ( 1 0 0 ) 
Ideal of Maximal Equation Order of FF1 over Valuation ring of Univariate 
rational function field over GF(13^2) with generator 1/x
Generators:
1/x^3
($.1^21*x^3 + $.1^86*x^2 + $.1^151*x + $.1^48)/x^6*b + $.1^79/x^3 * ( 0 1 0 ) 
Ideal of Maximal Equation Order of FF1 over Valuation ring of Univariate 
rational function field over GF(13^2) with generator 1/x
Generator:
1/x^3*b * ( 0 0 1 ) ,
r : 0,
A :
Divisor in ideal representation:
Ideal of Maximal Equation Order of FF2 over Maximal Equation Order of FF1 over 
Univariate Polynomial Ring in x over GF(13^2)
Generator:
1, Fractional ideal of Maximal Order of FF2 over Maximal Equation Order of FF1 
over Valuation ring of Univariate rational function field over GF(13^2) with 
generator 1/x
Generators:
x
x,
a : 
(x)^-1 * (b)
</PRE>
A nicer (but potentially more expensive) way to print, would be to ensure the
divisor had a representation as a linear combination of places and exponents.
<P>
<P>
<PRE>
&gt; p, e := Support(d);
&gt; d;
4*(x, (($.1^24*x + 9)*b + ($.1^133*x + $.1^117))*d^2 + (($.1^83*x + $.1^36)*b +
    ($.1^97*x + $.1^2))*d + ($.1^101*x + $.1^165)*b + $.1^108*x) + (x + $.1^102,
    (($.1^141*x + $.1^113)*b + ($.1^157*x + $.1^48))*d^2 + (($.1^94*x + $.1^92)*b
    + ($.1^167*x + $.1^79))*d + ($.1^36*x + $.1^85)*b + $.1^18*x + 6) + (x^2 +
    $.1^47*x + 8, (($.1^19*x^3 + $.1^155*x^2 + $.1^75*x + $.1^106)*b + (8*x^3 +
    $.1^131*x^2 + $.1^125*x + $.1^46))*d^2 + (($.1^86*x^3 + $.1^11*x^2 +
    $.1^141)*b + ($.1^94*x^3 + $.1^127*x^2 + 6*x + $.1^57))*d + ($.1^68*x^3 +
    $.1^82*x^2 + $.1^52*x + $.1^69)*b + $.1^95*x^3 + $.1^55*x^2 + $.1^30*x +
    $.1) + (x^8 + $.1^138*x^7 + $.1^91*x^6 + $.1^59*x^5 + $.1^25*x^4 +
    $.1^74*x^3 + 6*x^2 + $.1^153*x + 5, (($.1^86*x^10 + 12*x^9 + $.1^5*x^8 +
    $.1^7*x^7 + $.1^123*x^6 + $.1^8*x^5 + $.1^77*x^4 + $.1^43*x^3 + $.1^110*x^2
    + $.1^124*x + $.1^51)*b + ($.1^78*x^9 + $.1^105*x^8 + $.1^153*x^7 + 6*x^6 +
    $.1^142*x^5 + $.1^152*x^4 + $.1^54*x^3 + $.1^9*x^2 + $.1^43*x + $.1^37))*d^2
    + (($.1^63*x^10 + $.1^125*x^9 + $.1^156*x^8 + $.1^44*x^7 + $.1^27*x^6 +
    $.1^127*x^5 + $.1^160*x^4 + $.1^46*x^3 + 9*x^2 + 8*x + $.1^37)*b +
    ($.1^99*x^10 + $.1^119*x^9 + $.1^103*x^8 + $.1^25*x^7 + $.1*x^6 +
    $.1^114*x^5 + $.1^133*x^4 + $.1^34*x^3 + $.1^4*x^2 + $.1^40*x + $.1^71))*d +
    ($.1^86*x^10 + $.1^7*x^9 + $.1^142*x^8 + 4*x^7 + $.1^161*x^6 + 2*x^5 +
    $.1^17*x^4 + $.1^50*x^3 + $.1^100*x^2 + $.1^144*x + $.1^12)*b + $.1^31*x^10
    + $.1^40*x^9 + 8*x^8 + 9*x^7 + $.1^39*x^6 + $.1^120*x^5 + $.1^114*x^4 +
    $.1^116*x^3 + $.1^43*x^2 + $.1^103*x + $.1^93) - 15*(1/x, (($.1^114*x^2 +
    $.1^96*x + 12)/x^3*b + ($.1^153*x^2 + 4*x + 12)/x^3)*d^2 + (($.1^17*x^2 +
    $.1^124*x + 12)/x^3*b + ($.1^159*x^2 + $.1^124*x + 12)/x^3)*d + ($.1^159*x^2
    + 6*x + 12)/x^3*b + ($.1^21*x + 12)/x^2)
&gt; g := GCD(D, E);
&gt; l := LCM(D, E);
&gt; g + l eq d;
true
&gt; g le D;
true
&gt; l ge E;
true
</PRE>
<HR>
<H5><A NAME = "4946">Other Element Operations</A></H5>



<H5><A NAME = "4947">FunctionField(D) : DivFunElt -&gt; FldFun</A></H5>
<BLOCKQUOTE>
Given a divisor D, return the function field.
</BLOCKQUOTE>
<H5><A NAME = "4948">Degree(D) : DivFunElt -&gt; RngIntElt</A></H5>
<BLOCKQUOTE>
The degree of the divisor D over k, the constant field of definition.
</BLOCKQUOTE>
<H5><A NAME = "4949">Support(D) : DivFunElt -&gt; [ PlcFunElt ]</A></H5>
<BLOCKQUOTE>
A sequence containing the places occurring in the divisor D.
</BLOCKQUOTE>
<H5><A NAME = "4950">Numerator(D) : DivFunElt -&gt; DivFunElt</A></H5>
<H5>ZeroDivisor(D) : DivFunElt -&gt; DivFunElt</H5>
<BLOCKQUOTE>
The numerator of the divisor D.
</BLOCKQUOTE>
<H5><A NAME = "4951">Denominator(D) : DivFunElt -&gt; DivFunElt</A></H5>
<H5>PoleDivisor(D) : DivFunElt -&gt; DivFunElt</H5>
<BLOCKQUOTE>
The denominator of the divisor D.
</BLOCKQUOTE>
<H5><A NAME = "4952">Ideals(D) : DivFunElt  -&gt; RngFunOrdIdl, RngFunOrdIdl</A></H5>
<BLOCKQUOTE>
Create two ideals of the `finite' and `infinite' maximal order respectively corresponding to the divisor D.
</BLOCKQUOTE>
<H5><A NAME = "4953">Norm(D) : DivFunElt -&gt; DivFunElt</A></H5>
<BLOCKQUOTE>
The divisor of the norms of the ideals of the divisor D.
</BLOCKQUOTE>
<H5><A NAME = "4954">FiniteSplit(D) : DivFunElt -&gt; DivFunElt, DivFunElt</A></H5>
<H5>FiniteDivisor(D) : DivFunElt -&gt; DivFunElt</H5>
<H5>InfiniteDivisor(D) : DivFunElt -&gt; DivFunElt</H5>
<BLOCKQUOTE>
Split the divisor D into its finite and infinite part, returning either
2 divisors which are the sum of the finite places in D and the sum of 
the infinite places in D or the appropriate one of these. 
</BLOCKQUOTE>
<H5><A NAME = "4955">Dimension(D) : DivFunElt -&gt; RngIntElt</A></H5>
<BLOCKQUOTE>
The dimension of the Riemann-Roch space (L)(D) of the divisor D
over k, 
the constant field of definition.
</BLOCKQUOTE>
<H5><A NAME = "4956">IndexOfSpeciality(D) : DivFunElt -&gt; RngIntElt</A></H5>
<BLOCKQUOTE>
The index of speciality of the divisor D, which equals the dimension of 
(L)(W - D) where W is a canonical divisor.
</BLOCKQUOTE>
<H5><A NAME = "4957">ShortBasis(D : parameters) : DivFunElt -&gt; [RngElt], [RngIntElt]</A></H5>

<PRE>    Reduction: BoolElt                  Default: <TT>true</TT></PRE>

<PRE>    Simplification: MonStgElt           Default: "Full"</PRE>
<BLOCKQUOTE>
Compute a basis for the Riemann-Roch space of D in short form:
<P>
Let F = k(x, y) be an algebraic function field defined by
f(x, y)=0 over k.  Given a divisor D of F/k this
function returns a basis of the k-vector space (L)(D) = { a &isin;F<sup> x </sup> | (a) &ge; - D } &cup;{ 0 }
in the short form B = [  b<sub>1</sub> ..., b<sub>n</sub>  ],  [  d<sub>1</sub>, ..., 
d<sub>n</sub>  ] with b<sub>i</sub> &isin;F<sup> x </sup> and d<sub>i</sub> &isin;Z for all 
1 &le;i &le;n, where n
denotes the degree in y of the defining equation f of
F, such that (L)(D) = { &sum;<sub>i=1</sub><sup>n</sup>
&lambda;<sub>i</sub> b<sub>i</sub> | &lambda;<sub>i</sub> &isin;k[x]  (with  deg )
&lambda;<sub>i</sub> &le;d<sub>i</sub>  (for ) 1 &le;i &le;n }.
<P>
The optional argument <TT>Reduction</TT> controls whether to use
divisor reduction internally or not; it defaults to <TT>true</TT>.
For small divisors this is sometimes faster.
<P>
The optional argument <TT>Simplification</TT> controls whether the
resulting basis is simplified or not; it defaults to <TT>"Full"</TT>.
Simplification sometimes is not insignificantly expensive and can be avoided
by setting the parameter to <TT>"None"</TT>.
<P>
The algorithm is described in <A  HREF = "text441.htm#bib_He2">[He&szlig;99]</A>.
</BLOCKQUOTE>
<H5><A NAME = "4958">Basis(D : parameters) : DivFunElt -&gt; [ FldFunElt ]</A></H5>

<PRE>    Reduction: BoolElt                  Default: <TT>true</TT></PRE>

<PRE>    Simplification: MonStgElt           Default: "Full"</PRE>
<BLOCKQUOTE>
A sequence containing a basis of the Riemann-Roch space (L)(D),
for the divisor D.
<P>
The optional argument <TT>Reduction</TT> controls whether to use
divisor reduction internally or not; it defaults to <TT>true</TT>. 
For small divisors this is sometimes faster.
<P>
The optional argument <TT>Simplification</TT> controls whether the
resulting basis is simplified or not; it defaults to <TT>"Full"</TT>.
Simplification sometimes is not insignificantly expensive and can
be avoided by setting the parameter to <TT>"None"</TT>.
</BLOCKQUOTE>
<H5><A NAME = "4959">RiemannRochSpace(D) : DivFunElt -&gt; ModFld, Map</A></H5>
<H5>RiemannRochSpace(P) : PlcFunElt -&gt; ModFld, Map</H5>
<BLOCKQUOTE>
Given a function field F/k and a divisor D belonging to F/k, return
a vector space V and a k-linear mapping h: V -&gt; F
such that V is isomorphic to the Riemann-Roch space (L)(D)
&sub;F under h.
</BLOCKQUOTE>
<H5><A NAME = "4960">Valuation(D, P) : DivFunElt, PlcFunElt -&gt; RngIntElt</A></H5>
<BLOCKQUOTE>
The exponent of the place P in the divisor D.
</BLOCKQUOTE>
<H5><A NAME = "4961">Reduction(D) : DivFunElt -&gt; DivFunElt, RngIntElt, DivFunElt, FldFunElt</A></H5>
<H5>Reduction(D, A) : DivFunElt, DivFunElt -&gt; DivFunElt, RngIntElt, DivFunElt, FldFunElt</H5>
<BLOCKQUOTE>
Let D be a divisor. Denote the result of both functions by
tilde(D), r, A and a (for the second function the input A always
equals the output A). The divisor A has (must have) positive degree and the
following holds:
<DL COMPACT class='compact'>
<DT>(i)</DT><DD>D = tilde(D) + rA - (a),
<DT>(ii)</DT><DD>tilde(D) &ge;0 and deg(tilde(D)) &lt; g + deg(A)
(over the exact constant field),
<DT>(iii)</DT><DD>tilde(D) has minimal degree among all such 
divisors satisfying (i), (ii).</DL>
</BLOCKQUOTE>
<H5><A NAME = "4962"></A><A NAME = "DivFunElt:GapNumbers">GapNumbers</A>(D, P) : DivFunElt, PlcFunElt -&gt; SeqEnum[RngIntElt]</H5>
<BLOCKQUOTE>
The sequence of gap numbers of the divisor D at P
where P must be a place of degree one:
<P>
Let F/k be an algebraic function field, D a divisor and
P a place of degree one. An integer m &ge;1 is a gap number of
D at P if dim bigl( D + (m - 1)P bigr) = dim(D + mP)
holds. The gap numbers m of D satisfy 1 &le;m &le;2g - 1 - deg(D)
and their cardinality equals the index of speciality i(D). <TT>GapNumbers(D, P)</TT> returns such a particular sequence.  The sequences
of gap numbers of D at various P are independent of constant field
extensions for perfect k and are the same for all but a finite
number of places P of degree one (consider e.g. k algebraically
closed). If P is omitted in the function call, this uniform sequence
is returned by <TT>GapNumbers(D)</TT>. The places P where D has
different sequences of gap numbers are called Weierstra&szlig; places of
D and are returned by <TT>WeierstrassPlaces(D)</TT>. In the above
mentioned functions it is equivalent to replace D by either F or
the zero divisor.
</BLOCKQUOTE>
<H5><A NAME = "4963">GapNumbers(D) : DivFunElt -&gt; SeqEnum[RngIntElt]</A></H5>

<PRE>    SeparatingElement: FldFunGElt       Default: </PRE>
<BLOCKQUOTE>
The sequence of global gap numbers of the divisor D. A
separating element used internally for the computation can be
specified, it defaults to <TT>SeparatingElement(F)</TT>. See the
description of <A  HREF = "text456.htm#DivFunElt:GapNumbers">GapNumbers</A>.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "4964">Example <TT>FldFunG_divisors (H44E36)</TT></A></H3>
<P>
Consider the function field F defined by the curve
of genus 7 defined by
<P>
y<sup>4</sup> + (2 * x<sup>5</sup> + x<sup>4</sup> + 2 * x<sup>3</sup> + x<sup>2</sup>) * y<sup>2</sup> + x<sup>8</sup> + 2 * x<sup>6</sup> + x<sup>5</sup> + x<sup>4</sup> + x<sup>3</sup> + x<sup>2</sup>
<P>
We construct the function field F/GF(9) and compute the Riemann-Roch space 
corresponding to a certain divisor.
<P>
<P>
<P>
<PRE>
&gt; k&lt;w&gt; := GF(9);
&gt; R&lt;x&gt; := FunctionField(k);
&gt; P&lt;y&gt; := PolynomialRing(R);
&gt; f := y^4 + (2*x^5 + x^4 + 2*x^3 + x^2)*y^2 + x^8 
&gt;      + 2*x^6 + x^5 +x^4 + x^3 + x^2;
&gt; F&lt;a&gt; := FunctionField(f);
&gt; Genus(F);
7
&gt; P1 := RandomPlace(F, 1);
&gt; P2 := RandomPlace(F, 1);
&gt; D := P1 - P2;
&gt; D;
(1/x, w^7/x^7*a^3 + w^5/x^5*a^2 + w^3/x^2*a + w) - (x, 2/(x^4 + x^2 + 2*x)*a^3 +
    w^3/x*a^2 + (w^5*x^3 + w^3*x + w^7)/(x^3 + x + 2)*a + w^5)
&gt; IsPrincipal(336*D);
true
&gt; infty := Poles(F!x)[1];
&gt; V, h := RiemannRochSpace(11*infty);
&gt; V;
KModule V of dimension 5 over GF(3^2)
&gt; h;
Mapping from: ModFld: V to FldFun: F
&gt; B := h(Basis(V));                       
&gt; B;
[
    x/(x^3 + x + 2)*a^3 + (2*x^4 + 2*x^3 + x)/(x^3 + x + 2)*a,
    1/(x^3 + x + 2)*a^3 + (2*x^3 + 2*x^2 + 1)/(x^3 + x + 2)*a,
    a^2 + 2*x^3 + 2*x^2,
    1/x*a^2 + 2*x^2 + 2*x,
    1
]
&gt; (B[2] + 2*B[3])@@h;
(    0     1     2     0     0)
</PRE>
<HR>
<H3><A NAME = "4965">Example <TT>FldFunG_AlgReln1 (H44E37)</TT></A></H3>
As a trivial but illustrative example we consider the 
algebraic function field generated by sin(x) and cos(x) over Q 
and construct a single function a(x) such that sin(x) and cos(x) 
can be expressed in terms of a(x):
<P>
<P>
<P>
<PRE>
&gt; Qc&lt;c&gt; := PolynomialRing(RationalField());
&gt; Qcs&lt;s&gt; := PolynomialRing(Qc);
&gt; F&lt;s&gt; := FunctionField(s^2 + c^2 - 1);
&gt; c := F!c;
&gt; Genus(F);
0
&gt; Zeros(s);
[ (c - 1, s), (c + 1, s) ]
&gt; Zeros(c-1);
[ (c - 1, s) ]
&gt; P := Zeros(c-1)[1];
&gt; Degree(P);
1
&gt; Dimension(1*P);
2
&gt; Basis(1*P);
[ 1/(c - 1)*s, 1 ]
&gt; a := Basis(1*P)[1];
&gt; Degree(a);
1
&gt; MinimalPolynomial(a);
$.1^2 + (c + 1)/(c - 1)
&gt; (a^2 - 1)/(a^2 + 1);
c
&gt; a * ((a^2 - 1)/(a^2 + 1) - 1);
s
</PRE>
<HR>
<H3><A NAME = "4966">Example <TT>FldFunG_AlgReln2 (H44E38)</TT></A></H3>
<P>
Over Q(i) the familiar identities 
cos(x) = (exp(ix) + exp( - ix))/2 
sin(x) = (exp(ix) - exp( - ix))/(2i). 
hold. In Magma one can proceed as follows:
<P>
<P>
<P>
<PRE>
&gt; Qx&lt;x&gt; := PolynomialRing(RationalField());
&gt; k&lt;i&gt; := NumberField(x^2 + 1);
&gt; kc&lt;c&gt; := PolynomialRing(k);
&gt; kcs&lt;s&gt; := PolynomialRing(kc);
&gt; F&lt;s&gt; := FunctionField(s^2 + c^2 - 1);
&gt; c := F!c;
&gt; Genus(F);
0
&gt; e := c + i*s;
&gt; ebar := c - i*s;
&gt; Degree(e);
1
&gt; c eq (e + ebar) / 2; 
true
&gt; s eq (e - ebar) / (2*i);
true
</PRE>
<HR>
<H5><A NAME = "4967"></A><A NAME = "DivFunElt:RamificationDivisor">RamificationDivisor</A>(D) : DivFunElt -&gt; DivFunElt</H5>

<PRE>    SeparatingElement: FldFunGElt       Default: </PRE>
<BLOCKQUOTE>
The ramification divisor of the divisor D (using <TT>SeparatingElement</TT>
for the computation which defaults to <TT>SeparatingElement(F)</TT> for
F/k the function field of D):
<P>
Let F/k be an algebraic function field, x a separating
variable and D a divisor. The ramification divisor of D is defined
to be  i(D)  ( W - D ) + bigl( W<sub>x</sub>(D) bigr) + &nu;  (dx),
where W is a canonical divisor of F/k, W<sub>x</sub>(D) is the determinant
of the Wronskian matrix of D with respect to x and &nu; is the sum
of the Wronskian orders of D with respect to x. It is effective and
consists of the Weierstra&szlig; places of D.  The constant field k
is required to be exact.
</BLOCKQUOTE>
<H5><A NAME = "4968"></A><A NAME = "DivFunElt:WeierstrassPlaces">WeierstrassPlaces</A>(D) : DivFunElt -&gt; [PlcFunElt]</H5>

<PRE>    SeparatingElement: FldFunGElt       Default: </PRE>
<BLOCKQUOTE>
The Weierstrass places of the divisor D (using <TT>SeparatingElement</TT>
for the computation which defaults to <TT>SeparatingElement(F)</TT> for
F/k the function field of D):
<P>
Let F/k be an algebraic function field, D a divisor and
P a place of degree one. An integer m &ge;1 is a gap number of
D at P if dim bigl( D + (m - 1)P bigr) = dim(D + mP)
holds. The gap numbers m of D at P satisfy 1 &le;m &le;2g - 1 - deg(D) and their cardinality equals the index of speciality
i(D).  The sequences of gap numbers of D are independent of
constant field extensions for perfect k and are the same for all but
a finite number of places P of degree one (consider e.g. k
algebraically closed). The places P of degree one at which D has
different sequences of gap numbers are called Weierstra&szlig; places of
D. <P> This function returns a list of all places of F/k (having
not necessarily degree one) which are lying below Weierstra&szlig;
places of D viewed in F bar(k) / bar(k) (k perfect).  The
constant field k is required to be exact. Note that if the
characteristic of F is positive this function is currently quite
slow for large genus because of <TT>Differentiation()</TT>.
</BLOCKQUOTE>
<H5><A NAME = "4969">IsWeierstrassPlace(D, P) : DivFunElt, PlcFunElt -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Given a divisor D and a degree 1 place P of a function field,
return whether P is a weierstrass place of D.
</BLOCKQUOTE>
<H5><A NAME = "4970"></A><A NAME = "DivFunElt:WronskianOrders">WronskianOrders</A>(D) : DivFunElt -&gt; [RngIntElt]</H5>

<PRE>    SeparatingElement: FldFunGElt       Default: </PRE>
<BLOCKQUOTE>
Let D be a divisor of an algebraic function field F/k with separating
element x and let v<sub>1</sub>, ... v<sub>l</sub> be a basis of (L)(D). For
the differentiation D<sub>x</sub> with respect to x consider the
successively smallest &nu;<sub>1</sub> &le; ... &le;&nu;<sub>l</sub> &isin;Z<sup>&ge;0</sup>
such that the rows D<sub>x</sub><sup>(&nu;<sub>i</sub>)</sup>(v<sub>1</sub>), ..., D<sub>x</sub><sup>(&nu;<sub>i</sub>)</sup>(v<sub>l</sub>), 1
&le;i &le;l are F-linearly independent. The numbers &nu;<sub>1</sub>, ..., &nu;<sub>l</sub> are the Wronskian orders of D with respect to x and
are returned. If D has dimension zero, the empty list is
returned. The constant field k is required to be exact.
<P>
The separating element can be given by setting the <TT>SeparatingElement</TT>
parameter appropriately.
</BLOCKQUOTE>
<H5><A NAME = "4971">ComplementaryDivisor(D) : DivFunElt -&gt; DivFunElt</A></H5>
<BLOCKQUOTE>
Return the complementary divisor D^# of the divisor D. The function
field F/k of D must be a finite extension of a rational function
field k(x). The divisor D^# equals Diff(F/k(x)) - D for F the
function field of D and Diff(F/k(x)) the different divisor
of F/k(x).
</BLOCKQUOTE>
<H5><A NAME = "4972">DifferentialBasis(D) : DivFunElt -&gt; [DiffFunElt]</A></H5>
<BLOCKQUOTE>
A basis of the space of differentials of the divisor D. See 
<A  HREF = "text457.htm#Differentials:Subspaces:DifferentialBasis">DifferentialBasis</A> for details.
</BLOCKQUOTE>
<H5><A NAME = "4973">DifferentialSpace(D) : DivFunElt -&gt; ModFld, Map</A></H5>
<BLOCKQUOTE>
A vector space and the isomorphism from this space to the differential space
of the divisor D.
</BLOCKQUOTE>
<H5><A NAME = "4974">Parametrization(F, D) : FldFun, DivFunElt -&gt; FldFunElt, [FldFunRatUElt]</A></H5>
<BLOCKQUOTE>
An element x in F which is a non constant element of the basis of the 
divisor D having degree one
and a sequence of elements L in the rational function field are
returned such that x generates the function field 
F over the constant field and L
contains the images of the generators of F over its constant field in
the rational function field.
</BLOCKQUOTE>
<H4><A NAME = "4975">Functions related to Divisor Class Groups of Global Function Fields</A></H4>

<P>
<P>
<P>
Let F/k be a global function field. The group of divisor classes is
isomorphic to the product of a copy of Z and the group of divisors
classes of degree zero which is a finite abelian group. Magma features
an algorithm to compute the divisor class group by computing an
abelian group G in the form Z/c<sub>1</sub>Z x ... x Z/c<sub>2g</sub>Z x Z with integers c<sub>1</sub> | ... | c<sub>2g</sub> and a
surjective homomorphism f: Div(F) -&gt; G from the divisor
group to G whose kernel consists precisely of the principal
divisors. <P>
<P>
The algorithm employed is a randomized index calculus style method of
expected subexponential running time for "small" constant field size
and "large" genus. A description of this and other algorithms of
this section can be found in <A  HREF = "text441.htm#bib_He2">[He&szlig;99]</A>.
<P>
Elements in product representation may result from applying the maps
returned by some of the computations below. It can be expensive to put these
elements into sets and to test them for equality.


<H5><A NAME = "4976">ClassGroupGenerationBound(q, g) : RngIntElt, RngIntElt -&gt; RngIntElt</A></H5>
<BLOCKQUOTE>
A bound B such that the places of degree (over the exact constant
field) less than or equal to B, taken together with the places of a
divisor of degree one, generate the whole divisor class group of any global
function field of genus g over the exact constant field of q elements.
</BLOCKQUOTE>
<H5><A NAME = "4977">ClassGroupGenerationBound(F) : FldFunG -&gt; RngIntElt</A></H5>
<BLOCKQUOTE>
A bound B such that all places of degree (over the exact constant
field) less than or equal to B, taken together with the places of a
divisor of degree one, generate the whole divisor class group of the function
field F.
Particular properties of the function field are taken into account.
</BLOCKQUOTE>
<H5><A NAME = "4978">ClassNumberApproximation(F, e) : FldFunG, FldReElt -&gt; FldReElt</A></H5>
<BLOCKQUOTE>
An approximation of the class number of the global function field F/k with
multiplicative error less than 1 + e for e &gt; 0. The formula
biggl|  log bigl( h  / q<sup>g</sup>  bigr) - 
          &sum;<sub>r=1</sub><sup>b</sup> q<sup> - r</sup>/r bigl( N<sub>r</sub> - (q<sup>r</sup> + 1) bigl)
           biggr|  &le;  2g q<sup> - b/2</sup> / bigl( (q<sup>1/2</sup> - 1)(b + 1) bigr) 
is used where N<sub>r</sub> denotes the number of places of degree one in the constant
field extension of degree r of F/k.
</BLOCKQUOTE>
<H5><A NAME = "4979">ClassNumberApproximationBound(q, g, e) : RngIntElt, RngIntElt, FldReElt, -&gt; RngIntElt</A></H5>
<BLOCKQUOTE>
Returns an integer B such that all places of degree less than or
equal to B of a global function field of genus g over the exact
constant field of q elements have to be considered in order to
approximate the class number with multiplicative error less than 1 + e
for e &gt; 0.
</BLOCKQUOTE>
<H5><A NAME = "4980"></A><A NAME = "Divisors:Classes:ClassGroup">ClassGroup</A>(F : parameters) : FldFun -&gt; GrpAb, Map, Map</H5>

<PRE>    DegreeBound: RngIntElt              Default: </PRE>

<PRE>    SizeBound: RngIntElt                Default: </PRE>

<PRE>    ReductionDivisor: DivFunElt         Default: </PRE>

<PRE>    Proof: BoolElt                      Default: </PRE>
<BLOCKQUOTE>
The divisor class group of the function field F/k as an abelian group, a map of 
representatives from the class group to the divisor group and the 
homomorphism from the divisor group onto the divisor class group.
<P>
<P>
The optional parameter <TT>DegreeBound</TT> allows to control the
size of the factor basis which consists of all places of degree less
equal <TT>DegreeBound</TT> (plus a small additional amount; the degree is
taken over the exact constant field). If not provided the algorithm tries to
choose an appropriate value.
<P>
<P>
The optional parameter <TT>SizeBound</TT> bounds the size of the
factor basis to not exceed <TT>SizeBound</TT> places. Every time the
factor basis has to be enlarged during the computation it will be by
no more than <TT>SizeBound</TT> additional places. If not provided there
is no bound on the size of the factor basis. Every enlargement of
the factor basis will append all places of the next degree.
<P>
<P>
The optional parameter <TT>ReductionDivisor</TT> contains the
reduction divisor used in the relation search stage. Reasonable
choices are divisors of small positive degree. If not provided the
algorithm tries to choose an appropriate reduction divisor.
<P>
<P>
The optional parameter <TT>Proof</TT> indicates whether the computed
result should be proven in a proof step. If a small degree bound for
the factor basis is used and the divisor class group happens to be a
product of a large number of cyclic groups the proof step can be very
time consuming and <TT>Proof := false</TT> might be helpful.  Once a value
is given for <TT>Proof</TT> it remains the default value until set
differently. The initial value of <TT>Proof</TT> for every function field
is <TT>true</TT>.
</BLOCKQUOTE>
<H5><A NAME = "4981"></A><A NAME = "Divisors:Classes:ClassGroupAbelianInvariants">ClassGroupAbelianInvariants</A>(F : parameters) : FldFun -&gt; SeqEnum</H5>

<PRE>    DegreeBound: RngIntElt              Default: </PRE>

<PRE>    SizeBound: RngIntElt                Default: </PRE>

<PRE>    ReductionDivisor: DivFunElt         Default: </PRE>

<PRE>    Proof: BoolElt                      Default: </PRE>
<BLOCKQUOTE>
Computes a sequence of integers containing the Abelian invariants
of the divisor class group of the function field F/k.
<P>
<P>
The optional parameters are the same as for <TT>ClassGroup</TT>.
</BLOCKQUOTE>
<H5><A NAME = "4982">ClassNumber(F) : FldFun -&gt; RngIntElt</A></H5>
<BLOCKQUOTE>
The order of the group of divisor classes of degree zero of the function field F/k.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "4983">Example <TT>FldFunG_divisors-class (H44E39)</TT></A></H3>
Some class group calculations :
<P>
<P>
<PRE>
&gt; Y&lt;t&gt; := PolynomialRing(Integers());
&gt; R&lt;x&gt; := FunctionField(GF(9));
&gt; P&lt;y&gt; := PolynomialRing(R);
&gt; f := y^3 + y + x^5 + x + 1;
&gt; F&lt;alpha&gt; := FunctionField(f);
&gt; ClassNumberApproximation(F, 1.3);
24890.25505701632912193514
&gt; ClassGroup(F);
Abelian Group isomorphic to Z/13 + Z/13 + Z/13 + Z/13 + Z
Defined on 5 generators
Relations:
    13*$.1 = 0
    13*$.2 = 0
    13*$.3 = 0
    13*$.4 = 0
Mapping from: Abelian Group isomorphic to Z/13 + Z/13 + Z/13 + Z/13 + Z
Defined on 5 generators
Relations:
    13*$.1 = 0
    13*$.2 = 0
    13*$.3 = 0
    13*$.4 = 0 to Divisor group of F
Mapping from: Divisor group of F to Abelian Group isomorphic to Z/13 + Z/13 + 
Z/13 + Z/13 + Z
Defined on 5 generators
Relations:
    13*$.1 = 0
    13*$.2 = 0
    13*$.3 = 0
    13*$.4 = 0 given by a rule
&gt; ClassNumber(F);
28561
&gt; Evaluate(LPolynomial(F), 1);
28561
</PRE>
<HR>
<H5><A NAME = "4984">GlobalUnitGroup(F) : FldFun -&gt; GrpAb, Map</A></H5>
<BLOCKQUOTE>
The group of global units of the function field F/k, i. e. the multiplicative group of
the exact constant field, as an Abelian group, together with the map
into F.
</BLOCKQUOTE>
<H5><A NAME = "4985">IsGlobalUnit(a) : FldFunElt -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Whether the function field element a is a global unit, i.e. a constant (equivalent to <TT>IsConstant</TT>).
</BLOCKQUOTE>
<H5><A NAME = "4986">IsGlobalUnitWithPreimage(a) : FldFunElt -&gt; BoolElt, GrpAbElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> and the preimage of the function field element 
a in the global unit group, <TT>false</TT> otherwise.
</BLOCKQUOTE>
<H5><A NAME = "4987">PrincipalDivisorMap(F) : FldFunG -&gt; Map</A></H5>
<BLOCKQUOTE>
The map from the multiplicative group of the function field to the group of 
divisors.
</BLOCKQUOTE>
<H5><A NAME = "4988">ClassGroupExactSequence(F) : FldFunG -&gt; Map, Map, Map</A></H5>
<BLOCKQUOTE>
Returns the three maps in the center of the exact sequence 
 0 -&gt; k<sup> x </sup> -&gt; F<sup> x </sup> -&gt; Div -&gt; Cl -&gt; 0 where k<sup> x </sup> is the global unit group of 
the function field, F<sup> x </sup> is the multiplicative group of 
the function field, Div is the divisor group and Cl is the divisor 
class group.
</BLOCKQUOTE>
<H5><A NAME = "4989">SUnitGroup(S) : SetEnum[PlcFunElt] -&gt; GrpAb, Map</A></H5>
<BLOCKQUOTE>
The group of S-units as an Abelian group and the map into 
the function field, where S is a sequence of places of a function field.
</BLOCKQUOTE>
<H5><A NAME = "4990">IsSUnit(a, S) : FldFunElt, SetEnum[PlcFunElt] -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if the function field element
a is an S-unit for the sequence of places S, <TT>false</TT> otherwise.
</BLOCKQUOTE>
<H5><A NAME = "4991">IsSUnitWithPreimage(a, S) : FldFunElt, SetEnum[PlcFunElt] -&gt; BoolElt, GrpAbElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> and the preimage of the function field element
a in the S-unit group if a is an
S-unit for the sequence of places S, <TT>false</TT> otherwise.
</BLOCKQUOTE>
<H5><A NAME = "4992">SRegulator(S) : SetEnum[PlcFunElt] -&gt; RngIntElt</A></H5>
<BLOCKQUOTE>
The S-Regulator for the sequence of places S.
</BLOCKQUOTE>
<H5><A NAME = "4993">SPrincipalDivisorMap(S) : SetEnum[PlcFunElt] -&gt; Map</A></H5>
<BLOCKQUOTE>
The map from the multiplicative group of the function field to the
group of divisors (mod places in the sequence S).
</BLOCKQUOTE>
<H5><A NAME = "4994">IsSPrincipal(D, S) : DivFunElt, SetEnum[PlcFunElt] -&gt; BoolElt, FldFunElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> and a generator if the divisor
D is principal modulo places in the sequence S, 
<TT>false</TT> otherwise
</BLOCKQUOTE>
<H5><A NAME = "4995">SClassGroup(S) : SetEnum[PlcFunElt] -&gt; GrpAb, Map, Map</A></H5>
<BLOCKQUOTE>
The S-class group for the sequence of places S
as an Abelian group, a map of representatives from the
S-class group to the group of divisors (mod places in S) and the 
homomorphism from the group of divisors (mod places in S) onto the 
S-class group.
</BLOCKQUOTE>
<H5><A NAME = "4996">SClassGroupExactSequence(S) : SetEnum[PlcFunElt] -&gt; Map, Map, Map</A></H5>
<BLOCKQUOTE>
Returns the three maps in the center of the exact sequence  0 -&gt; U(S) -&gt; F<sup> x </sup> -&gt; Div(S) -&gt; Cl(S) -&gt; 0 where U(S) is the S-unit group, F<sup> x </sup>
is the multiplicative group of the function field, Div(S) is the
group of divisors (mod places in the sequence S) and Cl(S) is the S-class
group.
</BLOCKQUOTE>
<H5><A NAME = "4997">SClassGroupAbelianInvariants(S) : SetEnum[PlcFunElt] -&gt; SeqEnum</A></H5>
<BLOCKQUOTE>
Computes a sequence of integers containing the Abelian invariants
of the S-class group for the sequence of places S.
</BLOCKQUOTE>
<H5><A NAME = "4998">SClassNumber(S) : SetEnum[PlcFunElt] -&gt; RngIntElt</A></H5>
<BLOCKQUOTE>
The order of the torsion part of the S-class group for the sequence of places S.
</BLOCKQUOTE>
<H5><A NAME = "4999"></A><A NAME = "Divisors:Classes:ClassGroupPRank">ClassGroupPRank</A>(F) : FldFunG -&gt; RngIntElt</H5>
<BLOCKQUOTE>
Compute the p-rank of the class group of F/k where p is the
characteristic of F/k. More precisely: 
Let F/k be a function field of characteristic p.  Consider the
subgroup Cl<sup>0</sup>(F/k)[p] of p-torsion elements of the group of
divisor classes of degree zero. This function returns its dimension as
an GF(p)-vector space. Possible values range from 0 to g, where
g is the genus of F/k. The field k is currently required to be a finite
field.
</BLOCKQUOTE>
<H5><A NAME = "5000"></A><A NAME = "Divisors:Classes:HasseWittInvariant">HasseWittInvariant</A>(F) : FldFunG -&gt; RngIntElt</H5>
<BLOCKQUOTE>
Return the Hasse--Witt invariant of F/k. More precisely:
Let F/k be a function field of characteristic p.  Let F bar(k) /
bar(k) be the constant field extension by the algebraic closure
bar(k) of k within an algebraic closure bar(F) of F/k.
Consider the subgroup Cl<sup>0</sup>(F bar(k) / bar(k))[p] of p-torsion
elements of the group of divisor classes of degree zero. This function
returns its dimension as an GF(p)-vector space. Possible values
range from 0 to g, where g is the genus of F/k. k is
required to be perfect.
</BLOCKQUOTE>
<H5><A NAME = "5001">TateLichtenbaumPairing(D1, D2, m) : DivFunElt, DivFunElt, RngIntElt -&gt; RngElt</A></H5>
<BLOCKQUOTE>
The Tate--Lichtenbaum pairing Cl<sub>0</sub>[m] x Cl<sub>0</sub>/mCl<sub>0</sub> -&gt; k
for coprime divisors D1 and D2.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "5002">Example <TT>FldFunG_tate (H44E40)</TT></A></H3>
<P>
<P>
<PRE>
&gt; k&lt;w&gt; := GF(9);
&gt; R&lt;x&gt; := FunctionField(k);
&gt; P&lt;y&gt; := PolynomialRing(R);
&gt; f := y^4 + (2*x^5 + x^4 + 2*x^3 + x^2)*y^2 +
&gt;             x^8 + 2*x^6 + x^5 + x^4 + x^3 + x^2;
&gt; F&lt;a&gt; := FunctionField(f);
&gt; D1 := Zeros(a)[1] - Poles(F!x)[1];
&gt; D2 := Zeros(a)[4] - Poles(F!x)[2];
&gt; G,mapfromG,maptoG:=ClassGroup(F : Proof:=false);
&gt; Order(maptoG(D1));
48
&gt; Order(maptoG(D2));
336
&gt; TateLichtenbaumPairing(D1,D2,48);
w^7
&gt; TateLichtenbaumPairing(D2,D1,336);
w^3
</PRE>
<HR>
<PRE></PRE> <A  HREF = "text457.htm">[Next]</A><A  HREF = "text455.htm">[Prev]</A> <A  HREF = "text457.htm">[Right]</A> <A  HREF = "text455.htm">[Left]</A> <A  HREF = "text442.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<br><small>Version: V2.22 of <I>
Thu Jun  9 16:37:49 EST 2016
</I></small>
</body></html>