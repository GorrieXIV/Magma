<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <link rel='stylesheet' href='help.css' type='text/css'>
  <TITLE>Operations</TITLE>
</head>
<body BGCOLOR="#FFFFFF">

 <A  HREF = "text124.htm">[Next]</A><A  HREF = "text121.htm">[Prev]</A> [_____] <A  HREF = "text121.htm">[Left]</A> <A  HREF = "text120.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<PRE></PRE><H3><A NAME = "898">Operations</A></H3>



<H5><A NAME = "899">AssociativeArray(): -&gt; Assoc</A></H5>
<BLOCKQUOTE>
Create the null associative array with no index universe.
The first assignment to the array will determine its index universe.
</BLOCKQUOTE>
<H5><A NAME = "900">AssociativeArray(I): Str -&gt; Assoc</A></H5>
<BLOCKQUOTE>
Create the empty associative array with index universe I.
</BLOCKQUOTE>
<H5><A NAME = "901">A[x] := y : Assoc, Elt, Elt -&gt;</A></H5>
<BLOCKQUOTE>
Set the value in A associated with index x to be y.
If x is not coercible into the current index universe I of A,
then an attempt is first made to lift the index universe of A to
contain both I and x.
</BLOCKQUOTE>
<H5><A NAME = "902">A[x] : Assoc, Elt -&gt; Elt</A></H5>
<BLOCKQUOTE>
Given an index x coercible into the index universe I of A, return the
value associated with x.  If x is not in the keys of A,
then an error is raised.
</BLOCKQUOTE>
<H5><A NAME = "903">IsDefined(A, x) : Assoc, Elt -&gt; Bool, Elt</A></H5>
<BLOCKQUOTE>
Given an index x coercible into the index universe I of A, return whether
x is currently in the keys of A and if so, return also the value A[x].
</BLOCKQUOTE>
<H5><A NAME = "904">Remove(~A, x) : Assoc, Elt -&gt;</A></H5>
<BLOCKQUOTE>
(Procedure.)  Destructively remove the value indexed by x from the
array A.  If x is not present as an index, then nothing happens
(i.e., an error is not raised).
</BLOCKQUOTE>
<H5><A NAME = "905">Universe(A): Assoc -&gt; Str</A></H5>
<BLOCKQUOTE>
Given an associative array A, return the index universe I of A, in
which the keys of A currently lie.
</BLOCKQUOTE>
<H5><A NAME = "906">Keys(A): Assoc -&gt; SetEnum</A></H5>
<BLOCKQUOTE>
Given an associative array A, return the current keys of A as a set.
Warning: this constructs a new copy of the set of keys, so should only 
be called when that is needed.  It is not meant to be used as a quick access
function.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "907">Example <TT>Assoc_InvarField1 (H13E1)</TT></A></H3>
This example shows simple use of associative arrays.  First we create
an array indexed by rationals.
<P>
<P>
<PRE>
&gt; A := AssociativeArray();
&gt; A[1/2] := 7;             
&gt; A[3/8] := "abc";
&gt; A[3] := 3/8;
&gt; A[1/2];
7
&gt; IsDefined(A, 3);
true 3/8
&gt; IsDefined(A, 4);
false
&gt; IsDefined(A, 3/8);
true abc
&gt; Keys(A);
{ 3/8, 1/2, 3 }
&gt; for x in Keys(A) do x, A[x]; end for;
1/2 7
3/8 abc
3 3/8
&gt; Remove(~A, 3/8);
&gt; IsDefined(A, 3/8);
false
&gt; Keys(A);
{ 1/2, 3 }
&gt; Universe(A);
Rational Field
</PRE>
We repeat that an associative array can be indexed by elements of any
structure.  We now index an array by elements of the symmetric group S<sub>3</sub>.
<P>
<P>
<PRE>
&gt; G := Sym(3);
&gt; A := AssociativeArray(G);
&gt; v := 1; for x in G do A[x] := v; v +:= 1; end for;
&gt; A;
Associative Array with index universe GrpPerm: G, Degree 3, Order 2 * 3
&gt; Keys(A);
{
    (1, 3, 2),
    (2, 3),
    (1, 3),
    (1, 2, 3),
    (1, 2),
    Id(G)
}
&gt; A[G!(1,3,2)];
3
</PRE>
<PRE></PRE> <A  HREF = "text124.htm">[Next]</A><A  HREF = "text121.htm">[Prev]</A> [_____] <A  HREF = "text121.htm">[Left]</A> <A  HREF = "text120.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<br><small>Version: V2.22 of <I>
Thu Jun  9 16:37:49 EST 2016
</I></small>
</body></html>