<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <link rel='stylesheet' href='help.css' type='text/css'>
  <TITLE>Vector Enumeration</TITLE>
</head>
<body BGCOLOR="#FFFFFF">

 <A  HREF = "text924.htm">[Next]</A><A  HREF = "text938.htm">[Prev]</A> <A  HREF = "text924.htm">[Right]</A> <A  HREF = "text938.htm">[Left]</A> <A  HREF = "text925.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<PRE></PRE><H3><A NAME = "10589">Vector Enumeration</A></H3>

<P>
<P>
Vector enumeration (originally misnamed module enumeration) is an
algorithm for converting a finitely-presented module for a
finitely-presented algebra into a concrete vector space on which the
algebra has explicit matrix action. The algebra may be the group
algebra of an fp-group, in which case the resulting module will be a
matrix representation of the group, or it might be a more general
fp-algebra, such as a Hecke algebra or a quotient of a polynomial
ring.



<H5>Subsections</H5>
<UL>
<LI> <A  HREF = "text939.htm#10590">Finitely Presented Modules</A>
<LI> <A  HREF = "text939.htm#10591">S-algebras</A>
<LI> <A  HREF = "text939.htm#10592">Finitely Presented Algebras</A>
<LI> <A  HREF = "text939.htm#10593">Vector Enumeration</A>
<LI> <A  HREF = "text939.htm#10595">The Isomorphism</A>
<LI> <A  HREF = "text939.htm#10596">Sketch of the Algorithm</A>
<LI> <A  HREF = "text939.htm#10597">Weights</A>
<LI> <A  HREF = "text939.htm#10598">Setup Functions</A>
<LI> <A  HREF = "text939.htm#10600">The Quotient Module Function</A>
<LI> <A  HREF = "text939.htm#10602">Structuring Presentations</A>
<LI> <A  HREF = "text939.htm#10603">Options and Controls</A>
<LI> <A  HREF = "text939.htm#10604">Weights</A>
<LI> <A  HREF = "text939.htm#10606">Limits</A>
<LI> <A  HREF = "text939.htm#10608">Logging</A>
<LI> <A  HREF = "text939.htm#10610">Miscellaneous</A>
</UL>
<H4><A NAME = "10590">Finitely Presented Modules</A></H4>

<P>
<P>
For a ring R, let M be an R-module M, generated as an R-module by s
elements {m<sub>1</sub>, ..., m<sub>s</sub>}. There is an R-module epimorphism
&psi;: R<sup>s</sup> |-&gt; M, given by (r<sub>1</sub>, ..., r<sub>s</sub>) |-&gt; m<sub>1</sub>r<sub>1</sub> + ... + m<sub>s</sub>r<sub>s</sub>.
This shows that M is isomorphic to  A<sup>s</sup>/ker&psi;.
<P>
If ker&psi; is generated as an R-module by a finite set L then we
will say that M is presented by s generators and the relators
L.


<H4><A NAME = "10591">S-algebras</A></H4>

<P>
<P>
Suppose there is another ring S, equipped with a ring homomorphism
&phi;: S |-&gt; R, such that &phi;(S) is central in R. In this
situation any R-module can be described as an S-module, on which
R acts as a ring of S-module endomorphisms. We say that R is an
S-algebra. In particular, when S is a field k, any R-module is
a k-vector space. If such a module V has finite k-dimension n,
then V is characterised by this dimension and R will act on it as
a subring of M<sub>n</sub>(k).


<H4><A NAME = "10592">Finitely Presented Algebras</A></H4>

<P>
<P>
Given a finite set X, and a ring S, we can define the free
S-algebra A generated by X. This can be seen either as the
monoid algebra of the free monoid of words in X, or as all
expressions in X and k, combined by addition and multiplication.
<P>
Given a finite set R&sub;A we can define 
P = (A/&lt; ARA &gt;).
We say that P is a <I>finitely-presented</I> S-algebra, with
generators X and relators R, and write it
P = &lt; X | R &gt;.
<P>
The monoid algebra of any finitely-presented monoid (or group, of
course) is
finitely-presented, since
k&lt; X | l<sub>1</sub> = r<sub>1</sub>, ..., l<sub>k</sub>=r<sub>k</sub> &gt;_((monoid)) = &lt; X | l<sub>1</sub> - r<sub>1</sub>, ..., l<sub>k</sub> - r<sub>k</sub> &gt;<sub>k- algebra</sub>.
Furthermore, any quotient of a finitely-presented algebra by a
finitely-generated two-sided ideal is finitely-presented. This gives
us the general form of a finitely-presented algebra in Magma, as the
quotient of the monoid algebra of an fp-monoid, by the two-sided ideal
generated by some additional relators.


<H4><A NAME = "10593">Vector Enumeration</A></H4>

<P>
<P>
The vector enumeration algorithm explicitly reconciles these two
descriptions of an R-module, in the case where R is a finitely
presented k-algebra for a field k, and M is a finitely
presented R-module, which also has finite k-dimension. 
<P>
Given the
presentation of R as k-algebra, and that of M as R-module, it
computes the k-dimension  of M and the matrices giving the action
of the generators of R on M. If M has infinite k-dimension the
algorithm will fail to terminate.


<HR>
<H3><A NAME = "10594">Example <TT>AlgFP_Abstract (H87E8)</TT></A></H3>
We consider some examples in the abstract. Below we will see how these
and other calculations may be performed in Magma.
<DL COMPACT class='compact'>
<DT>(1)</DT><DD><B>A permutation module</B>
<P>
</DL>
In practice, it is always better to use the classical Todd-Coxeter
algorithm to construct permutation representations of groups.
<P>
We know that the group with presentation &lt; a, b | a<sup>4</sup> = b<sup>2</sup> =
(ab)<sup>2</sup> = 1 &gt; is the dihedral group of order 8. Its group
algebra over any field k is thus the fp-k-algebra &lt; a, b, a', b' | aa' - 1, a'a - 1, bb' - 1, b'b - 1, a<sup>4</sup> - 1, b<sup>2</sup> - 1, (ab)<sup>2</sup> - 1 &gt;.
The permutation module of degree 4 of this algebra is presented by one
generator (as it is transitive) and the submodule generator b - 1. 
<P>
Applying the algorithm to this case we obtain the matrices
<PRE>
a = [ 0 0 1 0 ]
    [ 1 0 0 0 ]
    [ 0 0 0 1 ]
    [ 0 1 0 0 ]

b = [ 1 0 0 0 ]
    [ 0 0 1 0 ]
    [ 0 1 0 0 ]
    [ 0 0 0 1 ]
</PRE>and their inverses for a' and b'. 
<DL COMPACT class='compact'>
<DT>(2)</DT><DD><B>A quotient of a permutation module</B>
<P>
</DL>
Like all permutation modules, this one fixes the all-ones vector
(1, 1, 1, 1), which we can see to be an image of 1 + a'(1 + b + a'). We can
construct the quotient of the permutation module by this 1-dimensional
submodule by adding that word to the submodule generators. This gives
<DL COMPACT class='compact'>
<PRE>
a = [  0  0  1 ]
    [  1  0  0 ]
    [ -1 -1 -1 ]

b = [  1  0  0 ]
    [  0  0  1 ]
    [  0  1  0 ]
</PRE><DT>(3)</DT><DD><B>A non-cyclic module</B>
<P>
</DL>
A permutation module of a group-ring is cyclic (that is, generated as a
module by one element) just when the permutation representation is
transitive. An intransitive permutation representation can be easily
constructed from its transitive components, but in general it is not
so easy to construct an arbitrary module from cyclic submodules.
Accordingly it can be worthwhile to construct non-cyclic modules
directly. 
<P>
As an example we take two copies of the representation constructed in
example one, and fuse their one-dimensional submodules. The generators
and relators are as before, and now s=2 and the submodule generators
are a<sup>2</sup> =
{(b - 1, 0), (0, b - 1), (1 + a'(1 + a' + b), - 1 - a'(1 + a' + b))}. We obtain a
representation of degree seven, given by
<PRE>
a = [  0  0  0  1  0  0  0 ]
    [  0  0  0  0  0  0  1 ]
    [  1  0  0  0  0  0  0 ]
    [  0  0  0  0  1  0  0 ]
    [  0  0  1  0  0  0  0 ]
    [  0  1  0  0  0  0  0 ]
    [  1 -1  1  1  1 -1 -1 ]

b = [  1  0  0  0  0  0  0 ]
    [  0  1  0  0  0  0  0 ]
    [  0  0  0  1  0  0  0 ]
    [  0  0  1  0  0  0  0 ]
    [  0  0  0  0  1  0  0 ]
    [  0  0  0  0  0  0  1 ]
    [  0  0  0  0  0  1  0 ]
</PRE>
<HR>
<H4><A NAME = "10595">The Isomorphism</A></H4>

<P>
<P>
In determining the k-dimension of M, and giving matrices
representing the action of R on M, the algorithm is, in effect,
constructing a k-vector space, on which R has matrix action, and which
is R-module isomorphic to M, which is formally a quotient module
of R<sup>s</sup>. The algorithm also computes this
isomorphism, giving images in the vector space for the s standard
generators of R<sup>s</sup> and pre-images in R<sup>s</sup> of the basis of the vector space.
<P>
In example (1) above, we find that the module generator has image
(1, 0, 0, 0), while the basis vectors have pre-images 1, a', a'<sup>2</sup>
and b.
<P>
In example (3) the images of the two module generators are (1, 0, 0, 0, 0, 0, 0)
and (0, 1, 0, 0, 0, 0, 0) while the basis vectors are images of (1, 0),
(0, 1), (a', 0) ,(a, 0), (a<sup>2</sup>, 0), (0, a') and (0, a).


<H4><A NAME = "10596">Sketch of the Algorithm</A></H4>

<P>
<P>
The algorithm is based on the Haselgrove-Leech-Trotter (HLT) version
of the Todd-Coxeter algorithm, which we consider as a means of
constructing the permutation representation of a finitely-presented
group on the cosets of a finitely generated subgroup. 
<P>
The algorithm proceeds by manipulating a partial action of the free
algebra on a vector space. This is represented as a table, with
columns indexed by the generators of the algebra, and rows indexed by
the basis of the space. Each entry is either a vector or bot,
signifying that no action is given.
<P>
We can extend this to a "complete action with side-effects", by
adding a new row to the table whenever needed. We call this <I>the
action with defining</I>.
<P>
The action of the fp-algebra P on M gives an action for the free
algebra A, and our objective is to modify out partial action until
it becomes this action. We know certain things about this action,
which drive our modification process:
<DL COMPACT class='compact'>
<DT>1.</DT><DD>It is a complete action.
<DT>2.</DT><DD>The relators of P annihilate every vector.
<DT>3.</DT><DD>The images in the space of the relators of M are zero.
<DT>4.</DT><DD>The space contains images of the R-module generators of M.
<P>
</DL>
The algorithm begins by applying the fourth fact and creating s
linearly independent vectors. It then applies the third, computing the
action with defining of the relators of M (the set called L
above). The fact that these images should be zero gives a linear
dependence among our basis vectors (called a coincidence), which we
use to reduce their number. As we do this, we have to take care not to
lose the information already in the table, which may give rise to
further coincidences.
<P>
We now start to exploit the second fact about M, constructing the
action (with defining) of the relators of P, on the basis vectors,
and applying the resulting coincidences. This process may not
terminate, as we are defining new basis vectors on the one hand, and
removing them through coincidences on the other. It is possible to
prove, however, that if M is in fact finite-dimensional then the
process will terminate.
<P>
The first fact is applied by adding the relators x - x for each x&isin;X to the relators of P, so that the image of every basis vector
under each x is sure to be defined.


<H4><A NAME = "10597">Weights</A></H4>

<P>
<P>
The above sketch leaves open the question of the order in which the
relators are applied to the basis vectors. The proof that the
algorithm completes when M is finite-dimensional imposes some rather
loose constraints, but within these constraints there is considerable 
choice.
<P>
The implementation in Magma uses a system of weights. Each relator
r is assigned a weight w<sub>r</sub> by the user, and each basis vector e
has a weight w<sub>e</sub>.  There is a current weight w, which increases as
the computation progresses, and at weight w all basis vector,
relator pairs (b, r) such that w<sub>b</sub> + w<sub>r</sub> &le;w, which have not been
processed already, are processed. New basis vectors defined during
this process are assigned weight w. The initial basis vectors and those
defined during processing of the submodule generators are assigned
weight 1. See below for details of how to set the weights, and their
default values.


<H4><A NAME = "10598">Setup Functions</A></H4>

<P>
<P>
For V2.11, the following functions create the old representation
for fp-algebras which are necessary for the Vector Enumeration algorithm.
These are compatible with older versions of Magma.
See the examples below for examples of how to use these functions.


<H5><A NAME = "10599">FreeAlgebra(R, M) : Rng, MonFP -&gt; AlgFPOld</A></H5>
<H5>FreeAlgebra(R, G) : Rng, GrpFP -&gt; AlgFPOld</H5>
<BLOCKQUOTE>
Construct the special fp-algebra over the ring R and the monoid M
or the group G, for use in the Vector Enumeration algorithm.
</BLOCKQUOTE>
<H4><A NAME = "10600">The Quotient Module Function</A></H4>



<H5><A NAME = "10601">QuotientModule(A, S) : AlgFPOld, AlgFPOld -&gt; [AlgMatElt], [ModTupFldElt], [AlgFPEltOld]</A></H5>
<BLOCKQUOTE>
Given an fp-k-algebra A, for a field k, with r generators, and
a submodule N of the free A-module of rank s specified by S,
construct an A-module isomorphic to the quotient module A<sup>s</sup>/N
together with the isomorphism.
<P>
The three values returned are:
<DL COMPACT class='compact'>
<DT>M</DT><DD>a sequence of r n x n matrices with entries in
k;
<DT>I</DT><DD>a sequence of s vectors of length n with entries in
k;
<DT>P</DT><DD>a sequence of n elements of the free A-module A<sup>s</sup>.
<P>
</DL>
The matrices M specify a homomorphism from A to End<sub>k</sub>(k<sup>n</sup>),
under which k<sup>n</sup> becomes an A-module isomorphic to A<sup>s</sup>/N.
That isomorphism is given in one direction by the vectors I, which are the images in
k<sup>n</sup> of the s generators (1, 0, ..., 0), (0, 1, 0, ..., 0), ..., (0, ..., 0, 1) of A<sup>s</sup>. In the other direction, the
elements P give representatives for the images in A<sup>s</sup>/N of the
images of the n standard basis elements of k<sup>n</sup>.
<P>
The submodule N may be specified by the parameter S in three ways:
<DL COMPACT class='compact'>
<DT>(1)</DT><DD>S may simply be N, a finitely generated submodule of a
free A-module (except that such an object cannot currently be
created).
<DT>(2)</DT><DD>S may be a finitely generated right ideal of A, in which case s = 1
 and N is S considered as a submodule of A considered as a right
module for itself.
<DT>(3)</DT><DD>S may be a sequence of elements of a free A-module A<sup>s</sup>,
in which case N is the submodule that they generate (this is a stand
in for 1 and could be removed when 1 is implemented).</DL>
</BLOCKQUOTE>
<H4><A NAME = "10602">Structuring Presentations</A></H4>

<P>
<P>
The relations used by the vector enumeration algorithm come from three
sources:
<DL COMPACT class='compact'>
<DT>(1)</DT><DD>The relations of the fp-group or fp-monoid underlying A.
<DT>(2)</DT><DD>The relations of A itself.
<DT>(3)</DT><DD>The generators of N.
<P>
<P>
</DL>
The third group play the same role as subgroup generators in the
Todd-Coxeter algorithm, and are treated specially, while the first
two groups are logically equivalent, forming the relations of A in
the variety of free finitely-generated associative algebras. However,
when the underlying monoid of A is actually an fp-group G, the vector
enumeration algorithm can use a more efficient technique to process the 
relations of G, and can take advantage of the fact that the
generators of G are known to be invertible.
<P>
This greatly improves the performance of the algorithm, and so users
are recommended to ensure as far as possible that:
<DL COMPACT class='compact'>
<DT>(1)</DT><DD>If the underlying monoid of an fp-algebra is in fact an fp-group then it
should be presented to Magma as such.
<DT>(2)</DT><DD>Relations which can be written as equations between monomials
should be given as relations of the underlying monoid, rather than as
relations of the algebra.</DL>


<H4><A NAME = "10603">Options and Controls</A></H4>

<P>
<P>
The <TT>QuotientModule</TT> function supports a large selection of
optional arguments.


<H4><A NAME = "10604">Weights</A></H4>

<P>
<P>
The processing of the relations of A by the vector enumeration
algorithm depends on weights which are assigned to those relations
(see above).
The higher the weight of a relation the later it will be processed. By
default, all relations are given weight 3, except those arising from
relators of an fp-group, which are given weight equal to half the
length of the relator.
<P>
Separate weights are used in lookahead mode, with the same default
values.


<H5><A NAME = "10605">QuotientModule(A, S) : AlgFP, AlgFP -&gt; AlgFP</A></H5>
<BLOCKQUOTE>
<P>
<PRE>
     MonomialWeights: [ RngIntElt ]      Default: 
</PRE>
<P>
<PRE>
     MonWts: [ RngIntElt ]               Default: 
</PRE>
This option sets the sequence of weights for the relations derived from the
relations of the underlying monoid of A. The weights w<sub>1</sub>, w<sub>2</sub>,
etc. are applied to
the relations in the order in which they appear. If there are fewer
weights than relations the remaining relations are assigned the
default weight; if there are more weights than relations the extra
weights are silently discarded.
<P>
Unless the <TT>MonomialLookaheadweights</TT> or <TT>MonLWts</TT> parameters
are present, these weights are also used in lookahead mode.
<P>
<P>
<PRE>
     MonomialLookaheadWeights: [ RngIntElt ] Default: 
</PRE>
<P>
<PRE>
     MonLWts: [ RngIntElt ]              Default: 
</PRE>
This option sets the sequence of weights for the relations derived from the
relations of the underlying monoid of A in lookahead mode only.
It is otherwise similar to <TT>MonomialWeights</TT>.
<P>
<P>
<PRE>
     AlgebraWeights: [ RngIntElt ]       Default: 
</PRE>
<P>
<PRE>
     AlgWts: [ RngIntElt ]               Default: 
</PRE>
This option sets the sequence of weights for the relations given explicitly as
relations of the algebra A.
It is otherwise similar to <TT>MonomialWeights</TT>.
<P>
<P>
<P>
<PRE>
     AlgebraLookaheadWeights: [ RngIntElt ] Default: 
</PRE>
<P>
<PRE>
     AlgLWts: [ RngIntElt ]              Default: 
</PRE>
This option sets the sequence of weights for the relations given explicitly as
relations of the algebra A in lookahead mode only.
It is otherwise similar to <TT>AlgebraWeights</TT>.
</BLOCKQUOTE>
<H4><A NAME = "10606">Limits</A></H4>



<H5><A NAME = "10607">QuotientModule(A, S) : AlgFP, AlgFP -&gt; AlgFP</A></H5>
<BLOCKQUOTE>
Options in this group set limits on the progress of the algorithm. If
the calculation cannot be performed under these constraints the value
<TT>undef</TT> is returned, unless the <TT>ErrorOnFail</TT> option was set,
in which case a run-time error is generated.
<P>
<P>
<PRE>
     MaximumDimension: RngIntElt         Default: &infin;
</PRE>
<P>
<PRE>
     MaxDim: [ RngIntElt ]               Default: &infin;
</PRE>
This sets a limit of n on the dimension of the vector-space
constructed, and on the dimension of the intermediate spaces used in
the construction. 
<P>
By default there is no limit, except for available memory.
<P>
<P>
<PRE>
     MaximumTime: FldReElt               Default: &infin;
</PRE>
<P>
<PRE>
     MaxTime: FldReElt                   Default: &infin;
</PRE>
This sets a limit on the CPU time available for the vector
enumeration. The limit is given as a real number t and is measured
in seconds. 
<P>
This limit is only checked at certain points in the calculation, so it
is possible for a vector enumeration to over-run, possibly by a
significant amount.
<P>
By default, there is no limit.
<P>
<P>
<PRE>
     MaximumWeight: RngIntElt            Default: 100
</PRE>
<P>
<PRE>
     MaxWt: RngIntElt                    Default: 100
</PRE>
This sets a limit on the maximum weight of (basis vector, relation)
pairs that will be used by the algorithm. 
<P>
The weight of a basis vector is the weight of the pair that was being
processed when it was defined. The weight of a pair is the weight of
the basis vector plus the weight of the relation (see above). 
<P>
The default limit is 100.
</BLOCKQUOTE>
<H4><A NAME = "10608">Logging</A></H4>



<H5><A NAME = "10609">QuotientModule(A, S) : AlgFP, AlgFP -&gt; AlgFP</A></H5>
<BLOCKQUOTE>
There are a number of options to control the level of detail provided
in the informational message from the vector enumerator. When multiple
contradictory options are given the first one given takes precedence.
<P>
<PRE>
     NoLogging: BoolElt                  Default: <TT>false</TT>
</PRE>
<P>
<PRE>
     NoLog: BoolElt                      Default: <TT>false</TT>
</PRE>
<P>
<PRE>
     Silent: BoolElt                     Default: <TT>false</TT>
</PRE>
This option turns off all the informational messages produced by the
vector enumerator.
<P>
<P>
<PRE>
     MaximumLogging: BoolElt             Default: <TT>false</TT>
</PRE>
<P>
<PRE>
     MaxLog: BoolElt                     Default: <TT>false</TT>
</PRE>
This option turns on the highest possible level of detail in the
informational messages. This is <I>too detailed</I> for almost all
purposes except debugging.
<P>
<P>
<PRE>
     LogActions: RngIntElt               Default: 0
</PRE>
<P>
<PRE>
     LogAct: RngIntElt                   Default: 0
</PRE>
This option sets the level of messages about the computation of the
action of the algebra on the vector space under construction. At level
0 (the default) no messages are produced. All other levels produce
copious output, with all levels above 2 being equivalent.
<P>
<P>
<PRE>
     LogCoincidences: RngIntElt          Default: 0
</PRE>
<P>
<PRE>
     LogCoin: RngIntElt                  Default: 0
</PRE>
This option sets the level of messages about the coincidences
discovered and the processing of them.
At level 0 (the default)
no messages are produced. At level 1 every coincidence and deduction
is recorded when it is discovered and when it is processed. At level 2
or higher
the operation of finding the undeleted image of a vector is also
recorded.
<P>
<P>
<PRE>
     LogInitialization: RngIntElt        Default: 0
</PRE>
<P>
<PRE>
     LogInitialisation: RngIntElt        Default: 0
</PRE>
<P>
<PRE>
     LogInit: RngIntElt                  Default: 0
</PRE>
This option sets the level of messages about the initialisation of new
basis vectors.
At level 0 (the default)
no messages are produced. All other levels produce a message whenever
a new basis vector is defined.
<P>
<P>
<PRE>
     LogPacking: RngIntElt               Default: 1
</PRE>
<P>
<PRE>
     LogPack: RngIntElt                  Default: 1
</PRE>
This option sets the level of messages about the reclamation of free
space in the tables used by the algorithm. At level 0 no messages are
produced. At level 1 (the default) it produces a message each time the
pack routine is called. At level 2 or higher it records the exact
renaming used to reclaim the space.
<P>
<P>
<PRE>
     LogPushes: RngIntElt                Default: 0
</PRE>
<P>
<PRE>
     LogPush: RngIntElt                  Default: 0
</PRE>
This option sets the level of messages about the pushing (or tracing)
of (basis vector, relation) pairs. At level 0 (the default) it produces
no messages. At level 1 a message is produced for each push that is
started. At level 2 or higher the outcome of the push is also
recorded.
<P>
<P>
<PRE>
     LogProgress: RngIntElt              Default: 0
</PRE>
<P>
<PRE>
     LogStages: RngIntElt                Default: 0
</PRE>
This option sets the level of messages about the overall progress of
the algorithm. At level 0 no messages are produced. At level 1, simple
messages are printed as the algorithm passes through its major stages.
At level 2 the
relations are printed as they are read in, and the complete action on
the final module is printed. At level 3 or higher the action is also
printed after the processing of submodule generators is complete.
<P>
<P>
<PRE>
     LogWeightChanges: RngIntElt         Default: 1
</PRE>
<P>
<PRE>
     LogWt: RngIntElt                    Default: 1
</PRE>
This option sets the level of messages about changes in the current
weight (ie the weight of (basis vector, relation pairs) currently
being pushed. At level 0 no such messages are produced. At level 1
(the default) or higher a message giving the new weight and the current
dimension is printed.
</BLOCKQUOTE>
<H4><A NAME = "10610">Miscellaneous</A></H4>



<H5><A NAME = "10611">QuotientModule(A, S) : AlgFP, AlgFP -&gt; AlgFP</A></H5>
<BLOCKQUOTE>
<P>
<PRE>
     Lookahead: BoolElt                  Default: <TT>true</TT>
</PRE>
This option controls whether, and to what extent, lookahead is used.
If x is <TT>false</TT> then lookahead is not used. If x is <TT>true</TT>,
the default, the lookahead by the default amount (two weights) is
used. If x is a positive  integer n then lookahead n weights is
used. A sufficiently large value of n is equivalent to complete
lookahead. Lookahead is commenced approximately every time the
dimension doubles.
<P>
<P>
<PRE>
     EarlyClosing: BoolElt               Default: <TT>false</TT>
</PRE>
<P>
<PRE>
     Early: BoolElt                      Default: <TT>false</TT>
</PRE>
This option permits the algorithm to stop as soon as the table
represents a complete action (but see below), without checking to see whether the
action satisfies all the relations. In practice this action is usually
correct. The default behaviour is to continue and check all the
relations.
<P>
<P>
<P>
<PRE>
     EarlyClosingMinimum: RngIntElt      Default: 
</PRE>
<P>
<PRE>
     ECMin: RngIntElt                    Default: 
</PRE>
This option sets a minimum dimension at which the algorithm may stop
without checking all the relators. It implies <TT>EarlyClosing</TT>.
<P>
<P>
<P>
<PRE>
     EarlyClosingMaximum: RngIntElt      Default: 
</PRE>
<P>
<PRE>
     ECMax: RngIntElt                    Default: 
</PRE>
This option sets a maximum dimension at which the algorithm aamy stop
without checking all the relators. It implies <TT>EarlyClosing</TT>.
<P>
<P>
<PRE>
     ConstructMorphism: BoolElt          Default: <TT>true</TT>
</PRE>
<P>
<PRE>
     Morphism: BoolElt                   Default: <TT>true</TT>
</PRE>
This option controls whether the third return value of the <TT>QuotientModule</TT> function is in fact computed. A small overhead of time
and space is required to compute it, and many applications do not need
it, so this option is provided. When b is <TT>true</TT> (the default)
the third return value is computed, when b is <TT>false</TT> it is not.
<P>
<P>
<PRE>
     ErrorOnFail: BoolElt                Default: 
</PRE>
<P>
<PRE>
     ErrFail: BoolElt                    Default: 
</PRE>
This option controls the behaviour of the program if there is
insufficient time or space to complete the calculation, or if the
calculation has not been completed when the maximum weight is reached.
If it is present a run-time error is generated, otherwise the value
<TT>undef</TT> is returned.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "10612">Example <TT>AlgFP_PermutationActionD8 (H87E9)</TT></A></H3>
First we repeat the examples above, in Magma.
The permutation action of D<sub>8</sub>
<P>
<P>
<PRE>
&gt; d8&lt;a,b&gt; := Group&lt;a,b | a^ 4 = b^ 2 = (a*b)^ 2 = 1&gt;;
&gt; q := RationalField();
&gt; a1&lt;a,b&gt; := FreeAlgebra(q,d8);
&gt; i1 := rideal&lt;a1 | b-1 &gt;;
&gt; mats, im, preim := QuotientModule(a1,i1);
Read Input
Done submodule generators
Starting weight 2 in define mode, 1 alive out of 2
Starting weight 3 in define mode, 1 alive out of 2
Looking ahead ...
Starting weight 4 in lookahead mode, 4 alive out of 5
Starting weight 5 in lookahead mode, 4 alive out of 5
    ...done
Packing 5 to 4
Starting weight 4 in define mode, 4 alive out of 4
Starting weight 5 in define mode, 4 alive out of 4
Starting weight 6 in define mode, 4 alive out of 4
Starting weight 7 in define mode, 5 alive out of 6
Starting weight 8 in define mode, 6 alive out of 7
Starting weight 9 in define mode, 4 alive out of 7
Starting weight 10 in define mode, 4 alive out of 7
Closed, 7 rows defined
Packing 7 to 4
4 live dimensions
Successful
&gt; mats;
[
    [0 0 1 0]
    [1 0 0 0]
    [0 0 0 1]
    [0 1 0 0],


    [1 0 0 0]
    [0 0 1 0]
    [0 1 0 0]
    [0 0 0 1]
]
&gt; im;
[
    (1 0 0 0)
]
&gt; preim;
[ Id(), a^ -1, a^ -1 * b, a^ -2 ]
&gt;
</PRE>
<HR>
<H3><A NAME = "10613">Example <TT>AlgFP_Quotient (H87E10)</TT></A></H3>
<P>
A quotient of that module.
<P>
We continue from the last example and set:
<P>
<P>
<PRE>
&gt; d8&lt;a,b&gt; := Group&lt;a,b | a^ 4 = b^ 2 = (a*b)^ 2 = 1&gt;;
&gt; q := RationalField();
&gt; a1&lt;a,b&gt; := FreeAlgebra(q,d8);
&gt; i2 := rideal&lt;a1 | b-1, 1+a^ 3+a^ 3*b+a^ 2&gt;; 
&gt; mats, im, preim := QuotientModule(a1,i2);
Read Input
Done submodule generators
Starting weight 2 in define mode, 4 alive out of 6
Starting weight 3 in define mode, 5 alive out of 7
Starting weight 4 in define mode, 3 alive out of 7
Starting weight 5 in define mode, 3 alive out of 7
Closed, 7 rows defined
Packing 7 to 3
3 live dimensions
Successful
&gt; mats;
[
    [ 0  1  0]
    [ 0  0  1]
    [-1 -1 -1],


    [ 1  0  0]
    [-1 -1 -1]
    [ 0  0  1]
]
</PRE>
<PRE></PRE> <A  HREF = "text924.htm">[Next]</A><A  HREF = "text938.htm">[Prev]</A> <A  HREF = "text924.htm">[Right]</A> <A  HREF = "text938.htm">[Left]</A> <A  HREF = "text925.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<br><small>Version: V2.22 of <I>
Thu Jun  9 16:37:49 EST 2016
</I></small>
</body></html>