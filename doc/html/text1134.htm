<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <link rel='stylesheet' href='help.css' type='text/css'>
  <TITLE>Lie Algebras Generated by Extremal Elements</TITLE>
</head>
<body BGCOLOR="#FFFFFF">

 <A  HREF = "text1135.htm">[Next]</A><A  HREF = "text1133.htm">[Prev]</A> <A  HREF = "text1135.htm">[Right]</A> <A  HREF = "text1133.htm">[Left]</A> <A  HREF = "text1130.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<PRE></PRE><H3><A NAME = "12698">Lie Algebras Generated by Extremal Elements</A></H3>

<P>
<P>
<P>
<P>
A non-zero element x of a Lie algebra L over the field K is extremal if [x, [x, y]] &isin;K x for all y &isin;L.
If x is extremal, the existence of a linear map f<sub>x</sub> : L -&gt; K such that [x, [x, y]] = f<sub>x</sub>(y) x for all y &isin;L
immediately follows from linearity of [., .].
<P>
In this section we describe functions for computing with Lie algebras generated by such extremal elements. For a simple connected
undirected finite graph &Gamma; we consider an algebraic variety X over K whose K-points parametrize Lie algebras generated
by extremal elements. Here the generators of the Lie algebras correspond to the vertices of the graph, and we prescribe commutation relations corresponding to the nonedges of &Gamma;.
<P>
Details of the setup may be found in <A  HREF = "text1129.htm#bib_roozemond11">[Roo11]</A>; we describe the essential ingredients here.
<P>
Assume that &Gamma; is a connected undirected finite graph with n vertices, without loops or multiple bonds, and that K is a field of characteristic distinct from 2. We let &Pi; be the vertex set of &Gamma; and denote adjacency of two vertices x, y &isin;&Pi; by i ~j.
<P>
We denote by F(K, &Gamma;) the quotient of the free Lie algebra over K generated by &Pi; modulo the relations [x, y]=0 for all x, y &isin;&Pi; with x not~y. We write F<sup> * </sup> for the space of all K-linear functions on F. For every f &isin;(F<sup> * </sup>)<sup>&Pi;</sup> we denote by L(K, &Gamma;, f) (often abbreviated to L(f)) the quotient of F(K, &Gamma;) by the ideal I( f ) generated by the infinitely many elements [x, [x, y]] - f<sub>x</sub>(y) x  for x &isin;&Pi;, y &isin;F.
<P>
By construction L( f ) is a Lie algebra generated by |&Pi;| = n extremal elements, the extremal generators corresponding to the vertices of &Gamma; and commuting whenever they are not adjacent. The element f<sub>x</sub> &isin;F<sup> * </sup> is a parameter expressing the extremality of x &isin;&Pi;.
<P>
In the Lie algebra L(0) the elements of &Pi; map to sandwich elements. This algebra is finite-dimensional, by <A  HREF = "text1129.htm#bib_ZK90">[ZK90]</A> this Lie algebra is finite-dimensional; for general f &isin;(F<sup> * </sup>)<sup>&Pi;</sup> we have dim(L(f)) &le;dim(L(0)) by <A  HREF = "text1129.htm#bib_CSUW01">[CSUW01, Lemma 4.3]</A>. It is therefore natural to focus on the Lie algebras L( f ) of maximal possible dimension, i.e., those of dimension dim(L(0)). We define the set X := { f &isin;(F<sup> * </sup>)<sup>&Pi;</sup> | dim(L(f)) = dim(L(0)) },  the parameter space for all maximal-dimensional Lie algebras of the form L( f ).
<P>
The functions currently implemented in Magma allow computation of X and L(f), for any f, for the cases where X is an affine space (which is unproven, but true in all currently known cases).
<P>
Lie algebras generated by extremal elements are of type <A NAME = "AlgLieExtr"><TT>AlgLieExtr</TT></A>.
The verbose flag <TT>"AlgLieExtr"</TT> may be set between 1 and 5 to show details and progress of the various computations.



<H5>Subsections</H5>
<UL>
<LI> <A  HREF = "text1134.htm#12699">Constructing Lie Algebras Generated by Extremal Elements</A>
<LI> <A  HREF = "text1134.htm#12702">Properties of Lie Algebras Generated by Extremal Elements</A>
<LI> <A  HREF = "text1134.htm#12714">Instances of Lie Algebras Generated by Extremal Elements</A>
<LI> <A  HREF = "text1134.htm#12718">Studying the Parameter Space</A>
</UL>
<H4><A NAME = "12699">Constructing Lie Algebras Generated by Extremal Elements</A></H4>



<H5><A NAME = "12700"></A><A NAME = "ExtremalLieAlgebraKn">ExtremalLieAlgebra</A>(K, n) : Rng, RngIntElt -&gt; AlgLieExtr</H5>

<PRE>    CommGens: SeqEnum                   Default: []</PRE>

<PRE>    HeisenbergPairs: SeqEnum            Default: []</PRE>
<BLOCKQUOTE>
Construct the Lie algebra over the field K generated by n extremal elements.
The characteristic of K must be distinct from 2.
<P>
The optional argument <TT>CommGens</TT> contains pairs of integers (i, j), with
1 &le;i, j &le;n, describing that generators x<sub>i</sub> and x<sub>j</sub> commute, i.e., [x<sub>i</sub>, x<sub>j</sub>] = 0.
<P>
The optional argument <TT>HeisenbergPairs</TT> contains pairs of integers (i, j), with
1 &le;i &le;n and 1 &le;j &le;dim(L(0)), describing that f<sub>x<sub>i</sub></sub>(b<sub>j</sub>) should
be taken equal to 0. (Note that if it is required to have j &gt; n it would be necessary
to have prior knowledge about the basis of L(0)).
</BLOCKQUOTE>
<H5><A NAME = "12701">ExtremalLieAlgebra(K, G) : Rng, GrphUnd -&gt; AlgLieExtr</A></H5>

<PRE>    HeisenbergPairs: SeqEnum            Default: []</PRE>
<BLOCKQUOTE>
Construct the Lie algebra over the field K whose extremal generators are described
by the graph G, i.e., with |V(G)| generators, and x<sub>i</sub> and x<sub>j</sub> commute whenever
vertices x<sub>i</sub> and x<sub>j</sub> of G are not adjacent.
<P>
See <A  HREF = "text1134.htm#ExtremalLieAlgebraKn">ExtremalLieAlgebra</A> above
for a description of the optional argument <TT>HeisenbergPairs</TT>.
</BLOCKQUOTE>
<H4><A NAME = "12702">Properties of Lie Algebras Generated by Extremal Elements</A></H4>



<H5><A NAME = "12703">NumberOfGenerators(L) : AlgLieExtr -&gt; RngIntElt</A></H5>
<H5>Ngens(L) : AlgLieExtr -&gt; RngIntElt</H5>
<BLOCKQUOTE>
The number of generators of L.
</BLOCKQUOTE>
<H5><A NAME = "12704">CoefficientRing(L) : AlgLieExtr -&gt; Rng</A></H5>
<H5>BaseRing(L) : AlgLieExtr -&gt; Rng</H5>
<BLOCKQUOTE>
The coefficient ring of L. Immediately after construction, this is equal to the field K provided
as argument to <A  HREF = "text1134.htm#ExtremalLieAlgebraKn">ExtremalLieAlgebra</A>. However, after the multiplication table has been
computed (see below), the coefficient ring would in general be a multivariate polynomial ring over K
describing the parameter space.
</BLOCKQUOTE>
<H5><A NAME = "12705">CommutatorGraph(L) : AlgLieExtr -&gt; GrphUnd</A></H5>
<BLOCKQUOTE>
The graph describing the extremal generators of L and their commutator relations.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "12706">Example <TT>AlgLie_AlgLieExtrConstr (H106E11)</TT></A></H3>
We construct a Lie algebra generated by 4 extremal elements in two different manners.
<P>
<P>
<P>
<PRE>
&gt; QQ := Rationals();
&gt; L := ExtremalLieAlgebra(QQ, BipartiteGraph(2,2));
&gt; Ngens(L), CoefficientRing(L);
4 Rational Field
&gt; G := CommutatorGraph(L); G;
Graph
Vertex  Neighbours

1       3 4 ;
2       3 4 ;
3       1 2 ;
4       1 2 ;

&gt; L := ExtremalLieAlgebra(QQ, 4 : CommGens := [&lt;1,2&gt;,&lt;3,4&gt;]);
&gt; Ngens(L), CoefficientRing(L);
4 Rational Field
&gt; G := CommutatorGraph(L); G;
Graph
Vertex  Neighbours

1       3 4 ;
2       3 4 ;
3       1 2 ;
4       1 2 ;
</PRE>
<HR>
<H5><A NAME = "12707">Basis(L) : AlgLieExtr -&gt; SeqEnum[AlgFPLieElt], SeqEnum[UserProgram]</A></H5>
<BLOCKQUOTE>
Compute a monomial basis for L(0) (this is also a monomial basis for L(f) for any f &isin;X; see the introduction
of Section <A  HREF = "text1134.htm#12698">Lie Algebras Generated by Extremal Elements</A>).
<P>
The first return value is a sequence consisting of monomials of the free Lie algebra over K with n generators,
where K is the coefficient ring of L and n is the number of generators. 
The second return value is a sequence consisting of functions c. Each of these functions may be applied to a 
sequence of generators and a composition function. These may be used to construct the basis elements in other environments.
<P>
The algorithm used in this function is due to W. de Graaf.
</BLOCKQUOTE>
<H5><A NAME = "12708">ZBasis(L) : AlgLieExtr -&gt; SeqEnum[AlgFPLieElt], SeqEnum[RngIntElt], SeqEnum[AlgFPLieElt]</A></H5>
<BLOCKQUOTE>
For L a Lie algebra generated by extremal elements over the field of rational numbers, 
compute a basis of the corresponding Lie ring over the integers.
<P>
This function returns three sequences B, T, C, respectively, describing bases for L(0) over <B>any</B> field K.
B is a not necessarily monomial basis, with torsion described by T. It is such that if T[i] is nonzero, m say, then B[i] is zero unless the characteristic of K divides m.
<P>
The third sequence, C, is a sequence of monomials that linearly span L(0) over any field K. Note, however, that if T contains nonzero elements, then C would in general contain superfluous elements and therefore not be a basis.
<P>
The algorithm used in this function is due to W. de Graaf.
The only currently known case with nontrivial torsion is for &Gamma;(L) = K<sub>5</sub>.
</BLOCKQUOTE>
<H5><A NAME = "12709">Dimension(L) : AlgLieExtr -&gt; RngIntElt</A></H5>
<BLOCKQUOTE>
The dimension of L(0). This value is computed via a basis computation, so potentially quite time-consuming.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "12710">Example <TT>AlgLie_AlgLieExtrBasis (H106E12)</TT></A></H3>
We continue the previous example <A  HREF = "text1134.htm#12706">H106E11</A> and demonstrate the computation of a basis of L(0).
<P>
<P>
<PRE>
&gt; B, C := Basis(L); 
&gt; B;
[
    $.1,
    $.2,
    $.3,
    $.4,
    ($.4, $.2),
    ($.4, $.1),
    ($.3, $.2),
    ($.3, $.1),
    ($.4, ($.3, $.2)),
    ($.4, ($.3, $.1)),
    ($.2, ($.4, $.1)),
    ($.2, ($.3, $.1)),
    ($.4, ($.2, ($.3, $.1))),
    ($.3, ($.2, ($.4, $.1))),
    ($.2, ($.4, ($.3, $.1)))
]
&gt; [ c(["x","y","z","u"], func&lt;i,j|i cat j&gt;) : c in C ];
[ x, y, z, u, uy, ux, zy, zx, uzy, uzx, yux, yzx, uyzx, zyux, yuzx ]
&gt; A := FreeAlgebra(Rationals(), 4);
&gt; [ c([A.1,A.2,A.3,A.4], func&lt;x,y|x*y&gt;) : c in C ];
[
    $.1,
    $.2,
    $.3,
    $.4,
    $.4*$.2,
    $.4*$.1,
    $.3*$.2,
    $.3*$.1,
    $.4*$.3*$.2,
    $.4*$.3*$.1,
    $.2*$.4*$.1,
    $.2*$.3*$.1,
    $.4*$.2*$.3*$.1,
    $.3*$.2*$.4*$.1,
    $.2*$.4*$.3*$.1
]
&gt; #B, #C, Dimension(L);
15 15 15
</PRE>
<HR>
<H5><A NAME = "12711"></A><A NAME = "MultiplicationTableLproc">MultiplicationTable</A>(~L) : AlgLieExtr -&gt;</H5>

<PRE>    HowMuch: MonStgElt                  Default: "Auto"</PRE>

<PRE>    MemLimit: RngIntElt                 Default: &infin;</PRE>

<PRE>    FullJacobi: BoolElt                 Default: <TT>false</TT></PRE>
<BLOCKQUOTE>
Force computation of a general multiplication table for L, i.e., one that may be used for constructing
L(f) for any f &isin;X (see the introduction to this section <A  HREF = "text1134.htm#12698">Lie Algebras Generated by Extremal Elements</A>). This computation is
necessary for constructing instances as described in Section <A  HREF = "text1134.htm#12714">Instances of Lie Algebras Generated by Extremal Elements</A>, but it will 
be done automatically if needed. Data about the variety X is computed concurrently and stored 
internally; see Section <A  HREF = "text1134.htm#12718">Studying the Parameter Space</A> for the relevant functions in accessing that information.
<P>
The optional parameters may be used to influence the computation, although the defaults should generally work
well. <TT>HowMuch</TT> may be set to "Auto" (the default), "Top" or "Full" and prescribes whether only the
first <TT>Ngens(L)</TT> rows of the multiplication table are computed ("Top"), or all entries ("Full"). 
If set to "Auto" some fraction of the multiplication table is computed depending on the dimension of L
and the other parameters.
<P>
<TT>MemLimit</TT> may be set to a positive integer m, and if given Magma will attempt to limit its memory
usage to m MB, by limiting the portion of the multiplication table that is being computed.
<P>
<TT>FullJacobi</TT> may be set to <TT>true</TT> in order to force checking the Jacobi identity for all basis elements,
thus providing more certainty with regards to the information about the parameter space X.
Note that even if this parameter is set to <TT>true</TT> a heuristic (Monte-Carlo) method is used, 
as considering all dim(L(0))<sup>3</sup> triples quickly becomes infeasible as the dimension grows.
<P>
The verbose flag <TT>"AlgLieExtr"</TT> may be set to 3 or more to obtain some information about the default 
choices Magma makes with regards to these parameters.
</BLOCKQUOTE>
<H5><A NAME = "12712"></A><A NAME = "MultiplicationTableL">MultiplicationTable</A>(L) : AlgLieExtr -&gt; SeqEnum</H5>

<PRE>    Rep: MonStgElt                      Default: "Auto"</PRE>

<PRE>    Check: BoolElt                      Default: <TT>true</TT></PRE>
<BLOCKQUOTE>
A general multiplication table for L. 
<P>
If <TT>Rep</TT> is set to "Dense" it will be returned as 
a sequence of sequences of vectors over <TT>CoefficientRing(L)</TT>. If <TT>Rep</TT> is set to "Sparse"
it will be returned as a sequence of 4-tuples. If <TT>Rep</TT> is set to "Auto" a choice between
these representations is made depending on dim(L).
Both these representations may be used on the right hand side of the <A  HREF = "text1132.htm#LieAlgebraRnQ">LieAlgebra</A> constructor.
<P>
The optional parameter <TT>Check</TT> controls whether the Jacobi identity is verified for
all triples (if <TT>true</TT> it will actually be checked for all dim(L(0))<sup>3</sup> triples, as opposed to 
the behaviour of the procedural version, <A  HREF = "text1134.htm#MultiplicationTableLproc">MultiplicationTable</A><TT>(~L)</TT>, described above).
<P>
Note that this function is impractical in terms of CPU time and memory usage once dim(L) exceeds 
approximately 50. In such cases, the Lie algebra is more easily studied using the functions described 
in Section <A  HREF = "text1134.htm#12714">Instances of Lie Algebras Generated by Extremal Elements</A>.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "12713">Example <TT>AlgLie_AlgLieExtrMultTable (H106E13)</TT></A></H3>
We construct the generic Lie algebra generated by 3 extremal elements and construct a structure
constant Lie algebra using the multiplication table.
<P>
<P>
<PRE>
&gt; L := ExtremalLieAlgebra(Rationals(), 3);
&gt; L:Maximal;
Lie algebra generated by 3 extremal elements, defined over Rational 
Field
&gt; MultiplicationTable(~L);
&gt; L:Maximal;
Lie algebra generated by 3 extremal elements, originally defined over 
Rational Field
  Now living over Polynomial ring of rank 4 over Rational Field
  Dimension: 8
  Picked 4 f-values:
    f(2, [1]) = f21
    f(3, [1]) = f31
    f(3, [2]) = f32
    f(1, [32]) = f132

&gt; Dimension(L);
8
&gt; MT := MultiplicationTable(L);
&gt; MT[4][8];
(0   -1/2*f31*f32   0   -1/2*f132   0   0   0   1/2*f32)
&gt; M := LieAlgebra&lt;CoefficientRing(L), 8 | MT&gt;;
&gt; M;
Lie Algebra of dimension 8 with base ring Polynomial ring of rank 4 
over Rational Field
&gt; M.4*M.8;
(0   -1/2*f31*f32   0   -1/2*f132   0   0   0   1/2*f32)
&gt; M.1*(M.1*M.2);
(f21   0   0   0   0   0   0   0)
</PRE>
<HR>
<H4><A NAME = "12714">Instances of Lie Algebras Generated by Extremal Elements</A></H4>



<H5><A NAME = "12715">Instance(L) : AlgLieExtr -&gt; AlgLie</A></H5>

<PRE>    Rep: MonStgElt                      Default: "Auto"</PRE>

<PRE>    Check: BoolElt                      Default: <TT>true</TT></PRE>
<BLOCKQUOTE>
The Lie algebra L(f) for general f. The Lie algebra returned will in general be defined over
a multivariate polynomial ring.
<P>
This function is identical to <A  HREF = "text1134.htm#MultiplicationTableL">MultiplicationTable</A>, except that it returns a Lie algebra
rather than a multiplication table. Please refer to that function for information on the optional
arguments <TT>Rep</TT> and <TT>Check</TT>. Note that this function also is impractical in terms of CPU 
time and memory usage once dim(L) exceeds approximately 50. In such cases, the Lie algebra 
is more easily studied by constructing particular instances of L(f) individually, as described
below.
</BLOCKQUOTE>
<H5><A NAME = "12716">Instance(L, Q) : AlgLieExtr, SeqEnum -&gt; AlgLie, Map</A></H5>

<PRE>    Rep: MonStgElt                      Default: "Auto"</PRE>

<PRE>    Check: BoolElt                      Default: <TT>true</TT></PRE>
<BLOCKQUOTE>
Construct L(f) where the i-th free parameter of X is set to Q[i]. 
Consult <TT>L:Maximal</TT> or <A  HREF = "text1134.htm#FreefValues">FreefValues</A> to obtain information about the free parameters.
The coefficient ring of the Lie algebra M returned will be equal to <TT>Universe(Q)</TT>.
As a second return value, an invertible map from M to the free Lie algebra of rank <TT>Ngens(L)</TT>
is returned.
<P>
The optional argument <TT>Rep</TT> may be "Auto", "Dense" or "Sparse" (refer to the documentation
at <A  HREF = "text1134.htm#MultiplicationTableL">MultiplicationTable</A> for more information). <TT>Check</TT> may be set to <TT>true</TT> or <TT>false</TT>
and determines whether the Jacobi identity is checked on the Lie algebra returned.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "12717">Example <TT>AlgLie_AlgLieExtrMultInstance (H106E14)</TT></A></H3>
We construct the generic Lie algebra generated by 3 extremal elements and study one of its instances.
<P>
<P>
<PRE>
&gt; L := ExtremalLieAlgebra(Rationals(), 3);
&gt; MultiplicationTable(~L);
&gt; L:Maximal;
Lie algebra generated by 3 extremal elements, originally defined over 
Rational Field
  Now living over Polynomial ring of rank 4 over Rational Field
  Dimension: 8
  Picked 4 f-values:
    f(2, [1]) = f21
    f(3, [1]) = f31
    f(3, [2]) = f32
    f(1, [32]) = f132

&gt; M := Instance(L); M;
Lie Algebra of dimension 8 with base ring Polynomial ring of rank 4 
over Rational Field
&gt; M.1*(M.1*M.2);
(f21   0   0   0   0   0   0   0)
</PRE>
So in the most general case, [x<sub>1</sub>, [x<sub>1</sub>, x<sub>2</sub>]] = f<sub>x<sub>2</sub></sub>(x<sub>1</sub>) x<sub>1</sub>.
Next, we consider an instance where we set f<sub>x<sub>2</sub></sub>(x<sub>1</sub>) = 1/7,
f<sub>x<sub>3</sub></sub>(x<sub>1</sub>) = 1/5,
f<sub>x<sub>3</sub></sub>(x<sub>2</sub>) = 1/3 and
f<sub>x<sub>1</sub></sub>([x<sub>3</sub>, x<sub>2</sub>]) = 1.
<P>
<P>
<PRE>
&gt; N, phi := Instance(L, [Rationals()|1/7,1/5,1/3,1]);
&gt; N;
Lie Algebra of dimension 8 with base ring Rational Field
&gt; SemisimpleType(N);
A2
&gt; N.1*(N.1*N.2);
(1/7   0   0   0   0   0   0   0)
&gt; y := phi(N.2); z := phi(N.3); 
&gt; Parent(y):Minimal;
Free Lie algebra of rank 3 over Rational Field
&gt; (y,(y,z));
-($.2, ($.3, $.2))
&gt; (y,(y,z)) @@ phi;
(  0 1/3   0   0   0   0   0   0)
&gt; (y,(y,z)) @@ phi @ phi;
1/3*$.2
</PRE>
<HR>
<H4><A NAME = "12718">Studying the Parameter Space</A></H4>



<H5><A NAME = "12719"></A><A NAME = "FreefValues">FreefValues</A>(L) : AlgLieExtr -&gt; SeqEnum, SeqEnum</H5>
<BLOCKQUOTE>
The values f<sub>x</sub>(b) generating the parameter space X (see the introduction to this section <A  HREF = "text1134.htm#12698">Lie Algebras Generated by Extremal Elements</A>
for details). This function returns two sequences: the first of the f<sub>x</sub>(b) as elements of <TT>CoefficientRing(L)</TT>
and the second of the pairs (x, b) as two-tuples of integers.
</BLOCKQUOTE>
<H5><A NAME = "12720">fValue(L, x, b) : AlgLieExtr, RngIntElt, RngIntElt -&gt; RngElt</A></H5>
<BLOCKQUOTE>
The value f<sub>x</sub>(b) as an element of <TT>CoefficientRing(L)</TT>.
</BLOCKQUOTE>
<H5><A NAME = "12721">fValueProof(L, x, b) : AlgLieExtr, RngIntElt, RngIntElt -&gt;</A></H5>
<BLOCKQUOTE>
Print a proof of correctness for the value f<sub>x</sub>(b).
</BLOCKQUOTE>
<HR>
<H3><A NAME = "12722">Example <TT>AlgLie_AlgLieExtrfVal (H106E15)</TT></A></H3>
We consider the generic Lie algebra generated by 4 extremal elements.
<P>
<P>
<PRE>
&gt; L := ExtremalLieAlgebra(Rationals(), 4);
&gt; vals, pairs := FreefValues(L);
&gt; vals;
[
    f21,
    f31,
    f41,
    f32,
    f42,
    f43,
    f143,
    f243,
    f142,
    f132,
    f1432,
    f2431
]
&gt; #vals;
12
&gt; pairs;
[ &lt;2, 1&gt;, &lt;3, 1&gt;, &lt;4, 1&gt;, &lt;3, 2&gt;, &lt;4, 2&gt;, &lt;4, 3&gt;, &lt;1, 5&gt;, &lt;2, 5&gt;, &lt;1, 
6&gt;, &lt;1, 8&gt;, &lt;1, 11&gt;, &lt;2, 12&gt; ]
</PRE>
This shows that dim(X) = 12. We compute some values f<sub>x</sub>(b).
<P>
<P>
<PRE>
&gt; fValue(L, 1, 5);
f143
&gt; fValue(L, 4, 17);
-f41*f42
&gt; fValueProof(L, 4, 17);
f(4, [241]) -&gt; -f(4,[2])*f(4,[1]) {f(x,[y,[x,N]]) = -f(x,y)f(x,N) by 
  assoc. of f and anti-comm. of L}
    f(4, [2]) = f42 {Free}
    f(4, [1]) = f41 {Free}
= -f41*f42
</PRE>
<HR>
<H5><A NAME = "12723"></A><A NAME = "DimensionsEstimate">DimensionsEstimate</A>(L, g) : AlgLieExtr, UserProgram -&gt; SeqEnum, SetMulti</H5>

<PRE>    NumSamples: RngIntElt               Default: &infin;</PRE>

<PRE>    Check: BoolElt                      Default: <TT>true</TT></PRE>

<PRE>    Rep: MonStgElt                      Default: "Auto"</PRE>

<PRE>    SetVerbose("AlgLieExtr", n):        Maximum: 10</PRE>
<BLOCKQUOTE>
Estimate the dimensions of the subvarieties of the parameter space X of L giving rise to
irreducible Lie algebra modules of different dimensions. 
<P>
This procedure repeatedly (exactly <TT>NumSamples</TT> times) invokes <TT>Instance(L, g())</TT> to produce
a Lie algebra M. The composition series of M are computed, and the dimension e of 
its simple factor is stored. Then, for each of these e encountered, the dimension of the 
subvariety (inside the algebraic variety X) that contains Lie algebras whose top factor
has dimension e is estimated using the dimension d of the full f-variety. (Here d is 
taken to be the number of free f-values computed; see <A  HREF = "text1134.htm#FreefValues">FreefValues</A>).
<P>
If the verbose flag <TT>"AlgLieExtr"</TT> is set 3 or more, then after each step the estimate is 
printed as a sequence of triples (e, n, s): n is the number of times
dimension e was encountered, and s the estimate for the dimension of the subvariety.
<P>
Upon finishing (which will only happen if <TT>NumSamples</TT> is set to some finite number) that 
sequence of triples is returned. The second return value is a multiset containing the dimensions
encountered in the search.
<P>
<P>
<P>
<P>
Note that this procedure assumes that X itself is an affine variety (which has been proved 
if <TT>CommutatorGraph(L)</TT> is a connected simply laced Dynkin diagram of finite or affine type)
and that <TT>g</TT> produces uniformly random elements of X. If either of these two is not the 
case, the estimates produced are likely wrong. Moreover, <TT>g</TT> must produce sequences of
elements of a finite field.
<P>
The optional argument <TT>Rep</TT> may be "Auto", "Dense" or "Sparse" (refer to the documentation
at <A  HREF = "text1134.htm#MultiplicationTableL">MultiplicationTable</A> for more information). <TT>Check</TT> may be set to <TT>true</TT> or <TT>false</TT>
and determines whether the Jacobi identity is checked on the Lie algebras constructed.
</BLOCKQUOTE>
<H5><A NAME = "12724">InstancesForDimensions(L, g, D) : AlgLieExtr, UserProgram, SetEnum[RngIntElt] -&gt; Assoc</A></H5>

<PRE>    Check: BoolElt                      Default: <TT>true</TT></PRE>
<BLOCKQUOTE>
For each d &isin;D attempt to find an instance of L whose simple factor has dimension d,
by repeatedly invoking <TT>Instance(L, g())</TT>. The result is returned in the form of an
associative array A such that, for all d &isin;D, A[d] is a triple (v, M, &phi;) where
v is such that <TT>Instance(L, v)</TT> is M, and &phi; is an invertible map from M to the
free Lie algebra.
<P>
See <A  HREF = "text1134.htm#DimensionsEstimate">DimensionsEstimate</A> for the required properties of <TT>g</TT>.
The optional parameter <TT>Check</TT> may be set to <TT>true</TT> or <TT>false</TT>
and determines whether the Jacobi identity is checked on the Lie algebras constructed.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "12725">Example <TT>AlgLie_AlgLieExtrVarietyDims (H106E16)</TT></A></H3>
We consider the generic Lie algebra generated by 3 extremal elements.
<P>
<P>
<PRE>
&gt; L := ExtremalLieAlgebra(Rationals(), 3);
&gt; FreefValues(L);
[
    f21,
    f31,
    f32,
    f132
]
[ &lt;2, 1&gt;, &lt;3, 1&gt;, &lt;3, 2&gt;, &lt;1, 4&gt; ]
</PRE>
So dim(X) = 4. 
We create a function <TT>g</TT> used to construct random instances of L over GF(5).
<P>
<P>
<PRE>
&gt; g := func&lt; | [ Random(GF(5)) : i in [1..4] ]&gt;;
&gt; repeat M := Instance(L, g()); until Rank(KillingForm(M)) eq 8;
&gt; M;
Lie Algebra of dimension 8 with base ring GF(5)
&gt; SemisimpleType(M);
A2
</PRE>
So in this case <TT>g()</TT> yielded a Lie algebra of type A<sub>2</sub>.
We use <TT>g</TT> to obtain information about X, using 500 random instances.
<P>
<P>
<PRE>
&gt; DimensionsEstimate(L, g : NumSamples := 500);
[ &lt;3, 121, "3.12"&gt;, &lt;8, 379, "3.83"&gt; ]
{* 3^^121, 8^^379 *}
</PRE>
This shows that 379 instances were found where M was simple of dimension 8,
and 121 cases where M had a simple factor of dimension 3.
Using this result one might conjecture that there is a codimension 1 subspace of X with
Lie algebras whose simple factor has dimension 3.
<P>
<P>
<PRE>
&gt; A := InstancesForDimensions(L, g, {3,8} : Check := false);         
&gt; A[3];
&lt;[ 2, 1, 4, 4 ], Lie Algebra of dimension 8 with base ring GF(5), 
Mapping from: Lie Algebra of dimension 8 with base ring GF(5) to Free 
Lie algebra of rank 3 over GF(5) given by a rule&gt;
&gt; M := A[3][2]; MM := M/SolvableRadical(M); MM;
Lie Algebra of dimension 3 with base ring GF(5)
&gt; SemisimpleType(MM);
A1
&gt; M := A[8][2]; IsSimple(M);
true
&gt; SemisimpleType(M);
A2
</PRE>
<HR>
<PRE></PRE> <A  HREF = "text1135.htm">[Next]</A><A  HREF = "text1133.htm">[Prev]</A> <A  HREF = "text1135.htm">[Right]</A> <A  HREF = "text1133.htm">[Left]</A> <A  HREF = "text1130.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<br><small>Version: V2.22 of <I>
Thu Jun  9 16:37:49 EST 2016
</I></small>
</body></html>