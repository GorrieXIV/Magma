<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <link rel='stylesheet' href='help.css' type='text/css'>
  <TITLE>Quantifiers</TITLE>
</head>
<body BGCOLOR="#FFFFFF">

 <A  HREF = "text93.htm">[Next]</A><A  HREF = "text91.htm">[Prev]</A> <A  HREF = "text93.htm">[Right]</A> <A  HREF = "text91.htm">[Left]</A> <A  HREF = "text85.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<PRE></PRE><H3><A NAME = "723">Quantifiers</A></H3>

<P>
<P>
To test whether some enumerated set is empty or not, one may use
the <TT>IsEmpty</TT> function. However, to use  <TT>IsEmpty</TT>, the set
has to be created in full first. The existential quantifier
<TT>exists</TT> enables one to do the test and abort the construction
of the set as soon as an element is found; moreover, the element
found will be assigned to a variable.
<P>
Likewise, <TT>forall</TT> enables one to abort the construction of
the set as soon as an element not satisfying a certain
property is encountered.
<P>
Note that <TT>exists(t){ e(x) : x in E | P(x) }</TT>
is <I>not</I> designed to
return true if an element of the set of values e(x) satisfies P, but rather
if there is an x&isin;E satisfying P(x) (in which case e(x) is
assigned to t).
<P>
For the notation used here, see the beginning of this chapter.


<H5><A NAME = "724">exists(t){ e(x): x in E | P(x) }</A></H5>
<H5>exists(t<sub>1</sub>, ..., t<sub>r</sub>){ e(x) :x in E | P(x) }</H5>
<BLOCKQUOTE>
Given an enumerated structure E and a Boolean expression P(x),
the Boolean value <TT>true</TT> is returned if E 
contains at least one element x for which P(x) is true. 
If P(x) is not true for any element x of E, then the 
Boolean value <TT>false</TT> is returned.
<P>
Moreover, if P(x) is found to be true for the element y, say, of E, then
in the first form of the exists expression, variable t will be assigned
the value of the expression e(y).
If P(x) is never true for an element of E,
t will be left unassigned.
In the second form, where r variables t<sub>1</sub>, ..., t<sub>r</sub> are given,
the result e(y) should be a tuple of length r; each variable
will then be assigned to the corresponding component of the tuple.  Similarly,
all the variables will be left unassigned if P(x) is never true.
The clause <TT>(t)</TT> may be omitted entirely.
<P>
The expression P may be omitted if it is always true.
</BLOCKQUOTE>
<H5><A NAME = "725">exists(t){ e(x<sub>1</sub>, ..., x<sub>k</sub>): x<sub>1</sub> in E<sub>1</sub>,..., x<sub>k</sub> in E<sub>k</sub> | P(x<sub>1</sub>, ..., x<sub>k</sub>) }</A></H5>
<H5>exists(t<sub>1</sub>, ..., t<sub>r</sub>){ e(x<sub>1</sub>, ..., x<sub>k</sub>) :x<sub>1</sub> in E<sub>1</sub>, ..., x<sub>k</sub> in E<sub>k</sub> | P }</H5>
<BLOCKQUOTE>
Given enumerated structures E<sub>1</sub>, ..., E<sub>k</sub>, and a Boolean expression
P(x<sub>1</sub>, ..., x<sub>k</sub>), the Boolean value <TT>true</TT> is returned 
if there is an element &lt;y<sub>1</sub>, ..., y<sub>k</sub>&gt; in the 
Cartesian product E<sub>1</sub> x ... x E<sub>k</sub>, such that 
P(y<sub>1</sub>, ..., y<sub>k</sub>) is true. 
If P(x<sub>1</sub>, ..., x<sub>k</sub>) is not true for any element 
(y<sub>1</sub>, ..., y<sub>k</sub>)  of E<sub>1</sub> x ... x E<sub>k</sub>, 
then the Boolean value <TT>false</TT> is returned.
<P>
Moreover, if P(x<sub>1</sub>, ..., x<sub>k</sub>) is found to be true for the element
&lt;y<sub>1</sub>, ..., y<sub>k</sub>&gt; of
E<sub>1</sub> x ... x E<sub>k</sub>, then
in the first form of the exists expression, the variable t will 
be assigned the value of the expression e(y<sub>1</sub>, ..., y<sub>k</sub>).
If P(x<sub>1</sub>, ..., x<sub>k</sub>) is never true for an element
of E<sub>1</sub> x ... x E<sub>k</sub>, then the variable t will 
be left unassigned.
In the second form, where r variables t<sub>1</sub>, ..., t<sub>r</sub> are given,
the result e(y<sub>1</sub>, ..., y<sub>k</sub>) should be a tuple of length r; each variable
will then be assigned to the corresponding component of the tuple.  Similarly,
all the variables will be left unassigned if P(x<sub>1</sub>, ..., x<sub>k</sub>) is
never true.
The clause <TT>(t)</TT> may be omitted entirely.
<P>
The expression P may be omitted if it is always true.
<P>
If successive structures E<sub>i</sub> and E<sub>i + 1</sub> are identical, then
the abbreviation <TT>x<sub>i</sub>, x<sub>i + 1</sub> in E<sub>i</sub></TT> may be used.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "726">Example <TT>Set_Exists (H9E12)</TT></A></H3>
As a variation on an earlier example, we check whether or not
some integers can be written as sums of cubes (less than 10<sup>3</sup> in
absolute value):
<P>
<P>
<PRE>
&gt; exists(t){ &lt;x, y&gt; : x, y in [ t^3 : t in [-10..10] ] | x + y eq 218 };
true
&gt; t;
&lt;-125, 343&gt;
&gt; exists(t){ &lt;x, y&gt; : x, y in [ t^3 : t in [1..10] ] | x + y eq 218 };
false
&gt; t;
&gt;&gt; t;
   ^
User error: Identifier 't' has not been declared
</PRE>
<HR>
<H5><A NAME = "727">forall(t){ e(x) : x in E | P(x) }</A></H5>
<H5>forall(t<sub>1</sub>, ..., t<sub>r</sub>){ e(x) :x in E | P(x) }</H5>
<BLOCKQUOTE>
Given an enumerated structure E and a Boolean expression P(x),
the Boolean value <TT>true</TT> is returned if P(x) 
is true for every element x of E. 
<P>
If P(x) is not true for at least one element x of E, 
then the Boolean value <TT>false</TT> is returned.
<P>
Moreover, if P(x) is found to be false for the element y, say, of E, then
in the first form of the exists expression, variable t will be assigned
the value of the expression e(y).
If P(x) is true for every element of E,
t will be left unassigned.
In the second form, where r variables t<sub>1</sub>, ..., t<sub>r</sub> are given,
the result e(y) should be a tuple of length r; each variable
will then be assigned to the corresponding component of the tuple.  Similarly,
all the variables will be left unassigned if P(x) is always true.
The clause <TT>(t)</TT> may be omitted entirely.
<P>
The expression P may be omitted if it is always true.
</BLOCKQUOTE>
<H5><A NAME = "728">forall(t){ e(x<sub>1</sub>, ..., x<sub>k</sub>): x<sub>1</sub> in E<sub>1</sub>,..., x<sub>k</sub> in E<sub>k</sub> | P(x<sub>1</sub>, ..., x<sub>k</sub>) }</A></H5>
<H5>forall(t<sub>1</sub>, ..., t<sub>r</sub>){ e(x<sub>1</sub>, ..., x<sub>k</sub>) :x<sub>1</sub> in E<sub>1</sub>, ..., x<sub>k</sub> in E<sub>k</sub> | P }</H5>
<BLOCKQUOTE>
Given sets E<sub>1</sub>, ..., E<sub>k</sub>, and a Boolean expression
P(x<sub>1</sub>, ..., x<sub>k</sub>), the Boolean value <TT>true</TT> is returned 
if P(x<sub>1</sub>, ..., x<sub>k</sub>) is true for every element
(x<sub>1</sub>, ..., x<sub>k</sub>) in the Cartesian product 
E<sub>1</sub> x ... x E<sub>k</sub>. 
<P>
If P(x<sub>1</sub>, ..., x<sub>k</sub>) fails to be true for some element 
(y<sub>1</sub>, ..., y<sub>k</sub>)  of E<sub>1</sub> x ... x E<sub>k</sub>, 
then the Boolean value <TT>false</TT> is returned.
<P>
Moreover, if P(x<sub>1</sub>, ..., x<sub>k</sub>) is false for the element
&lt;y<sub>1</sub>, ..., y<sub>k</sub>&gt; of
E<sub>1</sub> x ... x E<sub>k</sub>, then
in the first form of the exists expression, the variable t will 
be assigned the value of the expression e(y<sub>1</sub>, ..., y<sub>k</sub>).
If P(x<sub>1</sub>, ..., x<sub>k</sub>) is true for every element
of E<sub>1</sub> x ... x E<sub>k</sub>, then the variable t will 
be left unassigned.
In the second form, where r variables t<sub>1</sub>, ..., t<sub>r</sub> are given,
the result e(y<sub>1</sub>, ..., y<sub>k</sub>) should be a tuple of length r; each variable
will then be assigned to the corresponding component of the tuple.  Similarly,
all the variables will be left unassigned if P(x<sub>1</sub>, ..., x<sub>k</sub>) is
never true.
The clause <TT>(t)</TT> may be omitted entirely.
<P>
The expression P may be omitted if it is always true.
<P>
If successive structures E<sub>i</sub> and E<sub>i + 1</sub> are identical, then
the abbreviation <TT>x<sub>i</sub>, x<sub>i + 1</sub> in E<sub>i</sub></TT> may be used.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "729">Example <TT>Set_NestedExists (H9E13)</TT></A></H3>
This example shows that <TT>forall</TT> and <TT>exists</TT> may be nested.
<P>
It is well known that every prime that is 1 modulo 4 can be written
as the sum of two squares, but not every integer m congruent to 1 modulo 4 can.
In this example we explore for small m whether perhaps m plus or minus &epsilon;
(with |&epsilon;|leq1) is always a sum of
squares.
<P>
<P>
<PRE>
&gt; forall(u){ m : m in [5..1000 by 4] | 
&gt;       exists{ &lt;x, y, z&gt; : x, y in [0..30], z in [-1, 0, 1] |
&gt;          x^2+y^2+z eq m } };
false
&gt; u;
77
</PRE>
<HR>
<PRE></PRE> <A  HREF = "text93.htm">[Next]</A><A  HREF = "text91.htm">[Prev]</A> <A  HREF = "text93.htm">[Right]</A> <A  HREF = "text91.htm">[Left]</A> <A  HREF = "text85.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<br><small>Version: V2.22 of <I>
Thu Jun  9 16:37:49 EST 2016
</I></small>
</body></html>