<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <link rel='stylesheet' href='help.css' type='text/css'>
  <TITLE>Analytic Jacobians of Hyperelliptic Curves</TITLE>
</head>
<body BGCOLOR="#FFFFFF">

 <A  HREF = "text1482.htm">[Next]</A><A  HREF = "text1500.htm">[Prev]</A> <A  HREF = "text1482.htm">[Right]</A> <A  HREF = "text1500.htm">[Left]</A> <A  HREF = "text1483.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<PRE></PRE><H3><A NAME = "17058">Analytic Jacobians of Hyperelliptic Curves</A></H3>

<P>
<P>
<P>
<P>
This section contains descriptions of functions pertaining to the
creation and use of analytic Jacobians for hyperelliptic curves.
<P>
Suppose C is a curve of genus g defined over the complex
numbers. The analytic Jacobian of the curve is an abelian torus and is
constructed as follows: We view the complex points on the curve,
C(C), as a compact Riemann surface of genus g.  It is known
that the dimension of the vector space of holomorphic differentials is
equal to the genus of the curve. So let &phi;<sub>i</sub>, i = 1, 2, ... , g be a basis for this vector space and set /line(&phi;) =
()<sup>t</sup>(&phi;<sub>1</sub>, ..., &phi;<sub>g</sub>), a vector of holomorphic 1-forms. For a
hyperelliptic curve there is a natural choice of holomorphic
differentials, namely &phi;<sub>i</sub> = x<sup>i - 1</sup>dx/y. We can now define a
mapping (Int) : C -&gt; C<sup>g</sup> by  P |-&gt; int<sub>P</sub>^&infin;/line(&phi;). To remove the dependency of this
mapping on the path of integration, we define &Lambda; to be the
image of the map from the first homology group of C, H<sub>1</sub>(C, Z), to
C<sup>g</sup> which sends a closed path, &sigma; &isin;H<sub>1</sub>(C, Z), on the
Riemann surface to int<sub>&sigma;</sub> /line(&phi;). Then &Lambda;
turns out to be a lattice in C<sup>g</sup> and so we get the complex torus
C<sup>g</sup>/&Lambda;. We then see that (Int) is a well-defined mapping from
C into C<sup>g</sup>/&Lambda;. We extend this mapping additively to the
divisors of degree zero on C.  The Abel part of the Abel-Jacobi
theorem states that two divisors map to the same image under (Int) 
if and only if they are linearly equivalent. The Jacobi part of the
theorem asserts that the map is onto. So there is a bijection between 
the points of C<sup>g</sup>/&Lambda; and the points of the (algebraic) Jacobian.
<P>
So far the analytic Jacobian C<sup>g</sup>/&Lambda; is just a torus, but it
can be made into an abelian manifold by choosing a polarization.  Let
A<sub>1</sub>, ..., A<sub>g</sub>, B<sub>1</sub>, ..., B<sub>g</sub> be a symplectic homology basis. That is,
the A<sub>i</sub> and B<sub>i</sub> are closed paths on the Riemann surface such that
all intersection numbers are 0 except that A<sub>i</sub> intersects B<sub>i</sub>
with intersection number 1 for each i.  Let &omega;<sub>1</sub> and
&omega;<sub>2</sub> be the g x g-matrices with entries 
(&omega;<sub>1</sub>)<sub>ij</sub> = int<sub>B<sub>j</sub></sub> &phi;<sub>i</sub>,
and 
(&omega;<sub>2</sub>)<sub>ij</sub> = int<sub>A<sub>j</sub></sub> &phi;<sub>i</sub>.
Then the columns of P = (&omega;<sub>1</sub>, &omega;<sub>2</sub>) form a
Z-basis for the lattice &Lambda; = P Z<sup>2g</sup>. The matrix P is
called the (big) period matrix. The space of complex, symmetric g x g
matrices with positive definite imaginary part is called the Siegel
upper-half space of degree g. Because we chose a symplectic basis
for the homology it follows that &tau; = &omega;<sub>2</sub><sup> - 1</sup>&omega;<sub>1</sub> is an element
of Siegel upper half-space. We will refer to &tau; as the small period matrix.
<P>
Set 
<PRE>
J = (0 1_g) 
    (-1_g 0). 
</PRE>If
we define  E(P x, P y) = ()<sup>t</sup>x J y, for
any x, y &isin;R<sup>2g</sup>, then E is a Riemann form for the torus
C<sup>g</sup>/&Lambda; and so the torus acquires a polarization.  The
existence of a Riemann form on a torus is a necessary and sufficient
condition for the torus to be embeddable into projective space.  The
image is isomorphic to the (algebraic) Jacobian.
<P>
In order
for the theory describing the map from the analytic Jacobian to the
algebraic Jacobian (see Mumford <A  HREF = "text1482.htm#bib_mumford2">[Mum84]</A>) to work we actually
need a special symplectic basis linked to a particular ordering of the
roots of the hyperelliptic polynomial. For an example of such a basis
see Mumford <A  HREF = "text1482.htm#bib_mumford2">[Mum84, Chap III.5]</A>. The basis used can be obtained
using the function <A  HREF = "text1501.htm#HomologyBasislabel">HomologyBasis</A> and the roots in the 
corresponding order are stored as the attribute <TT>A`Roots</TT> (where 
<TT>A</TT> is an analytic Jacobian).
<P>
<P>
Note: many of the function with analytic Jacobians use complex approximations,
and indelicacies involving these can cause the functions to fail. One common
remedy is to first transform the hyperelliptic curve before applying the
analytic Jacobian machinery, either by translating or by inverting
x -&gt; 1/x. This can often have the effect of changing the internal
computations sufficiently that any errors are avoided.



<H5>Subsections</H5>
<UL>
<LI> <A  HREF = "text1501.htm#17059">Creation and Access Functions</A>
<LI> <A  HREF = "text1501.htm#17067">Maps between Jacobians</A>
<LI> <A  HREF = "text1501.htm#17082">From Period Matrix to Curve</A>
<LI> <A  HREF = "text1501.htm#17085">Voronoi Cells</A>
</UL>
<H4><A NAME = "17059">Creation and Access Functions</A></H4>



<H5><A NAME = "17060"></A><A NAME = "AnalyticJacobianlabel">AnalyticJacobian</A>(f) : RngUPolElt -&gt; AnHcJac</H5>
<BLOCKQUOTE>
Given f &isin;C[x] where C is a complex field
(see Chapter <A  HREF = "text233.htm#2030">REAL AND COMPLEX FIELDS</A>),
this function returns the analytic Jacobian of the hyperelliptic curve
defined by y<sup>2</sup> = f(x). The polynomial must have degree at least 3
and the complex field precision at least 20 and, for the moment,
less than 2000.
</BLOCKQUOTE>
<H5><A NAME = "17061"></A><A NAME = "HyperellipticPolynomiallabel">HyperellipticPolynomial</A>(A) : AnHcJac -&gt; RngUPolElt</H5>
<BLOCKQUOTE>
Returns the polynomial defining the hyperelliptic curve whose Jacobian is A.
</BLOCKQUOTE>
<H5><A NAME = "17062">SmallPeriodMatrix(A) : AnHcJac -&gt; AlgMatElt</A></H5>
<BLOCKQUOTE>
The small period matrix of the analytic Jacobian A. If A has dimension g or
equivalently the hyperelliptic curve has genus g, then this is a
symmetric g x g matrix with positive definite imaginary
part. If P = (&omega;<sub>1</sub>, &omega;<sub>2</sub>) is the full period matrix (see
<A  HREF = "text1501.htm#BigPeriodMatrixlabel">BigPeriodMatrix</A>) then the small period matrix
is defined by &omega;<sub>2</sub><sup> - 1</sup> &omega;<sub>1</sub>.
</BLOCKQUOTE>
<H5><A NAME = "17063"></A><A NAME = "BigPeriodMatrixlabel">BigPeriodMatrix</A>(A) : AnHcJac -&gt; AlgMatElt</H5>
<BLOCKQUOTE>
The full period matrix of the hyperelliptic curve of the Jacobian A. If A has dimension g or
equivalently the hyperelliptic curve has genus g, then this is a
g x 2g matrix. The analytic Jacobian as a torus equals 
C<sup>g</sup>/&Lambda;, where &Lambda; is the Z-lattice spanned by the
columns of the period matrix. The period matrix is computed with
respect to the holomorphic differentials &phi;<sub>i</sub> = x<sup>i - 1</sup>dx/y and
a symplectic basis for the homology that can be retrieved using
<A  HREF = "text1501.htm#HomologyBasislabel">HomologyBasis</A>.
</BLOCKQUOTE>
<H5><A NAME = "17064"></A><A NAME = "HomologyBasislabel">HomologyBasis</A>(A) : AnHcJac -&gt; SeqEnum, SeqEnum, Mtrx</H5>
<BLOCKQUOTE>
The symplectic homology basis used for the computation of the period
matrix of the Jacobian A. First assume that <A  HREF = "text1501.htm#HyperellipticPolynomiallabel">HyperellipticPolynomial</A><TT>(A)</TT>
has odd degree. The function <TT>HomologyBasis(A)</TT> returns three values 
which we label <TT>basepoints</TT>, <TT>loops</TT> and <TT>S</TT>. Then 
<TT>basepoints</TT> is a list of points in the complex
plane. The return value<TT>loops</TT> is a list of 2g lists of indices 
into <TT>basepoints</TT>. So the list <TT>[i1, i2, i3, ...]</TT>  corresponds 
to the loop consisting of joining the straight lines from <TT>basepoints[in]</TT> to <TT>basepoints[in+1]</TT> for <TT>i</TT> = 1, 2, ....
These closed loops form a homology basis for the curve but probably
not a symplectic basis. The third return value, <TT>S</TT>, is a matrix
giving the linear combinations of the loops that were used to form a
symplectic homology basis and to compute the period matrix.
<P>
If <A  HREF = "text1501.htm#HyperellipticPolynomiallabel">HyperellipticPolynomial</A><TT>(A)</TT> has even degree then
the returned homology basis is not for the Riemann surface for this
curve, but for the curve of odd degree obtained by sending a =  <TT>A`InfiniteRoot</TT> to infinity through the linear fractional
transformation given by x |-&gt; 1/(x - a). So one needs to apply the
inverse transformation to the returned basis in order to get the basis
that was used to compute the period matrix.
</BLOCKQUOTE>
<H5><A NAME = "17065">Dimension(A) : AnHcJac -&gt; RngIntElt</A></H5>
<H5>Genus(A) : AnHcJac -&gt; RngIntElt</H5>
<BLOCKQUOTE>
The dimension of the Jacobian A as a complex abelian variety. This 
is equal to the genus of the curve C for which A is the Jacobian. 
</BLOCKQUOTE>
<H5><A NAME = "17066">BaseField(A) : JacHyp -&gt; Fld</A></H5>
<H5>BaseRing(A) : JacHyp -&gt; Rng</H5>
<H5>CoefficientRing(A) : JacHyp -&gt; Rng</H5>
<BLOCKQUOTE>
The base field of the Jacobian A.
</BLOCKQUOTE>
<H4><A NAME = "17067">Maps between Jacobians</A></H4>



<H5><A NAME = "17068">ToAnalyticJacobian(x, y, A) : FldComElt, FldComElt, AnHcJac -&gt; Mtrx</A></H5>
<BLOCKQUOTE>
Let A be the analytic Jacobian of y<sup>2</sup> = f(x). This function maps
the point (x, y) on the curve to the analytic Jacobian. More
precisely, let a = &infin; when <A  HREF = "text1501.htm#HyperellipticPolynomiallabel">HyperellipticPolynomial</A>
has odd degree and a = <TT>A`InfiniteRoot</TT> otherwise. Then it maps
the divisor (x, y) - (a, 0) to the analytic Jacobian. As any point on the
algebraic Jacobian is simply a sum of such divisors, we can get its
image by linearity of the map. The function returns a g x 1
matrix. This should be thought of as an element of C<sup>g</sup> / &Lambda;
where &Lambda; is the Z-lattice generated by the columns of the
<A  HREF = "text1501.htm#BigPeriodMatrixlabel">BigPeriodMatrix</A>.
</BLOCKQUOTE>
<H5><A NAME = "17069"></A><A NAME = "FromAnalyticJacobianlabel">FromAnalyticJacobian</A>(z, A) : Mtrx, AnHcJac -&gt; SeqEnum</H5>
<BLOCKQUOTE>
Let A be an analytic Jacobian of y<sup>2</sup> = f(x), with small period
matrix &tau;. Let z be a g x 1 complex matrix (thought of as 
an element of C<sup>g</sup> / &Lambda; where
&Lambda; is the Z-lattice generated by the columns of the 
<A  HREF = "text1501.htm#BigPeriodMatrixlabel">BigPeriodMatrix</A>). This function returns a list of g
(the dimension of A), or fewer,
pairs P<sub>i</sub> = &lt; x<sub>i</sub>, y<sub>i</sub> &gt; satisfying y<sup>2</sup> = f(x). This is an
element of the algebraic Jacobian when interpreted as the divisor
&sum;<sub>i=1</sub><sup>g</sup> P<sub>i</sub> - g&infin;.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "17070">Example <TT>CrvHyp_Analytic_Jacobian_Addition (H131E46)</TT></A></H3>
We give an example of moving between the algebraic and analytic 
Jacobians. We take two points on an algebraic Jacobian, map them 
to the analytic Jacobian, add them there and map the answer back 
to the algebraic Jacobian. We check that the answer corresponds 
to adding the points on the algebraic Jacobian.
<P>
<P>
<P>
<PRE>
&gt; P&lt;x&gt; := PolynomialRing(RationalField());
&gt; f := -8*x^5 - 14*x^4 + 28*x^3 - 30*x^2 + 6*x;
&gt; C := HyperellipticCurve(f);
&gt; J := Jacobian(C);
&gt; pts := ReducedBasis(RationalPoints(J:Bound:=500)); pts;
[ (x^2 + 1, -3*x + 5, 2), (x^2 - 4/9*x + 1/9, -55/27*x + 43/27, 2) ]
</PRE>
This Jacobian has rank 2 and these are two generators. We will use them as 
our two points.
<P>
<P>
<PRE>
&gt; P1 := pts[1]; P2 := pts[2];
&gt; C&lt;I&gt; := ComplexField(50);
&gt; K&lt;x&gt; := PolynomialRing(C);
&gt; f2 := Evaluate(f,x);
&gt; div1 := [r[1] : r in Roots(Evaluate(ElementToSequence(P1)[1],x))];
&gt; div1 := [&lt;d1,Evaluate(ElementToSequence(P1)[2],d1)&gt; : d1 in div1];
&gt; div2 := [r[1] : r in Roots(Evaluate(ElementToSequence(P2)[1],x))];
&gt; div2 := [&lt;d1,Evaluate(ElementToSequence(P2)[2],d1)&gt; : d1 in div2];
&gt; A := AnalyticJacobian(f2);
</PRE>
We are working with 50 decimal places. The sequences <TT>div1</TT> and 
<TT>div2</TT> are the two points on the algebraic Jacobian represented
as pairs of &lt; x, y &gt; coordinates.
<P>
<P>
<PRE>
&gt; pt1 := &amp;+[ToAnalyticJacobian(d[1],d[2],A) : d in div1];
&gt; pt2 := &amp;+[ToAnalyticJacobian(d[1],d[2],A) : d in div2];
</PRE>
Now <TT>pt1</TT> and <TT>pt2</TT> are the images of the two points <TT>P1</TT> and 
<TT>P2</TT> on the analytic Jacobian (two 2 x 1 matrices).
<P>
<P>
<PRE>
&gt; sum := FromAnalyticJacobian(pt1+pt2,A);
&gt; sum;
[ &lt;0.62500000000000000000000000000000000000000000000024 + 
-1.4999999999999999999999999999999999999999999999992*I, 
1.7343750000000000000000000000000000000000000000053 + 
-11.718749999999999999999999999999999999999999999985*I&gt;, 
&lt;0.62500000000000000000000000000000000000000000000036 + 
1.4999999999999999999999999999999999999999999999992*I, 
1.7343750000000000000000000000000000000000000000075 + 
11.718749999999999999999999999999999999999999999986*I&gt; ]
</PRE>
<P>
Now we have mapped sum back to the algebraic Jacobian where it is
given as a sequence of two &lt; x, y &gt; coordinates. 
We compare the polynomial having these two x-coordinates as 
roots, with the algebraic sum of <TT>P1</TT> and <TT>P2</TT>.
<P>
<P>
<P>
<PRE>
&gt; clst := Coefficients((x-sum[1][1])*(x-sum[2][1]));
&gt; xpol := P![BestApproximation(Re(c),1000) : c in clst];
&gt; xpol;
x^2 - 5/4*x + 169/64
&gt; P1+P2;
(x^2 - 5/4*x + 169/64, 125/16*x - 403/128, 2)
</PRE>
<HR>
<H5><A NAME = "17071">Isomorphisms, Isogenies and Endomorphism Rings of Analytic Jacobians</A></H5>

<P>
<P>
<P>
In this section we discuss the functionality provided for finding
isomorphisms and isogenies between different analytic Jacobians and
also for computing the endomorphism ring of an analytic Jacobian.
<P>
Suppose we have two abelian varieties A<sub>1</sub> = C<sup>g</sup>/&Lambda;<sub>1</sub> and A<sub>2</sub>
= C<sup>g</sup>/&Lambda;<sub>2</sub> with a morphism &phi; : A<sub>1</sub> |-&gt; A<sub>2</sub>. This map
lifts to a map C<sup>g</sup> |-&gt; C<sup>g</sup>, given by some complex g x g
matrix, &alpha;. This is called the complex representation of
&phi;. Suppose &Lambda;<sub>i</sub> is spanned by the columns of the g x 2g matrix P<sub>i</sub>. As &phi;(&Lambda;<sub>1</sub>) &sub;&Lambda;<sub>2</sub>, we see that
there must exist an integral 2g x 2g matrix M such that
&alpha; P<sub>1</sub> = P<sub>2</sub> M. M is called the rational representation of
&phi;. If A<sub>1</sub> and A<sub>2</sub> are isomorphic and P<sub>1</sub> and P<sub>2</sub> are
Frobenius bases, that is, they provide a basis with respect to which
the polarization is given by the matrix J = (0 1_g; -1_g  0),  
then it follows that M must be a symplectic matrix. That is, M
must be such that MJ()<sup>t</sup>M = J. The symplectic matrices act on Siegel
upper half-space. If M = (a b; c d) 
is a symplectic matrix and &tau; an element of Siegel upper half-space,
then the action is given by &tau; |-&gt; (a &tau; + b)(c &tau; +
d)<sup> - 1</sup>. Note that if there is an isomorphism from A<sub>1</sub> to A<sub>2</sub>
with rational representation M then &tau;<sub>1</sub> equals the result of
letting ()<sup>t</sup>M (not M) act on &tau;<sub>2</sub>.
<P>
In the case of finding isomorphisms between abelian surfaces, the code
makes use of a fundamental domain for 2-dimensional upper half-space
(see <A  HREF = "text1482.htm#bib_Gottschling">[Got59]</A>). This often works well even with relatively low
precision. The other functions all rely on the function 
<TT>LinearRelation</TT> and work with greater reliability if a high 
precision is chosen. This also means that it can happen that these 
functions miss finding a map. Even if a map is reported it might be 
an artifact of insufficient precision causing <TT>LinearRelation</TT> 
to identify a relation that disappears at higher precision. Of course, 
every effort was made to make these functions work as well as
possible and no cases are known where sufficient precision fails
to give correct results.


<H5><A NAME = "17072">To2DUpperHalfSpaceFundamentalDomian(z) : Mtrx -&gt; Mtrx, Mtrx</A></H5>
<BLOCKQUOTE>
Given a complex matrix in 2-dimensional Siegel upper half-space (that
is a symmetric matrix with positive definite imaginary part), this function
returns two matrices. The first is an element of the fundamental
domain for 2-dimensional Siegel upper half-space described by
Gottschling in <A  HREF = "text1482.htm#bib_Gottschling">[Got59]</A> and the second is a symplectic
matrix that takes the input to the first return value. Note that if
the input is equivalent to an element on the border of the fundamental
domain the returned value might depend heavily on the least
significant digits of the input.
</BLOCKQUOTE>
<H5><A NAME = "17073">AnalyticHomomorphisms(t1, t2) : Mtrx, Mtrx -&gt; SeqEnum</A></H5>
<BLOCKQUOTE>
Given two small period matrices t<sub>1</sub> and t<sub>2</sub>, this function returns a basis 
for the Z-module of 2g x 2g integer
matrices M such that there exists a complex g x g matrix &alpha; 
such that &alpha; (t<sub>1</sub>, 1) = (t<sub>2</sub>, 1) M.
</BLOCKQUOTE>
<H5><A NAME = "17074">IsIsomorphicSmallPeriodMatrices(t1,t2) : Mtrx, Mtrx -&gt; Bool, Mtrx</A></H5>
<BLOCKQUOTE>
For two small period matrices t<sub>1</sub> and t<sub>2</sub>, this function finds a 
2g x 2g symplectic integer matrix M such that there exists 
a complex g x g matrix &alpha; such that &alpha; (t<sub>1</sub>, 1) = (t<sub>2</sub>, 1) M. 
Such matrices define isomorphisms between the corresponding analytic 
Jacobians. The first return value is true if such a matrix is found, false
otherwise. The second return value is the matrix, if found. Zero
matrix otherwise.
</BLOCKQUOTE>
<H5><A NAME = "17075">IsIsomorphicBigPeriodMatrices(P1, P2) : Mtrx, Mtrx -&gt; Bool, Mtrx, Mtrx</A></H5>
<BLOCKQUOTE>
For two big period matrices P<sub>1</sub> and P<sub>2</sub>, this function finds a 
2g x 2g symplectic
integer matrix M such that there exists a complex g x g matrix 
&alpha; such that &alpha; P<sub>1</sub> = P<sub>2</sub> M. Such matrices define isomorphisms 
between the corresponding analytic Jacobians. The first return value is true
if such a matrix is found, false otherwise. The second and third
return values are M and &alpha;, if found. 
</BLOCKQUOTE>
<H5><A NAME = "17076">IsIsomorphic(A1, A2) : AnHcJac, AnHcJac -&gt; Bool, Mtrx, Mtrx</A></H5>
<BLOCKQUOTE>
For two analytic Jacobians A<sub>1</sub> and A<sub>2</sub> with big period matrices P<sub>1</sub>
and P<sub>2</sub>, this function finds a 2g x 2g symplectic integer matrix 
M such that there exists a complex g x g matrix &alpha; such that 
&alpha; P<sub>1</sub> = P<sub>2</sub> M. Such matrices define isomorphisms between the analytic
Jacobians. The first return value is true if such a matrix is found,
false otherwise. The second and third return values are M and &alpha;,
if found. 
</BLOCKQUOTE>
<H5><A NAME = "17077">IsIsogenousPeriodMatrices(P1, P2) : Mtrx, Mtrx -&gt; Bool, Mtrx</A></H5>
<BLOCKQUOTE>
For two period matrices (small or big) P<sub>1</sub> and P<sub>2</sub>, this function finds 
a nonsingular 2g x 2g integer matrix M such that there exists a 
complex g x g matrix &alpha; such that &alpha; (P<sub>1</sub>, 1) = (P<sub>2</sub>, 1) M, 
in case of small period matrices, or &alpha; P<sub>1</sub> = P<sub>2</sub> M for big period 
matrices. Such a matrix
defines an isogeny between the corresponding analytic Jacobians. The
first return value is true if such a matrix is found, false
otherwise. The second return value is M, if found. In the case of big 
period matrices &alpha; is the third return value.
</BLOCKQUOTE>
<H5><A NAME = "17078">IsIsogenous(A1, A2) : AnHcJac, AnHcJac -&gt; Bool, Mtrx, Mtrx</A></H5>
<BLOCKQUOTE>
For two analytic Jacobians A<sub>1</sub> and A<sub>2</sub> with big period matrices P<sub>1</sub> 
and P<sub>2</sub>, this function finds a nonsingular 2g x 2g integer matrix 
M such that there exists a complex g x g matrix &alpha; such that 
&alpha; P<sub>1</sub> = P<sub>2</sub> M. Such a matrix defines an isogeny between the analytic
Jacobians. The first return value is true if such a matrix is found,
false otherwise. The second and third return values are M and &alpha;,
if found. 
</BLOCKQUOTE>
<H5><A NAME = "17079"></A><A NAME = "EndomorphismRinglabel">EndomorphismRing</A>(P) : Mtrx -&gt; AlgMat</H5>
<BLOCKQUOTE>
This function returns the endomorphism ring, as a matrix algebra, 
of the analytic Jacobian associated to the given period matrix P. 
If a big period matrix, P, is given then it also returns a list 
of &alpha;-matrices such that &alpha; P = P M, for each generator, 
M, of the matrix algebra.
</BLOCKQUOTE>
<H5><A NAME = "17080">EndomorphismRing(A) : AnHcJac -&gt; AlgMat, SeqEnum</A></H5>
<BLOCKQUOTE>
This function returns the endomorphism ring, as a matrix algebra, of 
the given analytic Jacobian A. Suppose the analytic Jacobian has big period 
matrix P. The second return value is a list of &alpha;-matrices 
such that &alpha; P = P M, for each generator, M, of the matrix algebra.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "17081">Example <TT>CrvHyp_Find_Rational_Isogeny (H131E47)</TT></A></H3>
We give an example of how magma can be used to find rational isogenies 
between the Jacobians of genus 2 curves. Let us consider the two curves
y<sup>2</sup> = x<sup>5</sup> - 4x<sup>4</sup> + 8x<sup>2</sup> - 4x,
and
y<sup>2</sup> = x<sup>5</sup> + 4x<sup>4</sup> + 10x<sup>3</sup> + 12x<sup>2</sup> + x.
These are curves 1 and 3 in the twenty second isogeny class of
Smart <A  HREF = "text1482.htm#bib_Smart1">[Sma97]</A>. We compute their analytic Jacobians to 100 decimal
places.
<P>
<P>
<P>
<PRE>
&gt; K&lt;x&gt; := PolynomialRing(RationalField());
&gt; C&lt;i&gt; := ComplexField(100);
&gt; KC&lt;xc&gt; := PolynomialRing(C);
&gt; f1 := x^5 - 4*x^4 + 8*x^2 - 4*x;
&gt; f1C := Evaluate(f1,xc);
&gt; A1 := AnalyticJacobian(f1C);
&gt; f2 := x^5 + 4*x^4 + 10*x^3 + 12*x^2 + x;
&gt; f2C := Evaluate(f2,xc);
&gt; A2 := AnalyticJacobian(f2C);
</PRE>
We now get a basis for the Z-module of isogenies from <TT>A1</TT> to
<TT>A2</TT>. Note that <TT>IsIsogenous</TT> returns <TT>true</TT> for these two
Jacobians, but it does not return an isogeny defined over Q.
<P>
<P>
<PRE>
&gt; Mlst := AnalyticHomomorphisms(SmallPeriodMatrix(A1),SmallPeriodMatrix(A2));
&gt; Mlst;
[
  [ 1  0 -1  0]
  [ 0  1  0  0]
  [ 1  1  1  0]
  [ 1  1 -1  2],


  [ 1  0  1  0]
  [ 0  0  0 -1]
  [-1  0  1 -1]
  [ 1  2  1 -1],


  [ 0  1  0 -1]
  [ 1  0  0  0]
  [ 1  1  0  1]
  [ 1  1  2 -1],


  [ 0  1  0  1]
  [ 0  0 -1  0]
  [ 0 -1 -1  1]
  [ 2  1 -1  1]
]
&gt; 
</PRE>
For each of these four "M" matrices let us find the corresponding &alpha;
matrices.
<P>
<P>
<PRE>
&gt; P1 := BigPeriodMatrix(A1);
&gt; P2 := BigPeriodMatrix(A2);
&gt; alst := [Submatrix(P2*Matrix(C,M),1,1,2,2)
&gt;          *Submatrix(P1,1,1,2,2)^-1 : M in Mlst];
&gt; alst[1][1,1];
9.49857267318279326916448048991143479789137754919824276557860348643797948105949
8481543257426864218501E-101 + -1.41421356237309504&equiv;6887242096980785696718753
76948073176679737990732478462107038850387534327641573*i
&gt; 
</PRE>
So at least <TT>alst[1]</TT> does not correspond to a rational
isogeny. In general none of the four &alpha;-matrices might correspond to a
rational isogeny. But it is possible that some Z-linear combination of
them is defined over the rationals and we want to know whether this
actually happens. We can find out by recognizing the entries of the
&alpha;-matrices as algebraic numbers. This can be done using the <TT>PowerRelation</TT> function.
<P>
<P>
<PRE>
&gt; SetDefaultRealFieldPrecision(100);
&gt; pol := PowerRelation(C!alst[4][1,1],8:Al:="LLL");
&gt; Evaluate(pol,x);
x^4 + 2*x^2 - 1
</PRE>
It turns out that every entry of each of the <TT>alst</TT> matrices is in the
number field defined by the polynomial x<sup>8</sup> + 12x<sup>6</sup> + 34x<sup>4</sup> + 52x<sup>2</sup> + 1.
We can use <TT>LinearRelation</TT> to write each entry as a
linear combination of the elements of a power basis for this number
field. For example:
<P>
<P>
<PRE>
&gt; aroot := C!Roots(Evaluate(x^8 + 12*x^6 + 34*x^4 + 52*x^2 + 1,xc))[1][1];
&gt; basis := [aroot^i : i in [0..7]];
&gt; LinearRelation(Append(basis,alst[1][1,1]));
[ 0, 411, 0, 293, 0, 107, 0, 9, -40 ]
</PRE>
So we can write each &alpha;-matrix as an algebraic number in the
number field defined by x<sup>8</sup> + 12x<sup>6</sup> + 34x<sup>4</sup> + 52x<sup>2</sup> + 1. It is
then a simple matter to find a linear combination of the &alpha;-matrices 
that is defined over Q. In this particular case we get lucky and 
<TT>alst[3]</TT> itself is already rational:
<P>
<P>
<PRE>
&gt; alpha := alst[3];
&gt; alpha;
[1.1429873912822749822157835483053409594519099948227986612151258432276326359067
  38195675448021860172030E-100 + 1.23928539763340698646676489320756860362798512
  5201250666217517621001351893530963357790883492962362769E-100*i
  -0.99999999999999999999999999999999999999999999999999999999999999999999999999
  99999999999999999999999999 + -1.186746029522145753827915120679934647863639129
  872566393745293697438092777106745249196918175632802507E-100*i]
[-2.000000000000000000000000000000000000000000000000000000000000000000000000000
  000000000000000000000000 + 8.334710799700090834903499884806428065464872993741
  227568734726305245439778438567887663105063271942125E-101*i
  1.000000000000000000000000000000000000000000000000000000000000000000000000000
  000000000000000000000000 + -1.29064186778300376477121365149925086148800581946
  5331943514008039451662739730964143625816137036994307E-100*i]
&gt; Matrix(2,2,[Round(Real(x)) : x in Eltseq(alpha)]);
[ 0  1]
[ 2 -1]
</PRE>
So the two Jacobians are Q-isogenous. We can use <TT>alpha</TT> to map
points from the one Jacobian to the other. We check that it maps rational 
points to rational points.
<P>
<P>
<PRE>
&gt; C1 := HyperellipticCurve(f1);
&gt; J1 := Jacobian(C1);
&gt; pts1 := RationalPoints(J1:Bound:=500);
&gt; pts1;
{@ (1, 0, 0), (x^2 - 2*x + 1, 1/2*x + 1/2, 2), (x^2 - 2*x + 1, -1/2*x - 1/2, 2),
(x, 0, 1), (x - 1, 1, 1), (x - 1, -1, 1), (x^2 - 2, 0, 2), (x^2 + 2, 4*x, 2), 
(x^2 + 2, -4*x, 2), (x^2 - x, x, 2), (x^2 - x, -x, 2), (x^2 - 4*x - 2, 4*x, 2), 
(x^2 - 4*x - 2, -4*x, 2), (x^2 - 4*x + 2, 0, 2), (x^2 - 9/4*x - 4, 3/8*x - 2, 
2), (x^2 - 9/4*x - 4, -3/8*x + 2, 2), (x^2 - 52/9*x + 50/9, 152/27*x - 160/27, 
2), (x^2 - 52/9*x + 50/9, -152/27*x + 160/27, 2), (x^2 + 16/25*x - 18/25, 
  152/125*x - 96/125, 2), (x^2 + 16/25*x - 18/25, -152/125*x + 96/125, 2) @}
&gt; P1 := pts1[8]; P1;
(x^2 + 2, 4*x, 2)
&gt; div1 := [r[1] : r in Roots(Evaluate(ElementToSequence(P1)[1],xc))];
&gt; div1 := [&lt;d1,Evaluate(ElementToSequence(P1)[2],d1)&gt; : d1 in div1];
&gt; pt1 := &amp;+[ToAnalyticJacobian(d[1],d[2],A1) : d in div1];
&gt; P2 := FromAnalyticJacobian(alpha*pt1,A2);
&gt; clst := Coefficients((xc-P2[1][1])*(xc-P2[2][1]));
&gt; xpol := K![BestApproximation(Re(c),10^50) : c in clst];
&gt; xpol;
x^2 + x + 1
&gt; C2 := HyperellipticCurve(f2);
&gt; J2 := Jacobian(C2);
&gt; pts2 := RationalPoints(J2:Bound:=500);
&gt; pts2;
{@ (1, 0, 0), (x^2 + 2*x + 1, x - 1, 2), (x^2 + 2*x + 1, -x + 1, 2), (x + 1, 2, 
1), (x + 1, -2, 1), (x, 0, 1), (x^2 + x, 2*x, 2), (x^2 + x, -2*x, 2), (x^2 + x +
  1, 2*x - 1, 2), (x^2 + x + 1, -2*x + 1, 2), (x^2 - 23*x - 16, 122*x + 84, 2), 
(x^2 - 23*x - 16, -122*x - 84, 2), (x^2 + 23/4*x + 9, 59/8*x + 57/2, 2), (x^2 + 
  23/4*x + 9, -59/8*x - 57/2, 2), (x^2 - 106/9*x + 1/9, 2599/54*x - 19/54, 2), 
(x^2 - 106/9*x + 1/9, -2599/54*x + 19/54, 2), (x^2 - 9/16*x - 1/16, 269/64*x + 
  21/64, 2), (x^2 - 9/16*x - 1/16, -269/64*x - 21/64, 2) @}
</PRE>
<HR>
<H4><A NAME = "17082">From Period Matrix to Curve</A></H4>



<H5><A NAME = "17083"></A><A NAME = "RosenhainInvariantslabel">RosenhainInvariants</A>(t) : Mtrx -&gt; Set</H5>
<BLOCKQUOTE>
Given a small period matrix t corresponding to an analytic Jacobian A
of genus g, this function returns a set S of 2g - 1 complex numbers 
such that the hyperelliptic curve y<sup>2</sup> = x(x - 1) &prod;<sub>s &isin;S</sub> (x - s) 
has Jacobian isomorphic to A. The name of the function comes from the 
fact that a hyperelliptic curve in the form 
y<sup>2</sup> = x(x - 1)(x - &lambda;<sub>1</sub>)...(x - &lambda;<sub>2g - 1</sub>) is said to be in
Rosenhain normal form.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "17084">Example <TT>CrvHyp_Find_CM_Curve (H131E48)</TT></A></H3>
We give an example of how magma can be used to find the equation of a
genus 2 curve whose Jacobian has Complex Multiplication by a given
field. We use the field Q(Sqrt( - 2 + &#8730;(2))).
<P>
<P>
<P>
<PRE>
&gt; SetSeed(1);
&gt; Q := RationalField();
&gt; P&lt;x&gt; := PolynomialRing(Q);
&gt; R&lt;s&gt; := NumberField(x^2-2);
&gt; PP&lt;x&gt; := PolynomialRing(R);
&gt; RF := NumberField(x^2-(-2+s));
&gt; CMF&lt;t&gt; := AbsoluteField(RF);
&gt; O := MaximalOrder(CMF);
</PRE>
Now, for a CM type &Phi;, and O the ring of integers,
C<sup>2</sup>/&Phi;((O)) is a torus with Complex
Multiplication by the maximal order of our field
Q(Sqrt( - 2 + &#8730;(2))). In order for this to be an abelian variety
we have to find a principal polarization. This can be done using
Algorithm 1 in <A  HREF = "text1482.htm#bib_wam_red">[Wam99]</A>. In this case it turns out that a
principal polarization is essentially given by a generator of the
inverse different.
<P>
<P>
<PRE>
&gt; D := Different(O);
&gt; IsPrincipal(D);
true
&gt; xi := -1/8*O.2; // a chosen generator of D^-1
&gt; xi*O eq D^-1;
true
&gt; auts := Automorphisms(CMF : Abelian := true);
&gt; cc := auts[3];
&gt; cc(cc(t)) eq t;
true
&gt; cc(xi^2) eq xi^2;
true
</PRE>
So <TT>cc</TT> is complex multiplication and <TT>xi</TT> squared 
is in the real subfield.
By Theorem 3 of <A  HREF = "text1482.htm#bib_wam_red">[Wam99]</A> we see that this gives a principal 
polarization. We now find a Frobenius basis for our lattice with respect to 
the non-degenerate Riemann form given by <TT>xi</TT>.
<P>
<P>
<PRE>
&gt; Z := IntegerRing();                                                          
&gt; E := Matrix(Z,4,4,[Trace(xi*cc(a)*b) : b in Basis(O), a in Basis(O)]);
&gt; D, C := FrobeniusFormAlternating(E); D;
[ 0  0  1  0]
[ 0  0  0  1]
[-1  0  0  0]
[ 0 -1  0  0]
&gt; newb := ElementToSequence(Matrix(O,C)*Matrix(O,4,1,Basis(O)));
&gt; SetKantPrecision(O,100);
&gt; Abs(Re(Conjugate(xi,2))) lt 10^-10 and Im(Conjugate(xi,2)) gt 0;
true
&gt; Abs(Re(Conjugate(xi,4))) lt 10^-10 and Im(Conjugate(xi,4)) gt 0;
true
</PRE>
The CM type &Phi; is given by the second and fourth complex
embeddings. We can finally write down a big period matrix and find the
element in the Siegel upper half-space corresponding to our CM Jacobian:
<P>
<P>
<PRE>
&gt; C := ComplexField(100);
&gt; BigPM := Matrix(C,2,4,[Conjugate(b,2) : b in newb] cat
&gt;                       [Conjugate(b,4) : b in newb]);
&gt; tau := Submatrix(BigPM,1,3,2,2)^-1*Submatrix(BigPM,1,1,2,2);
</PRE>
We can use <A  HREF = "text1501.htm#EndomorphismRinglabel">EndomorphismRing</A> to check that the analytic Jacobian
corresponding to <TT>tau</TT> does have CM by the correct field:
<P>
<P>
<PRE>
&gt; MA := EndomorphismRing(tau); Dimension(MA);
4
&gt; MAGens := SetToSequence(Generators(MA)); MAGens;
[
    [-1  0  0  0]
    [ 0 -1  0  0]
    [ 0  0 -1  0]
    [ 0  0  0 -1],

    [  0   0 -17  -7]
    [  0   0  -7  -3]
    [  5 -12   0   0]
    [-12  29   0   0]
]
&gt; MP := [MinimalPolynomial(g): g in MAGens];
&gt; IsIsomorphic(NumberField(rep{f: f in MP | Degree(f) gt 1}), CMF);
true
</PRE>
Now let us find a curve with this Jacobian.
<P>
<P>
<PRE>
&gt; S := RosenhainInvariants(tau);
&gt; P&lt;x&gt; := PolynomialRing(C);
&gt; f := x*(x-1)*&amp;*{x-a : a in S};
&gt; IC := IgusaClebschInvariants(f);
&gt; ICp := [BestApproximation(Re(r),10^50) : r in
&gt;          [IC[1]/IC[1], IC[2]/IC[1]^2, IC[3]/IC[1]^3, IC[4]/IC[1]^5]];
&gt; ICp;
[ 1, 5/324, 31/5832, 1/1836660096 ]
&gt; C1 := HyperellipticCurveFromIgusaClebsch(ICp);
&gt; C2 := ReducedWamelenModel(C1);
&gt; C2;
Hyperelliptic Curve defined by y^2 = -x^5 - 3*x^4 + 2*x^3 + 6*x^2 - 3*x - 1 
over Rational Field
</PRE>
Let's check that this curve's analytic Jacobian is isomorphic to the one 
corresponding to <TT>tau</TT>.
<P>
<P>
<PRE>
&gt; P&lt;x&gt; := PolynomialRing(C);
&gt; f := -x^5 - 3*x^4 + 2*x^3 + 6*x^2 - 3*x - 1;
&gt; A := AnalyticJacobian(f);
&gt; IsIsomorphicSmallPeriodMatrices(tau,SmallPeriodMatrix(A));
true
[ 1 -2  0  0]
[ 0  0  2  1]
[ 1 -2  5  2]
[ 2 -5  4  2]
</PRE>
<HR>
<H4><A NAME = "17085">Voronoi Cells</A></H4>

<P>
<P>
This section describes two functions that are concerned with the
computation of Voronoi cells.


<H5><A NAME = "17086"></A><A NAME = "Delaunaylabel">Delaunay</A>(sites) : SeqEnum -&gt; SeqEnum</H5>
<BLOCKQUOTE>
This function computes the Delaunay triangulation for the sites given by 
sites. The argument sites should be a sequence of pairs 
(of type <TT>Tup</TT>) of real numbers. The real numbers should all belong 
to the same real field. For n sites, a sequence of n sequences is 
returned. The ith sequence contains the list of indices of the sites 
to which site i should be joined to form the triangulation.
</BLOCKQUOTE>
<H5><A NAME = "17087">Voronoi(sites) : SeqEnum -&gt; SeqEnum, SeqEnum, SeqEnum</A></H5>
<BLOCKQUOTE>
This function computes the Voronoi cells for the sites given by
sites. A Voronoi cell of a site consists of all those points
in the plane closer to that site than to any other. The argument
sites should be a sequence of pairs (of type <TT>Tup</TT>) of
real numbers. The real numbers can be either fixed precision or
free reals, but they should all be in the same real field. 
<P>
Three sequences, <I>siteedges</I>, <I>dualsites</I> and <I>cells</I> are
returned. The sequence <I>siteedges</I> is what the intrinsic 
<A  HREF = "text1501.htm#Delaunaylabel">Delaunay</A> would have returned (so it defines the 
Delaunay triangulation). The sequence <I>dualsites</I>
is a sequence of triples &lt;x, y, m&gt;, interpreted as follows: If
m is zero the triple represents the point x, y. If m 
is non-zero the triple represents a point "at infinity" in
the direction of the vector x, y.  For n sites, <I>cells</I>
is a sequence of n sequences. The ith sequence is a list 
[i1, i2, i3, ..., im] such that the cell around site i is formed
by connecting <I>dualsites[i1]</I> to <I>dualsites[i2]</I>, ... If a
cell is infinite the first and last indices in the sequence point to
infinite points. That is, the two infinite sides are given by the
lines (x<sub>0</sub>, y<sub>0</sub>) + t (x<sub>1</sub>, y<sub>1</sub>), for t &ge;0 where (x<sub>0</sub>, y<sub>0</sub>)
equals <I>dualsites[i2][1], dualsites[i2][2]</I> and (x<sub>1</sub>, y<sub>1</sub>)
equals <I>dualsites[i1][1], dualsites[i1][2]</I> or (x<sub>0</sub>, y<sub>0</sub>)
equals <I>dualsites[i{m-1</I>][1], dualsites[i{m-1}][2]} and
(x<sub>1</sub>, y<sub>1</sub>) equals <I>dualsites[im][1], dualsites[im][2]</I>.
</BLOCKQUOTE>
<PRE></PRE> <A  HREF = "text1482.htm">[Next]</A><A  HREF = "text1500.htm">[Prev]</A> <A  HREF = "text1482.htm">[Right]</A> <A  HREF = "text1500.htm">[Left]</A> <A  HREF = "text1483.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<br><small>Version: V2.22 of <I>
Thu Jun  9 16:37:49 EST 2016
</I></small>
</body></html>