<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <link rel='stylesheet' href='help.css' type='text/css'>
  <TITLE>The Combinatorics of  Polytopes</TITLE>
</head>
<body BGCOLOR="#FFFFFF">

 <A  HREF = "text1734.htm">[Next]</A><A  HREF = "text1732.htm">[Prev]</A> <A  HREF = "text1734.htm">[Right]</A> <A  HREF = "text1732.htm">[Left]</A> <A  HREF = "text1729.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<PRE></PRE><H3><A NAME = "19065">The Combinatorics of  Polytopes</A></H3>




<H5>Subsections</H5>
<UL>
<LI> <A  HREF = "text1733.htm#19066">Points in Polytopes and Polyhedra</A>
<LI> <A  HREF = "text1733.htm#19074">Ehrhart Theory of Polytopes</A>
<LI> <A  HREF = "text1733.htm#19080">Isomorphism Testing and Normal Forms for Polytopes</A>
<LI> <A  HREF = "text1733.htm#19089">Automorphisms of a Polytope</A>
<LI> <A  HREF = "text1733.htm#19092">Operations on Polytopes</A>
</UL>
<H4><A NAME = "19066">Points in Polytopes and Polyhedra</A></H4>

<P>
<P>
Given a polygon, one might want to know how many integral points
it contains, and one might want to list them.
These are computed by different algorithms (although one can
of course list the points and then count them). For point counting
we use the methods of Barvinok and Pommersheim (<A  HREF = "text1728.htm#bib_MR1731815">[BP99]</A>),
as described in <A  HREF = "text1728.htm#bib_MR2094541">[DLHTY04]</A>.
More generally, one might want to know the number of points
in integral dilations of a polytope: these numbers are the
coefficients of a generating function, the Ehrhart series;
this is discussed in a later section.


<H5><A NAME = "19067">v in C : TorLatElt,TorCon -&gt; BoolElt</A></H5>
<H5>v in P : TorLatElt,TorPol -&gt; BoolElt</H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if and only if the point v is contained in the cone C or polyhedron P.
</BLOCKQUOTE>
<H5><A NAME = "19068">IsInInterior(v,C) : TorLatElt,TorCon -&gt; BoolElt</A></H5>
<H5>IsInInterior(v,P) : TorLatElt,TorPol -&gt; BoolElt</H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if and only if the point v lies in the strict interior of the cone C or polyhedron P.
</BLOCKQUOTE>
<H5><A NAME = "19069">IsOnBoundary(v,C) : TorLatElt,TorCon -&gt; BoolElt</A></H5>
<H5>IsOnBoundary(v,P) : TorLatElt,TorPol -&gt; BoolElt</H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if and only if the point v lies on the (relative) boundary of the cone C or polyhedron P.
</BLOCKQUOTE>
<H5><A NAME = "19070">HasIntegralPoint(P) : TorPol -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if and only if the polyhedron P contains an integral lattice point.
</BLOCKQUOTE>
<H5><A NAME = "19071">Points(P) : TorPol -&gt; SeqEnum[TorLatElt]</A></H5>
<H5>InteriorPoints(P) : TorPol -&gt; SeqEnum[TorLatElt]</H5>
<H5>BoundaryPoints(P) : TorPol -&gt; SeqEnum[TorLatElt]</H5>
<BLOCKQUOTE>
The integral toric lattice points, the strictly interior
lattice points, or the boundary lattice points
of the polytope P.
</BLOCKQUOTE>
<H5><A NAME = "19072">NumberOfPoints(P) : TorPol -&gt; RngIntElt</A></H5>
<H5>NumberOfInteriorPoints(P) : TorPol -&gt; RngIntElt</H5>
<H5>NumberOfBoundaryPoints(P) : TorPol -&gt; RngIntElt</H5>
<BLOCKQUOTE>
The number of integral toric lattice points, the number of strictly interior lattice points, or the number of boundary lattice points of the polytope P.
</BLOCKQUOTE>
<H5><A NAME = "19073">Volume(P) : TorPol -&gt; FldRatElt</A></H5>
<H5>VolumeOfBoundary(P) : TorPol -&gt; FldRatElt</H5>
<BLOCKQUOTE>
The normalised volume and normalised boundary volume of the polytope P.
</BLOCKQUOTE>
<H4><A NAME = "19074">Ehrhart Theory of Polytopes</A></H4>



<H5><A NAME = "19075">EhrhartSeries(P) : TorPol -&gt; FldFunRatUElt</A></H5>
<BLOCKQUOTE>
The rational generating function (Ehr)<sub>P</sub>(t) of the Ehrhart series for the polytope P. The coefficient c<sub>m</sub> of t<sup>m</sup> in the power-series expansion of (Ehr)<sub>P</sub>(t) is equal to the number of lattice points in mP.
</BLOCKQUOTE>
<H5><A NAME = "19076">EhrhartDeltaVector(P) : TorPol -&gt; SeqEnum</A></H5>
<BLOCKQUOTE>
The Ehrhart &delta;-vector (also known as the h<sup> * </sup>-vector) for the polytope P. This is a sequence of integers defining the numerator of the Ehrhart generating function (Ehr)<sub>P</sub>(t) of P. More precisely, if n=(dim)(P) and k&isin;Z<sub>&gt;0</sub> is the smallest dilation of P such that kP is a lattice polytope, then (Ehr)<sub>P</sub>(t) = (&delta;<sub>0</sub> + &delta;<sub>1</sub>t + ... + &delta;<sub>k(n + 1) - 1</sub>t<sup>k(n + 1) - 1</sup>) / (1 - t<sup>k</sup>)<sup>n + 1</sup>.
</BLOCKQUOTE>
<H5><A NAME = "19077">EhrhartPolynomial(P) : TorPol -&gt; [RngUPolElt]</A></H5>
<BLOCKQUOTE>
A sequence representing the Ehrhart (quasi-)polynomial for the polytope P. That is, a sequence of polynomials [p<sub>0</sub>, ..., p<sub>r - 1</sub>] of length r, the quasi-period of the Ehrhart polynomial, so that the number of lattice points of the dilation mP is the value of p<sub>s</sub>(k), where m=kr + s is the Euclidean division of m by r; in other words, s is the least residue of m modulo r. Note that since Magma indexes sequences from 1, we have that p<sub>i</sub> =  <TT>EhrhartPolynomial(P)[i+1]</TT>.
</BLOCKQUOTE>
<H5><A NAME = "19078">EhrhartCoefficients(P,l) : TorPol,RngIntElt -&gt; [RngIntElt]</A></H5>
<BLOCKQUOTE>
The first l + 1 coefficients of the Ehrhart series for the polytope P
(starting with 0P up to and including lP).
</BLOCKQUOTE>
<H5><A NAME = "19079">EhrhartCoefficient(P,k) : TorPol,RngIntElt -&gt; RngIntElt</A></H5>
<BLOCKQUOTE>
The number of lattice points in the (non-negative, integral)
dilation kP of the polytope P.
</BLOCKQUOTE>
<H4><A NAME = "19080">Isomorphism Testing and Normal Forms for Polytopes</A></H4>

<P>
<P>
It is often necessary to determine whether two convex polytopes P and Q, embedded in a lattice &Lambda;, are isomorphic with respect to a lattice automorphism; that is, whether there exists an element of GL<sub>n</sub>(Z) sending P to Q. For example, in toric geometry lattice polytopes form one of the key constructions of projective toric varieties, and any classification must somehow address the issue of whether there exists an automorphism of the underlying lattice sending P to Q.
<P>
In general, any isomorphism problem can be solved in one of two ways: on a case-by-case basis by constructing an explicit isomorphism between the two objects, or by determining a normal form for each isomorphism class. Both approaches are supported.
<P>
The first approach -- dynamically constructing a lattice-preserving isomorphism in GL<sub>n</sub>(Z) between the two polytopes -- has the advantage that it works equally well for rational polytopes and for polytopes of non-zero codimension. The algorithm works by reducing the problem to a graph isomorphism question to which well-developed tools such as Brendan McKay's Nauty software <A  HREF = "text1728.htm#bib_bdm_nauty_paper">[McK81]</A>, <A  HREF = "text1728.htm#bib_bdm_nauty_manual">[McK]</A> can then be applied.
<P>
The second approach -- to compute a normal form (NF)(P) for each isomorphism class -- works only for lattice polytopes of codimension zero. The normal form algorithm used by Magma is based on one developed by Kreuzer and Skarke for their Palp software <A  HREF = "text1728.htm#bib_KS04">[KS04]</A>. Briefly, row and column permutations are applied to the vertex--facet pairing matrix of P, placing it in a form that is maximal with respect to a certain ordering. This in turn defines an order in which to list the vertices of P; the choice of basis is fixed by taking the Hermite normal form.
<P>
Slightly more generally, one may wish to consider polytopes up to change of basis and translation, i.e. up to affine equivalence. Once again Magma offers two solutions. Affine equivalence between two (possibly rational) polytopes can be determined on a case-by-case basis, or an affine normal form can be calculated. All the algorithms are described in detail in <A  HREF = "text1728.htm#bib_GK13">[GK13]</A>.


<H5><A NAME = "19081">IsIsomorphic(P,Q) : TorPol,TorPol -&gt; BoolElt, Map</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> iff the polytopes P and Q are isomorphic, i.e. if there exists an  element in GL<sub>n</sub>(Z) sending P to Q. If true, also gives an isomorphism  from P to Q. The polytopes may be rational, and need not be of maximum dimension in the ambient lattice.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "19082">Example <TT>Polyhedra_polytope-isomorphism-example (H149E5)</TT></A></H3>
We begin by creating a random rational 2-dimensional polytope in a 3-dimensional lattice. We shall then apply a random change of basis to P to generate an isomorphic polytope Q.
<P>
<P>
<PRE>
&gt; P:=RandomPolytope(3,3,4) / 2;
&gt; P;
2-dimensional polytope P with 3 generators:
    ( 0,  -2,   1),
    ( 0, 1/2,  -2),
    (-1, 3/2,   0)
&gt; Q:=P * RandomGLnZ(3,3,3);
&gt; Q;
2-dimensional polytope Q with 3 generators:
    ( -2,  -3,   -1),
    (1/2, 5/2, -3/2),
    (5/2, 3/2,  5/2)
</PRE>
Now we recover the isomorphism between these two polytopes:
<P>
<P>
<PRE>
&gt; bool,phi:=IsIsomorphic(P,Q);
&gt; bool;
true
&gt; Image(phi,P) eq Q;
true
</PRE>
The lattice isomorphism can easily be recovered as a matrix in GL<sub>3</sub>(Z):
<P>
<P>
<PRE>
&gt; M:=DefiningMatrix(phi);
&gt; M;
[-1  0 -1]
[ 1  1  1]
[ 0 -1  1]
&gt; P * M eq Q;
true
</PRE>
<HR>
<H5><A NAME = "19083">IsEquivalent(P,Q) : TorPol,TorPol -&gt; BoolElt, Map, TorLatElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> iff the polytopes P and Q are equivalent, i.e. if there exists an  element in GL<sub>n</sub>(Z) and lattice translation sending P to Q. If true, also gives the map as a lattice map varphi and translation v such that varphi(P) + v = Q.
</BLOCKQUOTE>
<H5><A NAME = "19084">NormalForm(P) : TorPol -&gt; SeqEnum, GrpPermElt</A></H5>
<H5>PALPNormalForm(P) : TorPol -&gt; SeqEnum, GrpPermElt</H5>
<BLOCKQUOTE>
The Palp normal form of the maximum dimensional lattice polytope P. This is given as a sequence of lattice points equal to the (ordered) vertices of (NF)(P). Also gives the permutation of the vertices of P used to calculate this normal form.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "19085">Example <TT>Polyhedra_polytope-normal-form-example (H149E6)</TT></A></H3>
We start by computing the normal form of a lattice polytope.
<P>
<P>
<PRE>
&gt; P:=Polytope([[62,23],[-8,-3],[-27,-10]]);
&gt; NF:=NormalForm(P);
&gt; NF;
[
    (1, 0),
    (0, 1),
    (-2, -1)
]
</PRE>
People familiar with toric geometry will recognise this as the weighted projective space P(1, 1, 2); we can verify this in one line of code by comparing the normal forms:
<P>
<P>
<PRE>
&gt; NormalForm(PolytopeOfWPS([1,1,2])) eq NF;
true
</PRE>
Now we exhibit one way to recover the change of basis that sends P to its normal form (NF)(P). We need to capture the permutation of the vertices, so we redo the calculation and this time we save the second return value:
<P>
<P>
<PRE>
&gt; NF,perm:=NormalForm(P);
&gt; perm;
(1, 3)
</PRE>
The change of basis in GL<sub>2</sub>(Z) is now trivial to compute:
<P>
<P>
<PRE>
&gt; vertsP:=PermuteSequence(Vertices(P),perm);
&gt; VP:=Matrix(vertsP);
&gt; VQ:=Matrix(NF);
&gt; M:=Solution(Transpose(VP),Transpose(VQ));
&gt; M:=Transpose(M);
&gt; M;
[ -3  10]
[  8 -27]
&gt; P * M;
2-dimensional polytope with 3 vertices:
    (-2, -1),
    ( 0,  1),
    ( 1,  0)
</PRE>
<HR>
<H5><A NAME = "19086">AffineNormalForm(P) : TorPol -&gt; SeqEnum, GrpPermElt</A></H5>
<BLOCKQUOTE>
The affine normal form of the maximum dimensional lattice polytope P. This is given as a sequence of lattice points equal to the (ordered) vertices of (AffNF)(P). Also gives the permutation of the vertices of P used to calculate this affine normal form.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "19087">Example <TT>Polyhedra_polytope-affine-normal-form-example (H149E7)</TT></A></H3>
We wish to classify all polygons in an [0, N] x [0, N] box but not contained in a smaller [0, N - 1] x [0, N - 1] box, up to change of basis and translation. To do this we make use of the affine normal form. We will perform the classification for N&le;4.
<P>
<P>
<PRE>
&gt; procedure classify_polygons_recurse(P,~class,allclass)
&gt;     for v in Vertices(P) do
&gt;         Q:=Polytope(Exclude(Points(P),v));
&gt;         if Dimension(Q) eq 2 then
&gt;             AffNF:=AffineNormalForm(Q);
&gt;             if not AffNF in class and
&gt;                     not &amp;or[AffNF in subclass : subclass in allclass] then
&gt;                 Include(~class,AffNF);
&gt;                 $$(Q,~class,allclass);
&gt;             end if;
&gt;         end if;
&gt;     end for;
&gt; end procedure;
&gt;
&gt; function classify_polygons(N)
&gt;     allclass:=[];
&gt;     for i in [1..N] do
&gt;         B:=Polytope([[0,0],[i,0],[0,i],[i,i]]);
&gt;         class:={AffineNormalForm(B)};
&gt;         classify_polygons_recurse(B,~class,allclass);
&gt;         Append(~allclass,class);
&gt;     end for;
&gt;     return allclass;
&gt; end function;
&gt;
&gt; classification:=classify_polygons(4);
&gt; [#class : class in classification];
[ 2, 15, 131, 1369 ]
</PRE>
<HR>
<H5><A NAME = "19088">MaximalVertexFacetHeightMatrix(P) : TorPol -&gt; AlgMatElt</A></H5>
<BLOCKQUOTE>
This is the maximal vertex--facet pairing matrix of P constructed as part of the normal form algorithm. For the details of its construction, see <A  HREF = "text1728.htm#bib_KS04">[KS04]</A>, <A  HREF = "text1728.htm#bib_GK13">[GK13]</A>.
</BLOCKQUOTE>
<H4><A NAME = "19089">Automorphisms of a Polytope</A></H4>



<H5><A NAME = "19090">AutomorphismGroup(P) : TorPol -&gt; GrpMat</A></H5>
<BLOCKQUOTE>
The subgroup of GL(n, (Z)) (acting on the ambient lattice) which leaves
the polyhedron P unchanged.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "19091">Example <TT>Polyhedra_polytope-automorphism-example (H149E8)</TT></A></H3>
<P>
<P>
<PRE>
&gt; P:=CrossPolytope(2);
&gt; P;
2-dimensional polytope P with 4 vertices:
    ( 1,  0),
    ( 0,  1),
    (-1,  0),
    ( 0, -1)
&gt; AutomorphismGroup(P);
MatrixGroup(2, Integer Ring)
Generators:
    [0 1]
    [1 0]

    [ 0  1]
    [-1  0]
</PRE>
<HR>
<H4><A NAME = "19092">Operations on Polytopes</A></H4>



<H5><A NAME = "19093">Triangulation(P) : TorPol -&gt; SetEnum</A></H5>
<BLOCKQUOTE>
A sequence of polytopes that make a triangulation of the polytope P.
</BLOCKQUOTE>
<H5><A NAME = "19094">TriangulationOfBoundary(P) : TorPol -&gt; SetEnum</A></H5>
<BLOCKQUOTE>
A sequence of polytopes that make a triangulation of the
boundary of the polytope P.
</BLOCKQUOTE>
<PRE></PRE> <A  HREF = "text1734.htm">[Next]</A><A  HREF = "text1732.htm">[Prev]</A> <A  HREF = "text1734.htm">[Right]</A> <A  HREF = "text1732.htm">[Left]</A> <A  HREF = "text1729.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<br><small>Version: V2.22 of <I>
Thu Jun  9 16:37:49 EST 2016
</I></small>
</body></html>