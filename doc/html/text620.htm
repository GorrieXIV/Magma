<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <link rel='stylesheet' href='help.css' type='text/css'>
  <TITLE>Standard Subgroup  Constructions</TITLE>
</head>
<body BGCOLOR="#FFFFFF">

 <A  HREF = "text621.htm">[Next]</A><A  HREF = "text619.htm">[Prev]</A> <A  HREF = "text621.htm">[Right]</A> <A  HREF = "text619.htm">[Left]</A> <A  HREF = "text612.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<PRE></PRE><H3><A NAME = "6734">Standard Subgroup  Constructions</A></H3>

<P>
<P>
Some functions described in this section may not exist or may have restrictions
for some categories of groups. Details can be found in the chapters on the
individual categories.



<H5>Subsections</H5>
<UL>
<LI> <A  HREF = "text620.htm#6745">Abstract Group Predicates</A>
</UL>
<H5><A NAME = "6735">H ^ g : GrpFin, GrpFinElt -&gt; GrpFin</A></H5>
<H5>Conjugate(H, g) : GrpFin, GrpFinElt -&gt; GrpFin</H5>
<BLOCKQUOTE>
Construct the conjugate g<sup> - 1</sup>Hg of the group H by the element g. 
The group H and the element g must belong to the same generic group.
</BLOCKQUOTE>
<H5><A NAME = "6736">H meet K : GrpFin, GrpFin -&gt; GrpFin</A></H5>
<BLOCKQUOTE>
Given groups H and K which belong to the same symmetric
group, construct the intersection of H and K.
</BLOCKQUOTE>
<H5><A NAME = "6737">CommutatorSubgroup(G, H, K) : GrpFin, GrpFin, GrpFin -&gt; GrpFin</A></H5>
<H5>CommutatorSubgroup(H, K) : GrpFin, GrpFin -&gt; GrpFin</H5>
<BLOCKQUOTE>
Given groups H and K, both subgroups of the group G, construct 
the commutator subgroup of H and K in the group G. If K is a
subgroup of H, then the group G may be omitted.
</BLOCKQUOTE>
<H5><A NAME = "6738">Centralizer(G, g) : GrpFin, GrpFinElt -&gt; GrpFin</A></H5>
<H5>Centraliser(G, g) : GrpFin, GrpFinElt -&gt; GrpFin</H5>
<BLOCKQUOTE>
Construct the centralizer of the element g in the group G.
</BLOCKQUOTE>
<H5><A NAME = "6739">Centralizer(G, H) : GrpFin, GrpFin -&gt; GrpFin</A></H5>
<H5>Centraliser(G, H) : GrpFin, GrpFin -&gt; GrpFin</H5>
<BLOCKQUOTE>
Construct the centralizer of the group H in the group G.
</BLOCKQUOTE>
<H5><A NAME = "6740">Core(G, H) : GrpFin, GrpFin -&gt; GrpFin</A></H5>
<BLOCKQUOTE>
Given a subgroup H of the group G, construct the maximal normal 
subgroup of G that is contained in the subgroup H.
</BLOCKQUOTE>
<H5><A NAME = "6741">H ^ G : GrpFin, GrpFin -&gt; GrpFin</A></H5>
<H5>NormalClosure(G, H) : GrpFin, GrpFin -&gt; GrpFin</H5>
<BLOCKQUOTE>
Given a subgroup H of the group G, construct
the normal closure of H in G.
</BLOCKQUOTE>
<H5><A NAME = "6742">Normalizer(G, H) : GrpFin, GrpFin -&gt; GrpFin</A></H5>
<H5>Normaliser(G, H) : GrpFin, GrpFin -&gt; GrpFin</H5>
<BLOCKQUOTE>
Given a subgroup H of the group G, construct the normalizer
of H in G.
</BLOCKQUOTE>
<H5><A NAME = "6743">pCore(G, p) : GrpFin, RngIntElt -&gt; GrpFin</A></H5>
<BLOCKQUOTE>
Given a group G and a prime p dividing the order of G,
construct the maximal normal p-subgroup of G.
</BLOCKQUOTE>
<H5><A NAME = "6744">SylowSubgroup(G, p) : GrpFin, RngIntElt -&gt; GrpFin</A></H5>
<H5>Sylow(G, p) : GrpFin, RngIntElt -&gt; GrpFin</H5>
<BLOCKQUOTE>
Given a group G and a prime p, construct a Sylow
p-subgroup of G.
</BLOCKQUOTE>
<H4><A NAME = "6745">Abstract Group Predicates</A></H4>

<P>
<P>
Some functions described in this section may not exist or may have restrictions
for some categories of groups. Details can be found in the chapters on the
individual categories.


<H5><A NAME = "6746">IsAbelian(G) : GrpFin -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if the group G is abelian, <TT>false</TT> otherwise.
</BLOCKQUOTE>
<H5><A NAME = "6747">IsCyclic(G) : GrpFin -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if the group G is cyclic, <TT>false</TT> otherwise.
</BLOCKQUOTE>
<H5><A NAME = "6748">IsElementaryAbelian(G) : GrpFin -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if the group G is elementary abelian, <TT>false</TT> otherwise.
</BLOCKQUOTE>
<H5><A NAME = "6749">IsCentral(G, H) : GrpFin, GrpFin -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Return <TT>true</TT> if the subgroup H of the group G lies in the centre of
G, <TT>false</TT> otherwise.
</BLOCKQUOTE>
<H5><A NAME = "6750">IsConjugate(G, g, h) : GrpFin, GrpFinElt, GrpFinElt -&gt; BoolElt, GrpFinElt</A></H5>
<BLOCKQUOTE>
Given a group G and elements g and h belonging to G,
return the value <TT>true</TT> if g and h are conjugate in G. The
function returns a second value if the elements
are conjugate: an element k which conjugates g into h.
</BLOCKQUOTE>
<H5><A NAME = "6751">IsConjugate(G, H, K) : GrpFin, GrpFin, GrpFin -&gt; BoolElt, GrpFinElt</A></H5>
<BLOCKQUOTE>
Given a group G and subgroups H and K belonging to G,
return the value <TT>true</TT> if H and K are conjugate in G. The
function returns a second value if the subgroups
are conjugate: an element z which conjugates H into K.
</BLOCKQUOTE>
<H5><A NAME = "6752">IsExtraSpecial(G) : GrpFin -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Given a group G is a p-group G, return <TT>true</TT> if G is
extra-special, <TT>false</TT> otherwise.
</BLOCKQUOTE>
<H5><A NAME = "6753">IsHyperelementary(G) : Grp -&gt; BoolElt,Grp,Grp</A></H5>

<PRE>    p: RngIntElt                        Default: 0</PRE>
<BLOCKQUOTE>
Test if G is a finite hyperelementary (=quasi-elementary) group, 
that is a semi-direct product G=C:P with C cyclic and P 
a p-group of order coprime to C. If yes, returns <TT>true</TT>, C, P. 
Otherwise returns <TT>false</TT>. 
The prime number p can be forced with an optional parameter 
p (0 by default).
</BLOCKQUOTE>
<HR>
<H3><A NAME = "6754">Example <TT>Grp_grp-ishyperelementary (H62E20)</TT></A></H3>
<P>
<P>
<PRE>
&gt; ok,C,P:=IsHyperelementary(Sym(3));   // S3=C3:C2 is hyperelementary
&gt; ok,GroupName(C),GroupName(P);
true C3 C2
&gt; ok,C,P:=IsHyperelementary(Sylow(Sym(6),2));    // So is any p-group
&gt; ok,GroupName(C),GroupName(P);
true C1 C2*D4
&gt; IsHyperelementary(Sym(4));             // S4 is not hyperelementary
false
</PRE>
<HR>
<H5><A NAME = "6755">IsMaximal(G, H) : GrpFin, GrpFin -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if the subgroup H of the group G is a maximal subgroup
of G.  This function is evaluated by constructing the
permutation representation of G on the cosets of H and
testing this representation for primitivity.  For this reason,
the use of <TT>IsMaximal</TT> should be avoided if the index of H
in G exceeds a one hundred thousand.
</BLOCKQUOTE>
<H5><A NAME = "6756">IsNilpotent(G) : GrpFin -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Return <TT>true</TT> if the group G is nilpotent, <TT>false</TT> otherwise.
</BLOCKQUOTE>
<H5><A NAME = "6757">IsNormal(G, H) : GrpFin, GrpFin -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Return <TT>true</TT> if the subgroup H of the group G is a normal subgroup
of G, <TT>false</TT> otherwise.
</BLOCKQUOTE>
<H5><A NAME = "6758">IsPerfect(G) : GrpFin -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Return <TT>true</TT> if the group G is perfect, <TT>false</TT> otherwise.
</BLOCKQUOTE>
<H5><A NAME = "6759">IsQGroup(G) : Grp -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if the group G is a Q-group (all characters are rational-valued).
</BLOCKQUOTE>
<HR>
<H3><A NAME = "6760">Example <TT>Grp_grp-isqgroup (H62E21)</TT></A></H3>
<P>
<P>
<PRE>
&gt; IsQGroup(Sym(4));         // Symmetric groups S_n are Q-groups
true
&gt; IsQGroup(Alt(4));         // and alternating groups A_n are not (for n&gt;2)
false
</PRE>
<HR>
<H5><A NAME = "6761">IsSelfNormalizing(G, H) : GrpFin, GrpFin -&gt; BoolElt</A></H5>
<H5>IsSelfNormalising(G, H) : GrpFin, GrpFin -&gt; BoolElt</H5>
<BLOCKQUOTE>
Return <TT>true</TT> if the subgroup H of the group G is self-normalizing
in G, <TT>false</TT> otherwise.
</BLOCKQUOTE>
<H5><A NAME = "6762">IsSimple(G) : GrpFin -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Return <TT>true</TT> if the group G is simple, <TT>false</TT> otherwise.
</BLOCKQUOTE>
<H5><A NAME = "6763">IsSoluble(G) : GrpFin -&gt; BoolElt</A></H5>
<H5>IsSolvable(G) : GrpFin -&gt; BoolElt</H5>
<BLOCKQUOTE>
Return <TT>true</TT> if the group G is soluble, <TT>false</TT> otherwise.
</BLOCKQUOTE>
<H5><A NAME = "6764">IsSpecial(G) : GrpFin -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Given a p-group G,  return <TT>true</TT> if G is special, <TT>false</TT>
otherwise.
</BLOCKQUOTE>
<H5><A NAME = "6765">IsSubnormal(G, H) : GrpFin, GrpFin -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Return <TT>true</TT> if the subgroup H of the group G is subnormal in G,
<TT>false</TT> otherwise.
</BLOCKQUOTE>
<H5><A NAME = "6766">IsTrivial(G) : Grp -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Return <TT>true</TT> if G is trivial, <TT>false</TT> otherwise.
</BLOCKQUOTE>
<PRE></PRE> <A  HREF = "text621.htm">[Next]</A><A  HREF = "text619.htm">[Prev]</A> <A  HREF = "text621.htm">[Right]</A> <A  HREF = "text619.htm">[Left]</A> <A  HREF = "text612.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<br><small>Version: V2.22 of <I>
Thu Jun  9 16:37:49 EST 2016
</I></small>
</body></html>