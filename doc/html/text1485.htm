<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <link rel='stylesheet' href='help.css' type='text/css'>
  <TITLE>Creation Functions</TITLE>
</head>
<body BGCOLOR="#FFFFFF">

 <A  HREF = "text1486.htm">[Next]</A><A  HREF = "text1484.htm">[Prev]</A> <A  HREF = "text1486.htm">[Right]</A> <A  HREF = "text1484.htm">[Left]</A> <A  HREF = "text1483.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<PRE></PRE><H3><A NAME = "16731">Creation Functions</A></H3>




<H5>Subsections</H5>
<UL>
<LI> <A  HREF = "text1485.htm#16732">Creation of a Hyperelliptic Curve</A>
<LI> <A  HREF = "text1485.htm#16737">Creation Predicates</A>
<LI> <A  HREF = "text1485.htm#16741">Changing the Base Ring</A>
<LI> <A  HREF = "text1485.htm#16747">Models</A>
<LI> <A  HREF = "text1485.htm#16758">Predicates on Models</A>
<LI> <A  HREF = "text1485.htm#16764">Twisting Hyperelliptic Curves</A>
<LI> <A  HREF = "text1485.htm#16774">Type Change Predicates</A>
</UL>
<H4><A NAME = "16732">Creation of a Hyperelliptic Curve</A></H4>

<P>
<P>
A hyperelliptic curve C given by a generalized Weierstrass equation 
y<sup>2</sup> + h(x) y = f(x) is created by specifying polynomials h(x) and 
f(x) over a field K.  The class of hyperelliptic curves includes 
curves of genus one, and a hyperelliptic curve may also be constructed 
by type change from an elliptic curve E.  Note that the ambient
space of C is a weighted projective space in which the one or two 
points at infinity are nonsingular. 


<H5><A NAME = "16733">HyperellipticCurve(f, h) : RngUPolElt, RngUPolElt -&gt; CrvHyp</A></H5>
<H5>HyperellipticCurve(f, h) : RngElt, RngUPolElt -&gt; CrvHyp</H5>
<H5>HyperellipticCurve(f, h) : RngUPolElt, RngElt -&gt; CrvHyp</H5>
<H5>HyperellipticCurve(f) : RngUPolElt  -&gt; CrvHyp</H5>
<H5>HyperellipticCurve([f, h]) : [ RngUPolElt ] -&gt; CrvHyp</H5>
<BLOCKQUOTE>
Given two polynomials h and f &isin;R[x] where R is a field or
integral domain, this function returns the nonsingular hyperelliptic 
curve C: y<sup>2</sup> + h(x)y = f(x).  If h(x) is not given, then it is 
taken as zero.  If R is an integral domain rather than a field, 
the base field of the curve is taken to be the field of fractions of
R. An error is returned if the given curve C is singular.
</BLOCKQUOTE>
<H5><A NAME = "16734">HyperellipticCurve(P, f, h) : Prj, RngUPolElt, RngUPolElt -&gt; CrvHyp</A></H5>
<BLOCKQUOTE>
Create the hyperelliptic curve as described above using the projective space
P as the ambient. The ambient P should have dimension 2.
</BLOCKQUOTE>
<H5><A NAME = "16735">HyperellipticCurveOfGenus(g, f, h) : RngIntElt, RngUPolElt, RngUPolElt -&gt; CrvHyp</A></H5>
<H5>HyperellipticCurveOfGenus(g, f, h) : RngIntElt, RngElt, RngUPolElt -&gt; CrvHyp</H5>
<H5>HyperellipticCurveOfGenus(g, f, h) : RngIntElt, RngUPolElt, RngElt -&gt; CrvHyp</H5>
<H5>HyperellipticCurveOfGenus(g, f) : RngIntElt, RngUPolElt -&gt; CrvHyp</H5>
<H5>HyperellipticCurveOfGenus(g, [f, h]) : RngIntElt, [RngUPolElt] -&gt; CrvHyp</H5>
<BLOCKQUOTE>
Given a positive integer g and two polynomials h and f &isin;R[x]
where R is a field or integral domain, this function returns the 
nonsingular hyperelliptic curve of genus g given by C: y<sup>2</sup> + h(x)y = f(x). 
If h(x) is not given, then it is taken as zero.  Before attempting to
create C, the function checks that its genus will be g by testing
various numerical conditions on f and g. If the genus is not correct, 
a runtime error is raised.  If R is an integral domain rather than a field, 
the base field of C is taken to be the field of fractions of R. An 
error is returned if the curve C is singular.
</BLOCKQUOTE>
<H5><A NAME = "16736">HyperellipticCurve(E) : CrvEll  -&gt; CrvHyp, Map</A></H5>
<BLOCKQUOTE>
Returns the hyperelliptic curve C corresponding to the elliptic 
curve E, followed by the map from E to C.
</BLOCKQUOTE>
<H4><A NAME = "16737">Creation Predicates</A></H4>



<H5><A NAME = "16738">IsHyperellipticCurve([f, h]) : [ RngUPolElt ] -&gt; BoolElt, CrvHyp</A></H5>
<BLOCKQUOTE>
Given a sequence containing two polynomials h, f &isin;R[x], where
R is an integral domain, return <TT>true</TT> if and only if C: y<sup>2</sup> + h(x)y =
f(x) is a hyperelliptic curve. In this case, the curve is returned as
a second value.
</BLOCKQUOTE>
<H5><A NAME = "16739">IsHyperellipticCurveOfGenus(g, [f, h]) : RngIntElt, [RngUPolElt] -&gt; BoolElt, CrvHyp</A></H5>
<BLOCKQUOTE>
Given a positive integer g and a sequence containing two polynomials
h, f &isin;R[x] where R is an integral domain, return <TT>true</TT> if and
only if C: y<sup>2</sup> + h(x)y = f(x) is a hyperelliptic curve of genus g.
In this case, the curve is returned as a second value.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "16740">Example <TT>CrvHyp_Creation (H131E1)</TT></A></H3>
<P>
Create a hyperelliptic curve over the rationals:
<P>
<P>
<P>
<PRE>
&gt; P&lt;x&gt; := PolynomialRing(RationalField());
&gt; C := HyperellipticCurve(x^6+x^2+1);
&gt; C;
Hyperelliptic Curve defined by y^2 = x^6 + x^2 + 1 over Rational Field
&gt; C![0,1,1];
(0 : 1 : 1)
</PRE>
<P>
Now create the same curve over a finite field:
<P>
<P>
<P>
<PRE>
&gt; P&lt;x&gt; := PolynomialRing(GF(7));
&gt; C := HyperellipticCurve(x^6+x^2+1);
&gt; C;
Hyperelliptic Curve defined by y^2 = x^6 + x^2 + 1 over GF(7)
&gt; C![0,1,1];
(0 : 1 : 1)
</PRE>
<HR>
<H4><A NAME = "16741">Changing the Base Ring</A></H4>



<H5><A NAME = "16742">BaseChange(C, K) : Sch, Fld  -&gt; Sch</A></H5>
<H5>BaseExtend(C, K) : Sch, Fld  -&gt; Sch</H5>
<BLOCKQUOTE>
Given a hyperelliptic curve C defined over a field k, and a field K
which is an extension of k, return a hyperelliptic curve C' over K 
using the natural inclusion of k in K to map the coefficients of C 
into elements of K.
</BLOCKQUOTE>
<H5><A NAME = "16743">BaseChange(C, j) : Sch, Map -&gt; Sch</A></H5>
<H5>BaseExtend(C, j) : Sch, Map -&gt; Sch</H5>
<BLOCKQUOTE>
Given a hyperelliptic curve C defined over a field k and a ring map
j : k -&gt; K, return a hyperelliptic curve C' over K by
applying j to the coefficients of E.
</BLOCKQUOTE>
<H5><A NAME = "16744">BaseChange(C, n) : Sch, RngIntElt -&gt; Sch</A></H5>
<H5>BaseExtend(C, n) : Sch, RngIntElt -&gt; Sch</H5>
<BLOCKQUOTE>
If C is a hyperelliptic curve defined over a finite field k and a 
positive integer n, let K denote the extension of k of degree n.
This function returns a hyperelliptic curve C' over K using the 
natural inclusion of k in K to map the coefficients of C into 
elements of K.
</BLOCKQUOTE>
<H5><A NAME = "16745">ChangeRing(C, K) : Sch, Rng -&gt; Sch</A></H5>
<BLOCKQUOTE>
Given a hyperelliptic curve C defined over a field k, and a field K,
return a hyperelliptic curve C' over K that is obtained from C by
by mapping the coefficients of C into K using the standard coercion
map from k to K.  This is useful when there is no appropriate ring 
homomorphism between k and K (e.g., when k=Q and K is a finite 
field).
</BLOCKQUOTE>
<HR>
<H3><A NAME = "16746">Example <TT>CrvHyp_BaseExtension (H131E2)</TT></A></H3>
<P>
We construct a curve C over the rationals and use <TT>ChangeRing</TT>
to construct the corresponding curve C1 over GF(101).
<P>
<P>
<P>
<PRE>
&gt; P&lt;x&gt; := PolynomialRing(RationalField());
&gt; C := HyperellipticCurve([x^9-x^2+57,x+1]);
&gt; C1 := ChangeRing(C, GF(101));
&gt; C1;
Hyperelliptic Curve defined by y^2 + (x + 1)*y = x^9 + 100*x^2 + 57 
over GF(101)
&gt; Q&lt;t&gt; := PolynomialRing(GF(101));
&gt; HyperellipticPolynomials(C1);
t^9 + 100*t^2 + 57
t + 1
&gt; C2, f := SimplifiedModel(C1);
&gt; HyperellipticPolynomials(C2);
4*t^9 + 98*t^2 + 2*t + 27
0
&gt; P1 := C1![31,30,1];
&gt; P1;
(31 : 30 : 1)
&gt; Q := P1@f; // evaluation 
&gt; Q;
(31 : 92 : 1)
&gt; Q@@f; // pullback 
(31 : 30 : 1)
</PRE>
<P>
An explanation of the syntax for isomorphisms of hyperelliptic 
curves and the functions for models is given below.
<HR>
<H4><A NAME = "16747">Models</A></H4>



<H5><A NAME = "16748">SimplifiedModel(C) : CrvHyp -&gt; CrvHyp, MapIsoSch</A></H5>
<BLOCKQUOTE>
Given a hyperelliptic curve C defined over a field of characteristic
not equal to 2, this function returns an isomorphic hyperelliptic 
curve C' of the form y<sup>2</sup> = f(x), followed by the isomorphism 
C -&gt; C'.
</BLOCKQUOTE>
<H5><A NAME = "16749">HasOddDegreeModel(C) : CrvHyp -&gt; BoolElt, CrvHyp, MapIsoSch</A></H5>
<BLOCKQUOTE>
Given a hyperelliptic curve C, this function returns <TT>true</TT> if 
C has a model C' of the form y<sup>2</sup> = f(x), with f of odd 
degree.  If so, C' is returned together with the isomorphism 
C -&gt; C'.
</BLOCKQUOTE>
<H5><A NAME = "16750">IntegralModel(C) : CrvHyp -&gt; CrvHyp, MapIsoSch</A></H5>

<PRE>    Reduce: BoolElt                     Default: <TT>false</TT></PRE>
<BLOCKQUOTE>
Given a hyperelliptic curve C defined over the rationals, this 
function returns an isomorphic curve C' given by polynomials with 
integral coefficients, together with the isomorphism C -&gt; C'.
If <TT>Reduce</TT> is set <TT>true</TT>, common divisors of the coefficients 
are eliminated as far as possible.
</BLOCKQUOTE>
<H5><A NAME = "16751">MinimalWeierstrassModel(C) : CrvHyp -&gt; CrvHyp, MapIsoSch</A></H5>

<PRE>    Bound: RngIntElt                    Default: 0</PRE>

<PRE>    SetVerbose("CrvHypMinimal", n):     Maximum: 3</PRE>
<BLOCKQUOTE>
Given a hyperelliptic curve C defined over the rationals, this 
function returns a globally minimal Weierstrass model C' of C. 
If <TT>Bound</TT> is set, it gives an upper bound for the bad primes 
that are checked.  As this calculation uses trial division, 
<TT>Bound</TT> should not be set much larger than 10<sup>7</sup>. The 
isomorphism C -&gt; C' is returned as a second value.
</BLOCKQUOTE>
<H5><A NAME = "16752">pIntegralModel(C, p) : CrvHyp, RngIntElt -&gt; CrvHyp, MapIsoSch</A></H5>
<H5>pIntegralModel(C, p) : CrvHyp, FldRatElt -&gt; CrvHyp, MapIsoSch</H5>
<H5>pIntegralModel(C, p) : CrvHyp, RngUPolElt -&gt; CrvHyp, MapIsoSch</H5>
<H5>pIntegralModel(C, p) : CrvHyp, FldFunRatUElt -&gt; CrvHyp, MapIsoSch</H5>
<H5>pIntegralModel(C, p) : CrvHyp, Infty -&gt; CrvHyp, MapIsoSch</H5>

<PRE>    SetVerbose("CrvHypMinimal", n):     Maximum: 3</PRE>
<BLOCKQUOTE>
Given a hyperelliptic curve C defined over Q or a rational
function field, this function returns a model C'
of the curve that is integral at the place p given as an 
integer, rational, polynomial, rational function or &infin;. The isomorphism 
C -&gt; C' is returned as a second value.
</BLOCKQUOTE>
<H5><A NAME = "16753">pNormalModel(C, p) : CrvHyp, RngIntElt -&gt; CrvHyp, MapIsoSch</A></H5>
<H5>pNormalModel(C, p) : CrvHyp, FldRatElt -&gt; CrvHyp, MapIsoSch</H5>
<H5>pNormalModel(C, p) : CrvHyp, RngUPolElt -&gt; CrvHyp, MapIsoSch</H5>
<H5>pNormalModel(C, p) : CrvHyp, FldFunRatUElt -&gt; CrvHyp, MapIsoSch</H5>
<H5>pNormalModel(C, p) : CrvHyp, Infty -&gt; CrvHyp, MapIsoSch</H5>

<PRE>    SetVerbose("CrvHypMinimal", n):     Maximum: 3</PRE>
<BLOCKQUOTE>
Given a hyperelliptic curve C defined over Q or a rational
function field, this function returns a model C'
of the curve that is normal at the place p given as an integer,
rational, polynomial, rational function or &infin;. The isomorphism 
C -&gt; C' is returned as a second value.
</BLOCKQUOTE>
<H5><A NAME = "16754">pMinimalWeierstrassModel(C, p) : CrvHyp, RngIntElt -&gt; CrvHyp, MapIsoSch</A></H5>
<H5>pMinimalWeierstrassModel(C, p) : CrvHyp, FldRatElt -&gt; CrvHyp, MapIsoSch</H5>
<H5>pMinimalWeierstrassModel(C, p) : CrvHyp, RngUPolElt -&gt; CrvHyp, MapIsoSch</H5>
<H5>pMinimalWeierstrassModel(C, p) : CrvHyp, FldFunRatUElt -&gt; CrvHyp, MapIsoSch</H5>
<H5>pMinimalWeierstrassModel(C, p) : CrvHyp, Infty -&gt; CrvHyp, MapIsoSch</H5>

<PRE>    SetVerbose("CrvHypMinimal", n):     Maximum: 3</PRE>
<BLOCKQUOTE>
Given a hyperelliptic curve C defined over Q or a rational
function field, this function returns a Weierstrass model C'
of the curve that is minimal at the place p given as an integer,
rational, polynomial, rational function or &infin;. The isomorphism 
C -&gt; C' is returned as a second value.
</BLOCKQUOTE>
<H5><A NAME = "16755">ReducedModel(C) : CrvHyp -&gt; CrvHyp, MapIsoSch</A></H5>

<PRE>    Simple: BoolElt                     Default: <TT>false</TT></PRE>

<PRE>    Al: MonStgElt                       Default: "Stoll"</PRE>

<PRE>    SetVerbose("CrvHypReduce", n):      Maximum: 3</PRE>
<BLOCKQUOTE>
Given a hyperelliptic curve C with integral coefficients, this 
computes a reduced model C'.  If the Stoll algorithm is used (default)
then the curve argument must have integral coefficients and reduction
is performed with respect to the action of SL<sub>2</sub>(Z) on the 
(x, z)-coordinates.  If the Wamelen algorithm is used, 
(<TT>Al := "Wamelen"</TT>), the curve must have genus 2.
The isomorphism C -&gt; C' is currently returned only for the 
algorithm of Stoll. 
</BLOCKQUOTE>
<H5><A NAME = "16756">ReducedMinimalWeierstrassModel(C) : CrvHyp -&gt; CrvHyp, MapIsoSch</A></H5>

<PRE>    Simple: BoolElt                     Default: <TT>false</TT></PRE>

<PRE>    SetVerbose("CrvHypMinimal", n):     Maximum: 3</PRE>

<PRE>    SetVerbose("CrvHypReduce", n):      Maximum: 3</PRE>
<BLOCKQUOTE>
Given a hyperelliptic curve C defined over the rationals, this 
function returns a globally minimal integral Weierstrass model C' 
of C that is reduced with respect to the action of SL<sub>2</sub>(Z), 
using Stoll's algorithm in <TT>ReducedModel</TT>.  The isomorphism 
C -&gt; C' is returned as a second value.
</BLOCKQUOTE>
<H5><A NAME = "16757">SetVerbose("CrvHypReduce", v) : MonStgElt, RngIntElt -&gt;</A></H5>
<BLOCKQUOTE>
This sets the verbose printing level for the curve reduction algorithms 
of Stoll and Wamelen.  The second argument can take integral values 
in the interval [0, 3], or boolean values: <TT>false</TT> (equivalent to 0) 
and <TT>true</TT> (equivalent to 1).
</BLOCKQUOTE>
<H4><A NAME = "16758">Predicates on Models</A></H4>



<H5><A NAME = "16759">IsSimplifiedModel(C) : CrvHyp -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if the hyperelliptic curve C is of the form y<sup>2</sup> = f(x).
</BLOCKQUOTE>
<H5><A NAME = "16760">IsIntegral(C) : CrvHyp -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Given a hyperelliptic curve C, the function returns <TT>true</TT> 
if C has integral coefficients, and <TT>false</TT> otherwise.
</BLOCKQUOTE>
<H5><A NAME = "16761">IspIntegral(C, p) : CrvHyp, RngIntElt -&gt; BoolElt</A></H5>
<H5>IspIntegral(C, p) : CrvHyp, RngUPolElt -&gt; BoolElt</H5>
<H5>IspIntegral(C, p) : CrvHyp, Infty -&gt; BoolElt</H5>
<BLOCKQUOTE>
Given a hyperelliptic curve C defined over Q or a rational
function field, this function returns <TT>true</TT>
if the given model of C is integral at the given place. 
</BLOCKQUOTE>
<H5><A NAME = "16762">IspNormal(C, p) : CrvHyp, RngIntElt -&gt; BoolElt</A></H5>
<H5>IspNormal(C, p) : CrvHyp, RngUPolElt -&gt; BoolElt</H5>
<H5>IspNormal(C, p) : CrvHyp, Infty -&gt; BoolElt</H5>
<BLOCKQUOTE>
Given a hyperelliptic curve C defined over Q or a rational
function field, this function returns <TT>true</TT>
if the given model of C is normal at the given place. 
</BLOCKQUOTE>
<H5><A NAME = "16763">IspMinimal(C, p) : CrvHyp, RngIntElt -&gt; BoolElt, BoolElt</A></H5>
<H5>IspMinimal(C, p) : CrvHyp, RngUPolElt -&gt; BoolElt, BoolElt</H5>
<H5>IspMinimal(C, p) : CrvHyp, Infty -&gt; BoolElt, BoolElt</H5>
<BLOCKQUOTE>
Given a hyperelliptic curve C defined over Q or a rational
function field, this function decides whether 
the given model of C is minimal at the given place. 
The returned values as follows:
<P>
<DL COMPACT class='compact'>
<DT><IMG SRC="closed.gif" ALT="" WIDTH=7 HEIGHT=7></DT><DD><TT>false</TT>, <TT>false</TT> if C is not an integral 
minimal model at the given place.
<P>
<DT><IMG SRC="closed.gif" ALT="" WIDTH=7 HEIGHT=7></DT><DD><TT>true</TT>, <TT>false</TT> if C is integral and minimal at the given place, 
but not the unique minimal model (up to transformations that are invertible over the local ring).
<P>
<DT><IMG SRC="closed.gif" ALT="" WIDTH=7 HEIGHT=7></DT><DD><TT>true</TT>, <TT>false</TT> if C is the unique integral minimal model at the given place, 
(up to transformations that are invertible over the local ring).</DL>
</BLOCKQUOTE>
<H4><A NAME = "16764">Twisting Hyperelliptic Curves</A></H4>

<P>
<P>
There are standard functions for quadratic twists of hyperelliptic curves
in characteristic not equal to 2. In addition, from the new package of
Lercier and Ritzenthaler (described in more detail in the next section)
there are functions to return <I>all</I> twists of a genus 2 hyperelliptic
curve over a finite field of any characteristic.


<H5><A NAME = "16765">QuadraticTwist(C, d) : CrvHyp, RngElt -&gt; CrvHyp</A></H5>
<BLOCKQUOTE>
Given a hyperelliptic curve C defined over a field k of 
characteristic not equal to 2 and an element d that is coercible
into k, return the quadratic twist of C by d.
</BLOCKQUOTE>
<H5><A NAME = "16766">QuadraticTwist(C) : CrvHyp -&gt; CrvHyp</A></H5>
<BLOCKQUOTE>
Given a hyperelliptic curve C defined over a finite field k,
return the standard quadratic twist of C over the unique extension
of k of degree 2. If the characteristic of k is odd, then this is
the same as the twist of C by a primitive element of k.
</BLOCKQUOTE>
<H5><A NAME = "16767">QuadraticTwists(C) : CrvHyp -&gt; SeqEnum</A></H5>
<BLOCKQUOTE>
Given a hyperelliptic curve C defined over a finite field k of
odd characteristic, return a sequence containing the non-isomorphic
quadratic twists of C.
<P>
</BLOCKQUOTE>
<H5><A NAME = "16768">IsQuadraticTwist(C, D) : CrvHyp, CrvHyp -&gt; BoolElt, RngElt</A></H5>

<PRE>    SetVerbose("CrvHypIso", n):         Maximum: 3</PRE>
<BLOCKQUOTE>
Given hyperelliptic curves C and D over a common field k
having characteristic not equal to two, return <TT>true</TT> if and 
only if C is a quadratic twist of D  over k.  If so, the 
twisting factor is returned as the second value. 
</BLOCKQUOTE>
<H5><A NAME = "16769">Twists(C) : CrvHyp -&gt; SeqEnum[CrvHyp], GrpPerm</A></H5>
<H5>Twists(GI) : SeqEnum[FldFin] -&gt; SeqEnum[CrvHyp], GrpPerm</H5>
<BLOCKQUOTE>
For C a genus 2 or 3 hyperelliptic curve over a finite field k,
returns the sequence of <I>all</I> twists of C
(<I>ie</I>, a set of representatives of all isomorphism classes of
curves over k isomorphic to C over bar(k)) along with the
abstract geometric automorphism group of C (and all of its twists)
as a permutation group.
<P>
For genus 2, k can be any characteristic. For genus 3, the
characteristic of k must be at least 11 and the model of C
of the form y<sup>2</sup>=f(x).
<P>
There is also a version where the argument is GI, the sequence of
Cardona-Quer-Nart-Pujola invariants of a genus 2 curve over a finite
field (see Section <A  HREF = "text1486.htm#16790">Igusa Invariants</A>) which returns the
full set of isomorphism classes (twists) of curves over k with the
given invariants.
<P>
These functions are part of the package contributed by Lercier and
Ritzenthaler which is more fully described in the Igusa invariants
section.
</BLOCKQUOTE>
<H5><A NAME = "16770">HyperellipticPolynomialsFromShiodaInvariants(JI) : SeqEnum -&gt; SeqEnum, GrpPerm</A></H5>
<BLOCKQUOTE>
Computes and returns all twists of a genus 3 hyperelliptic curve and its geometric
automorphism group corresponding to a sequence of Shioda invariants JI
(see Section <A  HREF = "text1486.htm#16807">Shioda Invariants</A>) over a finite field of characteristic
at least 11. In fact the first return value is a sequence of polynomials f(x)
of degree 7 or 8 such that the twisted curves correspond to y<sup>2</sup>=f(x). The
reason for this is that JI could be a <I>singular</I> set of invariants
corresponding to polynomials f with discriminant zero. In that case, these
do not correspond to hyperelliptic curves, but it might be useful to
get the full set of twists anyway.
<P>
This function comes from the genus 3 package contributed by Lercier and
Ritzenthaler.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "16771">Example <TT>CrvHyp_QuadraticTwists (H131E3)</TT></A></H3>
We construct the quadratic twists of the hyperelliptic curve 
y<sup>2</sup>=x<sup>6</sup> + x<sup>2</sup> + 1 defined over GF(7).
<P>
<P>
<P>
<PRE>
&gt; P&lt;x&gt; := PolynomialRing(GF(7));
&gt; C := HyperellipticCurve(x^6+x^2+1);
&gt; QuadraticTwists(C);
[
    Hyperelliptic Curve defined by y^2 = x^6 + x^2 + 1 over GF(7),
    Hyperelliptic Curve defined by y^2 = 3*x^6 + 3*x^2 + 3 over GF(7)
]
&gt; IsIsomorphic($1[1],$1[2]);
false
</PRE>
<HR>
<H3><A NAME = "16772">Example <TT>CrvHyp_QuadraticTwists (H131E4)</TT></A></H3>
We take a hyperelliptic curve over the rationals and form a quadratic twist
of it.
<P>
<P>
<P>
<PRE>
&gt; P&lt;x&gt; := PolynomialRing(Rationals());
&gt; C := HyperellipticCurve(x^6+x);
&gt; C7 := QuadraticTwist(C, 7);
&gt; C7;
Hyperelliptic Curve defined by y^2 = 7*x^6 + 7*x over Rational Field
</PRE>
<P>
We now use the function <TT>IsIsomorphic</TT> to verify that C and C<sub>7</sub>
are nonisomorphic. We then extend the field of definition of both curves 
to Q(Sqrt(7)) and verify that the curves become isomorphic over this 
extension.
<P>
<P>
<P>
<PRE>
&gt; IsIsomorphic(C, C7);                                                 
false
&gt; K&lt;w&gt; := ext&lt; Rationals() | x^2-7 &gt;;                                  
&gt; CK := BaseChange(C, K);                                              
&gt; C7K := BaseChange(C7, K);                                            
&gt; IsIsomorphic(CK, C7K);                                               
true (x : y : z) :-&gt; (x : -1/7*w*y : z)
</PRE>
<HR>
<H3><A NAME = "16773">Example <TT>CrvHyp_QuadraticTwists (H131E5)</TT></A></H3>
We find all the twists of a supersingular genus 2 curve over F<sub>2</sub>.
<P>
<P>
<P>
<PRE>
&gt; P&lt;x&gt; := PolynomialRing(GF(2));
&gt; C := HyperellipticCurve(x^5,P!1);                                            
&gt; C;
Hyperelliptic Curve defined by y^2 + y = x^5 over GF(2)
&gt; tws,auts := Twists(C);
&gt; tws;
[
    Hyperelliptic Curve defined by y^2 + y = x^5 over GF(2),
    Hyperelliptic Curve defined by y^2 + y = x^5 + x^4 over GF(2),
    Hyperelliptic Curve defined by y^2 + y = x^5 + x^4 + 1 over GF(2)
]
&gt; #auts; // auts is the geometric automorphism group of C
160
</PRE>
<HR>
<H4><A NAME = "16774">Type Change Predicates</A></H4>



<H5><A NAME = "16775">IsEllipticCurve(C) : CrvHyp -&gt; BoolElt, CrvEll, MapIsoSch, MapIsoSch</A></H5>
<BLOCKQUOTE>
The function returns <TT>true</TT> if and only if C is a genus one hyperelliptic curve of odd 
degree, in which case it also returns an elliptic curve E isomorphic to 
C followed by the isomorphism C -&gt; E and the inverse 
isomorphism E -&gt; C.
</BLOCKQUOTE>
<PRE></PRE> <A  HREF = "text1486.htm">[Next]</A><A  HREF = "text1484.htm">[Prev]</A> <A  HREF = "text1486.htm">[Right]</A> <A  HREF = "text1484.htm">[Left]</A> <A  HREF = "text1483.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<br><small>Version: V2.22 of <I>
Thu Jun  9 16:37:49 EST 2016
</I></small>
</body></html>