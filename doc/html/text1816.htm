<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <link rel='stylesheet' href='help.css' type='text/css'>
  <TITLE>Elementary Invariants and  Predicates for Multigraphs</TITLE>
</head>
<body BGCOLOR="#FFFFFF">

 <A  HREF = "text1817.htm">[Next]</A><A  HREF = "text1815.htm">[Prev]</A> <A  HREF = "text1817.htm">[Right]</A> <A  HREF = "text1815.htm">[Left]</A> <A  HREF = "text1809.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<PRE></PRE><H3><A NAME = "20164">Elementary Invariants and  Predicates for Multigraphs</A></H3>

<P>
<P>
<P>
<P>
<P>
<P>
Most but not all of the invariants and predicates that apply to simple graphs
  (see Sections <A  HREF = "text1792.htm#19827">Elementary Invariants of a  Graph</A> and <A  HREF = "text1793.htm#19832">Elementary Graph Predicates</A>) also apply to 
  multigraphs.
We list them below.
<P>
<P>
<P>
Let G and H be two graphs.
For clarity, we list here once again the conditions under which
  G is equal to H and H is a subgraph of G.
<P>
<P>
<P>
The graphs G and H are equal if and only if:
<DL COMPACT class='compact'>
<DT>-</DT><DD>they are of the same type,
<DT>-</DT><DD>they are structurally identical,
<DT>-</DT><DD>they have the same support,
<DT>-</DT><DD>they have identical vertex and edge labels,
<DT>-</DT><DD>if applicable, the total capacity from u to v in G 
         is equal to the   total capacity from u to v in H.
<P>
<P>
<P>
</DL>
Also, H is a subgraph of G if and only if:
<DL COMPACT class='compact'>
<DT>-</DT><DD>they are of the same type,
<DT>-</DT><DD>H is a structural subgraph of G,
<DT>-</DT><DD>any vertex <TT>v</TT> in H has the same support as the vertex
        <TT>VertexSet(G)!v</TT> in G,
<DT>-</DT><DD>any vertex <TT>v</TT>  in H has the same label as the vertex
        <TT>VertexSet(G)!v</TT> in G,
<DT>-</DT><DD>any edge <TT>e</TT> in H has the same label as the edge
        <TT>EdgeSet(G)!e</TT> in G,
<DT>-</DT><DD>if applicable, the total capacity from u to v in G 
        is at least as large as the   total capacity from u to v
        in H.
<P>
<P>
<P>
</DL>
Note that the truth value of the above two tests is not dependent
  on the weights of the edges of the graphs, should these
  edges be weighted.
<P>
Finally, we have introduced a few predicates to help users determine
  if a general graph is simple or not, undirected or not.


<H5><A NAME = "20165">Order(G) : GrphMult -&gt; RngIntElt</A></H5>
<H5>NumberOfVertices(G) : GrphMult -&gt; RngIntElt</H5>
<BLOCKQUOTE>
The number of vertices of the graph G.
</BLOCKQUOTE>
<H5><A NAME = "20166">Size(G) : GrphMult -&gt; RngIntElt</A></H5>
<H5>NumberOfEdges(G) : GrphMult -&gt; RngIntElt</H5>
<BLOCKQUOTE>
The number of edges of the graph G.
</BLOCKQUOTE>
<H5><A NAME = "20167">u adj v : GrphVert, GrphVert -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Let u and v be two vertices of the same graph G.
If G is undirected, returns <TT>true</TT> if and only if u and v 
  are adjacent.
If G is directed, returns <TT>true</TT> if and only if there is an edge
  directed from u to v.
</BLOCKQUOTE>
<H5><A NAME = "20168">e adj f : GrphEdge, GrphEdge -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Let e and f be two edges of the same graph G.
If G is undirected, returns <TT>true</TT> if and only if e and f share
  a common vertex.
If G is directed, returns <TT>true</TT> if and only if the terminal 
  vertex of e (f) is the initial vertex of f (e).
</BLOCKQUOTE>
<H5><A NAME = "20169">u notadj v : GrphVert, GrphVert -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
The negation of the <TT>adj</TT> predicate applied to vertices.
</BLOCKQUOTE>
<H5><A NAME = "20170">e notadj f : GrphEdge, GrphEdge -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
The negation of the <TT>adj</TT> predicate applied to edges.
</BLOCKQUOTE>
<H5><A NAME = "20171">u in e : GrphVert, GrphEdge -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Let u be a vertex and e an edge of a graph G.
Returns <TT>true</TT> if and only if u is an end-vertex of e.
</BLOCKQUOTE>
<H5><A NAME = "20172">u notin e : GrphVert, GrphEdge -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
The negation of the <TT>in</TT> predicate applied to a vertex with 
 respect to an edge.
</BLOCKQUOTE>
<H5><A NAME = "20173">G eq H : GrphMultUnd, GrphMultUnd -&gt; BoolElt</A></H5>
<H5>G eq H : GrphMultDir, GrphMultDir -&gt; BoolElt</H5>
<H5>G eq H : GrphNet, GrphNet -&gt; BoolElt</H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if and only if the graphs G and H are equal,
  that is if and only if they are structurally equal
  and are compatible with respect to their support, vertex and 
  edge labels, and edge capacities (see the introduction to this section).
</BLOCKQUOTE>
<H5><A NAME = "20174">IsSubgraph(G, H) : GrphMultUnd, GrphMultUnd  -&gt; BoolElt</A></H5>
<H5>IsSubgraph(G, H) : GrphMultDir, GrphMultDir  -&gt; BoolElt</H5>
<H5>IsSubgraph(G, H) : GrphNet, GrphNet  -&gt; BoolElt</H5>
<BLOCKQUOTE>
Returns <TT>true</TT>  if and only if H is a subgraph of G,
  that is, if and only if H is a structural subgraph of G 
  and the graphs are compatible with respect to their support,
  vertex and edge labels, and edge capacities
  (see the introduction to this section).
</BLOCKQUOTE>
<H5><A NAME = "20175">IsBipartite(G) : GrphMultUnd -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if and only if the graph G is bipartite.
</BLOCKQUOTE>
<H5><A NAME = "20176">Bipartition(G) : GrphMultUnd -&gt; [ { GrphVert } ]</A></H5>
<BLOCKQUOTE>
Given a bipartite graph G, return its two partite sets in the form
of a pair of subsets of V(G).
</BLOCKQUOTE>
<H5><A NAME = "20177">IsRegular(G) : GrphMult -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if and only if G is a regular graph.
</BLOCKQUOTE>
<H5><A NAME = "20178">IsComplete(G) : GrphMult -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if and only if the graph G, on n vertices, 
         is the complete graph on n vertices.
</BLOCKQUOTE>
<H5><A NAME = "20179">IsEmpty(G) : GrphMult -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if and only if the  edge-set of the graph is empty.
</BLOCKQUOTE>
<H5><A NAME = "20180">IsNull(G) : GrphMult -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if and only if the vertex-set of the graph is empty.
</BLOCKQUOTE>
<H5><A NAME = "20181">IsSimple(G) : GrphMult -&gt; BoolElt</A></H5>
<H5>IsSimple(G) : Grph -&gt; BoolElt</H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if and only if G is a simple graph.
</BLOCKQUOTE>
<H5><A NAME = "20182">IsUndirected(G) : GrphMult -&gt; BoolElt</A></H5>
<H5>IsUndirected(G) : Grph -&gt; BoolElt</H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if and only if G is a undirected graph.
</BLOCKQUOTE>
<H5><A NAME = "20183">IsDirected(G) : GrphMult -&gt; BoolElt</A></H5>
<H5>IsDirected(G) : Grph -&gt; BoolElt</H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if and only if G is a directed graph.
</BLOCKQUOTE>
<PRE></PRE> <A  HREF = "text1817.htm">[Next]</A><A  HREF = "text1815.htm">[Prev]</A> <A  HREF = "text1817.htm">[Right]</A> <A  HREF = "text1815.htm">[Left]</A> <A  HREF = "text1809.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<br><small>Version: V2.22 of <I>
Thu Jun  9 16:37:49 EST 2016
</I></small>
</body></html>