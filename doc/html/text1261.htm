<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <link rel='stylesheet' href='help.css' type='text/css'>
  <TITLE>Basic Module Constructions</TITLE>
</head>
<body BGCOLOR="#FFFFFF">

 <A  HREF = "text1262.htm">[Next]</A><A  HREF = "text1260.htm">[Prev]</A> <A  HREF = "text1262.htm">[Right]</A> <A  HREF = "text1260.htm">[Left]</A> <A  HREF = "text1254.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<PRE></PRE><H3><A NAME = "13877">Basic Module Constructions</A></H3>

<P>
<P>
The following functions give some fundamental basic constructions with modules.


<H5><A NAME = "13878">M + N : ModMPol, ModMPol -&gt; ModMPol</A></H5>
<BLOCKQUOTE>
Given compatible modules M and N (ie, embedded in the same ambient module),
return the sum of M and N; that is, the submodule of the ambient generated
by M and N.
</BLOCKQUOTE>
<H5><A NAME = "13879">M meet N : ModMPol, ModMPol -&gt; ModMPol</A></H5>
<BLOCKQUOTE>
Given compatible modules M and N (ie, embedded in the same ambient module),
return the intersection of M and N in the ambient. This uses the standard
algorithm for intersecting two modules of a free module (see Section 2.8.3 of
<A  HREF = "text1253.htm#bib_GrPf02">[GP02]</A>). If the ambient
is the quotient of a free module F by non-trivial relations, the intersection
performed is effectively that of the inverse images of M and N in F.
</BLOCKQUOTE>
<H5><A NAME = "13880">f * M : ModMPol, RngElt -&gt; ModMPol</A></H5>
<H5>M * f : ModMPol, RngElt -&gt; ModMPol</H5>
<BLOCKQUOTE>
Given an R-module M and an element f&isin;R, return the
submodule of M generated by { f.v: v &isin;M }
or { v.f: v &isin;M }, respectively.
</BLOCKQUOTE>
<H5><A NAME = "13881">I * M : RngMPol, ModMPol -&gt; ModMPol</A></H5>
<H5>M * I : ModMPol, RngMPol -&gt; ModMPol</H5>
<BLOCKQUOTE>
Given an R-module M and an ideal I of R, return the
submodule of M generated by { f.v: f &isin;I, v &isin;M }
or { v.f: f &isin;I, v &isin;M }, respectively.
</BLOCKQUOTE>
<H5><A NAME = "13882">M / N : ModMPol, ModMPol -&gt; ModMPol</A></H5>
<BLOCKQUOTE>
Given compatible modules M and N (ie, embedded in the same ambient module),
return the quotient module M/(M &cap;N).
This has the same effect as using the <TT>quo</TT> constructor.
</BLOCKQUOTE>
<H5><A NAME = "13883">DirectSum(M, N) : ModMPol, ModMPol -&gt; ModMPol, [ModMPolHom], [ModMPolHom]</A></H5>
<BLOCKQUOTE>
Given R-modules M and N, return the direct sum D = M direct-sum N
and two sequences of corresponding homomorphisms giving the injections
into and projections from D, respectively.
</BLOCKQUOTE>
<H5><A NAME = "13884">DirectSum(S) : [ModMPol] -&gt; ModMPol, [ModMPolHom], [ModMPolHom]</A></H5>
<H5>DirectSum(S) : [* ModMPol *] -&gt; ModMPol, [ModMPolHom], [ModMPolHom]</H5>
<BLOCKQUOTE>
A sequence or list L of R-modules, return their direct sum D and
two sequences of corresponding homomorphisms giving the injections into
and projections from D, respectively.
</BLOCKQUOTE>
<H5><A NAME = "13885">Twist(M, d) : ModMPol, RngIntElt -&gt; [ ModMPolElt ], ModMPolHom</A></H5>
<BLOCKQUOTE>
Given a graded module M, and an integer d, return the Serre twist M(d)
and an isomorphism f:M -&gt; M(d).  The twisted module is simply
an isomorphic copy of M, but with the grading twisted by d (so
d is subtracted from each weight of M). f has degree -d.
</BLOCKQUOTE>
<PRE></PRE> <A  HREF = "text1262.htm">[Next]</A><A  HREF = "text1260.htm">[Prev]</A> <A  HREF = "text1262.htm">[Right]</A> <A  HREF = "text1260.htm">[Left]</A> <A  HREF = "text1254.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<br><small>Version: V2.22 of <I>
Thu Jun  9 16:37:49 EST 2016
</I></small>
</body></html>