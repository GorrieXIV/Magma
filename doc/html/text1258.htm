<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <link rel='stylesheet' href='help.css' type='text/css'>
  <TITLE>Basic Creation and Access</TITLE>
</head>
<body BGCOLOR="#FFFFFF">

 <A  HREF = "text1259.htm">[Next]</A><A  HREF = "text1257.htm">[Prev]</A> <A  HREF = "text1259.htm">[Right]</A> <A  HREF = "text1257.htm">[Left]</A> <A  HREF = "text1254.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<PRE></PRE><H3><A NAME = "13791">Basic Creation and Access</A></H3>

<P>
<P>
An ambient free module M=R<sup>k</sup> is created by giving the base ring R (see
introduction above),
the degree r or a sequence W of r integers for the column weights,
and, optionally, an argument specifying the type of
module monomial order.



<H5>Subsections</H5>
<UL>
<LI> <A  HREF = "text1258.htm#13792">Creation of Ambient Embedded  Modules</A>
<LI> <A  HREF = "text1258.htm#13797">Creation of Reduced Modules</A>
<LI> <A  HREF = "text1258.htm#13802">Localization</A>
<LI> <A  HREF = "text1258.htm#13804">Basic Invariants</A>
<LI> <A  HREF = "text1258.htm#13818">Creation of Module Elements</A>
<LI> <A  HREF = "text1258.htm#13823">Element Operations</A>
</UL>
<H4><A NAME = "13792">Creation of Ambient Embedded  Modules</A></H4>

<P>
<P>
The following functions create ambient embedded modules.


<H5><A NAME = "13793"></A><A NAME = "PMod:EModule">EModule</A>(R, k) : Rng, RngIntElt -&gt; ModMPol</H5>
<BLOCKQUOTE>
Given a ring R, create the ambient embedded module R<sup>k</sup> with the
default <TT>TOP</TT> module monomial order.
</BLOCKQUOTE>
<H5><A NAME = "13794">EModule(R, k, order) : Rng, RngIntElt, MonStgElt, ... -&gt; ModMPol</A></H5>
<BLOCKQUOTE>
Given a ring R, create the ambient embedded module R<sup>k</sup> with 
the module monomial order described by the given order order.  See
Section <A  HREF = "text1257.htm#13784">Monomial Orders</A> for the valid values for order.
</BLOCKQUOTE>
<H5><A NAME = "13795">EModule(R, W) : Rng, [ RngIntElt ] -&gt; ModMPol</A></H5>
<BLOCKQUOTE>
Given a ring R and a sequence W of k integers, create the ambient
embedded module R<sup>k</sup> with column weights given by W and with the <TT>TOPW</TT> module monomial order with weights W.
</BLOCKQUOTE>
<H5><A NAME = "13796">EModule(R, W, order) : Rng, [ RngIntElt ], MonStgElt, ... -&gt; ModMPol</A></H5>
<BLOCKQUOTE>
Given a ring R and a sequence W of k integers, create the ambient
embedded module R<sup>k</sup> with column weights given by W and with the
module monomial order described by the given order order.  See
Section <A  HREF = "text1257.htm#13784">Monomial Orders</A> for the valid values for order.
</BLOCKQUOTE>
<H4><A NAME = "13797">Creation of Reduced Modules</A></H4>

<P>
<P>
The following functions create reduced modules, which are always ambient.


<H5><A NAME = "13798"></A><A NAME = "PMod:RModule">RModule</A>(R, k) : Rng, RngIntElt -&gt; ModMPol</H5>
<BLOCKQUOTE>
Given a ring R, create the reduced module R<sup>k</sup> with zero column weights.
</BLOCKQUOTE>
<H5><A NAME = "13799">RModule(R, W) : Rng, [ RngIntElt ] -&gt; ModMPol</A></H5>
<BLOCKQUOTE>
Given a ring R and a sequence W of k integers, create the reduced
module R<sup>k</sup> with column weights given by W.
</BLOCKQUOTE>
<H5><A NAME = "13800">GradedModule(R, k) : Rng, RngIntElt -&gt; ModMPol</A></H5>
<BLOCKQUOTE>
Given a ring R, create the reduced graded module R<sup>k</sup> with zero
column weights.
The resulting module has type <TT>ModMPolGrd</TT>, so submodules and quotient
modules of it may only be generated by homogeneous elements.
<P>
Note also that in general it is preferable if possible that the base ring
R has a degree ordering (such as the <TT>grevlex</TT> or <TT>grevlexw</TT>
orders) so that associated Gr&ouml;bner bases of derived modules will be
easier to compute.
</BLOCKQUOTE>
<H5><A NAME = "13801">GradedModule(R, W) : Rng, [ RngIntElt ] -&gt; ModMPol</A></H5>
<BLOCKQUOTE>
Given a ring R and a sequence W of k integers, create the reduced
graded module R<sup>k</sup> with column weights given by W.
The resulting module has type <TT>ModMPolGrd</TT>, so submodules and quotient
modules of it may only be generated by homogeneous elements.
</BLOCKQUOTE>
<H4><A NAME = "13802">Localization</A></H4>



<H5><A NAME = "13803">Localization(M) : ModMPol -&gt; ModMPol</A></H5>
<BLOCKQUOTE>
Given an R-module M, where R=K[x<sub>1</sub>, ..., x<sub>n</sub>] for a field K,
return the corresponding S-module M<sub>&lt; x<sub>1</sub>, ..., x<sub>n</sub> &gt;</sub>,
where S=K[x<sub>1</sub>, ..., x<sub>n</sub>]<sub>&lt; x<sub>1</sub>, ..., x<sub>n</sub> &gt;</sub> is
the localization of R.  See Chapter <A  HREF = "text1234.htm#13666">LOCAL POLYNOMIAL RINGS</A> for more
information.
</BLOCKQUOTE>
<H4><A NAME = "13804">Basic Invariants</A></H4>

<P>
<P>
The following functions access simple defining invariants of a module M.


<H5><A NAME = "13805">Ambient(M) : ModMPol -&gt; ModMPol</A></H5>
<H5>Generic(M) : ModMPol -&gt; ModMPol</H5>
<BLOCKQUOTE>
Given a module M, return the ambient (or generic) module A
in which M is embedded.  The only case in which A differs from M
is when M is a proper submodule of an ambient embedded module.
So if M is reduced, A will always equal M.
</BLOCKQUOTE>
<H5><A NAME = "13806">IsAmbient(M) : ModMPol -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Given a module M, return whether M is ambient.
</BLOCKQUOTE>
<H5><A NAME = "13807">IsEmbedded(M) : ModMPol -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Given a module M, return whether M is embedded.
</BLOCKQUOTE>
<H5><A NAME = "13808">IsReduced(M) : ModMPol -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Given a module M, return whether M is reduced.
</BLOCKQUOTE>
<H5><A NAME = "13809">IsRoot(M) : ModMPol -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Given a module M, return whether M is a root (an independent module,
not derived via sub- or quotient constructions from another module).
</BLOCKQUOTE>
<H5><A NAME = "13810">CoefficientRing(M) : ModMPol -&gt; ModMPol</A></H5>
<H5>BaseRing(M) : ModMPol -&gt; Rng</H5>
<BLOCKQUOTE>
Given an R-module M, return the base ring R over which M is defined.
Note that one can then call <TT>BaseRing(R)</TT> to obtain the underlying
ring S in which the base coefficients of elements R lie.
</BLOCKQUOTE>
<H5><A NAME = "13811">Degree(M) : ModMPol -&gt; RngIntElt</A></H5>
<BLOCKQUOTE>
Given an R-module M, return the degree of M, which is the k such that
the ambient module of M equals R<sup>k</sup>/&lt; <I>relations</I> &gt;.
Note that if M is free and ambient, then the degree of M equals
the rank of M, but otherwise in general the rank of M may be less
than the degree of M (see the function <A  HREF = "text1263.htm#PMod:Rank">Rank</A> below).
</BLOCKQUOTE>
<H5><A NAME = "13812">ColumnWeights(M) : ModMPol -&gt; [ RngIntElt ]</A></H5>
<H5>Grading(M) : ModMPol -&gt; [ RngIntElt ]</H5>
<BLOCKQUOTE>
Given a module M of degree k, return the grading of M, which is a
sequence of k integers giving the grading on the columns of M.
</BLOCKQUOTE>
<H5><A NAME = "13813">RelationModule(M) : ModMPol -&gt; [ ModMPol ]</A></H5>
<BLOCKQUOTE>
Given an R-module M of degree k, return the submodule of the
embedded module R<sup>k</sup> which is generated by the defining relations of M.
</BLOCKQUOTE>
<H5><A NAME = "13814">Relations(M) : ModMPol -&gt; [ ModMPol ]</A></H5>
<BLOCKQUOTE>
Given an R-module M of degree k, return the defining relations of
M as a sorted sequence of elements of the embedded module R<sup>k</sup>.
</BLOCKQUOTE>
<H5><A NAME = "13815">RelationMatrix(M) : ModMPol -&gt; ModMatRngElt</A></H5>
<BLOCKQUOTE>
Given a module M, return the relation matrix of M, which is the
matrix whose rows are the defining relations of M.
</BLOCKQUOTE>
<H5><A NAME = "13816">Presentation(M) : ModMPol -&gt; [ ModMPol ]</A></H5>
<BLOCKQUOTE>
Given an R-module M, return the presentation module P of M.
This is a reduced module isomorphic to M (and such that automatic
coercion between M and P is allowed).  If M is reduced, then P
is identical to M.
</BLOCKQUOTE>
<H5><A NAME = "13817">IsGraded(M) : ModMPol -&gt; BoolElt</A></H5>
<H5>IsHomogeneous(M) : ModMPol -&gt; BoolElt</H5>
<BLOCKQUOTE>
Given a module M, return whether M is graded (or equivalently,
homogeneous), w.r.t. the grading of M (given by the weights
on the columns of M and the variables of the base ring of M).
This is true iff the Gr&ouml;bner basis of M consists of homogeneous
elements only (always true if M is reduced) and the Gr&ouml;bner basis
of the relation module of M consists of homogeneous elements alone.
Note that a module of type <TT>ModMPolGrd</TT> is always graded.
</BLOCKQUOTE>
<H4><A NAME = "13818">Creation of Module Elements</A></H4>

<P>
<P>
Module elements (internally, multivariate polynomials with columns
attached to the monomials) are constructed in general by giving a sequence
or vector of elements from the coefficient ring R.


<H5><A NAME = "13819">M ! Q : ModMPol, [ RngElt ] -&gt; ModMPolElt</A></H5>
<BLOCKQUOTE>
Suppose M is an R-module of degree r.
Given a sequence Q = [a<sub>1</sub>, ..., a<sub>r</sub>] of ring elements such that the a<sub>i</sub> are coercible into R,
construct the element of M corresponding to Q.
</BLOCKQUOTE>
<H5><A NAME = "13820">M ! v : ModMPol, ModTupRngElt -&gt; ModMPolElt</A></H5>
<BLOCKQUOTE>
Suppose M is an R-module of degree r.
Given a vector v from the R-space R<sup>r</sup>,
construct the element of M corresponding to v.
</BLOCKQUOTE>
<H5><A NAME = "13821">M ! 0 : ModMPol, RngIntElt -&gt; ModMPolElt</A></H5>
<H5>Zero(M) : ModMPol -&gt; ModMPolElt</H5>
<BLOCKQUOTE>
Create the zero element of the module M.
</BLOCKQUOTE>
<H5><A NAME = "13822">UnitVector(M, i) : ModMPol,  RngIntElt -&gt; ModMPolElt</A></H5>
<BLOCKQUOTE>
Suppose M is an R-module of degree r.
Given an integer i in the range [1 .. r], construct
the i-th unit vector of M
(the vector with 1 in the i-th column and 0 elsewhere)
whose parent is the ambient module of M (since it may not lie in M itself).
Note that this <I>not</I> the same as the function <TT>BasisElement</TT>
(below) which depends on the current basis of M.
</BLOCKQUOTE>
<H4><A NAME = "13823">Element Operations</A></H4>

<P>
<P>
The following functions allow simple access and operations on module elements.
Some of them use the module structure and refer to the column structure of
an element; others use the polynomial structure and ignore the column structure.


<H5><A NAME = "13824">Access</A></H5>



<H5><A NAME = "13825">Eltseq(f) : ModMPolElt -&gt; [ RngMPolElt ]</A></H5>
<BLOCKQUOTE>
Given an element f of the R-module of degree r, return the sequence
[f<sub>1</sub>, ..., f<sub>r</sub>] of r elements from R corresponding to f.
</BLOCKQUOTE>
<H5><A NAME = "13826">Vector(f) : ModMPolElt -&gt; ModTupRngElt</A></H5>
<BLOCKQUOTE>
Given an element f of the module M over R and of degree r,
return the element of the R-space of degree r over R corresponding
to f.
</BLOCKQUOTE>
<H5><A NAME = "13827">f[i] : ModMPolElt, RngIntElt -&gt; RngMPolElt</A></H5>
<BLOCKQUOTE>
Given an element f of the R-module of degree r, together with an
integer i in the range [1 .. r], return the i-th component of f
as an element of R.
</BLOCKQUOTE>
<H5><A NAME = "13828">Arithmetic</A></H5>

<P>
<P>
The following functions act on elements of R-modules.  The
operations are similar to those for multivariate polynomials or vectors,
whenever meaningful.  For the binary operations, the elements must be <B>compatible</B>; that is, their parents must have the same ambient module.
Note that if quotient relations for M are present, then the result is
reduced to the unique normal form modulo the quotient relations, but
if the determination of the relations is delayed, then an element may
have a non-unique representation, but all the predicates on elements below
do not depend on the representation.


<H5>f + g : ModMPolElt, ModMPolElt -&gt; ModMPolElt</H5>

<H5>f - g : ModMPolElt, ModMPolElt -&gt; ModMPolElt</H5>

<H5>- f : ModMPolElt -&gt; ModMPolElt</H5>

<H5>r * f : RngElt, ModMPolElt -&gt; ModMPolElt</H5>

<H5>f * r : ModMPolElt, RngElt -&gt; ModMPolElt</H5><P>



Basic arithmetic operations.  The element r lies in the base ring R.


<H5><A NAME = "13829">f div s : ModMPolElt, RngMPolElt -&gt; ModMPolElt</A></H5>
<BLOCKQUOTE>
Given a scalar ring element s and an element f of the module M, such
that s is coercible into R s divides all components of f, return
the quotient of f by s.
</BLOCKQUOTE>
<H5><A NAME = "13830">SPolynomial(f, g) : ModMPolElt, ModMPolElt -&gt; ModMPolElt</A></H5>
<BLOCKQUOTE>
Given elements f and g of the module M such that the leading module
monomials
of f and g have the same column, return the S-polynomial of f and g.
Note that the result is always reduced to the unique normal form
modulo the quotient relations of M.
</BLOCKQUOTE>
<H5><A NAME = "13831">Normalize(f) : ModMPolElt -&gt; ModMPolElt</A></H5>
<BLOCKQUOTE>
Given an element f of the module M, return the normalized form of
f (so that the leading module monomial of f is normalized).
</BLOCKQUOTE>
<H5><A NAME = "13832">NormalForm(f, S) : ModMPolElt, ModMPol -&gt; ModMPolElt</A></H5>
<BLOCKQUOTE>
Given an element f of the module M, together with a compatible module
S, return the normal form of f with respect to S.  This is unique
if the base ring R is not local.  In general, S will be a non-ambient
embedded module for this to be useful (otherwise any f would already
be in S so the result would always be zero).
</BLOCKQUOTE>
<H5><A NAME = "13833">Coordinates(f, M) : ModMPolElt, ModMPol -&gt; [ RngMPolElt ]</A></H5>
<BLOCKQUOTE>
Given an element f of the R-module S, together with a compatible
R-module M such that f is in M, return the coordinates of f
with respect to the basis of M (whose components lie in R).
</BLOCKQUOTE>
<H5><A NAME = "13834">Accessing the Underlying Representation</A></H5>

<P>
<P>
The following functions access simple properties of module elements
which are to do with the underlying representation.


<H5>Coefficients(f) : ModMPolElt -&gt; [RngElt]</H5>

<H5>Monomials(f) : ModMPolElt -&gt; [ModMPolElt]</H5>

<H5>Terms(f) : ModMPolElt -&gt; [ModMPolElt]</H5>
<P>


<H5>LeadingCoefficient(f) : ModMPolElt -&gt; RngElt</H5>

<H5>LeadingMonomial(f) : ModMPolElt -&gt; ModMPolElt</H5>
<P>

<H5>LeadingTerm(f) : ModMPolElt -&gt; ModMPolElt</H5>
<P>

<H5>CoefficientsAndMonomials(f) : ModMPolElt -&gt; [RngElt], [ModMPolElt]</H5>
<P>



These functions are equivalent to the access functions for multivariate
polynomials and access the underlying distributed polynomial representation
(with columns added to the monomials); see Section <A  HREF = "text226.htm#1946">Coefficients, Monomials and Terms</A>
for details.


<H5><A NAME = "13835">Column(f) : ModMPolElt -&gt; RngIntElt</A></H5>
<BLOCKQUOTE>
Given a single-term element f of a module M, return the column
c of the single monomial-column pair (module monomial) s[c] which f has.
</BLOCKQUOTE>
<H5><A NAME = "13836">Degree(f) : ModMPolElt -&gt; RngIntElt</A></H5>
<H5>WeightedDegree(f) : ModMPolElt -&gt; RngIntElt</H5>
<BLOCKQUOTE>
Given an element f of a module M, return the weighted degree
(abbreviated to `degree' in this chapter) of f, which is the maximum of
the weighted degrees of the monomial-column pairs of f.  The weighted
degree of a monomial-column s[c] is the weighted degree of s (in
the base ring R) plus the degree of column c in the grading of M.
</BLOCKQUOTE>
<H5><A NAME = "13837">IsHomogeneous(f) : ModMPolElt -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Given an element f of a module M, return whether f is homogeneous;
that is, whether the weighted degrees of all the monomial-columns of f
are equal.  (Note that the grading of M is thus significant.)
</BLOCKQUOTE>
<H5><A NAME = "13838">Predicates</A></H5>



<H5><A NAME = "13839">IsZero(f) : ModMPolElt -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Given an element f of the module M, return whether f is the zero
element of M.  Note that if the relations of M are non-zero
this operation may be non-trivial (especially if the relations are
not yet computed, but they will be automatically computed if needed).
</BLOCKQUOTE>
<H5><A NAME = "13840">f eq g : ModMPolElt, ModMPolElt -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Given elements f and g of the module M, return whether f and g
are equal.  Note that this may be non-trivial (see the remarks above).
</BLOCKQUOTE>
<H5><A NAME = "13841">f lt g : ModMPolElt, ModMPolElt -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Given elements f and g of the module M, return whether f &lt; g w.r.t.
the underlying module monomial order.
The operators <TT>le</TT>, <TT>gt</TT>, <TT>ge</TT> are similarly defined.
</BLOCKQUOTE>
<H5><A NAME = "13842">f in M : ModMPolElt, ModMPol -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Given an element f of a module S together with a compatible module
M, return whether f is in M.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "13843">Example <TT>PMod_CreateEmbedded (H115E1)</TT></A></H3>
We illustrate simple modules over a multivariate
polynomial ring.
We construct simple ambient embedded modules over Q[x, y, z].  The first
module has default weights 0 on its columns, while the second has weights
1, 2, and 3 respectively on its columns.
<P>
<P>
<PRE>
&gt; R&lt;x,y,z&gt; := PolynomialRing(RationalField(), 3, "grevlex");
&gt; M := EModule(R, 3);
&gt; M;
Free Embedded Module R^3
Order: Module TOP: Graded Reverse Lexicographical
&gt; f := M![x, y, z^2];
&gt; g := M![z, y^3, x + 1];
&gt; f;
[x, y, z^2]
&gt; g;
[z, y^3, x + 1]
&gt; f + g;
[x + z, y^3 + y, z^2 + x + 1]
&gt; Terms(f);
[
    [0, 0, z^2],
    [x, 0, 0],
    [0, y, 0]
]
&gt; Degree(f);
2
&gt; [Degree(m): m in Monomials(f)];
[ 2, 1, 1 ]
&gt; LeadingMonomial(f);
[0, 0, z^2]
&gt; M2 := EModule(R, [10, 5, 1]); 
Free Embedded Module R^3 with grading [10, 5, 1]
Order: Module TOP with column weights [10, 5, 1]: Graded Reverse Lexicographical
&gt; f := M2![x, y, z^2];
&gt; f;
[x, y, z^2]
&gt; Terms(f);
[
    [x, 0, 0],
    [0, y, 0],
    [0, 0, z^2]
]
&gt; Degree(f);
11
&gt; [Degree(m): m in Monomials(f)];
[ 11, 6, 3 ]
</PRE>
Similar operations can be done with reduced modules.  There is no
difference for the elements.
<P>
<P>
<PRE>
&gt; M := RModule(R, 3);
&gt; M;
Free RModule R^3
&gt; M := GradedModule(R, [10, 5, 1]); 
&gt; M;
Free Graded Module R^3 with grading [10, 5, 1]
&gt; Grading(M);
[ 10, 5, 1 ]
&gt; f := M![x, y^6, z^10];
&gt; f;
[x, y^6, z^10]
&gt; IsHomogeneous(f);
true
</PRE>
<HR>
<PRE></PRE> <A  HREF = "text1259.htm">[Next]</A><A  HREF = "text1257.htm">[Prev]</A> <A  HREF = "text1259.htm">[Right]</A> <A  HREF = "text1257.htm">[Left]</A> <A  HREF = "text1254.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<br><small>Version: V2.22 of <I>
Thu Jun  9 16:37:49 EST 2016
</I></small>
</body></html>