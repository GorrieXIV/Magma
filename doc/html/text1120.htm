<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <link rel='stylesheet' href='help.css' type='text/css'>
  <TITLE>Construction of Pseudo- reflections</TITLE>
</head>
<body BGCOLOR="#FFFFFF">

 <A  HREF = "text1121.htm">[Next]</A><A  HREF = "text1119.htm">[Prev]</A> <A  HREF = "text1121.htm">[Right]</A> <A  HREF = "text1119.htm">[Left]</A> <A  HREF = "text1118.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<PRE></PRE><H3><A NAME = "12532">Construction of Pseudo- reflections</A></H3>

<P>
<P>
<P>
<P>
Let V be a vector space of dimension n over a field F. As defined in
Bourbaki <A  HREF = "text1117.htm#bib_BourbakiLie">[Bou68]</A>, a <I>pseudo-reflection</I> in Magma is a
linear transformation of V whose space of fixed points is a subspace of
dimension n - 1, namely a hyperplane.  (Some authors require a pseudo-reflection
to be invertible and diagonalisable.)
<P>
A reflection, as defined above, is a pseudo-reflection and so too is a transvection.
The Magma package described in this chapter includes code for the construction
of transvections but the emphasis is on groups generated by reflections.
<P>
If r is a pseudo-reflection, then dim(im(1 - r)) = 1 and a basis element
of im(1 - r) is called a <I>root</I> of r.
<P>
Let a be a root of the pseudo-reflection r and let H = ker(1 - r) be the
hyperplane of fixed points of r. For all v&isin;V there exists &phi;(v) &isin;F
such that v - vr = &phi;(v)a.  Then &phi;&isin;V<sup> * </sup> and ker&phi; = H.
This means that every pseudo-reflection has the form
<P>
  vr = v - &phi;(v)a
<P>
and its determinant is 1 - &phi;(a).  The linear functional &phi; is a
<I>coroot</I> of r.
<P>
<DL COMPACT class='compact'>
<DT><IMG SRC="closed.gif" ALT="" WIDTH=7 HEIGHT=7></DT><DD>If &phi;(a) = 1, then r is not invertible; it is the <I>projection</I>
of V onto H along a.
<P>
<DT><IMG SRC="closed.gif" ALT="" WIDTH=7 HEIGHT=7></DT><DD>If &phi;(a) = 0 (equivalently, a&isin;H), then r is by definition a <I>transvection</I>.
<P>
<DT><IMG SRC="closed.gif" ALT="" WIDTH=7 HEIGHT=7></DT><DD>If &phi;(a) &ne;0, 1, then r is called a <I>reflection</I>.  For the most part we
consider only reflections of finite order, but not necessarily of order two.
<P>
</DL>
In magma both V and its dual space V<sup> * </sup> are identified with the space F<sup>n</sup> of row 
vectors of length n and the standard bilinear pairing between V and V<sup> * </sup> is
(a, b) |-&gt; ab<sup>tr</sup>, where b<sup>tr</sup> denotes the column vector which is the 
<I>transpose</I> of b.
<P>
The row vector b which represents the coroot &phi; is also called a 
<I>coroot</I> of the pseudo-reflection; it is uniquely determined by r and a.  
The matrix of r is
<P>
     I - b<sup>tr</sup> a
<P>
and, in particular, ar = (1 - ab<sup>tr</sup>)a.  Thus r is a reflection of finite order d 
if and only if ab<sup>tr</sup> &ne;0, 1 and 1 - ab<sup>tr</sup> is a d-th root of unity.



<H5>Subsections</H5>
<UL>
<LI> <A  HREF = "text1120.htm#12543">Pseudo-reflections Preserving  Reflexive Forms</A>
</UL>
<H5><A NAME = "12533">PseudoReflection(a, b) : ModTupRngElt, ModTupRngElt -&gt; AlgMatElt</A></H5>
<BLOCKQUOTE>
The matrix of the pseudo-reflection with root a and coroot b. 
</BLOCKQUOTE>
<H5><A NAME = "12534">Transvection(a, b) : ModTupRngElt, ModTupRngElt -&gt; AlgMatElt</A></H5>
<BLOCKQUOTE>
The matrix of the transvection with root a and coroot b. The input is checked 
to ensure that the root and coroot define a transvection.
</BLOCKQUOTE>
<H5><A NAME = "12535">Reflection(a, b) : ModTupRngElt, ModTupRngElt -&gt; AlgMatElt</A></H5>
<BLOCKQUOTE>
The matrix of the reflection with root a and coroot b. The input is checked 
to ensure that the root and coroot define a reflection.
</BLOCKQUOTE>
<H5><A NAME = "12536">IsPseudoReflection(r) : Mtrx -&gt; BoolElt, ModTupRngElt, ModTupRngElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if r is the matrix of a pseudo-reflection, in which
case a root and a coroot are returned as well.
</BLOCKQUOTE>
<H5><A NAME = "12537">IsTransvection(r) : Mtrx -&gt; BoolElt, ModTupRngElt, ModTupRngElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if r is the matrix of a transvection, in which
case a root and a coroot are returned as well.
</BLOCKQUOTE>
<H5><A NAME = "12538">IsReflection(r) : Mtrx -&gt; BoolElt, ModTupRngElt, ModTupRngElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if r is the matrix of a reflection, in which
case a root and a coroot are returned as well.
</BLOCKQUOTE>
<H5><A NAME = "12539">IsReflectionGroup(G) : GrpMat -&gt; BoolElt</A></H5>

<PRE>    Strict: BoolElt                     Default: <TT>true</TT></PRE>
<BLOCKQUOTE>
The default action is to return <TT>true</TT> if every generator of G is a
reflection.  If <TT>Strict</TT> is <TT>false</TT>, the function checks if G can
be generated by <I>some</I> of its reflections, not necessarily those
returned by <TT>Generators(G)</TT>.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "12540">Example <TT>GrpRfl_pseudoreflection (H105E1)</TT></A></H3>
Create a pseudo-reflection directly and then check that it is
a transvection.
<P>
<P>
<P>
<PRE>
&gt; V := VectorSpace(GF(5), 3);
&gt; t := PseudoReflection(V![1,0,0],V![0,1,0]);                                  
&gt; t;            
[1 0 0]
[4 1 0]
[0 0 1]
&gt; IsTransvection(t);
true (1 0 0)
(0 1 0)
&gt; IsReflection(t);
false
</PRE>
<HR>
<H3><A NAME = "12541">Example <TT>GrpRfl_ref-group (H105E2)</TT></A></H3>
An example of a group which can be generated by reflections even
though not every given generator is a reflection.
<P>
<P>
<P>
<PRE>
&gt; F&lt;omega&gt; := CyclotomicField(3);
&gt; r := Matrix(F,2,2,[1,omega^2,0,omega]);
&gt; IsReflection(r);
true (         0 -omega + 1)
(1/3*(2*omega + 1)                 1)
&gt; s := Matrix(F,2,2,[0,-1,1,0]);
&gt; IsReflection(s);
false
&gt; G := MatrixGroup&lt;2,F | r,s &gt;;
&gt; IsReflectionGroup(G);
false
&gt; IsReflectionGroup(G : Strict := false);
true
&gt; #G;
24
</PRE>
<P>
To find reflection generators for this group we look for a reflection 
which, together with the reflection r, generates G.  (This
is a rather special example; not every finite reflection group
of rank two can be generated by two reflections.)
<P>
<P>
<P>
<PRE>
&gt; exists(t){ t : t in G | IsReflection(t) and G eq sub&lt;G|r,t&gt; };
true
&gt; t;
[        0 omega + 1]
[        1    -omega]
</PRE>
<HR>
<H3><A NAME = "12542">Example <TT>GrpRfl_transvections (H105E3)</TT></A></H3>
The groups SL(n, q) are generated by transvections. To illustrate
this we find representatives for the conjugacy classes of GL(3, 25)
which are transvections and then check that the normal closure is
SL(3, 25).
<P>
<P>
<P>
<PRE>
&gt; G := GL(3,25);
&gt; ccl := Classes(G);
&gt; T := [ c : c in ccl | IsTransvection(c[3]) ];
&gt; #T;
1
&gt; t := T[1][3]; t;
[     1      0      0]
[     0      1      1]
[     0      0      1]
&gt; S := ncl&lt; G | t &gt;;
&gt; S eq SL(3,25);
true
</PRE>
<HR>
<H4><A NAME = "12543">Pseudo-reflections Preserving  Reflexive Forms</A></H4>

<P>
<P>
<P>
<P>
Let J be the matrix of a non-degenerate reflexive bilinear or sesquilinear 
form &beta; on the vector space V over a field F.  Then &beta; is 
either a symmetric, alternating or hermitian form.
<P>
We may assume that F is equipped with an automorphism &sigma; such that 
&sigma;<sup>2</sup> = 1.  If &beta; is a symmetric or alternating form, &sigma;
is the identity; if &beta; is hermitian, the order of 
&sigma; :&alpha; |-&gt; bar&alpha; is two and J = bar J<sup>tr</sup>. If
a is the row vector (&alpha;<sub>1</sub>, &alpha;<sub>2</sub>, ..., &alpha;<sub>n</sub>), define
&sigma;(a) = (&sigma;(&alpha;<sub>1</sub>), &sigma;(&alpha;<sub>2</sub>), ..., &sigma;(&alpha;<sub>n</sub>)).
<P>
If a is a root of a pseudo-reflection r and if r preserves &beta;,
then the coroot of r is &alpha; &sigma;(a) J<sup>tr</sup> for some &alpha;&isin;F.
Thus the matrix of r is I - &alpha; J<sup>tr</sup>&sigma;(a)<sup>tr</sup> a.


<H5><A NAME = "12544">SymplecticTransvection(a, alpha) : ModTupRngElt, FldElt -&gt; AlgMatElt</A></H5>
<BLOCKQUOTE>
The symplectic transvection with root a and multiplier &alpha; with respect to 
the form attached to the parent of a.  If the form is not alternating a runtime 
error is generated.
<P>
<P>
<P>
If &beta; is a non-degenerate alternating form preserved by a pseudo-reflection
r, then the dimension of V is even and r must be a transvection.  If 
a is a root of r, the coroot is &alpha; aJ<sup>tr</sup> and the matrix of
r is I - &alpha; J a<sup>tr</sup> a, for some &alpha;&ne;0 in F.
<P>
<P>
<P>
</BLOCKQUOTE>
<H5><A NAME = "12545">UnitaryTransvection(a, alpha) : ModTupRngElt, FldElt -&gt; AlgMatElt</A></H5>
<BLOCKQUOTE>
The unitary transvection with root a and multiplier &alpha; with respect to the
hermitian form attached to the parent of a.  
<P>
<P>
<P>
The matrix of the unitary transvection is I - &alpha; J bar a<sup>tr</sup> a, where a is 
isotropic and the trace of &alpha; is 0; that is, a J bar a<sup>tr</sup> = 0 and 
&alpha; + bar&alpha; = 0.
<P>
A runtime error is generated if the form is not hermitian, if a is not isotropic, or
if the trace of &alpha; is not 0.
</BLOCKQUOTE>
<H5><A NAME = "12546">UnitaryReflection(a, zeta) : ModTupRngElt, FldElt -&gt; AlgMatElt</A></H5>
<BLOCKQUOTE>
The unitary reflection with root a and determinant &zeta;, where &zeta; is
a root of unity.   The reflection preserves the hermitian form attached to the
ambient space of a and sends a to &zeta; a.
<P>
<P>
<P>
In the case of a unitary reflection r with matrix I - &alpha; J<sup>tr</sup>&sigma;(a)<sup>tr</sup> a, the 
root a must be non-isotropic and ar = &zeta; a, where &zeta; is a root 
of unity.  Therefore, &alpha; = (1 - &zeta;)/aJ bar a<sup>tr</sup>.
<P>
The vector a<sup>v</sup> = bar&alpha; a is the <I>coroot</I> of a and the definition
of r becomes
<P>
  v r = v - &beta;(v, a<sup>v</sup>)a.
</BLOCKQUOTE>
<H5><A NAME = "12547">OrthogonalReflection(a) : ModTupFldElt -&gt; AlgMatElt</A></H5>
<BLOCKQUOTE>
The reflection determined by a non-singular vector a of a quadratic space.
<P>
A <I>quadratic space</I> is a vector space V equipped with a quadratic form Q (see
Chapter <A  HREF = "text1008.htm#11342">CLIFFORD ALGEBRAS</A> for more details).
The <I>polar form</I> of Q is the symmetric bilinear form &beta;(u, v) = Q(u + v) - Q(u) - Q(v).
Thus &beta;(v, v) = 2Q(v) and therefore, if the characteristic of F is not two, Q is
uniquely determined by &beta;.
<P>
If a is non-singular (that is, Q(a) &ne;0), the formula
<P>
  vr = v - Q(a)<sup> - 1</sup>&beta;(v, a)a
<P>
defines a pseudo-reflection.  If the characteristic of F is 2, this is a transvection; in
all other cases it is a reflection.  However, in characteristic 2 there is a certain
ambivalence in the literature and the pseudo-reflections just defined are often 
called reflections.
<P>
The <I>coroot</I> of a is a<sup>v</sup> = Q(a)<sup> - 1</sup>a.  If the characteristic of F is not two,
then a<sup>v</sup> = 2a/&beta;(a, a) and this coincides with the usual notion of coroot,
as found in <A  HREF = "text1117.htm#bib_HumphreysRefl">[Hum90]</A>, for example.  In particular, if &beta;(u, v) is the 
standard inner product (u, v) = uv<sup>tr</sup>, then the inner product and the pairing between
V and its dual are essentially the same and the concepts of coroot and coroot
coincide. 
</BLOCKQUOTE>
<HR>
<H3><A NAME = "12548">Example <TT>GrpRfl_unitary-transvection (H105E4)</TT></A></H3>
We create an hermitian space by attaching an hermitian form J to
a vector space V over a field with complex conjugation. The vector
a = (1, 0, 0, 0) is isotropic with respect to this form and therefore
we can use it to create a unitary transvection.
<P>
<P>
<P>
<PRE>
&gt; K&lt;i&gt; := CyclotomicField( 4 );
&gt; sigma := hom&lt; K -&gt; K | x :-&gt; ComplexConjugate(x) &gt;; 
&gt; J := Matrix(4,4,[K|0,0,0,1, 0,0,1,0, 0,1,0,0, 1,0,0,0]);
&gt; V := UnitarySpace(J,sigma);
&gt; a := V![1,0,0,0];
&gt; t := UnitaryTransvection(a,i);
&gt; t;
[ 1  0  0  0]
[ 0  1  0  0]
[ 0  0  1  0]
[-i  0  0  1]
</PRE>
<P>
<P>
Continuing the previous example we note that b = (1, 1, 1, 1) is 
non-isotropic and we create a unitary reflection of order 4 with b
as root.
<P>
<P>
<PRE>
&gt; b := V![1,1,1,1];
&gt; InnerProduct(b,b);
4
&gt; r := UnitaryReflection(b,i);
&gt; r, Eigenvalues(r);
[1/4*(i + 3) 1/4*(i - 1) 1/4*(i - 1) 1/4*(i - 1)]
[1/4*(i - 1) 1/4*(i + 3) 1/4*(i - 1) 1/4*(i - 1)]
[1/4*(i - 1) 1/4*(i - 1) 1/4*(i + 3) 1/4*(i - 1)]
[1/4*(i - 1) 1/4*(i - 1) 1/4*(i - 1) 1/4*(i + 3)]
{
    &lt;i, 1&gt;,
    &lt;1, 3&gt;
}
</PRE>
<HR>
<PRE></PRE> <A  HREF = "text1121.htm">[Next]</A><A  HREF = "text1119.htm">[Prev]</A> <A  HREF = "text1121.htm">[Right]</A> <A  HREF = "text1119.htm">[Left]</A> <A  HREF = "text1118.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<br><small>Version: V2.22 of <I>
Thu Jun  9 16:37:49 EST 2016
</I></small>
</body></html>