<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <link rel='stylesheet' href='help.css' type='text/css'>
  <TITLE>Operations on Lie Algebras</TITLE>
</head>
<body BGCOLOR="#FFFFFF">

 <A  HREF = "text1139.htm">[Next]</A><A  HREF = "text1137.htm">[Prev]</A> <A  HREF = "text1139.htm">[Right]</A> <A  HREF = "text1137.htm">[Left]</A> <A  HREF = "text1130.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<PRE></PRE><H3><A NAME = "12767">Operations on Lie Algebras</A></H3>




<H5>Subsections</H5>
<UL>
<LI> <A  HREF = "text1138.htm#12781">Basic Invariants</A>
<LI> <A  HREF = "text1138.htm#12787">Changing Base Rings</A>
<LI> <A  HREF = "text1138.htm#12790">Bases</A>
<LI> <A  HREF = "text1138.htm#12795">Operations for Semisimple and Reductive Lie Algebras</A>
</UL>
<H5><A NAME = "12768">L eq K : AlgLie, AlgLie -&gt; BoolElt</A></H5>
<H5>L eq K : AlgMatLie, AlgMatLie -&gt; BoolElt</H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if, and only if, the Lie algebras L and K are equal.
</BLOCKQUOTE>
<H5><A NAME = "12769">L ne K : AlgLie, AlgLie -&gt; BoolElt</A></H5>
<H5>L ne K : AlgMatLie, AlgMatLie -&gt; BoolElt</H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if, and only if, the Lie algebras L and K are not equal.
</BLOCKQUOTE>
<H5><A NAME = "12770">L subset K : AlgLie, AlgLie -&gt; BoolElt</A></H5>
<H5>L subset K : AlgMatLie, AlgMatLie -&gt; BoolElt</H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if, and only if, the Lie algebra L is contained in the Lie
algebra K.
</BLOCKQUOTE>
<H5><A NAME = "12771">L notsubset K : AlgLie, AlgLie -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if, and only if, the Lie algebra L is not contained in the Lie
algebra K.
</BLOCKQUOTE>
<H5><A NAME = "12772">L meet M : AlgLie, AlgLie -&gt; AlgLie</A></H5>
<H5>L meet M : AlgMatLie, AlgMatLie -&gt; AlgMatLie</H5>
<BLOCKQUOTE>
The intersection of the Lie algebras L and M is returned. 
Note that L and M have a common superalgebra.
</BLOCKQUOTE>
<H5><A NAME = "12773">L * M : AlgLie, AlgLie -&gt; AlgLie</A></H5>
<H5>L * M : AlgMatLie, AlgMatLie -&gt; AlgMatLie</H5>
<BLOCKQUOTE>
The Lie algebra product [L, M] of the algebras L and M is
returned. Note that L and M must have a common superalgebra.
</BLOCKQUOTE>
<H5><A NAME = "12774">L ^ n : AlgLie, RngIntElt -&gt; AlgLie</A></H5>
<BLOCKQUOTE>
The (left-normed) n-th power of the (structure constant) Lie algebra 
L, i.e., (( ... (L * L) * ... ) * L) is constructed.
</BLOCKQUOTE>
<H5><A NAME = "12775">Morphism(L, M) : AlgLie, AlgLie -&gt; Map</A></H5>
<BLOCKQUOTE>
The map giving the morphism from the (structure constant) Lie algebra 
L to M is constructed. Either L is a subalgebra of M, 
in which case the embedding of L into M is returned, or M is a quotient
algebra of L, in which case the natural epimorphism from L onto M is 
returned.
</BLOCKQUOTE>
<H5><A NAME = "12776"></A><A NAME = "IsIsomorphicLie">IsIsomorphic</A>(L, M) : AlgLie, AlgLie -&gt; BoolElt, .</H5>

<PRE>    HL: AlgLie                          Default: <TT>false</TT></PRE>

<PRE>    HM: AlgLie                          Default: <TT>false</TT></PRE>
<BLOCKQUOTE>
Returns <TT>true</TT> if the Lie algebras L and M are isomorphic. It is
currently implemented for trivial cases (such as when the dimensions differ), 
reductive Lie algebras, solvable Lie algebras up to dimension 4, 
nilpotent Lie algebras up to dimension 6 (some special cases excluded). 
The solvable and nilpotent cases are handled using the databases for such 
algebras described in Section <A  HREF = "text1148.htm#12930">Solvable and Nilpotent Lie Algebras Classification</A>).
<P>
In the case of reductive Lie algebras, split maximal toral subalgebras for L 
and M may be provided in the optional arguments HL and HM, respectively.
If these are not provided an attempt is made to compute them, a process which 
may fail, particularly in characteristic 0.
<P>
This intrinsic has two return values: the first a boolean describing whether L 
and M are isomorphic. If so, the second is an isomorphism from L to M, 
otherwise the second is a string describing the reason for non-isomorphism.
<P>
An error is thrown if isomorphism cannot be determined.
</BLOCKQUOTE>
<H5><A NAME = "12777">IsKnownIsomorphic(L, M) : AlgLie, AlgLie -&gt; BoolElt, BoolElt, .</A></H5>

<PRE>    HL: AlgLie                          Default: <TT>false</TT></PRE>

<PRE>    HM: AlgLie                          Default: <TT>false</TT></PRE>
<BLOCKQUOTE>
Returns <TT>true</TT> if Magma can determine isomorphism between Lie algebras 
L and M. If so, the second return value is whether L and M are 
isomorphic, and the third is an isomorphism or a string (describing the 
reason for non-isomorphism). Refer to <A  HREF = "text1138.htm#IsIsomorphicLie">IsIsomorphic</A> for more details 
on applicability and the meanings of the return values.
</BLOCKQUOTE>
<H5><A NAME = "12778">IsIsomorphism(m) : Map[AlgLie, AlgLie] -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if the mapping m between two Lie algebras is an isomorphism 
of Lie algebras.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "12779">Example <TT>AlgLie_Isomorphic (H106E27)</TT></A></H3>
We demonstrate that B<sub>2</sub> and C<sub>2</sub> are isomorphic over Q.
<P>
<P>
<PRE>
&gt; k := Rationals();
&gt; L := LieAlgebra("B2", k); M := LieAlgebra("C2", k);
&gt; b, c := IsIsomorphic(L, M);
&gt; b;
true
&gt; IsIsomorphism(c);
true
&gt; c(L.1);
(0 0 1 0 0 0 0 0 0 0)
</PRE>
We demonstrate that B<sub>3</sub> and C<sub>3</sub> are non-isomorphic over Q.
<P>
<P>
<PRE>
&gt; L := LieAlgebra("B3", k); M := LieAlgebra("C3", k);
&gt; b, c := IsIsomorphic(L, M);
&gt; b;
false
&gt; c;
21-dim component of L1 of type R1: Adjoint root datum of dimension 3 of type B3 
didn't match R2: 
Adjoint root datum of dimension 3 of type C3
</PRE>
We demonstrate that two distinct isogenies of B<sub>2</sub> are isomorphic over Q.
<P>
<P>
<PRE>
&gt; L := LieAlgebra("B2", k : Isogeny := "Ad");
&gt; M := LieAlgebra("B2", k : Isogeny := "SC");
&gt; b, c := IsIsomorphic(L, M);
&gt; b;
true
</PRE>
For larger nilpotent algebras Magma cannot decide on the isomorphism question.
<P>
<P>
<PRE>
&gt; L := LieAlgebra("B4", k);
&gt; pL, _, _ := StandardBasis(L);
&gt; subL := sub&lt;L | pL&gt;;
&gt; subL;
Lie Algebra of dimension 16 with base ring Rational Field
&gt; M := LieAlgebra("C4", k);
&gt; pM, _, _ := StandardBasis(M);
&gt; subM := sub&lt;M | pM&gt;;
&gt; subL;
Lie Algebra of dimension 16 with base ring Rational Field
&gt; IsNilpotent(subL), IsNilpotent(subM);
true true
&gt; a,b,c := IsKnownIsomorphic(subL, subM);
&gt; a;
false
</PRE>
<HR>
<H3><A NAME = "12780">Example <TT>AlgLie_IsomorphicG2 (H106E28)</TT></A></H3>
We demonstrate that in characteristic 3 the Lie algebras of type G<sub>2</sub> and 
A<sub>2</sub> have isomorphic nontrivial ideals.
<P>
<P>
<PRE>
&gt; k := GF(3);
&gt; CSL := CompositionSeries(LieAlgebra("G2", k));
&gt; CSL;
[
    Lie Algebra of dimension 7 with base ring GF(3),
    Lie Algebra of dimension 14 with base ring GF(3)
]
&gt; L := CSL[1];
&gt; CSM := CompositionSeries(LieAlgebra("A2", k));
&gt; CSM;
[
    Lie Algebra of dimension 7 with base ring GF(3),
    Lie Algebra of dimension 8 with base ring GF(3)
]
&gt; M := CSM[1];
&gt; a,b,c := IsKnownIsomorphic(L, M);
&gt; a;
true
&gt; b, c;
true Mapping from: AlgLie: L to AlgLie: M given by a rule
&gt; IsIsomorphism(c);
true
</PRE>
<HR>
<H4><A NAME = "12781">Basic Invariants</A></H4>



<H5><A NAME = "12782">CoefficientRing(L) : AlgLie -&gt; Rng</A></H5>
<H5>CoefficientRing(L) : AlgMatLie -&gt; Rng</H5>
<H5>BaseRing(L) : AlgLie -&gt; Rng</H5>
<H5>BaseRing(L) : AlgMatLie -&gt; Rng</H5>
<BLOCKQUOTE>
The coefficient ring (or base ring) over which the Lie algebra L is defined.
</BLOCKQUOTE>
<H5><A NAME = "12783">Dimension(L) : AlgLie -&gt; RngIntElt</A></H5>
<H5>Dimension(L) : AlgMatLie -&gt; RngIntElt</H5>
<BLOCKQUOTE>
The dimension of the Lie algebra L.
</BLOCKQUOTE>
<H5><A NAME = "12784"># L : AlgLie -&gt; RngIntElt</A></H5>
<H5># L : AlgMatLie -&gt; RngIntElt</H5>
<BLOCKQUOTE>
The cardinality of the Lie algebra L, if the coefficient ring is finite.
</BLOCKQUOTE>
<H5><A NAME = "12785">Moduli(L) : AlgLie -&gt; SeqEnum</A></H5>
<BLOCKQUOTE>
This returns a sequence of integers, of length equal to the dimension
of L. If the i-th element of this sequence is a<sub>i</sub> then a<sub>i</sub> is the
minimal non-negative integer such that a<sub>i</sub>e<sub>i</sub> = 0. So if L is defined
over a field, then the sequence consists of zeros.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "12786">Example <TT>AlgLie_ModuliOfLieAlgebra (H106E29)</TT></A></H3>
<P>
<P>
<PRE>
&gt; T:= [ &lt;1,2,2,2&gt;, &lt;2,1,2,2&gt; ];
&gt; t:= [0,4];
&gt; L:= LieAlgebra&lt; t | T : Rep:= "Dense" &gt;;
&gt; Moduli(L);
[ 0, 4 ]
</PRE>
<HR>
<H4><A NAME = "12787">Changing Base Rings</A></H4>



<H5><A NAME = "12788">ChangeRing(L, S) : AlgLie, Rng -&gt; AlgLie, Map</A></H5>
<H5>ChangeRing(L, S) : AlgMatLie, Rng -&gt; AlgMatLie, Map</H5>
<BLOCKQUOTE>
Given a Lie algebra L with base ring R, together with a ring S,
this function constructs the Lie algebra M with base ring S obtained 
by coercing the coefficients of elements of L into S. The homomorphism 
from L to M is produced as second return value.
</BLOCKQUOTE>
<H5><A NAME = "12789">ChangeRing(L, S, f) : AlgLie, Rng, Map -&gt; AlgLie, Map</A></H5>
<H5>ChangeRing(L, S, f) : AlgMatLie, Rng, Map -&gt; AlgMatLie, Map</H5>
<BLOCKQUOTE>
Given a Lie algebra L with base ring R, together with a ring S and a 
map f: R -&gt; S, this function constructs the Lie algebra M 
with base ring S obtained by mapping the coefficients of elements of 
L into S via f.  The homomorphism from L to M is produced as 
the second return value.
</BLOCKQUOTE>
<H4><A NAME = "12790">Bases</A></H4>



<H5><A NAME = "12791">BasisElement(A, i) : AlgLie, RngIntElt -&gt; AlgLieElt</A></H5>
<H5>BasisElement(A, i) : AlgMatLie, RngIntElt -&gt; AlgMatLieElt</H5>
<H5>A . i : AlgLie, RngIntElt -&gt; AlgLieElt</H5>
<H5>A . i : AlgMatLie, RngIntElt -&gt; AlgMatLieElt</H5>
<BLOCKQUOTE>
The i-th basis element of the algebra L.
</BLOCKQUOTE>
<H5><A NAME = "12792">Basis(A) : AlgLie -&gt; [ AlgLieElt ]</A></H5>
<H5>Basis(A) : AlgMatLie -&gt; [ AlgMatLieElt ]</H5>
<BLOCKQUOTE>
The basis of the algebra L, as a sequence of elements of L.
</BLOCKQUOTE>
<H5><A NAME = "12793">IsIndependent(Q) : [ AlgLieElt ] -&gt; BoolElt</A></H5>
<H5>IsIndependent(Q) : [ AlgMatLieElt ] -&gt; BoolElt</H5>
<H5>IsIndependent(Q) : { AlgLieElt } -&gt; BoolElt</H5>
<H5>IsIndependent(Q) : { AlgMatLieElt } -&gt; BoolElt</H5>
<BLOCKQUOTE>
Given a set or sequence Q of elements of the R-algebra L, this functions returns
<TT>true</TT> if these elements are linearly independent over R; otherwise <TT>false</TT>.
</BLOCKQUOTE>
<H5><A NAME = "12794">ExtendBasis(S, L) : AlgLie, AlgLie -&gt; [ AlgElt ]</A></H5>
<H5>ExtendBasis(S, L) : AlgMatLie, AlgMatLie -&gt; [ AlgElt ]</H5>
<H5>ExtendBasis(Q, L) : [ AlgLieElt ], AlgLie -&gt; [ AlgElt ]</H5>
<H5>ExtendBasis(Q, L) : [ AlgMatLie ], AlgMatLie -&gt; [ AlgElt ]</H5>
<BLOCKQUOTE>
Given an algebra L and either a subalgebra S of dimension m of L or a 
sequence Q of m linearly independent elements of L, this function returns 
a sequence containing a basis of L such that the first m elements are the 
basis of S resp. the elements in Q.
</BLOCKQUOTE>
<H4><A NAME = "12795">Operations for Semisimple and Reductive Lie Algebras</A></H4>



<P>
<P>
<P>
<P>
The <TT>WeylGroup</TT> functions are only available for structure constant Lie algebras.
<H5><A NAME = "12796">SemisimpleType(L) : AlgLie -&gt; MonStgElt</A></H5>
<H5>SemisimpleType(L) : AlgMatLie -&gt; MonStgElt</H5>
<H5>CartanName(L) : AlgLie -&gt; MonStgElt</H5>
<H5>CartanName(L) : AlgMatLie -&gt; MonStgElt</H5>
<BLOCKQUOTE>
Let L be a Lie algebra.If L has a nondegenerate Killing form, then
(over some algebraic extension of the ground field) L is the direct 
sum of absolutely simple Lie algebras. These Lie algebras have been
classified and the classes are named A<sub>n</sub>, B<sub>n</sub>, C<sub>n</sub>, D<sub>n</sub>,
E<sub>6</sub>, E<sub>7</sub>, E<sub>8</sub>, F<sub>4</sub> and G<sub>2</sub>.
This function returns a single string
containing the types of the direct summands of L.
<P>
For a description of the algorithm used in the general case we refer 
to <A  HREF = "text1129.htm#bib_wdg-lie-alg">[dG00]</A>, Para 5.17.1. For Lie algebras over fields of 
characteristic 2 and 3 the algorithm used is described in 
<A  HREF = "text1129.htm#bib_Roozemond2010">[Roo10]</A>, Chapter 5.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "12797">Example <TT>AlgLie_SemisimpleType (H106E30)</TT></A></H3>
We compute the semisimple type of the Levi subalgebra of a subalgebra of
the simple Lie algebra of type D<sub>7</sub>.
<P>
<P>
<PRE>
&gt; L := LieAlgebra("D7", RationalField());
&gt; L;
Lie Algebra of dimension 91 with base ring Rational Field
&gt; K := Centralizer(L, sub&lt;L | [L.1,L.2,L.3,L.4]&gt;);
&gt; K;
Lie Algebra of dimension 41 with base ring Rational Field
&gt; _,S := HasLeviSubalgebra(K);
&gt; S;
Lie Algebra of dimension 6 with base ring Rational Field
&gt; SemisimpleType(S);
A1 A1
</PRE>
<HR>
<H5><A NAME = "12798">ReductiveType(L) : AlgLie -&gt; RootDtm, MonStgElt, SeqEnum, SeqEnum</A></H5>
<H5>ReductiveType(L, H) : AlgLie, AlgLie -&gt; RootDtm, MonStgElt, SeqEnum, SeqEnum</H5>

<PRE>    AssumeAlmostSimple: BoolElt         Default: <TT>false</TT></PRE>
<BLOCKQUOTE>
Let L be a Lie algebra of a reductive algebraic group, and H a split 
maximal toral subalgebra of L. This function identifies the isomorphism
type of L. 
<P>
This function has four return values. The first is the appropriate root
datum and the second return value a textual description of L. 
The third return value is a sequence Q, containing a decomposition of
L into direct summands. Finally, the fourth return value is a
sequence P of records, such that P[i] contains additional information
(often a proof of correctness) of the identification of Q[i].
<P>
If a split maximal toral subalgebra H is not given, an attempt is made
to compute one by calling <A  HREF = "text1139.htm#SplitMaximalToralSubalgebra">SplitMaximalToralSubalgebra</A> if the
characteristic of the base field k is at least 5, or 
<A  HREF = "text1139.htm#SplitToralSubalgebra">SplitToralSubalgebra</A> if char(k) is 2 or 3. 
Note that, if k is infinite, such a subalgebra cannot in general be 
computed so the second parameter H must be supplied for this function
to work.
<P>
If the optional parameter <TT>AssumeAlmostSimple</TT> is set
to true, the (possibly time consuming) step of computing a direct sum
decomposition of L is skipped. 
<P>
Moreover, note that if L is the Lie algebra of a simple algebraic group
but itself non-simple (such as for example A<sub>n</sub> of intermediate type in
characteristic n + 1),
the third return value Q may not be the direct sum decomposition of L
but simply [L].
</BLOCKQUOTE>
<HR>
<H3><A NAME = "12799">Example <TT>AlgLie_ReductiveType (H106E31)</TT></A></H3>
We consider a particular Lie algebra of type A<sub>3</sub> over k = GF(2).
<P>
<P>
<PRE>
&gt; RA3 := RootDatum("A3" : Isogeny := 2);
&gt; L := LieAlgebra(RA3, GF(2));
&gt; D := DirectSumDecomposition(L);
&gt; D;
[
    Lie Algebra of dimension 14 with base ring GF(2),
    Lie Algebra of dimension 1 with base ring GF(2)
]
&gt; R, str, Q, _ := ReductiveType(L);
&gt; R;
RA3: Root datum of dimension 3 of type A3
&gt; str;
Lie algebra of type A3[ 2]
&gt; Q;
[
    Lie Algebra of dimension 15 with base ring GF(2)
]
</PRE>
Note that this is an example where Q is not the direct sum decomposition 
of L. Instead, L in its whole is recognised as the Lie algebra of a 
simple algebraic group.
In the remainder of the example, we investigate the 14-dimensional ideal of L.
<P>
<P>
<PRE>
&gt; M := D[1]; M;
Lie Algebra of dimension 14 with base ring GF(2)
&gt; R, _, _, P := ReductiveType(M);
&gt; R;
R: Adjoint root datum of dimension 2 of type G2
</PRE>
So this computation claims that L simeq M direct-sum k, 
where M is of type G<sub>2</sub>. Let us use the additional return values
to verify that fact.
<P>
<P>
<PRE>
&gt; pos  := P[1]`ChevBasData`BasisPos;
&gt; neg  := P[1]`ChevBasData`BasisNeg;
&gt; cart := P[1]`ChevBasData`BasisCart;
&gt; IsChevalleyBasis(M, RootDatum("G2"), pos, neg, cart);
true [ &lt;1, 2, 0&gt;, &lt;1, 3, 0&gt;, &lt;1, 4, 0&gt;, &lt;2, 5, 0&gt; ]
</PRE>
This demonstrates the fact that the Lie algebra of type G<sub>2</sub> is a
constituent of the Lie algebra of type A<sub>3</sub> over fields of 
characteristic 2.
<HR>
<H5><A NAME = "12800">RootSystem(L) : AlgLie -&gt; [ ModTupRngElt ], [ AlgLieElt ], [ ModTupRngElt ], AlgMatElt</A></H5>
<H5>RootSystem(L) : AlgMatLie -&gt; [ ModTupRngElt ], [ AlgMatLieElt ], [ ModTupRngElt ], AlgMatElt</H5>
<BLOCKQUOTE>
Given a semisimple Lie algebra L with a split Cartan subalgebra, this
function computes the root system of L.
This function returns four values:
<P>
<DL COMPACT class='compact'>
<DT>(a)</DT><DD>The roots of L with respect to the Cartan subalgebra which is output by 
<TT>CartanSubalgebra(L)</TT>. This is a sequence of vectors where the 
positive roots come first, followed by the negative roots.
<P>
<DT>(b)</DT><DD>A sequence of elements of L which are the root vectors 
corresponding to the roots of L (so the first element corresponds to
the first root and so on).
<P>
<DT>(c)</DT><DD>A sequence of simple roots.
<P>
<DT>(d)</DT><DD>The Cartan matrix of the root system with respect to the sequence of
simple roots.</DL>
</BLOCKQUOTE>
<HR>
<H3><A NAME = "12801">Example <TT>AlgLie_RootSystem (H106E32)</TT></A></H3>
We compute the root system of the simple Lie algebra of type G<sub>2</sub> over the
rational field.
<P>
<P>
<PRE>
&gt; L := LieAlgebra("G2", RationalField());
&gt; R, Rv, fund, C:=RootSystem(L);
&gt; R;
[
    (1 0),
    (0 1),
    (1 1),
    (2 1),
    (3 1),
    (3 2),
    (-1  0),
    ( 0 -1),
    (-1 -1),
    (-2 -1),
    (-3 -1),
    (-3 -2)
]
&gt; Rv;
[ (0 0 0 0 0 0 0 0 1 0 0 0 0 0), (0 0 0 0 0 0 0 0 0 1 0 0 0 0), 
(0 0 0 0 0 0 0 0 0 0 1 0 0 0), (0 0 0 0 0 0 0 0 0 0 0 1 0 0), 
(0 0 0 0 0 0 0 0 0 0 0 0 1 0), (0 0 0 0 0 0 0 0 0 0 0 0 0 1), 
(0 0 0 0 0 1 0 0 0 0 0 0 0 0), (0 0 0 0 1 0 0 0 0 0 0 0 0 0),
(0 0 0 1 0 0 0 0 0 0 0 0 0 0), (0 0 1 0 0 0 0 0 0 0 0 0 0 0), 
(0 1 0 0 0 0 0 0 0 0 0 0 0 0), (1 0 0 0 0 0 0 0 0 0 0 0 0 0) ]
</PRE>
<HR>
<H5><A NAME = "12802">RootDatum(L) : AlgLie -&gt; RootDtm</A></H5>
<H5>RootDatum(L) : AlgMatLie -&gt; RootDtm</H5>
<BLOCKQUOTE>
Here L is a semisimple Lie algebra. This function returns the 
root datum D of L with respect to the Cartan subalgebra which 
is output by <TT>CartanSubalgebra(L)</TT>. We note that the order of 
the positive roots in D is not necessarily the same as the order
in which they appear in the root system of L.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "12803">Example <TT>AlgLie_RootDatum (H106E33)</TT></A></H3>
We set up the root datum of a Lie algebra, and extract the Cartan matrix.
<P>
<P>
<PRE>
&gt; L:= LieAlgebra("F4", Rationals());
&gt; rd := RootDatum(L); 
&gt; rd;
Root datum of type F4
&gt; CartanMatrix(rd);
[ 2  0 -1  0]
[ 0  2  0 -1]
[-1  0  2 -1]
[ 0 -1 -2  2]
</PRE>
<HR>
<H5><A NAME = "12804"></A><A NAME = "ChevalleyBasis">ChevalleyBasis</A>(L) : AlgLie -&gt; [ AlgLieElt ], [ AlgLieElt ], [ AlgLieElt ]</H5>
<H5>ChevalleyBasis(L, H) : AlgLie, AlgLie -&gt; [ AlgLieElt ], [ AlgLieElt ], [ AlgLieElt ]</H5>
<H5>ChevalleyBasis(L) : AlgMatLie -&gt; [ AlgMatLieElt ], [ AlgMatLieElt ], [ AlgMatLieElt ]</H5>

<PRE>    AssumeAlmostSimple: BoolElt         Default: <TT>false</TT></PRE>
<BLOCKQUOTE>
Given a semisimple Lie algebra L with a split maximal toral subalgebra H,
this function returns three sequences, x, y and h of elements of L.
They form a Chevalley basis of L. The first sequence gives basis
elements corresponding to positive roots, the second to the negative roots
and the third to basis elements in a Cartan subalgebra.
If a split maximal toral subalgebra H is not given, an attempt is made to 
compute one.
<P>
For Lie algebras over fields of characteristic 2 and 3 the algorithm 
used is described in <A  HREF = "text1129.htm#bib_CohenRoozemond2009">[CR09]</A>. In particular, this
involves computing a direct sum decomposition of L, which can be quite
time consuming. If there is reason to believe that L is (almost) simple,
the optional parameter <TT>AssumeAlmostSimple</TT> should be set to {<TT>true</TT>}.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "12805">Example <TT>AlgLie_ChevalleyBasis (H106E34)</TT></A></H3>
We construct a Chevalley basis for two Lie algebras.
<P>
<P>
<PRE>
&gt; L := LieAlgebra("A2", RationalField());
&gt; x, y, h:= ChevalleyBasis(L);
&gt; x; y; h;
[ (0 0 0 0 0 1 0 0), (0 0 0 0 0 0 1 0), (0 0 0 0 0 0 0 1) ]
[ (0 0 1 0 0 0 0 0), (0 1 0 0 0 0 0 0), (1 0 0 0 0 0 0 0) ]
[ (0 0 0 1 0 0 0 0), (0 0 0 0 1 0 0 0) ]
&gt; L := LieAlgebra("A3", Rationals());
&gt; print RootDatum(L) : Maximal;                
Root datum of type A3 with simple roots
[ 1  0  1]
[ 1 -2  1]
[ 0  1 -2]
and simple coroots
[ 1  1  1]
[ 0 -1  0]
[ 0  0 -1]
</PRE>
<HR>
<H5><A NAME = "12806">ChevalleyBasis(L, H, R) : AlgLie, AlgLie, RootDtm -&gt; [ AlgLieElt ], [ AlgLieElt ], [ AlgLieElt ]</A></H5>
<BLOCKQUOTE>
Given a semisimple Lie algebra L with a split maximal toral subalgebra H,
and an irreducible root datum R, this function computes a Chevalley basis 
of L with respect to H and R.
This basis is returned in the form of three sequences, x, y and h 
of elements of L, where the first sequence gives basis elements corresponding 
to positive roots, the second to the negative roots
and the third to basis elements in the toral subalgebra H.
</BLOCKQUOTE>
<H5><A NAME = "12807">IsChevalleyBasis(L, R, x, y, h) : AlgLie, RootDtm, [ AlgLieElt ], [ AlgLieElt ], [ AlgLieElt ] -&gt; BoolElt, [ Tup ]</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if x, y and h form a Chevalley basis of the Lie algebra L 
with respect to the root datum R.  If so, return a sequence describing the extraspecial 
signs as second return value.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "12808">Example <TT>AlgLie_ChevalleyBasisSmallChar (H106E35)</TT></A></H3>
We compute a Chevalley basis for a Lie algebra of type E<sub>6</sub> inside one of type E<sub>7</sub>.
<P>
<P>
<PRE>
&gt; R := RootDatum("E7");
&gt; L1 := LieAlgebra(R, GF(2));
&gt; p1,n1,c1 := StandardBasis(L1);
&gt; L1;
Lie Algebra of dimension 133 with base ring GF(2)
&gt; DynkinDiagram(R);      

E7    1 - 3 - 4 - 5 - 6 - 7
              |
              2
&gt; S, proj := sub&lt;R | [1..6]&gt;;
&gt; S;
S: Root datum of dimension 7 of type E6 
&gt; #proj;
72
&gt; projpos := [i : i in proj | i le NumPosRoots(R)];
&gt; #projpos;
36
&gt; L2 := sub&lt;L1 | p1[projpos], n1[projpos]&gt;;                
&gt; L2;
Lie Algebra of dimension 78 with base ring GF(2)
&gt; H2 := L2 meet SplitMaximalToralSubalgebra(L1);
&gt; H2;
Lie Algebra of dimension 6 with base ring GF(2)
&gt; p2,n2,c2 := ChevalleyBasis(L2, H2, RootDatum("E6"));
&gt; ok := IsChevalleyBasis(L2, RootDatum("E6"), p2, n2, c2);      
&gt; ok;
true
</PRE>
<HR>
<H5><A NAME = "12809"></A><A NAME = "TwistedBasis">TwistedBasis</A>(L, H, R) : AlgLie, AlgLie, RootDtm -&gt; AlgLie, AlgLie, Rec, AlgMatElt</H5>
<BLOCKQUOTE>
For a Lie algebra L, a split toral subalgebra H of L, and a twisted root
datum R, the function constructs a "twisted basis" of L. 
<P>
Let k be the coefficient ring of L and K an extension field of k of
degree equal to the twisting degree of R. This function has 4 return 
values. First, L' = L tensor K; second, a homomorphism &phi; from L to L',
third, a record containing a Chevalley basis of L' with respect to the untwisted 
root datum of R; fourth, a matrix describing the action of the Frobenius
automorphism of K on the positive roots of the Chevalley basis of L'. 
<P>
Such a basis constitutes a proof that L' is of type R. Consult 
<A  HREF = "text1129.htm#bib_Roozemond2010">[Roo10]</A>, Chapter 5.3, for more details on such twisted bases.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "12810">Example <TT>AlgLie_TwistedBasis (H106E36)</TT></A></H3>
We investigate a twisted basis of the Lie algebra of type ()<sup>2</sup>A<sub>2</sub>
over the field with 5 elements. Let &delta; be the automorphism
of the root system of type A<sub>2</sub>, let k = GF(5), and let K = GF(5<sup>2</sup>).
<P>
<P>
<PRE>
&gt; R := TwistedRootDatum(RootDatum("A2") : Twist := 2);
&gt; L := TwistedLieAlgebra(R, GF(5));
&gt; H := SplitToralSubalgebra(L);
&gt; LK, phi, ChevBas, m := TwistedBasis(L, H, R);
&gt; m;
[     0      1]
[     1      0]
</PRE>
This matrix <TT>m</TT> shows that &delta; acts as expected on the 
Chevalley basis elements of <TT>LK</TT>  = L tensor K.
We verify the correctness of <TT>m</TT>.
<P>
<P>
<PRE>
&gt; K := CoefficientRing(LK);
&gt; simp := ChevBas`BasisPos[[1..Rank(R)]];
&gt; simp;
[ (     0      0      0      0      0      1  ksi^8      0), 
  (     0      0      0      0      0      1 ksi^16      0) ]
&gt; fr := FrobeniusMap(K);
&gt; frv := func&lt;x | Vector([ fr(i) : i in Eltseq(x)])&gt;;
&gt; [ Position(simp, frv(x)) : x in simp ];
[ 2, 1 ]
</PRE>
So indeed the Frobenius map (acting on the coordinates of LK) 
acts as &delta;. This is equivalent <A  HREF = "text1129.htm#bib_Roozemond2010">[Roo10, Lemma 5.3]</A> to 
the basis elements of L being stable under the composition of the
Frobenius map (this time acting on the Chevalley basis of L tensor K) 
and the root system automorphism &delta;.
We verify this assertion explicitly for this example.
<P>
<P>
<PRE>
&gt; p := ChevBas`BasisPos;
&gt; n := ChevBas`BasisNeg;
&gt; c := ChevBas`BasisCart;
&gt; pi := Sym(6)!(1, 2)(4, 5);
&gt; ChevBasLK := VectorSpaceWithBasis([ Vector(x) : x in p cat n cat c]);
&gt; piL := DiagramAutomorphism(LK, pi);
</PRE>
Now &delta; acts on L tensor K as <TT>T</TT>, and <TT>fr</TT> is still the Frobenius
automorphism of the field K. The images of the basis elements of L under
<TT>delta</TT> composed with <TT>fr</TT> are as follows:
<P>
<P>
<PRE>
&gt; for i in [1..Dimension(L)] do
&gt;    b := phi(L.i);
&gt;    printf "i = %o, b =    %o n", i, Coordinates(ChevBasLK, Vector(b));
&gt;    printf "   pi(b)^fr = %o n", [ fr(i) : i in 
&gt;                              Coordinates(ChevBasLK, Vector(piL(b))) ];
&gt; end for;
i = 1, b =    [ 0, 0, 0, 0, 0, ksi^9, 0, 0 ]
   (b*T)^fr = [ 0, 0, 0, 0, 0, ksi^9, 0, 0 ]
i = 2, b =    [ 0, 0, 0, ksi^5, ksi, 0, 0, 0 ]
   (b*T)^fr = [ 0, 0, 0, ksi^5, ksi, 0, 0, 0 ]
i = 3, b =    [ 0, 0, 0, ksi^9, ksi^21, 0, 0, 0 ]
   (b*T)^fr = [ 0, 0, 0, ksi^9, ksi^21, 0, 0, 0 ]
i = 4, b =    [ 0, 0, 0, 0, 0, 0, ksi^5, ksi ]
   (b*T)^fr = [ 0, 0, 0, 0, 0, 0, ksi^5, ksi ]
i = 5, b =    [ 0, 0, 0, 0, 0, 0, ksi, ksi^5 ]
   (b*T)^fr = [ 0, 0, 0, 0, 0, 0, ksi, ksi^5 ]
i = 6, b =    [ ksi, ksi^5, 0, 0, 0, 0, 0, 0 ]
   (b*T)^fr = [ ksi, ksi^5, 0, 0, 0, 0, 0, 0 ]
i = 7, b =    [ ksi^21, ksi^9, 0, 0, 0, 0, 0, 0 ]
   (b*T)^fr = [ ksi^21, ksi^9, 0, 0, 0, 0, 0, 0 ]
i = 8, b =    [ 0, 0, ksi^9, 0, 0, 0, 0, 0 ]
   (b*T)^fr = [ 0, 0, ksi^9, 0, 0, 0, 0, 0 ]
</PRE>
Thus, all the basis elements of L are stable under the composition of 
the diagram automorphism &delta; and the Frobenius automorphism.
<HR>
<H5><A NAME = "12811">WeylGroup(L) : AlgLie -&gt; GrpPermCox</A></H5>
<H5>WeylGroup(GrpPermCox, L) : Cat, AlgLie -&gt; GrpPermCox</H5>
<BLOCKQUOTE>
The Weyl group of the reductive Lie algebra L, as a permutation Coxeter group
(see Chapter <A  HREF = "text1101.htm#12331">COXETER GROUPS</A>).
</BLOCKQUOTE>
<H5><A NAME = "12812">WeylGroup(GrpFPCox, L) : Cat, AlgLie -&gt; GrpPermCox</A></H5>
<BLOCKQUOTE>
The Weyl group of the reductive Lie algebra L, as a Coxeter group
(see Chapter <A  HREF = "text1101.htm#12331">COXETER GROUPS</A>).
</BLOCKQUOTE>
<H5><A NAME = "12813">WeylGroup(GrpMat, L) : Cat, AlgLie -&gt; GrpPermCox</A></H5>
<BLOCKQUOTE>
The Weyl group of the reductive Lie algebra L, as a reflection group
(see Chapter <A  HREF = "text1101.htm#12331">COXETER GROUPS</A>).
</BLOCKQUOTE>
<PRE></PRE> <A  HREF = "text1139.htm">[Next]</A><A  HREF = "text1137.htm">[Prev]</A> <A  HREF = "text1139.htm">[Right]</A> <A  HREF = "text1137.htm">[Left]</A> <A  HREF = "text1130.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<br><small>Version: V2.22 of <I>
Thu Jun  9 16:37:49 EST 2016
</I></small>
</body></html>