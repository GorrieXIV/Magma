<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <link rel='stylesheet' href='help.css' type='text/css'>
  <TITLE>Cones and Polyhedra</TITLE>
</head>
<body BGCOLOR="#FFFFFF">

 <A  HREF = "text1735.htm">[Next]</A><A  HREF = "text1733.htm">[Prev]</A> <A  HREF = "text1735.htm">[Right]</A> <A  HREF = "text1733.htm">[Left]</A> <A  HREF = "text1729.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<PRE></PRE><H3><A NAME = "19095">Cones and Polyhedra</A></H3>




<H5>Subsections</H5>
<UL>
<LI> <A  HREF = "text1734.htm#19096">Generators of Cones</A>
<LI> <A  HREF = "text1734.htm#19105">Properties of Polyhedra</A>
<LI> <A  HREF = "text1734.htm#19125">Attributes of Polyhedra</A>
<LI> <A  HREF = "text1734.htm#19139">Combinatorics of Polyhedral Complexes</A>
</UL>
<H4><A NAME = "19096">Generators of Cones</A></H4>



<H5><A NAME = "19097">BoxElements(C) : TorCon -&gt; SetEnum</A></H5>
<BLOCKQUOTE>
Given a simplicial cone C, returns the coefficients of the points in the fundamental domain generated by the rays of C, with respect to the rays.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "19098">Example <TT>Polyhedra_toric-cone-boxelements-example (H149E9)</TT></A></H3>
Let C&sub;L be a simplicial cone and consider the sublattice L'&sub;L generated by the rays of C. We shall construct a representative set of points of L contained in the fundamental domain of L'.
<P>
<P>
<PRE>
&gt; C:=Cone([[1,-1,-3],[1,1,0],[1,0,1]]);
&gt; rays:=Rays(C);
&gt; Index(rays);
5
&gt; pts:=BoxElements(C);
&gt; pts;
{
    [ 0, 0, 0 ],
    [ 3/5, 3/5, 4/5 ],
    [ 2/5, 2/5, 1/5 ],
    [ 1/5, 1/5, 3/5 ],
    [ 4/5, 4/5, 2/5 ]
}
&gt; {&amp;+[rays[i] * c[i] : i in [1..3]] : c in pts};
{
    (2, 0, -2),
    (2, 0, -1),
    (1, 0, -1),
    (0, 0, 0),
    (1, 0, 0)
}
</PRE>
Using these points we can construct the rational Ehrhart generating function counting the number of points as successive heights in C:
<P>
<P>
<PRE>
&gt; d:=Dimension(C);
&gt; heights:=[&amp;+c : c in pts];
&gt; delta:=[#[i : i in heights | i eq h] : h in [0..d - 1]];
&gt; R&lt;x&gt;:=RationalFunctionField(Rationals());
&gt; f:=&amp;+[delta[i] * x^(i - 1) : i in [1..d]] / (1 - x)^d;
&gt; f;
(-2*x^2 - 2*x - 1)/(x^3 - 3*x^2 + 3*x - 1)
&gt; K&lt;t&gt;:=PowerSeriesRing(Rationals(),10);
&gt; K ! f;
1 + 5*t + 14*t^2 + 28*t^3 + 47*t^4 + 71*t^5 + 100*t^6 + 134*t^7 + \
    173*t^8 + 217*t^9 + O(t^10)
&gt; w:=Dual(Ambient(C)) ! [1,0,0];
&gt; [NumberOfPoints(Polyhedron(C,w,i)) : i in [0..9]];
[ 1, 5, 14, 28, 47, 71, 100, 134, 173, 217 ]
</PRE>
<HR>
<H5><A NAME = "19099">HilbertBasis(C) : TorCon -&gt; SeqEnum</A></H5>
<H5>ZGenerators(C) : TorCon -&gt; SeqEnum</H5>

<PRE>    level: RngIntElt                    Default: &infin;</PRE>
<BLOCKQUOTE>
If C lies in a toric lattice L, then return a finite sequence of elements of L that generate C as a monoid. If specified, the parameter <TT>level</TT> restricts the search for generators to that given level; this assumes that C is graded.
</BLOCKQUOTE>
<H5><A NAME = "19100">RGenerators(C) : TorCon -&gt; SeqEnum</A></H5>
<H5>MinimalRGenerators(C) : TorCon -&gt; SeqEnum</H5>
<BLOCKQUOTE>
If C lies in a toric lattice L, then return
a finite sequence of elements of L that generate C
over Q_ +.
The list is forced to be minimal for <TT>MinimalRGenerators</TT>,
but might not be otherwise.
</BLOCKQUOTE>
<H5><A NAME = "19101">Points(C,H,h) : TorCon,TorLatElt,FldRatElt -&gt; SetEnum</A></H5>
<BLOCKQUOTE>
The set of integral lattice points in the cone C contained in the hyperplane
given by the section determined by the dual lattice element H at height
given by the rational number h.
The intersection of H with C is required to be compact.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "19102">Example <TT>Polyhedra_toric-cone-sublattice-example (H149E10)</TT></A></H3>
Here we find the generators of a cone in the
sublattice spanned by its defining lattice points.
First build some points in a toric lattice and
make the cone they generate.
<P>
<P>
<PRE>
&gt; L := ToricLattice(4);
&gt; B := [ L | [1,2,3,-3], [-1,0,1,0], [1,2,1,-2], [2,0,0,-1], [0,0,2,-1] ];
&gt; L1,f := Sublattice(B);
&gt; Dimension(L1);
3
&gt; C := Cone(B);
&gt; Points(Polytope(B));
{
    (1, 2, 1, -2),
    (2, 0, 0, -1),
    (-1, 0, 1, 0),
    (1, 2, 3, -3),
    (1, 0, 1, -1),
    (0, 0, 2, -1),
    (0, 1, 1, -1),
    (1, 1, 2, -2)
}
&gt; ZGenerators(C);
[
    (-1, 0, 1, 0),
    (0, 1, 1, -1),
    (1, 2, 1, -2),
    (2, 0, 0, -1)
]
</PRE>
Using the embedding map f, pull the cone back to the lattice span of C.
<P>
<P>
<PRE>
&gt; C1 := C @@ f;
</PRE>
In the smaller lattice, this cone is nonsingular.
<P>
<P>
<PRE>
&gt; IsNonsingular(C1);
true
</PRE>
We can find out which points generate the cone in the smaller
lattice and compare them with the generators of the original cone.
<P>
<P>
<PRE>
&gt; B1 := ZGenerators(C1);
&gt; B1;
[
    (-1, 0, 1),
    (1, 1, 0),
    (2, 0, -1)
]
&gt; [ Index(B,Image(f,b)) : b in B1 ];
[ 2, 3, 4 ]
</PRE>
<HR>
<H5><A NAME = "19103">QuotientGenerators(C) : TorCon -&gt; SetEnum</A></H5>
<BLOCKQUOTE>
Let C&sub;L be a simplicial cone of maximum dimension in the lattice L. Let L'&sub;L be the sublattice generated by the rays of C. This intrinsic returns a sequence of generators for the torsion of L / L'; the generators are expressed in terms of the basis given by the rays of C.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "19104">Example <TT>Polyhedra_toric-cone-quotient-generators-example (H149E11)</TT></A></H3>
Consider the cyclic quotient singularity 1/3(1, 1, 2). We will begin by constructing the corresponding cone C.
<P>
<P>
<PRE>
&gt; L:=ToricLattice(3);
&gt; v:=L ! [1/3,1/3,2/3];
&gt; N,emb:=AddVectorToLattice(v);
&gt; C:=Image(emb,PositiveQuadrant(L));
&gt; C;
Cone C with 3 generators:
    (1, 0, 0),
    (0, 1, 0),
    (1, 1, 3)
&gt; IsIsolated(C);
true
&gt; IsQFactorial(C);
true
&gt; IsTerminal(C);
true
</PRE>
Now we reverse this operation: we take the cone C and recognise that it corresponds to 1/3(1, 1, 2).
<P>
<P>
<PRE>
&gt; QuotientGenerators(C);
{
    [ 2/3, 2/3, 1/3 ]
}
</PRE>
Of course, the generators are defined only up to multiplication by units in &mu;<sub>3</sub>.
<HR>
<H4><A NAME = "19105">Properties of Polyhedra</A></H4>



<H5><A NAME = "19106">CompactPart(P) : TorPol -&gt; TorPol</A></H5>
<BLOCKQUOTE>
The polytope defined by taking the convex hull of the vertices of the
polyhedron P. This is the smallest polytope which can occur
as a factor in an expression of P as the Minkowski sum of a
polytope and a cone.
</BLOCKQUOTE>
<H5><A NAME = "19107">IntegralPart(P) : TorPol -&gt; TorPol</A></H5>
<BLOCKQUOTE>
The polyhedron defined by taking the convex hull of the integral
points contained in the polyhedron P.
</BLOCKQUOTE>
<H5><A NAME = "19108">InfinitePart(P) : TorPol -&gt; TorCon</A></H5>
<BLOCKQUOTE>
The tail cone of the polyhedron P.
</BLOCKQUOTE>
<H5><A NAME = "19109">IsEmpty(P) : TorPol -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Return <TT>true</TT> if and only if the polyhedron P is empty.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "19110">Example <TT>Polyhedra_toric-polar-cone-example (H149E12)</TT></A></H3>
One can build a polytope as the convex hull of a finite sequence
of points---these may be elements of a toric lattice or simply
sequences of integer or rational coefficients.
<P>
<P>
<PRE>
&gt; P := Polytope([[-4,2,1],[0,3,4],[3,1,-3],[3,0,0],[2,-1,1]]);
</PRE>
The polar polyhedron comprises dual vectors that evaluate
to at least -1 on P. It is compact if and only if the
origin lies in the interior of P.
<P>
<P>
<PRE>
&gt; D := Polar(P);
&gt; D;
3-dimensional polyhedron D with 3-dimensional finite part with 5 vertices:
    ( 1/2,      1,    -1),
    (-1/3,    1/2,   1/6),
    (-1/3,   1/21,  -2/7),
    (-1/3,  -3/13, -1/13),
    (1/67, -37/67, 11/67)
and 3-dimensional infinite part given by a cone with 3 minimal generators:
    (   1,      2,     0),
    (   2,      9,     5),
    (   7,      9,    10)
</PRE>
Since D is infinite, there is no intrinsic to list its integral
points, but one can determine whether it contains integral points
at all.
<P>
<P>
<PRE>
&gt; HasIntegralPoint(D);
true
</PRE>
Computing the span of all the integral points of D is possible.
<P>
<P>
<PRE>
&gt; IntegralPart(D);
3-dimensional polyhedron with 3-dimensional finite part with 6 vertices:
    (0,  0,  0),
    (0,  1,  0),
    (0,  2,  1),
    (1,  1,  1),
    (1,  2, -1),
    (2,  2,  3)
and 3-dimensional infinite part given by a cone with 3 minimal generators:
    (1,  2,  0),
    (2,  9,  5),
    (7,  9, 10)
</PRE>
The compact and infinite parts of D can be recovered.
<P>
<P>
<PRE>
&gt; cD := CompactPart(D);
&gt; cD;
3-dimensional polytope cD with 5 vertices:
    ( 1/2,      1,    -1),
    (-1/3,    1/2,   1/6),
    (-1/3,   1/21,  -2/7),
    (-1/3,  -3/13, -1/13),
    (1/67, -37/67, 11/67)
</PRE>
Polytopes are special cases of polyhedra (those whose infinite tail
cone is the zero cone, or equivalently those that are compact),
and the distinction can be determined.
<P>
<P>
<PRE>
&gt; IsPolytope(cD);
true
&gt; IsPolytope(D);
false
</PRE>
<HR>
<H3><A NAME = "19111">Example <TT>Polyhedra_toric-polyhedron-example (H149E13)</TT></A></H3>
<P>
<P>
<PRE>
&gt; C:=Cone([[0,1,0],[0,1,1],[1,1,2],[1,1,4]]);
&gt; P:=Polyhedron(C);
&gt; P;
2-dimensional polyhedron P with 1-dimensional finite part with 2
vertices:
    (1, 2),
    (1, 4)
and 2-dimensional infinite part given by a cone with 2 minimal
generators:
    (1, 0),
    (1, 1)
</PRE>
<P>
<P>
<PRE>
&gt; CC:=Cone([[1,0],[1,1]]);
&gt; QQ:=Polytope([[1,2],[1,4]]);
&gt; PP:=CC + QQ;
&gt; PP;
2-dimensional polyhedron PP with 1-dimensional finite part with 2
vertices:
    (1, 2),
    (1, 4)
and 2-dimensional infinite part given by a cone with 2 minimal
generators:
    (1, 0),
    (1, 1)
</PRE>
But there's a potential catch.
<P>
<P>
<PRE>
&gt; PP eq P;
false
&gt; Ambient(PP);
2-dimensional toric lattice Z^2
&gt; Ambient(P);
2-dimensional toric lattice ker &lt;1, 0, 0&gt;
&gt; P:=ChangeAmbient(P,Ambient(PP));
&gt; PP eq P;
true
</PRE>
The ambients are different simply because of the
method of construction of the two polyhedra, but they
can be forced into the same space.
<HR>
<H5><A NAME = "19112">IsMaximumDimensional(C) : TorCon -&gt; BoolElt</A></H5>
<H5>IsMaximumDimensional(P) : TorPol -&gt; BoolElt</H5>
<BLOCKQUOTE>
Return <TT>true</TT> if and only if the cone C or polyhedron P has dimension
equal to that of its ambient lattice.
</BLOCKQUOTE>
<H5><A NAME = "19113">IsStrictlyConvex(C) : TorCon -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Return <TT>true</TT> if and only if the cone C is strictly convex; that is,
if there exists a hyperplane H such that C is contained on
one side of H and C meets H in single point 0.
</BLOCKQUOTE>
<H5><A NAME = "19114">IsLinearSpace(C) : TorCon -&gt; BoolElt</A></H5>
<H5>IsLinearSpace(P) : TorPol -&gt; BoolElt</H5>
<BLOCKQUOTE>
Return <TT>true</TT> if and only if the cone C or the polyhedron P is a linear space.
</BLOCKQUOTE>
<H5><A NAME = "19115">IsSimplicial(C) : TorCon -&gt; BoolElt</A></H5>
<H5>IsSimplicial(P) : TorPol -&gt; BoolElt</H5>
<BLOCKQUOTE>
Return <TT>true</TT> if and only if the cone C or the polyhedron P is simplicial.
</BLOCKQUOTE>
<H5><A NAME = "19116">IsSimplex(P) : TorPol -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Return <TT>true</TT> if and only if the polyhedron P is a simplex.
</BLOCKQUOTE>
<H5><A NAME = "19117">IsSimple(P) : TorPol -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Return <TT>true</TT> if and only if the polyhedron P is simple.
</BLOCKQUOTE>
<H5><A NAME = "19118">IsAffineLinear(P) : TorPol -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Return <TT>true</TT> if and only if the polyhedron P is an affine linear space.
</BLOCKQUOTE>
<H5><A NAME = "19119">IsZero(C) : TorCon -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Return <TT>true</TT> if and only if the cone C is supported at the origin of
its ambient toric lattice.
</BLOCKQUOTE>
<H5><A NAME = "19120">ContainsZero(P) : TorPol -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Return <TT>true</TT> if and only if the polyhedron P contains the origin strictly in its interior.
</BLOCKQUOTE>
<H5><A NAME = "19121">IsPointed(P) : TorPol -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> iff the polyhedron P is pointed, i.e. if it is empty of has a vertex.
</BLOCKQUOTE>
<H5><A NAME = "19122">IsFlag(P) : TorPol -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> iff the simplicial polytope P is a flag polytope.
</BLOCKQUOTE>
<H5><A NAME = "19123">IsPerfectlyCentered(P) : TorPol -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> iff the polyhedron P is a polytope containing the origin strictly in its interior such that for any non-empty face F of P, the intersection (relint)(F) with the (outer) normal cone is non-empty.
</BLOCKQUOTE>
<H5><A NAME = "19124">IsIntegrallyClosed(P) : TorPol -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> iff the polytope P is integrally closed; i.e. if every lattice point in kP can be written as the sum of k lattice points in P, for all k&isin;Z<sub>&ge;0</sub>.
</BLOCKQUOTE>
<H4><A NAME = "19125">Attributes of Polyhedra</A></H4>



<H5><A NAME = "19126">IsPolytope(P) : TorPol -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if and only if the polyhedron P is a polytope; that is, if and only if P is compact.
</BLOCKQUOTE>
<H5><A NAME = "19127">Dimension(C) : TorCon -&gt; RngIntElt</A></H5>
<H5>Dimension(P) : TorPol -&gt; RngIntElt</H5>
<BLOCKQUOTE>
The dimension of the toric cone C or polyhedron P.
</BLOCKQUOTE>
<H5><A NAME = "19128">Degree(P) : TorPol -&gt; RngIntElt</A></H5>
<H5>Codegree(P) : TorPol -&gt; RngIntElt</H5>
<BLOCKQUOTE>
The degree and codegree of the integral polytope P. The codegree is equal to the smallest dilation k&isin;Z<sub>&gt;0</sub> such that kP contains an interior lattice point.
</BLOCKQUOTE>
<H5><A NAME = "19129">Index(C) : TorCon -&gt; RngIntElt</A></H5>
<BLOCKQUOTE>
The index of the sublattice generated by the minimal
(R)-generators of the cone C in its linear span.
</BLOCKQUOTE>
<H5><A NAME = "19130">Width(P) : TorPol -&gt; FldRatElt, SetEnum</A></H5>
<H5>Width(P,u) : TorPol,TorLatElt -&gt; FldRatElt</H5>
<BLOCKQUOTE>
The width of a polytope P in a lattice L with respect to an element u&isin;L<sup>v</sup> in the dual lattice is the different max{u(v) : v&isin;P} - min{u(v) : v&isin;P}. More generally, the width of P is defined to be the smallest possible width ranging over all non-zero u.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "19131">Example <TT>Polyhedra_toric-width-example (H149E14)</TT></A></H3>
We calculate the (minimum) width of a polytope P, along with all forms realising this width.
<P>
<P>
<PRE>
&gt; P:=Polytope([[1,-2,3],[2,-4,-1],[5,-4,1],[-3,-3,-3]]);
&gt; width,us:=Width(P);
&gt; width;
1
&gt; us;
{
    (1, 3, -1),
    (-1, -3, 1)
}
&gt; u:=Representative(us);
&gt; [u * v : v in Vertices(P)];
[ -8, -9, -8, -9 ]
</PRE>
In particular, the fact that P is of width one implies that P contains no (strict) interior lattice points:
<P>
<P>
<PRE>
&gt; NumberOfInteriorPoints(P);
0
</PRE>
We calculate a change of basis to make the fact that P is of width one immediately apparent.
<P>
<P>
<PRE>
&gt; phi:=ChangeBasis(u);
&gt; DefiningMatrix(phi);
[ 1  0  1]
[ 0  1  3]
[ 0  0 -1]
&gt; Image(phi,P);
3-dimensional polytope with 4 vertices:
    ( 1, -2, -8),
    ( 2, -4, -9),
    ( 5, -4, -8),
    (-3, -3, -9)
</PRE>
<HR>
<H5><A NAME = "19132">IsPyramid(P) : TorPol -&gt; BoolElt, TorLatElt, TorPol, Map, TorLatElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> iff the polytope P is a pyramid, i.e. if there exists a facet F and an integral vertex u&isin;P such that P = (conv)(F &cup;{u}), where u is at height one relative to F. If P is a pyramid, then a choice of apex u, base facet F, an element varphi in GL<sub>n</sub>(Z), and a lattice translation v are also returned. These are chosen such that varphi(P) + v sends u to (1, 0, ..., 0) and embeds F in the (n - 1)-dimensional sublattice generated by (0, 1, ..., 0), ..., (0, 0, ..., 1).
</BLOCKQUOTE>
<H5><A NAME = "19133">Pyramid(P) : TorPol -&gt; TorPol, Map, Map, Map, Map</A></H5>
<BLOCKQUOTE>
The pyramid given by embedding the polyhedron P in the lattice Z x L  (where L is the ambient lattice containing P) and adding the point  (1, 0, ..., 0) to the convex hull. Also gives the two embedding maps and the two projection maps of the underlying lattices.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "19134">Example <TT>Polyhedra_toric-pyramid-example (H149E15)</TT></A></H3>
We begin with a 3-dimensional polytope P living in a 4-dimensional lattice:
<P>
<P>
<PRE>
&gt; P:=Polytope([
&gt;     [ -3, -2, -1, 3 ],
&gt;     [ 2, 2, 0, -3 ],
&gt;     [ 3, 0, -2, 0 ],
&gt;     [ 4, 1, 61, -121 ]
&gt; ]);
&gt; Dimension(P);
3
</PRE>
Next we see that P is a pyramid P=(conv)(F&cup;{u}). We recover the 2-dimensional polytope F and the corresponding apex u.
<P>
<P>
<PRE>
&gt; bool,u,F,phi,v:=IsPyramid(P);
&gt; bool;
true
&gt; F;
2-dimensional polytope F with 3 vertices:
    ( 2,   2,   0,   -3),
    ( 3,   0,  -2,    0),
    ( 4,   1,  61, -121)
&gt; u;
(-3, -2, -1, 3)
</PRE>
We make this pyramid construction explicit by calculating varphi(P) + v:
<P>
<P>
<PRE>
&gt; Image(phi,P) + v;
3-dimensional polytope with 4 vertices:
    (1,  0,  0,  0),
    (0,  0,  0,  0),
    (0,  1, -2, -1),
    (0,  2, -1, -1)
</PRE>
Let us consider F as a simplex in a 2-dimensional lattice; we see that it is equivalent to the standard empty triangle S.
<P>
<P>
<PRE>
&gt; F:=PolyhedronInSublattice(F);
&gt; F;
2-dimensional polytope F with 3 vertices:
    (2,  0),
    (3, -1),
    (4, -1)
&gt; NumberOfInteriorPoints(F);
0
&gt; S:=Polytope([
&gt;     [ 0, 0 ],
&gt;     [ 1, 0 ],
&gt;     [ 0, 1 ]
&gt; ]);
&gt; bool:=IsEquivalent(F,S);
&gt; bool;
true
</PRE>
Since P is equivalent to a pyramid over S, we have that the Ehrhart &delta;-vector (also known as the h<sup> * </sup>-vector) of P must be equal to (1, 0, 0, 0). We verify this fact:
<P>
<P>
<PRE>
&gt; EhrhartDeltaVector(P);
[ 1, 0, 0, 0 ]
</PRE>
<HR>
<H5><A NAME = "19135">VertexEdgeIncidenceMatrix(P) : TorPol -&gt; ModMatRngElt</A></H5>
<BLOCKQUOTE>
The vertex--edge incidence matrix of the polyhedron P, where the i, j-th  entry is 1 if and only if the i-th vertex is contained in the j-th edge.
</BLOCKQUOTE>
<H5><A NAME = "19136">VertexFacetIncidenceMatrix(P) : TorPol -&gt; ModMatRngElt</A></H5>
<BLOCKQUOTE>
The vertex--facet incidence matrix of the polyhedron P, where the i, j-th entry is 1 if and only if the i-th vertex is contained in the j-th facet.
</BLOCKQUOTE>
<H5><A NAME = "19137">VertexFacetHeightMatrix(P) : TorPol -&gt; AlgMatElt</A></H5>
<BLOCKQUOTE>
The vertex--facet height matrix of the polyhedron P, where the i, j-th entry is equal to the lattice height of the i-th vertex over the j-th facet.
</BLOCKQUOTE>
<H5><A NAME = "19138">EdgeFacetIncidenceMatrix(P) : TorPol -&gt; ModMatRngElt</A></H5>
<BLOCKQUOTE>
The edge--facet incidence matrix of the polyhedron P, where the i, j-th entry is 1 if and only if the i-th edge is contained in the j-th facet.
</BLOCKQUOTE>
<H4><A NAME = "19139">Combinatorics of Polyhedral Complexes</A></H4>



<H5><A NAME = "19140">Ambient(C) : TorCon -&gt; TorLat</A></H5>
<H5>Ambient(P) : TorPol -&gt; TorLat</H5>
<BLOCKQUOTE>
The ambient toric lattice of the toric cone C or polyhedron P.
</BLOCKQUOTE>
<H5><A NAME = "19141">ChangeAmbient(C,L) : TorCon,TorLat -&gt; TorCon</A></H5>
<H5>ChangeAmbient(P,L) : TorPol,TorLat -&gt; TorPol</H5>
<BLOCKQUOTE>
Make a cone or polyhedron identical to the toric cone C or
polyhedron P but lying in the toric lattice L; the identification
of the existing ambient toric lattice with L is simply
by identification of the two standard bases and it requires the
dimensions of the two spaces to be equal.
</BLOCKQUOTE>
<PRE></PRE> <A  HREF = "text1735.htm">[Next]</A><A  HREF = "text1733.htm">[Prev]</A> <A  HREF = "text1735.htm">[Right]</A> <A  HREF = "text1733.htm">[Left]</A> <A  HREF = "text1729.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<br><small>Version: V2.22 of <I>
Thu Jun  9 16:37:49 EST 2016
</I></small>
</body></html>