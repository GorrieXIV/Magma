<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <link rel='stylesheet' href='help.css' type='text/css'>
  <TITLE>Graphical Output</TITLE>
</head>
<body BGCOLOR="#FFFFFF">

 <A  HREF = "text1550.htm">[Next]</A><A  HREF = "text1559.htm">[Prev]</A> <A  HREF = "text1550.htm">[Right]</A> <A  HREF = "text1559.htm">[Left]</A> <A  HREF = "text1551.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<PRE></PRE><H3><A NAME = "17499">Graphical Output</A></H3>

<P>
<P>
When working with a particular congruence subgroup it is
often useful to be able to produce a picture of a fundamental
domain of the group.  Also when considering images of geodesics
in Hh<sup> * </sup> it can be useful to draw the images.  The following
graphics functions provide a useful tool for this purpose. 


<H5><A NAME = "17500">DisplayPolygons(P,file) : SeqEnum, MonStgElt -&gt;</A></H5>

<PRE>    Colours: SeqEnum                    Default: [1,1,0]</PRE>

<PRE>    Outline: BoolElt                    Default: <TT>true</TT></PRE>

<PRE>    Fill: BoolElt                       Default: <TT>true</TT></PRE>

<PRE>    Show: BoolElt                       Default: <TT>false</TT></PRE>

<PRE>    Labels: SeqEnum                     Default: {[0,1]}</PRE>

<PRE>    Fontsize: RngIntElt                 Default: 2</PRE>

<PRE>    Size: SeqEnum                       Default: [ ]</PRE>

<PRE>    Pixels: RngIntElt                   Default: 300</PRE>

<PRE>    Overwrite: BoolElt                  Default: <TT>false</TT></PRE>

<PRE>    Radius: FldReElt                    Default: 0.5</PRE>

<PRE>    PenColours: SeEnum                  Default: [0,0,0]</PRE>
<BLOCKQUOTE>
Given a sequence of polygons, each of which is defined by a
sequence of points in the upper half plane, produce the postscript 
drawing of these polygons, and write the result to the named file.
The function returns a sequence of 4 real numbers, <TT>[x0,x1,h,S]</TT>,
where <TT>(x0,0)</TT> are the coordinates of the lower left corner,
<TT>(x1,h)</TT> are the coordinates
of the upper right corner, and the scale
is such that there are <TT>S</TT> pixels per unit.   These values are
either given by the user, or computed automatically.
<DL COMPACT class='compact'>
<DT></DT><DD><TT>Colours</TT> : Either a sequence of 3 numbers, or a sequence of
such sequences, one for each polygon in the sequence of polygons given.
A colour is represented by 3 real numbers between 0 and 1, giving the
red, green and blue components of the colour.
This colour is used for the filling of the polygon.
<DT></DT><DD><TT>PenColours</TT> : A sequence of 3 numbers, or a sequence of
such sequences, one for each polygon in the sequence of polygons given.
A colour is represented by 3 real numbers between 0 and 1, giving the
red, green and blue components of the colour.
This colour is used for drawing the outline of the polygon.
<DT></DT><DD><TT>Labels</TT> : A sequence of elements of type <TT>SetCspElt</TT>, <TT>FldRatElt</TT>
or <TT>RngIntElt</TT>, which will be labeled on the real axis in the
diagram.
<DT></DT><DD><TT>Fontsize</TT> : The size of the font used in labeling the diagram.
<DT></DT><DD><TT>Pixels</TT> : When using Autoscale, the scale is computed so that the
width of the resulting diagram is given by <TT>Pixels</TT> in pixels,
plus a 20 pixel border.  The minimal possible value for <TT>Pixels</TT>
is 10, and if any smaller value is given it will be set to 10.
<DT></DT><DD><TT>Size</TT> : If <TT>Size</TT> is not the empty sequence, 
the values in the sequence <TT>Size</TT>
are used to determine the size of the image.  When <TT>Size</TT>
is given by <TT>[x0,x1,y,S]</TT>, the picture is draw with
coordinates <TT>(x0,0)</TT> in the lower left corner,
<TT>(x1,h)</TT> in the upper right corner, and the scale is such that there
are <TT>S</TT> pixels per unit.
If <TT>Size</TT> is not given, then an appropriate size for the image is
computed automatically.
<DT></DT><DD><TT>Overwrite</TT> : If <TT>Overwrite</TT> is set to <TT>true</TT>, then if the name of the file given
names a file which already exists, it will be overwritten.  Otherwise
the user will be asked whether they want to overwrite the file or not.
<DT></DT><DD><TT>Show</TT> : If <TT>Show</TT> is set to <TT>true</TT> a System command is issued to make
a window pop up showing the file just created.  The system
command is  <TT>System("gv file &amp;")</TT>.  In future other
options may be possible.  If <TT>Show</TT> is <TT>false</TT> then 
<DT></DT><DD><TT>Fill</TT> : A boolean or sequence of booleans, determining whether the
polygon is drawn filled in with a colour, the colour coming from the
sequence <TT>Colours</TT>.  If both <TT>Fill</TT> and <TT>Outline</TT> are set to <TT>false</TT>
outline is reset to <TT>true</TT>.
<DT></DT><DD><TT>Outline</TT> : A boolean or sequence of
booleans, determining whether the
polygon is drawn with an outline.  If both <TT>Fill</TT> and <TT>Outline</TT> are set to <TT>false</TT>
outline is reset to <TT>true</TT>.
<DT></DT><DD><TT>Radius</TT> : A real number giving the radius of points marked on the diagram.
A point will be marked for any polygon given by a single point.</DL>
</BLOCKQUOTE>
<H5><A NAME = "17501">DisplayFareySymbolDomain(FS,file) : SymFry, MonStgElt -&gt; SeqEnum</A></H5>
<H5>DisplayFareySymbolDomain(G,file) : GrpPSL2, MonStgElt -&gt; SeqEnum</H5>

<PRE>    Colour: SeqEnum                     Default: [1,1,0]</PRE>

<PRE>    Show: BoolElt                       Default: <TT>false</TT></PRE>

<PRE>    Fontsize: RngIntElt                 Default: 2</PRE>

<PRE>    Labelsize: RngIntElt                Default: 3</PRE>

<PRE>    Autoscale: BoolElt                  Default: <TT>true</TT></PRE>

<PRE>    Size: SeqEnum                       Default: []</PRE>

<PRE>    Pixels: RngIntElt                   Default: 300</PRE>

<PRE>    Overwrite: BoolElt                  Default: <TT>false</TT></PRE>

<PRE>    ShowInternalEdges: BoolElt          Default: <TT>false</TT></PRE>
<BLOCKQUOTE>
<DL COMPACT class='compact'>
<DT></DT><DD><TT>Display</TT>: a fundamental domain corresponding to the
Farey Symbol FS, or a group G, for which the Farey symbol
will be computed, with edge identifications and cusps labeled.
This function returns a sequence of 4 real numbers, <TT>[x0,x1,h,S]</TT>,
where <TT>(x0,0)</TT> are the coordinates of the lower left corner,
<TT>(x1,h)</TT> are the coordinates
of the upper right corner, and the scale
is such that there are <TT>S</TT> pixels per unit.   These values are
either given by the user, or computed automatically.
A polygon can be a sequence of any number of points of type
<TT>HypSpcElt</TT> or <TT>SetCspElt</TT>.  When at least 3 points are
given a polygon is drawn.  For two points, a geodesic between them is
drawn.  For one point a small circle is drawn to mark the point.
<DT></DT><DD><TT>Colour</TT>: This colour is used in colouring the domain drawn.
A colour is represented by a sequence of
3 real numbers between 0 and 1, giving the
red, green and blue components of the colour.  
<DT></DT><DD><TT>Fontsize</TT> : The size of the font used in labeling the cusps on the 
diagram.
<DT></DT><DD><TT>Labelsize</TT> : The size of the font used in labeling the identification
labels on the diagram.
<DT></DT><DD><TT>Autoscale</TT> : 
If <TT>true</TT>, the scale is computed and the file is created so that
all the polygons listed can be seen in the diagram, if this is feasible.
if <TT>Autoscale</TT> is set to <TT>false</TT>, then the variable <TT>Size</TT> must be
given.
<DT></DT><DD><TT>Pixels</TT> : When using <TT>Autoscale</TT>, the scale is computed so that the
width of the resulting diagram is given by <TT>Pixels</TT> in pixels,
plus a 20 pixel border.  The minimal possible value for <TT>Pixels</TT>
is 10, and if any smaller value is given it will be set to 10.
<DT></DT><DD><TT>Size</TT> : When <TT>Autoscale</TT> is <TT>false</TT>, the values in the sequence <TT>Size</TT>
are used to determine the size of the image.  When <TT>Size</TT>
is given by <TT>[x0,x1,y,S]</TT>, the picture is draw with
coordinates <TT>(x0,0)</TT> in the lower left corner,
<TT>(x1,h)</TT> in the upper right corner, and the scale is such that there
are <TT>S</TT> pixels per unit.
<DT></DT><DD><TT>Overwrite</TT> : If <TT>Overwrite</TT> is set to <TT>true</TT>, then if the name of the file given
names a file which already exists, it will be overwritten.  Otherwise
the user will be asked whether they want to overwrite the file or not.
<DT></DT><DD><TT>Show</TT> : If <TT>Show</TT> is set to <TT>true</TT> a System command is issued to make
a window pop up showing the file just created.  The system
command is  <TT>System("gv file &amp;")</TT>.  In future other
options may be possible.  If <TT>Show</TT> is <TT>false</TT> then 
<DT></DT><DD><TT>ShowInternalEdges</TT> : If this is set to <TT>true</TT> then internal edges
are drawn dividing the domain into fundamental domains for &Gamma;<sub>0</sub>(2).</DL>
</BLOCKQUOTE>
<HR>
<H3><A NAME = "17502">Example <TT>GrpPSL2_Graphics (H136E9)</TT></A></H3>
In the first example we draw a fundamental domain for 
&Gamma;<sub>0</sub>(12).
<P>
<P>
<P>
<PRE>
&gt; G := Gamma0(24);
&gt; FS := FareySymbol(G);
&gt; C := Cusps(FS);
&gt; Domain := FundamentalDomain(G);
&gt; red := [1,0,0];
&gt; DisplayPolygons(Domain,"/tmp/Gamma0N12.ps":
&gt; Colours := red, Labels := C, Show := true, Fontsize := 1);
[ 0.E-28, 1.000000000000000000000000000, 1.500000000000000000000000000, 300 ]
</PRE>
<P>
The user could write a procedure
as follows for drawing the fundamental domain as a union of
fundamental domains for PSL<sub>2</sub>(Z).
<P>
<P>
<P>
<PRE>
&gt; procedure draw_fundamental_domain(Group,file)
&gt;     cosets := CosetRepresentatives(Group);
&gt;     H&lt;i,r&gt; := UpperHalfPlaneWithCusps();
&gt;     tri := [H|Infinity(),0,r];
&gt;     red := [1,0,0];  
&gt;     yellow := [1,1,0];
&gt;     cyan := [0,1,1];
&gt;     cols := &amp;cat[[red,yellow,cyan] : i in [1..(Ceiling(#cosets/3))]];
&gt;     trans := [g*tri : g in cosets];
&gt;     Outlines := [false : g in cosets];
&gt;     DisplayPolygons(trans,file:
&gt;         Colours := cols, Outline := Outlines, Show := true);
&gt; end procedure;
&gt;
&gt; // use the procedure to draw a domain for Gamma_0(19):
&gt; draw_fundamental_domain(Gamma0(19),"/tmp/gamma019.ps");
[ 0.E-28, 1.000000000000000000000000000, 1.500000000000000000000000000, 300 ]
</PRE>
<P>
In the following example, we use the cosets of &Gamma;<sub>0</sub>(11) to
draw a fundamental domain for &Gamma;<sub>0</sub>(11), divided up into
fundamental domains for the group of automorphisms of Hh<sup> * </sup>
generated by PSL<sub>2</sub>(Z) together with the map z |-&gt; - /line(z).
<P>
<P>
<P>
<PRE>
&gt; G := Gamma0(11);
&gt; H&lt;i,rho&gt; := UpperHalfPlaneWithCusps();
&gt; tri := [H|Infinity(),i,rho];
&gt; tri1 := [H|0,i,rho];
&gt; C11 := CosetRepresentatives(G);
&gt; Colours := [[0.6,0.2,0.9] : i in [1..#C11]] cat [[1,1,0] : i in [1..#C11]];
&gt; triangles := [g*tri : g in C11] cat [g*tri1 : g in C11];
&gt; DisplayPolygons(triangles,"/tmp/Gamma_0_11.ps": 
&gt; Colours := Colours, Show := false);
[ 0.E-57, 1.000000000000000000000000000, 1.500000000000000000000000000, 300 ]
</PRE>
<P>
Continuing from the above example, we can take any other polygon we
wish, and look at it's translates under the action of the cosets
of &Gamma;<sub>0</sub>(11).
<P>
<P>
<P>
<PRE>
&gt; tri2 := [H|Infinity(),2*i + 1,i,rho];
&gt; DisplayPolygons([g*tri2 : g in C11],"/tmp/pic.ps": 
&gt; Colours := Colours, Show := true);
[ 0.E-57, 1.000000000000000000000000000, 2.500000000000000000000000000, 300 ]
</PRE>
<P>
In the next example we define three different triangles.
Each of these is a fundamental domain for &Gamma;<sup>0</sup>(2), though 
Magma
 currently does not verify this.  For each choice we use a set of
 generators of &Gamma;<sup>0</sup>(2) to draw a partial tiling of the upper half
plane with equivalent fundamental domains.
<P>
<P>
<P>
<PRE>
&gt; G := CongruenceSubgroup(4,2);
&gt; H&lt;i,r&gt; := UpperHalfPlaneWithCusps();
&gt; generators := Generators(G);
&gt; M := generators cat [g^(-1) : g in generators] cat [G!1];
&gt; tri1 := [H|Infinity(),r-1,0,r,r+1];
&gt; tri2 := [H|Infinity(),i-1,0,i+1];
&gt; tri3 := FundamentalDomain(G);
&gt; X := [1..#M];
&gt; L := [G!m : m in Set([Matrix(M[i]*M[j]*M[k]) : i in X, j in X, k in X])];
&gt; DisplayPolygons([g*tri1 : g in L],"/tmp/picture1.ps": Show := true);     
[ -4.000000000000000000000000000, 3.500000000000000000000000000, 
1.500000000000000000000000000, 200 ]
&gt; DisplayPolygons([g*tri2 : g in L],"/tmp/picture2.ps": Show := true);     
[ -4.000000000000000000000000000, 3.000000000000000000000000000, 
1.500000000000000000000000000, 200 ]
&gt; DisplayPolygons([g*tri3 : g in L],"/tmp/picture3.ps": Show := true);     
[ -4.000000000000000000000000000, 3.000000000000000000000000000, 
1.500000000000000000000000000, 200 ]
</PRE>
<P>
Edges and Polygons with different numbers of sides can be included in the
same picture, as in the following example.
<P>
<P>
<PRE>
&gt; H&lt;i,r&gt; := UpperHalfPlaneWithCusps();
&gt; cosets := CosetRepresentatives(Gamma0(19));
&gt; polygons := [g*tri : g in cosets, tri in [[H|i,r],[H|i,2*r,3*r-1]]];
&gt; outlines := [true : i in cosets] cat [false : i in cosets];
&gt; cyan := [0,1,1];
&gt; DisplayPolygons(polygons,"/tmp/pic.ps":
&gt; Colours := cyan, Outline := outlines, Labels := [], Show := false);
[ 0.E-57, 1.000000000000000000000000000, 3.098076211353315940291169512, 300 ]
</PRE>
<P>
In the following example a function is defined to determine the
colouring of the polygons in terms of which Farey sequence 
pairs of end points of the polygons belong to.
<P>
<P>
<P>
<PRE>
&gt; frac := func&lt;a | a[1]/a[2]&gt;;
&gt; 
&gt; function FareyValue(m)
&gt;   mat := Matrix(m);
&gt;   Denominators := [mat[2,1],mat[2,2],mat[2,1]+mat[2,2]];
&gt;   values := [Abs(v) : v in Denominators];
&gt;   return &amp;+ContinuedFraction(frac(Sort(values)));
&gt; end function;
&gt;
&gt; procedure drawDomain(cosets)
&gt;    H&lt;i,r&gt; := UpperHalfPlaneWithCusps();
&gt;    tri := [H|Infinity(),0,r];
&gt;    cols := [[0.5,0.2*FareyValue(c),1-0.2*FareyValue(c)] : c  in cosets];
&gt;    trans := [g*tri : g in cosets];
&gt;    DisplayPolygons(trans,"/tmp/pic.ps":
&gt;        Outline := false, Colours := cols, Show := true);
&gt; end procedure;
&gt;
&gt; // Now we can use the above functions and procedure, for example
&gt; // take the cosets as follows:
&gt; C := CosetRepresentatives(Gamma0(41));     
&gt; // Then draw the picture:
&gt; drawDomain(C);
[ 0.E-28, 1.000000000000000000000000000, 1.500000000000000000000000000, 300 ]
</PRE>
<HR>
<H3><A NAME = "17503">Example <TT>GrpPSL2_more-graphics (H136E10)</TT></A></H3>
Functions are provided for drawing pictures coming from Farey symbols
and fundamental domains.  These functions provide short cuts for producing
some of the pictures in the previous examples, but are not so flexible.
<P>
<P>
<P>
<PRE>
&gt; G := CongruenceSubgroup(5);
&gt; FS := FareySymbol(G);
&gt; FS;
[ 2, 2, 7, 8, 8, 10, 9, 3, 3, 9, 4, 1, 1, 4, 5, 5, 10, 11, 11, 7, 6, 6 ]
[ oo, 0, 1/5, 2/9, 1/4, 3/11, 5/18, 2/7, 1/3, 3/8, 5/13, 2/5, 1/2, 3/5, 5/8, 2/3,
5/7, 8/11, 3/4, 7/9, 4/5, 1, oo ]
&gt; // The following command graphically displays the information contained in FS:
&gt; DisplayFareySymbolDomain(FS,"/tmp/Gamma5b.ps": Show := false);
[ 0, 1.0000, 0.50000, 800 ]
&gt; // This picture represents a modular curve with genus 0:
&gt; Genus(G);
0
</PRE>
<HR>
<H3><A NAME = "17504">Example <TT>GrpPSL2_Graphics (H136E11)</TT></A></H3>
In the following example we show how to create a postscript file and
include the resulting file in a latex file.
<P>
The example in question is &Gamma;<sub>0</sub>(37).  
A simple question is to find what is the fundamental domain, and to give
a list of inequivalent elliptic points of the group, and display this
information graphically.
First we create the group and find the information we are interested in:
<P>
<P>
<PRE>
&gt; G := Gamma0(37);
&gt; // To draw a picture of the fundamental domain we need to define 
&gt; // the upper half plane.
&gt; H&lt;i,r&gt; := UpperHalfPlaneWithCusps();
&gt; D := FundamentalDomain(G,H);
&gt; E := EllipticPoints(G,H);
</PRE>
<P>
We can now take a look at the picture:
<P>
<P>
<PRE>
&gt; // We need to make sure the polygons we want to display all
&gt; // have the same type, so we have t create the following object:
&gt; HH:=Parent(D);  
&gt; // now we make a list of polygons and points:
&gt; P1:=[HH|D] cat [HH|[e] : e in E];
&gt; // we take a look at the default picture of the situation:
&gt; DisplayPolygons(P1,"/tmp/pic.ps": Show := true);
[ 0.E-28, 1.0000, 1.5000, 300 ]  
</PRE>
<P>
The points have been displayed in yellow, the default colour, but
we'd prefer a different colour.
Also the picture is not quite the right size.  It has been
shown with the real axis shown from 0 to 1, which is reasonable,
but we'd prefer less height, and the scale 300 could be changed,
as in this example:
<P>
<P>
<PRE>
&gt; // use different colours:
&gt; yellow := [1,1,0];
&gt; red := [1,0,0];
&gt; green := [0,1,0];
&gt; cyan := [0,1,1];
&gt; black := [0,0,0];
&gt; Colours := [yellow] cat [red : e in E];
&gt; // use a different size and scale:
&gt; Size := [0,1,0.2,400];
&gt; // view the result:
&gt; DisplayPolygons(P1,"/tmp/pic.ps": 
&gt; Show := true, Colours := Colours, Size := Size);
[ 0, 1, 0.1999999999999999999999999999, 400 ]
</PRE>
After more experimenting we reach the following:
<P>
<P>
<PRE>
&gt; // We use a slightly different list of polygons, to show more
&gt; // structure.
&gt; tri := [H|Infinity(),0,H.2];          
&gt; cosets := CosetRepresentatives(G);
&gt; P := [HH|g*tri : g in cosets] cat [HH|[e] : e in E] cat [HH|D];
&gt; // Choosing some colours:
&gt; LotsOfColours := &amp;cat[[yellow,green,cyan] : c in cosets];
&gt; Colours := [LotsOfColours[i] : i in [1..#cosets]] 
&gt;            cat [black] 
&gt;            cat [red : e in E];
&gt; // choose which polygons are filled, and which have outlines:
&gt; outlines := [false : i in cosets] cat [false : i in E] cat [true];
&gt; fill := [true : i in cosets] cat [true : i in E] cat [false];
&gt; labels := Cusps(FareySymbol(G));   
&gt; // Create a file of the result:
&gt; DisplayPolygons(P,"/tmp/pic.ps":
&gt; Colours := Colours, Show := false, Size := [0,1,1,200],
&gt; Labels := labels, Outline := outlines, Fill := fill, 
&gt; Fontsize := 1, Radius := 0.3); 
[ 0, 1, 1, 200 ]
</PRE>
<P>
If we are satisfied with the resulting picture then we can include the
resulting picture in a latex file as in the following example, where we
use the Latex <TT>graphicx</TT> package to include the diagram.
<P>
<P>
<PRE>
\documentclass{article}
\usepackage[dvips]{graphicx}     
\begin{document}

Here is a picture of a 
fundamental domain for $&Gamma;_0(37)$:
$${\includegraphics{/tmp/pic.ps}}$$
In the picture we have marked $4$ inequivalent
elliptic points.
\end{document}
</PRE>
<P>
Note that currently, given a list of points to draw, the 
postscript file will include all of the points, even if they are 
not in the area of the bounding box, which can produce
bad results some times.  This should be 
changed in a future version.  Sometimes using the 
Fundamental domain function can produce results in a more
reliable way, as in the following example, which produces a
similar picture to the above, and a latex file can be
written in the same way.
<P>
<P>
<P>
<PRE>
&gt; G := Gamma0(37);
&gt; H&lt;i,r&gt; := UpperHalfPlaneWithCusps();
&gt; D := FundamentalDomain(G,H);
&gt; HH:=Parent(D);  
&gt; E := EllipticPoints(G,H);
&gt; P:=[HH|D] cat [HH|[e] : e in E];
&gt; labels := Cusps(FareySymbol(G));   
&gt; yellow := [1,1,0];
&gt; red := [1,0,0];
&gt; Colours := [yellow] cat [red : e in E];
&gt; DisplayPolygons(P,"/tmp/pic.ps":
&gt; Colours := Colours, Show := false, Size := [0,1,0.2,200],
&gt; Labels := labels, 
&gt; Fontsize := 1, Radius := 0.3); 
[ 0, 1, 0.1999999999999999999999999999, 200 ]
</PRE>
<PRE></PRE> <A  HREF = "text1550.htm">[Next]</A><A  HREF = "text1559.htm">[Prev]</A> <A  HREF = "text1550.htm">[Right]</A> <A  HREF = "text1559.htm">[Left]</A> <A  HREF = "text1551.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<br><small>Version: V2.22 of <I>
Thu Jun  9 16:37:49 EST 2016
</I></small>
</body></html>