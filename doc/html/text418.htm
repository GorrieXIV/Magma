<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <link rel='stylesheet' href='help.css' type='text/css'>
  <TITLE>Introduction</TITLE>
</head>
<body BGCOLOR="#FFFFFF">

 <A  HREF = "text416.htm">[Next]</A><A  HREF = "text417.htm">[Prev]</A> <A  HREF = "text416.htm">[Right]</A> [____] <A  HREF = "text417.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<PRE></PRE><H3><A NAME = "4307">Introduction</A></H3>

<P>
<P>
This chapter presents the facilities provided in Magma for
Dirichlet and Hecke characters, currently implemented over number fields.
For Dirichlet characters over the rationals (as <TT>FldRat</TT>),
see Section <A  HREF = "text179.htm#1432">Dirichlet Characters</A>.
<P>
The principal constructors are <TT>DirichletGroup</TT> whose
elements are functions on number field elements,
and <TT>HeckeCharacterGroup</TT> who elements are functions on ideals.
The former is the dual of the <TT>RayResidueRing</TT> of an ideal,
and the latter is the dual of the <TT>RayClassGroup</TT> of an ideal
(see Chapter <A  HREF = "text405.htm#4195">CLASS FIELD THEORY</A>).
<P>
Arithmetic on groups can be done multiplicatively, and the characters
can be evaluated at suitable field elements and ideals.
The <TT>sub</TT> constructor, along with <TT>+</TT> and <TT>meet</TT>
for subgroups on the same modulus, should also work.
<P>
The associated types are <A NAME = "GrpDrchNF"><TT>GrpDrchNF</TT></A> and <A NAME = "GrpDrchNFElt"><TT>GrpDrchNFElt</TT></A>,
<A NAME = "GrpHecke"><TT>GrpHecke</TT></A> and <A NAME = "GrpHeckeElt"><TT>GrpHeckeElt</TT></A>.
The number field must be an absolute extension of the rationals.



<H5>Subsections</H5>
<UL>
<LI> <A  HREF = "text418.htm#4308">Creation Functions</A>
<LI> <A  HREF = "text418.htm#4314">Functions on Groups and Group Elements</A>
<LI> <A  HREF = "text418.htm#4329">Predicates on Group Elements</A>
<LI> <A  HREF = "text418.htm#4336">Passing between Dirichlet and Hecke Characters</A>
<LI> <A  HREF = "text418.htm#4349">L-functions of Hecke Characters</A>
<LI> <A  HREF = "text418.htm#4351">Hecke Gr&ouml;ssencharacters and their L-functions</A>
<LI> <A  HREF = "text418.htm#4369">Local Root Numbers</A>
<LI> <A  HREF = "text418.htm#4376">Gr&ouml;ssencharacters and Elliptic Curves</A>
</UL>
<H4><A NAME = "4308">Creation Functions</A></H4>



<H5><A NAME = "4309">DirichletGroup(I) : RngOrdIdl -&gt; GrpDrchNF</A></H5>
<H5>DirichletGroup(I, oo) : RngOrdIdl, SeqEnum -&gt; GrpDrchNF</H5>
<BLOCKQUOTE>
Given an ideal I of the integer ring of the number field K
and a set of real places of K, the intrinsic <TT>DirichletGroup</TT>
will return the dual group to the <TT>RayResidueRing</TT>
of the specified information.
</BLOCKQUOTE>
<H5><A NAME = "4310">HeckeCharacterGroup(I) : RngOrdIdl -&gt; GrpHecke</A></H5>
<H5>HeckeCharacterGroup(I, oo) : RngOrdIdl, SeqEnum -&gt; GrpHecke</H5>
<BLOCKQUOTE>
Given an ideal I of the integer ring of the number field K
and a set of real places of K, the intrinsic <TT>HeckeCharacterGroup</TT>
will return the dual group to the <TT>RayClassGroup</TT>
of the specified information.
</BLOCKQUOTE>
<H5><A NAME = "4311">UnitTrivialSubgroup(G) : GrpDrchNF -&gt; GrpDrchNF</A></H5>
<BLOCKQUOTE>
Given a group of Dirichlet characters, return the subgroup that is trivial
on the image of the field units in the residue ring.
</BLOCKQUOTE>
<H5><A NAME = "4312">TotallyUnitTrivialSubgroup(G) : GrpDrchNF -&gt; GrpDrchNF</A></H5>
<BLOCKQUOTE>
Given a group of Dirichlet characters, return the subgroup that is
totally trivial on the image of the field units in the residue ring.
That is, it is trivial at each place individually.
</BLOCKQUOTE>
<H5><A NAME = "4313">HilbertCharacterSubgroup(G) : GrpHecke -&gt; GrpHecke</A></H5>
<BLOCKQUOTE>
Given a group of Hecke characters, return the subgroup corresponding
to the class group (those with trivial conductor).
</BLOCKQUOTE>
<H4><A NAME = "4314">Functions on Groups and Group Elements</A></H4>



<H5><A NAME = "4315">Modulus(G) : GrpDrchNF -&gt; RngOrdIdl, SeqEnum</A></H5>
<H5>Modulus(G) : GrpHecke -&gt; RngOrdIdl, SeqEnum</H5>
<H5>Modulus(chi) : GrpDrchNFElt -&gt; RngOrdIdl, SeqEnum</H5>
<H5>Modulus(chi) : GrpHeckeElt -&gt; RngOrdIdl, SeqEnum</H5>
<BLOCKQUOTE>
Returns the modulus ideal and a (possibly empty) sequence of real places.
</BLOCKQUOTE>
<H5><A NAME = "4316">Order(chi) : GrpDrchNFElt -&gt; RngIntElt</A></H5>
<H5>Order(psi) : GrpHeckeElt -&gt; RngIntElt</H5>
<BLOCKQUOTE>
Returns the order of a Dirichlet or Hecke character.
</BLOCKQUOTE>
<H5><A NAME = "4317">Random(G) : GrpDrchNF -&gt; GrpDrchNFElt</A></H5>
<H5>Random(G) : GrpHecke -&gt; GrpHeckeElt</H5>
<BLOCKQUOTE>
Returns a random element of a Dirichlet or Hecke group.
</BLOCKQUOTE>
<H5><A NAME = "4318">Domain(G) : GrpDrchNF -&gt; FldNum</A></H5>
<H5>Domain(G) : GrpDrchNFElt -&gt; FldNum</H5>
<BLOCKQUOTE>
Returns the number field that is the domain for the Dirichlet character.
</BLOCKQUOTE>
<H5><A NAME = "4319">Domain(G) : GrpHecke -&gt; PowIdl</A></H5>
<H5>Domain(G) : GrpHeckeElt -&gt; PowIdl</H5>
<BLOCKQUOTE>
Returns the set of ideals that is the domain for the Hecke character.
</BLOCKQUOTE>
<H5><A NAME = "4320">Decomposition(chi) : GrpDrchNFElt -&gt; List</A></H5>
<BLOCKQUOTE>
Returns a list of characters of prime power modulus (and real places)
whose product (after extension to the original <TT>DirichletGroup</TT>)
is the given Dirichlet character.
</BLOCKQUOTE>
<H5><A NAME = "4321">Components(chi) : GrpDrchNFElt -&gt; Assoc</A></H5>
<H5>Components(psi) : GrpHeckeElt -&gt; Assoc</H5>
<BLOCKQUOTE>
Given a Hecke or Dirichlet character, return its components as an associative
array of Dirichlet characters indexed by bad places. For a Hecke character,
this is the decomposition of its <TT>DirichletRestriction</TT>. Note that the
character need not be primitive.
</BLOCKQUOTE>
<H5><A NAME = "4322">Component(chi, P) : GrpDrchNFElt, RngOrdIdl -&gt; GrpDrchNFEl</A></H5>
<H5>Component(psi, P) : GrpHeckeElt, RngOrdIdl -&gt; GrpDrchNFElt</H5>
<H5>Component(chi, oo) : GrpDrchNFElt, RngIntElt -&gt; GrpDrchNFEl</H5>
<H5>Component(psi, oo) : GrpHeckeElt, RngIntElt -&gt; GrpDrchNFElt</H5>
<H5>Component(chi, P) : GrpDrchNFElt, PlcNumElt -&gt; GrpDrchNFEl</H5>
<H5>Component(psi, P) : GrpHeckeElt, PlcNumElt -&gt; GrpDrchNFElt</H5>
<BLOCKQUOTE>
Given a Dirichlet or Hecke character and a prime ideal or place
(possibly specified by an integer for an infinite place), return the
corresponding Dirichlet character component. For a place that it is
not ramified, the trivial character of the integer ring is returned.
</BLOCKQUOTE>
<H5><A NAME = "4323">Conductor(chi) : GrpDrchNFElt -&gt; RngOrdIdl, SeqEnum</A></H5>
<H5>Conductor(psi) : GrpHeckeElt -&gt; RngOrdIdl, SeqEnum</H5>
<BLOCKQUOTE>
The product of the moduli of the all nontrivial characters in the
decomposition of the given Dirichlet character, given as an ideal
and a set of real places. Similarly with Hecke characters, where, in fact,
one takes the <TT>DirichletRestriction</TT> of the Hecke character, and
decomposes this.
</BLOCKQUOTE>
<H5><A NAME = "4324">AssociatedPrimitiveCharacter(chi) : GrpDrchNFElt -&gt; GrpDrchNFElt</A></H5>
<H5>AssociatedPrimitiveCharacter(psi) : GrpHeckeElt -&gt; GrpHeckeElt</H5>
<BLOCKQUOTE>
The primitive Dirichlet character associated to the one that is given,
which can be obtained by multiplying all the nontrivial characters
in the decomposition. Similarly with Hecke characters, for which
this decomposes the <TT>DirichletRestriction</TT> to finds its underlying
primitive part, and then takes the <TT>HeckeLift</TT> of this.
</BLOCKQUOTE>
<H5><A NAME = "4325">Restrict(chi, D) : GrpDrchNFElt, GrpDrchNF -&gt; GrpDrchNFElt</A></H5>
<H5>Restrict(psi, H) : GrpHeckeElt, GrpHecke -&gt; GrpHeckeElt</H5>
<H5>Restrict(chi, I) : GrpDrchNFElt, RngOrdIdl -&gt; GrpDrchNFElt</H5>
<H5>Restrict(psi, I) : GrpHeckeElt, RngOrdIdl -&gt; GrpHeckeElt</H5>
<H5>Restrict(chi, I, oo) : GrpDrchNFElt, RngOrdIdl, SeqEnum -&gt; GrpDrchNFElt</H5>
<H5>Restrict(psi, I, oo) : GrpHeckeElt, RngOrdIdl, SeqEnum -&gt; GrpHeckeElt</H5>
<H5>Restrict(G, D) : GrpDrchNF, GrpDrchNF -&gt; GrpDrchNF</H5>
<H5>Restrict(G, H) : GrpHecke, GrpHecke -&gt; GrpHecke</H5>
<H5>Restrict(G, I) : GrpDrchNF, RngOrdIdl -&gt; GrpDrchNF</H5>
<H5>Restrict(G, I) : GrpHecke, RngOrdIdl -&gt; GrpHecke</H5>
<H5>Restrict(G, I, oo) : GrpDrchNF, RngOrdIdl, SeqEnum -&gt; GrpDrchNF</H5>
<H5>Restrict(G, I, oo) : GrpHecke, RngOrdIdl, SeqEnum -&gt; GrpHecke</H5>
<BLOCKQUOTE>
Given a Dirichlet character modulo an ideal I
and a Dirichlet character group modulo J
for which I&sube;J (including behavior at real places when specified)
with the character trivial on (J/I)<sup>star</sup>,
this returns the restricted character on J.
Similarly with Hecke characters, and with an ideal (with possible real places)
at the second argument. Also with a group of characters as the first argument.
</BLOCKQUOTE>
<H5><A NAME = "4326">TargetRestriction(G, C) : GrpDrchNF, FldCyc -&gt; GrpDrchNF</A></H5>
<H5>TargetRestriction(H, C) : GrpHecke, FldCyc -&gt; GrpDrchNF</H5>
<BLOCKQUOTE>
Given a group of Dirichlet or Hecke characters and a cyclotomic field,
return the subgroup of characters whose image is contained in the
cyclotomic field.
</BLOCKQUOTE>
<H5><A NAME = "4327">SetTargetRing(~chi, e) : GrpDrchNFElt, RngElt -&gt;</A></H5>
<H5>SetTargetRing(~psi, e) : GrpHeckeElt, RngElt -&gt;</H5>
<BLOCKQUOTE>
Given a Dirichlet or Hecke character and a suitable root of unity,
modify the character to take values according to this root of unity.
The ring element must be a root of unity, and its order must be
a multiple of the order of the character.
Writing m=(ord)(&chi;),
if the character previously had &chi;(u)=&zeta;<sub>m</sub><sup>v</sup>,
it will now have &chi;(u)=(e<sup>q</sup>)<sup>v</sup> where q is (ord)(e)/m.
</BLOCKQUOTE>
<H5><A NAME = "4328">Extend(chi, D) : GrpDrchNFElt, GrpDrchNF -&gt; GrpDrchNFElt</A></H5>
<H5>Extend(psi, H) : GrpHeckeElt, GrpHecke -&gt; GrpHeckeElt</H5>
<H5>Extend(chi, I) : GrpDrchNFElt, RngOrdIdl -&gt; GrpDrchNFElt</H5>
<H5>Extend(psi, I) : GrpHeckeElt, RngOrdIdl -&gt; GrpHeckeElt</H5>
<H5>Extend(chi, I, oo) : GrpDrchNFElt, RngOrdIdl, SeqEnum -&gt; GrpDrchNFElt</H5>
<H5>Extend(psi, I, oo) : GrpHeckeElt, RngOrdIdl, SeqEnum -&gt; GrpHeckeElt</H5>
<H5>Extend(G, D) : GrpDrchNF, GrpDrchNF -&gt; GrpDrchNF</H5>
<H5>Extend(G, H) : GrpHecke, GrpHecke -&gt; GrpHecke</H5>
<H5>Extend(G, I) : GrpDrchNF, RngOrdIdl -&gt; GrpDrchNF</H5>
<H5>Extend(G, I) : GrpHecke, RngOrdIdl -&gt; GrpHecke</H5>
<H5>Extend(G, I, oo) : GrpDrchNF, RngOrdIdl, SeqEnum -&gt; GrpDrchNF</H5>
<H5>Extend(G, I, oo) : GrpHecke, RngOrdIdl, SeqEnum -&gt; GrpHecke</H5>
<BLOCKQUOTE>
Given a Dirichlet character modulo I and a Dirichlet character group
modulo J for which J&sube;I
(again possibly including the real places),
this function returns the induced character on J, that is,
the one that is trivial on (I/J)<sup>star</sup>.
Similarly with Hecke characters, and with an ideal (with possible real places)
at the second argument. Also with a group of characters as the first argument.
</BLOCKQUOTE>
<H4><A NAME = "4329">Predicates on Group Elements</A></H4>



<H5><A NAME = "4330">IsTrivial(chi) : GrpDrchNFElt -&gt; BoolElt</A></H5>
<H5>IsTrivial(psi) : GrpHeckeElt -&gt; BoolElt</H5>
<BLOCKQUOTE>
Returns whether the given character corresponds
to the trivial element in the character group.
</BLOCKQUOTE>
<H5><A NAME = "4331">IsTrivialOnUnits(chi) : GrpDrchNFElt -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns whether a Dirichlet character is trivial on the units of the
number field; this determines whether the character can lift to a Hecke
character on the ideals.
</BLOCKQUOTE>
<H5><A NAME = "4332">IsOdd(chi) : GrpDrchNFElt -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns whether a Dirichlet character &chi; has &chi;( - 1)= - 1.
</BLOCKQUOTE>
<H5><A NAME = "4333">IsEven(chi) : GrpDrchNFElt -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns whether a Dirichlet character &chi; has &chi;( - 1)= + 1.
</BLOCKQUOTE>
<H5><A NAME = "4334">IsTotallyEven(chi) : GrpDrchNFElt -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns whether a Dirichlet character &chi; has &chi;<sub>p</sub>( - 1)= + 1
for each &chi;<sub>p</sub> in its decomposition.
</BLOCKQUOTE>
<H5><A NAME = "4335">IsPrimitive(chi) : GrpDrchNFElt -&gt; BoolElt</A></H5>
<H5>IsPrimitive(psi) : GrpHeckeElt -&gt; BoolElt</H5>
<BLOCKQUOTE>
Returns whether a Dirichlet character is primitive, that is, whether
its conductor and modulus are equal.
</BLOCKQUOTE>
<H4><A NAME = "4336">Passing between Dirichlet and Hecke Characters</A></H4>



<H5><A NAME = "4337">HeckeLift(chi) : GrpDrchNFElt -&gt; GrpHeckeElt, GrpHecke</A></H5>
<BLOCKQUOTE>
Given a Dirichlet character that is trivial on the units of the number field,
this functions returns a Hecke character that extends its domain to all
the ideals of the integer ring. Also returns a kernel, so as to span the
set of all possible lifts.
</BLOCKQUOTE>
<H5><A NAME = "4338">DirichletRestriction(psi) : GrpHeckeElt -&gt; GrpDrchNFElt</A></H5>
<BLOCKQUOTE>
Given a Hecke character on the ideals of the integer ring of a number field,
this function returns the Dirichlet restriction of it on the field elements.
</BLOCKQUOTE>
<H5><A NAME = "4339">NormInduction(K, chi) : FldNum, GrpDrchElt -&gt; GrpHeckeElt</A></H5>
<BLOCKQUOTE>
Given a Dirichlet character &chi; over the rationals (as <TT>FldRat</TT>)
induce it to a Hecke character over the number field K.
That is, find &psi; with &psi;(a)=&chi;((N)a) with &psi; primitive.
</BLOCKQUOTE>
<H5><A NAME = "4340">QuadraticCharacter(e) : FldNumElt -&gt; GrpHeckeElt</A></H5>
<BLOCKQUOTE>
Given a nonzero field element e over an absolute number field, return the
associated quadratic Hecke character (which will be trivial when e
is a square).
</BLOCKQUOTE>
<HR>
<H3><A NAME = "4341">Example <TT>Char_dirichletQ (H41E1)</TT></A></H3>
This example tries to codify the terminology via a standard example
with Dirichlet characters over the rationals. We construct various
characters modulo 5.
<P>
<P>
<P>
<PRE>
&gt; Q := NumberField(Polynomial([-1, 1]) : DoLinearExtension);
&gt; O := IntegerRing(Q);
&gt; I := 5*O;
&gt; DirichletGroup(I);
Abelian Group isomorphic to Z/4
Group of Dirichlet characters of modulus of norm 5 mapping to
 Cyclotomic Field of order 4 and degree 2
</PRE>
<P>
The above group is the Dirichlet characters modulo 5. However, the odd
characters are not characters on ideals, as they are nontrivial on the units.
To pass to the Hecke characters, we need to enlarge the modulus to consider
embeddings at the real place. Note that this will give four more characters,
corresponding to multiplying the above by the character that has
&chi; as +1 on positive elements and -1 on negative elements;
such characters will not be periodic in the traditional sense of
Dirichlet characters, but are still completely multiplicative.
<P>
<P>
<P>
<PRE>
&gt; D := DirichletGroup(I, [1]); D; // include first real place
Abelian Group isomorphic to Z/2 + Z/4
Group of Dirichlet characters D of modulus of norm 5 and infinite
places [ 1 ] mapping to Cyclotomic Field of order 4 and degree 2
&gt; [ IsTrivialOnUnits(x) : x in Elements(D) ];
[ true, false, false, true, true, false, false, true ]
&gt; HeckeLift(D.1); // non-trivial on units
Runtime error in 'HeckeLift': Character is nontrivial on the units
&gt; hl := HeckeLift(D.1 * D.2);
&gt; hl(2);
zeta_4
&gt; hl(2) eq (D.1 * D.2)(2);
true
</PRE>
<P>
So only half of the 8 completely multiplicative characters on field elements
lift to characters on ideals, and these correspond exactly the standard
four Dirichlet characters modulo 5, though evinced in a different guise.
In terms of class field theory, this can viewed as saying that the
global Artin map relates -1 to complex conjugation.
<HR>
<H3><A NAME = "4342">Example <TT>Char_simple-char-ops (H41E2)</TT></A></H3>
This example gives some basic character operations.
<P>
<P>
<P>
<PRE>
&gt; K := QuadraticField(-23);
&gt; p3 := Factorization(3*Integers(K))[1][1];
&gt; G1 := HeckeCharacterGroup(p3^1);
&gt; G2 := HeckeCharacterGroup(p3^2);
&gt; G3 := HeckeCharacterGroup(p3^3);
&gt; assert Extend(G1.1,G3) eq G3.1^9;
&gt; assert Restrict(G2.1^3,G1) eq G1.1;
&gt; assert Extend(G1.1,p3^3) eq Extend(G2.1^3,p3^3);
&gt; assert Restrict(Restrict(G3.1^3,p3^2)^3,p3) eq G1.1;
&gt; assert G1 eq HilbertCharacterSubgroup(G1);
&gt; assert Restrict(HilbertCharacterSubgroup(G2),G1) eq G1;
&gt; assert Restrict(sub&lt;G2|[G2.1^3]&gt;,p3) eq G1;
&gt; assert Extend(G2,G3) eq sub&lt;G3|[G3.1^3]&gt;;
&gt; assert Extend(G1,p3^2) eq Restrict(sub&lt;G3|[G3.1^9]&gt;,G2);
</PRE>
<P>
<P>
<P>
<PRE>
&gt; chi := KroneckerCharacter(-7);
&gt; K := QuadraticField(5);
&gt; theta := NormInduction(K,chi);
&gt; Type(theta);
GrpHeckeElt
&gt; Modulus(theta); assert IsPrimitive(theta);
Principal Prime Ideal, Generator: 7
[ 1, 2 ] // places at infinity
&gt; cbrt := Parent(theta).1;
&gt; assert cbrt^3 eq theta; // Order(cbrt) is 6
&gt; SetTargetRing(~cbrt,GF(13)!2); // choice of gen
&gt; cbrt(K.1); // now an element of GF(13)
10
&gt; DirichletRestriction(cbrt)(K.1);
-zeta_6 + 1
</PRE>
<HR>
<H5><A NAME = "4343">DirichletCharacter(I, B) : RngOrdIdl, Tup -&gt; GrpDrchNFElt, GrpDrchNF</A></H5>
<H5>DirichletCharacter(I, oo, B) : RngOrdIdl, SeqEnum, Tup -&gt; GrpDrchNFElt, GrpDrchNF</H5>
<H5>DirichletCharacter(G, B) : GrpDrchNF, Tup -&gt; GrpDrchNFElt, GrpDrchNF</H5>
<H5>DirichletCharacter(I, L) : RngOrdIdl, List -&gt; GrpDrchNFElt, GrpDrchNF</H5>
<H5>DirichletCharacter(I, oo, L) : RngOrdIdl, SeqEnum, List -&gt; GrpDrchNFElt, GrpDrchNF</H5>
<H5>DirichletCharacter(G, L) : GrpDrchNF, List -&gt; GrpDrchNFElt, GrpDrchNF</H5>
<H5>HeckeCharacter(I, B) : RngOrdIdl, Tup -&gt; GrpHeckeElt</H5>
<H5>HeckeCharacter(I, oo, B) : RngOrdIdl, SeqEnum, Tup -&gt; GrpHeckeElt</H5>
<H5>HeckeCharacter(G, B) : GrpHecke, Tup -&gt; GrpHeckeElt</H5>
<H5>HeckeCharacter(I, L) : RngOrdIdl, List -&gt; GrpHeckeElt</H5>
<H5>HeckeCharacter(I, oo, L) : RngOrdIdl, SeqEnum, List -&gt; GrpHeckeElt</H5>
<H5>HeckeCharacter(G, L) : GrpHecke, List -&gt; GrpHeckeElt</H5>

<PRE>    RequireGenerators: BoolElt          Default: <TT>true</TT></PRE>
<BLOCKQUOTE>
Given either an ideal (and also possibly a set of real infinite places)
or a <TT>DirichletGroup</TT>, and a list/tuple of 2-tuples each containing
a field element and a element of <TT>Integers(m)</TT> for some m,
construct a Dirichlet character that sends each field element to the
cyclotomic unit corresponding to the residue element.
The second member of each 2-tuple can alternatively be a
torsion element of some cyclotomic field.
<P>
The parameter <TT>RequireGenerators</TT> demands that the given field elements
should generate the <TT>RayResidueRing</TT> of the ideal.
The second return argument is a subgroup of the ambient <TT>DirichletGroup</TT>
by which the returned character can be translated and still retain
the same values on the given elements.
<P>
Similarly for <TT>HeckeCharacter</TT> -- there the first element in each 2-tuple
can now be an ideal of the field, and <TT>RequireGenerators</TT> demands that
these generate the <TT>RayClassGroup</TT> of the ideal.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "4344">Example <TT>Char_dirichlet-hecke (H41E3)</TT></A></H3>
We define a character on 5 O<sub>K</sub> that sends Sqrt( - 23) to &zeta;<sub>8</sub><sup>2</sup>
(note that Sqrt( - 23) has order 8
in the <TT>RayResidueRing</TT> to this modulus).
<P>
<P>
<P>
<PRE>
&gt; K := QuadraticField(-23);
&gt; I := 5*IntegerRing(K);
&gt; chi, SG := DirichletCharacter
&gt;           (I, &lt;&lt;K.1, Integers(8)!2&gt;&gt; : RequireGenerators := false);
&gt; chi(K.1);
zeta_4
&gt; (SG.1 * chi)(K.1);
zeta_4
</PRE>
<P>
And then we define one that sends Sqrt( - 23) to &zeta;<sub>8</sub><sup>6</sup>
and (3 + 2Sqrt( - 23)), an element of order 6 in the <TT>RayResidueRing</TT>,
to &zeta;<sub>24</sub><sup>8</sup>.
<P>
<P>
<P>
<PRE>
&gt; data := &lt;&lt;K.1, Integers(8)!6&gt;, &lt;3+2*K.1,Integers(24)!8&gt;&gt;;
&gt; chi, SG := DirichletCharacter(I, data);
&gt; chi(K.1);
-zeta_4
&gt; chi(3+2*K.1);
zeta_3
&gt; #SG; // this subgroup SG is trivial, as the data determine chi
1
</PRE>
<P>
Note that we can replace the Integers(8)!6 in the first tuple by &zeta;<sub>8</sub><sup>6</sup>.
<P>
<P>
<P>
<PRE>
&gt; C&lt;zeta8&gt; := CyclotomicField(8);
&gt; data2 := &lt;&lt;K.1, zeta8^6&gt;, &lt;3+2*K.1,Integers(24)!8&gt;&gt;;
&gt; chi2 := DirichletCharacter(I, data2);
&gt; chi eq chi2;
true
</PRE>
<P>
Now we give a example with Hecke characters over a cubic field.
We also note that the evaluation of a character (either Dirichlet or Hecke)
can be obtained in "raw" form as an element in a residue ring via the
use of the <TT>Raw</TT> parameter.
<P>
<P>
<P>
<PRE>
&gt; _&lt;x&gt; := PolynomialRing(Integers());
&gt; K&lt;s&gt; := NumberField(x^3-x^2+7*x-6); // #ClassGroup(K) is 5
&gt; I := Factorization(11*IntegerRing(K))[2][1]; // norm 121
&gt; HG := HeckeCharacterGroup(I,[1]); // has 20 elements
&gt; f3 := Factorization(3*IntegerRing(K))[1][1]; // order 10
&gt; data := &lt; &lt;f3, Integers(10)!7&gt; &gt;;
&gt; psi := HeckeCharacter(HG, data : RequireGenerators := false);
&gt; psi(f3);
-zeta_10^2
&gt; psi(f3) eq CyclotomicField(10).1^7;
true
&gt; '@'(f3,psi : Raw); // get Raw form of evaluation
14
&gt; Parent($1);
Residue class ring of integers modulo 20
&gt; f113 := Factorization(113*IntegerRing(K))[1][1]; // order 4
&gt; data2 := &lt; &lt;f113, Integers(4)!3&gt; &gt;;
&gt; psi := HeckeCharacter(HG, &lt;data[1], data2[1]&gt;);
&gt; psi(f113);
-zeta_4
</PRE>
<HR>
<H5><A NAME = "4345">CentralCharacter(chi) : GrpDrchNFElt -&gt; GrpDrchNFElt</A></H5>
<H5>CentralCharacter(psi) : GrpHeckeElt -&gt; GrpDrchNFElt</H5>
<BLOCKQUOTE>
Given a Dirichlet or Hecke character, compute its central character
down to the rationals. This is defined by computing a Dirichlet character
that is defined over Q and agrees with the given character on
a set of generators of the residue ring of the norm of the modulus of
the given character. The <TT>AssociatedPrimitiveCharacter</TT> of this
is then returned. It should have the same value as the original character
on all unramified primes (at least).
Note that the central character will always be a Dirichlet character,
as the class number of the rationals is 1.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "4346">Example <TT>Char_central-chars (H41E4)</TT></A></H3>
<P>
<P>
<PRE>
&gt; K := NumberField(Polynomial([4,3,-1,1])); // x^3-x^2+3*x+4
&gt; f7 := Factorization(7*Integers(K))[1][1];
&gt; G:= DirichletGroup(f7^2,[1]);
&gt; chi := G.1*G.2*G.3;
&gt; cc := CentralCharacter(chi); Conductor(cc);
Principal Ideal, Generator: [49] // conductor 49
[ 1 ] // infinite place
&gt; cc := CentralCharacter(chi^14); Conductor(cc);
Principal Ideal, Generator: [7] // conductor 7
[ ] // no infinite places
&gt; ////////////////
&gt; K := NumberField(Polynomial([-10,-9,-10,1]));
&gt; #ClassGroup(K); // C7 class group
7
&gt; f5 := Factorization(5*Integers(K))[1][1];
&gt; H := HeckeCharacterGroup(f5,[1]);
&gt; cc:=CentralCharacter(H.1); Conductor(cc);
Principal Prime Ideal, Generator: [5] // conductor 5
[ 1 ] // infinite place
&gt; Order(H.1), Order(cc);
28 4
&gt; IsTrivial(CentralCharacter(H.1^4));
true
</PRE>
<HR>
<H5><A NAME = "4347">DirichletCharacterOverNF(chi) : GrpDrchElt -&gt; GrpDrchNFElt</A></H5>
<H5>DirichletCharacterOverQ(chi) : GrpDrchNFElt -&gt; GrpDrchElt</H5>
<BLOCKQUOTE>
These are utility functions to pass between the two types of Dirichlet
character over Q in Magma. The first takes a Dirichlet character
over the <TT>Rationals()</TT> and returns one over the rationals as a number
field (or more precisely over the first cyclotomic field, which unlike
<TT>QNF()</TT> is unique in Magma), and the second reverses this.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "4348">Example <TT>Char_dirich-chars-over-nf-and-q (H41E5)</TT></A></H3>
<P>
<P>
<PRE>
&gt; G := DirichletGroup(16*3^2*5^2*7*11, CyclotomicField(2^6*3*5));
&gt; #G;
57600
&gt; repeat chi := Random(G); until Order(chi) eq 30;
&gt; psi := DirichletCharacterOverNF(chi);
&gt; Order(psi);
30
&gt; #Parent(psi)`supergroup;
57600
&gt; &amp;and[chi(p) eq psi(p) : p in PrimesUpTo(1000)];
true
&gt; DirichletCharacterOverQ(psi) eq chi;
true
</PRE>
<HR>
<H4><A NAME = "4349">L-functions of Hecke Characters</A></H4>

<P>
<P>
Given a primitive Hecke character &psi;,
one can define the associated L-function as
L(&psi;, s)=&prod;<sub>p</sub> bigl(1 - &psi;(p)/(N)p<sup>s</sup>bigr)<sup> - 1</sup>,
and this satisfies a functional equation whose conductor is the product
of the conductor of &psi; and the discriminant of (the integer ring)
of the number field for &psi;.


<HR>
<H3><A NAME = "4350">Example <TT>Char_lfunc-hecke (H41E6)</TT></A></H3>
<P>
<P>
<PRE>
&gt; _&lt;x&gt; := PolynomialRing(Integers());
&gt; K&lt;s&gt; := NumberField(x^5 - 2*x^4 + 2*x + 2);
&gt; I2 := Factorization( 2 * IntegerRing(K) ) [1][1]; // ideal above 2
&gt; I11 := Factorization( 11 * IntegerRing(K) ) [1][1]; // above 11
&gt; I := I2*I11; Norm(I);
22
&gt; H := HeckeCharacterGroup(I, [1]);
&gt; #H;
2
&gt; psi := H.1; IsPrimitive(psi);
false
&gt; prim := AssociatedPrimitiveCharacter(psi); Norm(Conductor(prim));
11
&gt; L := LSeries(prim);
&gt; LSetPrecision(L, 10);
&gt; LCfRequired(L); // approx with old CheckFunctionalEquation
4042
&gt; CFENew(L);
-3.492459655E-10
</PRE>
<HR>
<H4><A NAME = "4351">Hecke Gr&ouml;ssencharacters and their L-functions</A></H4>

<P>
<P>
<P>
<P>
Computations with Gr&ouml;ssencharacters and their L-functions can now be done
in Magma. These are "quasi-characters" in that their image
is not restricted to the unit circle (and 0). The implementation
in Magma handles the "algebraic" characters of this sort,
that is, those of type A<sub>0</sub>; it also requires that the field of definition
be a CM-field (an imaginary quadratic extension of a totally real field).
The methods used are described in <A  HREF = "text416.htm#bib_WatkinsGrossen">[Wat11]</A>.
<P>
The natural definition of Gr&ouml;ssencharacters would be on a coset of the
dual group of the <TT>RayResidueRing</TT> extended by the <TT>ClassGroup</TT>,
without any modding out by units (which gives the <TT>RayClassGroup</TT>).
However, the Magma implementation uses a Hecke character combined with
an auxiliary Dirichlet character to simulate this.
Arithmetic with Gr&ouml;ssencharacters is also possible,
even though there is no underlying group structure.
However, equality with Gr&ouml;ssencharacters is not implemented
(one needs to check that various class group representatives
are compatible, etc.).


<H5><A NAME = "4352">Grossencharacter(psi, chi, T) : GrpHeckeElt, GrpDrchNFElt, SeqEnum -&gt; GrossenChar</A></H5>
<H5>RawEval(I, GR) : RngOrdFracIdl, GrossenChar -&gt; FldNumElt, FldCycElt, FldCycElt</H5>
<BLOCKQUOTE>
Given a Hecke character &psi; and a Dirichlet character &chi;
(of the same modulus) and a compatible &infin;-type T
return the associated Gr&ouml;ssencharacter.
<P>
The &infin;-type is a sequence of pairs of integers
which correspond to embeddings, such that
&psi;bigl((&alpha;)bigr)=
&prod;<sub>i=1</sub><sup>#T</sup> (&alpha;<sup>&sigma;<sub>i</sub></sup>)<sup>T[i][1]</sup>
(bar&alpha;<sup>&sigma;<sub>i</sub></sup>)<sup>T[i][2]</sup>
for all &alpha; that are congruent to 1 modulo the modulus of &psi;.
For a Gr&ouml;ssencharacter to exist it follows
that the &infin;-type must trivialise all
(totally positive) units that are congruent to 1 modulo the modulus of &psi;.
Each pair in T must have the same sum.
<P>
The Dirichlet character &chi; must correspond to the action on the
image of the <TT>UnitGroup</TT> in the <TT>RayResidueRing</TT> of the modulus
(note that <A  HREF = "text416.htm#bib_WatkinsGrossen">[Wat11, S5.2]</A> makes the reciprocal choice).
In particular, for every unit u we must have that
&chi;(u)=
&prod;<sub>i=1</sub><sup>#T</sup> (u<sup>&sigma;<sub>i</sub></sup>)<sup>T[i][1]</sup>(bar u<sup>&sigma;<sub>i</sub></sup>)<sup>T[i][2]</sup>,
and since the &infin;-type is multiplicative, we need only check this
on generators of the units.
<P>
Evaluating a Gr&ouml;ssencharacter returns a complex number,
corresponding to some choice of internal embeddings.
The use of <TT>RawEval</TT> on an ideal will return an element
in an extension of the field K (to which the &infin;-type is then applied)
and two elements in cyclotomic fields,
corresponding to evaluations for &chi; and &psi; respectively.
</BLOCKQUOTE>
<H5><A NAME = "4353">Grossencharacter(psi, T) : GrpHeckeElt, SeqEnum -&gt; GrossenChar</A></H5>
<BLOCKQUOTE>
Same as above, but Magma will try to compute a compatible Dirichlet
character &chi; for the given data. If there is more than one possibility,
an arbitrary choice could be made.
</BLOCKQUOTE>
<H5><A NAME = "4354">Conductor(GR) : GrossenChar -&gt; RngOrdIdl, SeqEnum</A></H5>
<H5>Modulus(GR) : GrossenChar -&gt; RngOrdIdl, SeqEnum</H5>
<H5>IsPrimitive(GR) : GrossenChar -&gt; BoolElt</H5>
<H5>AssociatedPrimitiveGrossencharacter(psi) : GrossenChar -&gt; GrossenChar</H5>
<BLOCKQUOTE>
The conductor of the Gr&ouml;ssencharacter is the conductor of the quotient
of the <TT>DirichletRestriction</TT> of the Hecke part divided by its
Dirichlet part
A Gr&ouml;ssencharacter is primitive if its modulus is the same as the conductor.
When taking L-functions, as before the conductor is multiplied by the
discriminant of the integer ring of the field.
</BLOCKQUOTE>
<H5><A NAME = "4355">Components(GR) : GrossenChar -&gt; Assoc</A></H5>
<BLOCKQUOTE>
Given a Gr&ouml;ssencharacter, return the components of its Hecke part
divided by the reciprocal of its Dirichlet part.
</BLOCKQUOTE>
<H5><A NAME = "4356">Component(GR, P) : GrossenChar, RngOrdIdl -&gt; GrpDrchNFEl</A></H5>
<H5>Component(GR, oo) : GrossenChar, RngIntElt -&gt; GrpDrchNFEl</H5>
<H5>Component(GR, P) : GrossenChar, PlcNumElt -&gt; GrpDrchNFEl</H5>
<BLOCKQUOTE>
Given a Gr&ouml;ssencharacter and a prime ideal or place
(possibly specified by an integer for an infinite place), return the
corresponding Dirichlet character component. For a place that it is
not ramified, the trivial character of the integer ring is returned.
</BLOCKQUOTE>
<H5><A NAME = "4357">Extend(GR, I) : GrossenChar, RngOrdIdl -&gt; GrossenChar</A></H5>
<H5>Restrict(GR, I) : GrossenChar, RngOrdIdl -&gt; GrossenChar</H5>
<BLOCKQUOTE>
Extension and restriction of a Gr&ouml;ssencharacter. Note that the second
argument is an ideal, unlike the Dirichlet/Hecke cases, where it is
a group of characters.
</BLOCKQUOTE>
<H5><A NAME = "4358">CentralCharacter(GR) : GrossenChar -&gt; GrpDrchNFElt</A></H5>
<BLOCKQUOTE>
Compute the central character (down to Q) of a Gr&ouml;ssencharacter,
normalizing the result to be weight 0, and returning it
as a Dirichlet character (over Q as a number field).
</BLOCKQUOTE>
<H5><A NAME = "4359">GrossenTwist(GR, D) : GrossenChar, List -&gt; GrossenChar, GrpHecke</A></H5>

<PRE>    Hilbert: BoolElt                    Default: <TT>false</TT></PRE>
<BLOCKQUOTE>
Given a Grossencharacter Y and a list D of tuples &lt; a, r &gt;,
find a twist &Psi; of Y (by a Hecke character of the same modulus as Y)
such that &Psi;(a)=r for all data tuples.
This operates by dividing the given r-values by the evaluations of Y
at the given ideals, and using <TT>HeckeCharacter</TT> on the resulting
cyclotomic data. The intrinsic also returns a group of Hecke characters
that corresponds to a kernel. The given values r should be coercible
into the complex numbers, and a numerical matching is made.
The a should be ideals or field elements.
The <TT>Hilbert</TT> parameter restricts to twisting by characters of trivial modulus.
</BLOCKQUOTE>
<H5><A NAME = "4360">TateTwist(GR, n) : GrossenChar, RngIntElt -&gt; GrossenChar</A></H5>
<H5>TateTwist(psi, n) : GrpHeckeElt, RngIntElt -&gt; GrossenChar</H5>
<BLOCKQUOTE>
Given a Grossencharacter or a Hecke character, return its Tate twist as
a Grossencharacter. Note that the field need not be CM in the latter case.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "4361">Example <TT>Char_grossenchar-gaussian (H41E7)</TT></A></H3>
First, an example of [1, 0]-type Gr&ouml;ssencharacters
on the Gaussian field, with modulus p<sub>2</sub><sup>3</sup> where p<sub>2</sub>
is the (ramified) prime above 2. This induces the L-function
for the congruent number curve.
<P>
<P>
<P>
<PRE>
&gt; K&lt;i&gt; := QuadraticField(-1);
&gt; I := (1+i)^3*IntegerRing(K);
&gt; HG := HeckeCharacterGroup(I, []);
&gt; DG := DirichletGroup(I, []); #DG;
4
&gt; GR := Grossencharacter(HG.0, DG.1^3, [[1,0]]);
&gt; L := LSeries(GR); CFENew(L);
1.57772181044202361082345713057E-30
&gt; CentralValue(L);
0.655514388573029952616209897475
&gt; CentralValue(LSeries(EllipticCurve("32a")));
0.655514388573029952616209897473
</PRE>
<HR>
<H3><A NAME = "4362">Example <TT>Char_grossenchar-sqrt23 (H41E8)</TT></A></H3>
An example with the canonical Gr&ouml;ssencharacter for K=Q(Sqrt( - 23)).
The ramification here is only at the prime above 23.
<P>
<P>
<P>
<PRE>
&gt; K&lt;s&gt; := QuadraticField(-23);
&gt; I := Factorization(23*IntegerRing(K))[1][1]; // ramified place
&gt; HG := HeckeCharacterGroup(I, []);
&gt; DG := DirichletGroup(I, []); #DG;
22
&gt; GR := Grossencharacter(HG.0, DG.1^11, [[1,0]]); // canonical character
&gt; CFENew(LSeries(GR));
4.73316543132607083247037139170E-30
&gt; H := K`extension_field; H; // defined by internal code
Number Field with defining polynomial y^3 + 1/2*(s + 3) over K
</PRE>
<P>
The values of the Gr&ouml;ssencharacter are in the given field extension of K.
We can also twist the Gr&ouml;ssencharacter by a Hecke character on I,
either via the <TT>Grossencharacter</TT> intrinsic, or by direct multiplication.
<P>
<P>
<P>
<PRE>
&gt; i2 :=  Factorization(2*IntegerRing(K))[1][1]; // ideal of norm 2
&gt; (GR*HG.1)(i2); // evaluation at i2
-0.140157638956246665944180&equiv;20 - 1.40725116316960648195556086783*i
&gt; GR2 := Grossencharacter(HG.1, DG.1^11, [[1,0]]); // psi over zeta_11
&gt; GR2(i2);
-0.140157638956246665944180&equiv;20 - 1.40725116316960648195556086783*i
&gt; RawEval(i2,GR2);  // first value is in the cubic extension of K
H.1
1
zeta_33^4
&gt; CFENew(LSeries(GR2));
-7.09974814698910624870555708755E-30
</PRE>
<HR>
<H3><A NAME = "4363">Example <TT>Char_grossenchar-symcubed-sqrt59 (H41E9)</TT></A></H3>
An example from Fernando Rodriguez Villegas
where the Gr&ouml;ssencharacter yields an L-function
with even functional equation, but vanishing central value.
This is the cube of the canonical character on (Q)(Sqrt( - 59)),
which has class number 3. The L-function can be alternatively
realised from a weight 4 modular form of level 59<sup>2</sup>.
<P>
<P>
<P>
<PRE>
&gt; K := QuadraticField(-59);
&gt; I := Factorization(59*IntegerRing(K))[1][1];
&gt; H := HeckeCharacterGroup(I);
&gt; DG := DirichletGroup(I);
&gt; GR := Grossencharacter(H.0, DG.1^29, [[3,0]]); // cube of canonical char
&gt; L := LSeries(GR);
&gt; CFENew(L);
0.000000000000000000000000000000
&gt; Sign(L);
1.00000000000000000000000000000
&gt; CentralValue(L);
3.51858026759864075475017925650E-30
&gt; LSetPrecision(L, 9);
&gt; LTaylor(L, 2, 3); // first 3 terms of Taylor series about s=2
-1.09144041E-12 + 9.82515510E-11*z + 2.87637101*z^2 - 7.65817878*z^3 + ...
</PRE>
<P>
The same Gr&ouml;ssencharacter can be obtained from cubing the
canonical character (of type [1, 0]).
<P>
<P>
<P>
<PRE>
&gt; GR3 := Grossencharacter(H.0, DG.1^29, [[1,0]])^3;
&gt; CentralValue(LSeries(GR3));
3.51858026759864075475017925650E-30
</PRE>
<HR>
<H3><A NAME = "4364">Example <TT>Char_grossen-char-cyclo5 (H41E10)</TT></A></H3>
<P>
An example with (Q)(&zeta;<sub>5</sub>), comparing the central value to the
periods derived from &Gamma;-values.
<P>
<P>
<P>
<PRE>
&gt; _&lt;x&gt; := PolynomialRing(Rationals());
&gt; K&lt;z5&gt; := NumberField(x^4+x^3+x^2+x+1);
&gt; p5 := Factorization(5*IntegerRing(K))[1][1]; // ramified prime above 5
&gt; H := HeckeCharacterGroup(p5^2);
&gt; DG := DirichletGroup(p5^2);  // need p5^2 to get chi with this oo-type
&gt; chi := DG.1^2*DG.2; // could alternatively have Magma compute this
&gt; GR := Grossencharacter(H.0, chi, [[3,0],[1,2]]);
</PRE>
<P>
We can compute that this &infin;-type sends &zeta;<sub>5</sub>
to (&zeta;<sub>5</sub><sup>1</sup>)<sup>3</sup>.(&zeta;<sub>5</sub><sup>4</sup>)<sup>0</sup>.(&zeta;<sub>5</sub><sup>2</sup>)<sup>1</sup>.(&zeta;<sub>5</sub><sup>3</sup>)<sup>2</sup>=&zeta;<sub>5</sub><sup>11</sup>
under the default embedding, and thus the ideal needs
to afford a character of order 5 for a Gr&ouml;ssencharacter to exist.
<P>
<P>
<P>
<PRE>
&gt; L := LSeries(GR);
&gt; LSeriesData(L); // Conductor is Norm(p5^2) * disc(K) = 5^2 * 5^3
&lt;4, [ 0, -1, 1, 0 ], 3125, ... &gt;;
&gt; CFENew(L); // functional equation works
0.000000000000000000000000000000
&gt; CentralValue(L); // same as Evaluate(L,2)
1.25684568045898366613593980559
&gt; Gamma(1/5)^3 * Gamma(2/5)^3 / Gamma(3/5)^2 / Gamma(4/5)^2 / 5^(7/2);
1.25684568045898366613593980558
</PRE>
<P>
The [[3, 0], [2, 1]] &infin;-type sends &zeta;<sub>5</sub>
to &zeta;<sub>5</sub><sup>3 + 0 + 2.2 + 3</sup>=1, but we still need p<sub>5</sub>
in the modulus to trivialise the units of infinite order.
<P>
<P>
<P>
<PRE>
&gt; H := HeckeCharacterGroup( 1 * IntegerRing(K)); // try conductor 1
&gt; GR := Grossencharacter(H.0, [[3,0],[2,1]]);
Runtime error in 'Grossencharacter':
oo-type should be trivial on all totally positive units that are 1 mod I
Fails for -zeta_5^2 - 1 which gives -1.000000000 - 3.293785801E-101*$.1
&gt; H := HeckeCharacterGroup(p5); // conductor of norm 5
&gt; GR := Grossencharacter(H.0, [[3,0],[2,1]]); // finds a character
&gt; L := LSeries(GR);
&gt; PI := Pi(RealField());
&gt; CentralValue(L); // now recognise as a product via logs and LLL
0.749859246433372123005585683300
&gt; A := [ Gamma(1/5), Gamma(2/5), Gamma(3/5), Gamma(4/5), 5, PI, $1 ];
&gt; LOGS := [ ComplexField() ! Log(x) : x in A ];
&gt; IntegerRelation(LOGS);
[ -14, 2, -2, 14, 15, -4, 4 ]
</PRE>
<HR>
<H3><A NAME = "4365">Example <TT>Char_grossenchar-embedding (H41E11)</TT></A></H3>
Twisting a Gr&ouml;ssencharacter by a Hilbert character
is equivalent to changing the embedding.
<P>
<P>
<P>
<PRE>
&gt; K := QuadraticField(-39);
&gt; I := 39*IntegerRing(K);
&gt; F := &amp;*[f[1] : f in Factorization(I)]; // ideal of norm 39
&gt; H := HeckeCharacterGroup(F); H;
Abelian Group isomorphic to Z/4 + Z/12 given as Z/4 + Z/12
&gt; Norm(Conductor(H.1)); // H.1 is a Hilbert character of norm 1
1
&gt; GR := Grossencharacter(H.0, [[3,0]]); // third power
</PRE>
<P>
There are four Hilbert characters here (from the class group of K),
and we twist the Gr&ouml;ssencharacter by each.
<P>
<P>
<P>
<PRE>
&gt; L0 := LSeries(AssociatedPrimitiveGrossencharacter(GR));
&gt; L1 := LSeries(AssociatedPrimitiveGrossencharacter(GR*H.1));
&gt; L2 := LSeries(AssociatedPrimitiveGrossencharacter(GR*H.1^2));
&gt; L3 := LSeries(AssociatedPrimitiveGrossencharacter(GR*H.1^3));
&gt; Ls := [ L0, L1, L2, L3 ]; for L in Ls do LSetPrecision(L, 10); end for;
&gt; for L in Ls do [CentralValue(L), Sign(L)]; end for;
[ 1.335826177, 1.000000000 + 2.706585223E-10*i ]
[ -1.373433032*i, -0.9999999999 - 6.351223882E-11*i ]
[ 1.335826177, 1.000000000 - 2.706585223E-10*i ]
[ 1.373433032*i, -0.9999999999 + 6.351223882E-11*i ]
</PRE>
<P>
The embedding information is stored internally in <TT>K'Hip</TT>,
and we modify this directly to get the same L-values via a different method.
<P>
<P>
<P>
<PRE>
&gt; K`Hip; // extension of infinite place of K
[ [ 1, 1 ] place at infinity ]
&gt; IP := InfinitePlaces(K`extension_field); IP;
[ [ 1, 1 ] place at infinity, [ 1, 2 ] place at infinity,
  [ 1, 3 ] place at infinity, [ 1, 4 ] place at infinity ]
&gt; for ip in IP do K`Hip := [ ip ]; // change ip, but use same GR
&gt;        L := LSeries(AssociatedPrimitiveGrossencharacter(GR));
&gt;        LSetPrecision(L, 10); [CentralValue(L), Sign(L)]; end for;
[ 1.335826177, 1.000000000 - 2.706585223E-10*i ]
[ 1.373433032*i, -0.9999999999 + 6.351223882E-11*i ]
[ 1.335826177, 1.000000000 - 2.706585223E-10*i ]
[ -1.373433032*i, -0.9999999999 - 6.351223882E-11*i ]
</PRE>
<P>
Finally, we can note that all the Hilbert characters have
sign +1 in their functional equations, though
two of the twists of the Gr&ouml;ssencharacter have sign -1.
<P>
<P>
<P>
<PRE>
&gt; Ls := [ LSeries(AssociatedPrimitiveCharacter(H.1^k)) : k in [1..4] ];
&gt; [ Sign(L) where _:=CFENew(L) : L in Ls ]; // force Sign computation
[ 0.999999999999999999999999999997, 1.00000000000000000000000000000,
  0.999999999999999999999999999997, 1.00000000000000000000000000000 ]
</PRE>
<HR>
<H3><A NAME = "4366">Example <TT>Char_grossen-large-gamma (H41E12)</TT></A></H3>
A final example with characters of trivial conductor,
here of type [2, 0] in (Q)(Sqrt( - 23)).
<P>
<P>
<P>
<PRE>
&gt; K&lt;s&gt; := QuadraticField(-23); // class number 3
&gt; I := 1*IntegerRing(K);
&gt; HG := HeckeCharacterGroup(I, []);
&gt; GR := Grossencharacter(HG.0, [[2,0]]); // of oo-type (2,0)
&gt; Evaluate(LSeries(GR), 2); // value at edge of critical strip
1.23819100212426040400794384795
&gt; Evaluate(LSeries(GR*HG.1), 2); // twist by nontrivial Hecke char
0.670337208665839403747922477469
&gt; Evaluate(LSeries(GR*HG.1^2), 2);
1.06110583266449728309907405960
</PRE>
<P>
The product of these three L-values should be related
to values of the &Gamma;-function at k/23 for integral k.
(One could alternatively relate these L-values to periods
of an elliptic curve over the Hilbert class field of K
having ramification only above 23.)
<P>
<P>
<P>
<PRE>
&gt; SetDefaultRealFieldPrecision(100);
&gt; e1 := Evaluate(LSeries(GR : Precision:=100), 2);
&gt; e2 := Evaluate(LSeries(GR*HG.1 : Precision:=100), 2);
&gt; e3 := Evaluate(LSeries(GR*HG.1^2 : Precision:=100), 2);
&gt; GAMMA := [Gamma(i/23) : i in [1..22]];
&gt; A := GAMMA cat [3,23,Pi(RealField())] cat [e1,e2,e3];
&gt; LOGS := [ComplexField()!Log(x) : x in A];
&gt; IntegerRelation(LOGS);
[ 2,  2,  2,  2, -2,  2, -2,  2,  2, -2, -2,
  2,  2, -2, -2,  2, -2,  2, -2, -2, -2, -2,
 -2, -7,  6, -2, -2, -2 ]
&gt; &amp;*[ GAMMA[i]^(2*(DirichletGroup(23).1)(i)) : i in [1..22] ];
24723927.96264290790447830542942451626433185347196157309315591128
&gt; 3^2 * 23^7 / Pi(RealField())^6 * (e1*e2*e3)^2;
24723927.96264290790447830542942451626433185347196157309315591128
</PRE>
<HR>
<H3><A NAME = "4367">Example <TT>Char_grossen-cyclo8 (H41E13)</TT></A></H3>
An example from <A  HREF = "text416.htm#bib_geemen-straten">[vGvS93, S8.8]</A>.
Here the Gr&ouml;ssencharacter is on an ideal of norm 2<sup>4</sup>
in the cyclotomic field (Q)(&zeta;<sub>8</sub>). The Euler factors
will factor in various fields. In Table 7.6 of the cited paper, one
notes that the coefficients satisfy a<sub>17</sub>= - 180 and a<sub>17<sup>2</sup></sub>=15878.
<P>
<P>
<P>
<PRE>
&gt; Q&lt;z8&gt; := CyclotomicField(8);
&gt; p2 := Factorization(2*Integers(Q))[1][1];
&gt; G := HeckeCharacterGroup(p2^4);
&gt; psi := G.0; // trivial
&gt; GR := Grossencharacter(psi, [[3,0],[1,2]]);
&gt; L:=LSeries(GR);
&gt; CFENew(L);
6.31088724176809444329382852226E-30
&gt; Factorization(EulerFactor(L,7 : Integral)); // p is 7 mod 8
[ &lt;343*x^2 + 1, 2&gt; ]
&gt; K&lt;s2&gt; := QuadraticField(-2);
&gt; _&lt;t&gt; := PolynomialRing(K);
&gt; Factorization(EulerFactor(L,3 : Integral),K); // 3 mod 8
[ &lt;t^2 + 1/81*(-2*s2 - 1), 1&gt;, &lt;t^2 + 1/81*(2*s2 - 1), 1&gt; ]
&gt; K&lt;i&gt; := QuadraticField(-1);
&gt; _&lt;t&gt; := PolynomialRing(K);
&gt; Factorization(EulerFactor(L,5 : Integral),K); // 5 mod 8
[ &lt;t^2 + 1/3125*(-24*i + 7), 1&gt;, &lt;t^2 + 1/3125*(24*i + 7), 1&gt; ]
&gt; EulerFactor(L,17 : Integral); // -180 and 15878 as desired
24137569*x^4 - 884340*x^3 + 15878*x^2 - 180*x + 1
</PRE>
<HR>
<H3><A NAME = "4368">Example <TT>Char_hypgeom-mot (H41E14)</TT></A></H3>
This examples exhibits the use of <TT>GrossenTwist</TT>, and links a
Gr&ouml;ssencharacter to a hypergeometric datum. The chosen t-value
is such that the degree 3 L-function is imprimitive, and it splits
as L(&chi;<sub>12</sub>, s + 1)L(&Psi;, s), where &Psi; is defined over
(Q)(Sqrt( - 84)), and has trivial modulus and [2, 0] &infin;-type;
there are still four such characters (the class number is 4), and we want
the one with &Psi;(tenfrak p<sub>2</sub>)=2 and &Psi;(tenfrak p<sub>3</sub>)= - 3.
We then check the degree 3 Euler factors on all good primes up to 100.
<P>
<P>
<P>
<PRE>
&gt; P := PrimesInInterval(5,100);
&gt; H := HypergeometricData([2,3],[1,6]);
&gt; t := -27;
&gt; ZT := Translate(LSeries(KroneckerCharacter(12)),1);
&gt; K := QuadraticField(-84);
&gt; DATA2 := &lt;Factorization(2*Integers(K))[1][1],2&gt;;
&gt; DATA3 := &lt;Factorization(3*Integers(K))[1][1],-3&gt;;
&gt; G := HeckeCharacterGroup(1*Integers(K));
&gt; GR := Grossencharacter(G.0,[[2,0]]);
&gt; LGR := LSeries(GrossenTwist(GR,[* DATA2, DATA3 *]));
&gt; PROD := LGR*ZT;
&gt; assert &amp;and[EulerFactor(PROD,p : Integral) eq
&gt;     EulerFactor(H,t,p) : p in P];
</PRE>
<P>
And another (simpler) example of GrossenTwist.
<P>
<P>
<P>
<PRE>
&gt; K := QuadraticField(-1);
&gt; H := HeckeCharacterGroup(7*Integers(K));
&gt; psi := H.1; // order 12
&gt; GR := Grossencharacter(psi,[[1,0]]);
&gt; TW := GR*psi^7;
&gt; P := PrimesUpTo(100,K);
&gt; D :=[* &lt;p,TW(p)&gt; : p in P | Gcd(14,Norm(p)) eq 1 *];
&gt; assert GrossenTwist(GR,D) eq TW;
</PRE>
<HR>
<H4><A NAME = "4369">Local Root Numbers</A></H4>

<P>
<P>
One can also compute the local root numbers of Hecke characters and
Gr&ouml;ssencharacters, at prime ideals over the field of definition,
and at places at infinity. Multiplying these together gives the global
root number.


<H5><A NAME = "4370">RootNumber(GR, P) : GrossenChar, RngOrgIdl -&gt; FldComElt</A></H5>
<H5>RootNumber(psi, P) : GrpHeckeElt, RngOrgIdl -&gt; FldComElt</H5>
<H5>RootNumber(GR, p) : GrossenChar, PlcNumElt -&gt; FldComElt</H5>
<H5>RootNumber(psi, p) : GrpHeckeElt, PlcNumElt -&gt; FldComElt</H5>

<PRE>    Precision: RngIntElt                Default: </PRE>
<BLOCKQUOTE>
Given a Hecke character or Gr&ouml;ssencharacter and a place or a prime ideal,
return the local root number as a complex number.
</BLOCKQUOTE>
<H5><A NAME = "4371">RootNumber(GR, p) : GrossenChar, RngIntElt -&gt; FldComElt</A></H5>
<H5>RootNumber(psi, p) : GrpHeckeElt, RngIntElt -&gt; FldComElt</H5>

<PRE>    Precision: RngIntElt                Default: </PRE>
<BLOCKQUOTE>
Given a Hecke character or Gr&ouml;ssencharcter and a rational prime p,
compute the (induced) root number at p.
</BLOCKQUOTE>
<H5><A NAME = "4372">RootNumbers(GR) : GrossenChar -&gt; SeqEnum</A></H5>
<H5>RootNumbers(psi) : GrossenChar -&gt; SeqEnum</H5>

<PRE>    Precision: RngIntElt                Default: </PRE>
<BLOCKQUOTE>
Given a Hecke character or Gr&ouml;ssencharacter, return the local root
numbers at bad places (including infinite ones) as an array of tuples
with places and complex approximations given.
</BLOCKQUOTE>
<H5><A NAME = "4373">RootNumber(GR) : GrossenChar -&gt; SeqEnum</A></H5>
<H5>RootNumber(psi) : GrossenChar -&gt; SeqEnum</H5>

<PRE>    Precision: RngIntElt                Default: </PRE>
<BLOCKQUOTE>
Given a Hecke character or Gr&ouml;ssencharacter, return the global root number.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "4374">Example <TT>Char_rootno-27a (H41E15)</TT></A></H3>
<P>
We compute the local root numbers of the Gr&ouml;ssencharacter
over (Q)(Sqrt( - 3)) for the elliptic curve 27a, and some
of its powers.
<P>
<P>
<P>
<PRE>
&gt; G := Grossencharacter(EllipticCurve("27a")); G;
Grossencharacter G of type [[ 1, 0 ]] for Hecke-Dirichlet pair
(1,$.1*$.2^2) with modulus of norm 9 over Quadratic Field x^2 + 3
&gt; K := NumberField(Order(Modulus(G)));
&gt; I := Ideal(Decomposition(K,3)[1][1]);
&gt; RootNumber(G,I);
6.80316131261355894597927551960E-31 + 1.00000000000000000000000000000*i
&gt; RootNumber(G,InfinitePlaces(K)[1]);
-1.00000000000000000000000000000*i
&gt; RootNumber(G); // product of the two previous
1.00000000000000000000000000000 - 6.80316131261355894597927551960E-31*i
&gt; // over Q, the root numbers get induced to -1 and -1
&gt; RootNumber(G,3); // at the rational prime 3
-1.00000000000000000000000000000 + 6.80316131261355894597927551960E-31*i
&gt; RootNumber(HodgeStructure(G)); // at oo
-1
&gt; for k in [1..12] do k,Real(RootNumber(G^k)); end for;
1 1.00000000000000000000000000000
2 1.00000000000000000000000000000
3 1.00000000000000000000000000000
4 1.00000000000000000000000000000
5 -1.00000000000000000000000000000
6 1.00000000000000000000000000000
7 1.00000000000000000000000000000
8 1.00000000000000000000000000000
9 -1.00000000000000000000000000000
10 1.00000000000000000000000000000
11 -1.00000000000000000000000000000
12 1.00000000000000000000000000000
</PRE>
<HR>
<H3><A NAME = "4375">Example <TT>Char_rohrlich-rootno (H41E16)</TT></A></H3>
<P>
This example comes from Exercise 5.5 in Rohrlich's PCMI lectures
<A  HREF = "text416.htm#bib_rohrlich-PCMI">[Roh]</A>.
<P>
We take the Gr&ouml;ssencharacter corresponding to the elliptic curve 49a,
and then twist it over (Q)(Sqrt( - 7)) by -118 - 18Sqrt( - 7).
This disturbs the root number and the resulting L-function is no
longer self dual, but it still vanishes at the central point.
<P>
<P>
<P>
<PRE>
&gt; GR := Grossencharacter(EllipticCurve("49a"));
&gt; K := NumberField(Order(Modulus(GR))); K; // ensure same field
Quadratic Field with defining polynomial x^2 + 7 over the Rational Field
&gt; psi := QuadraticCharacter(-118-18*K.1);
&gt; RootNumber(GR);
1.00000000000000000000000000000 + 1.04356488711804586030321101838E-30*i
&gt; RootNumber(psi);
1.00000000000000000000000000000 - 3.55311676760811128464401934867E-32*i
&gt; RootNumber(GR*psi);
0.943041920192897214648941373352 - 0.332673919565230241738496249562*i
&gt; L := LSeries(GR*psi);
&gt; CentralValue(L); // zero
2.91343312836088675607917006164E-30
&gt; Sign(L); // root of 253*x^4 - 394*x^2 + 253
0.943041920192897214648941373361 - 0.332673919565230241738496249560*i
</PRE>
<HR>
<H4><A NAME = "4376">Gr&ouml;ssencharacters and Elliptic Curves</A></H4>

<P>
<P>
There are also functions that transform between elliptic curves over Q
that have complex multiplication (over an imaginary quadratic field), and
Gr&ouml;ssencharacters associated to them.


<H5><A NAME = "4377">Grossencharacter(E) : CrvEll -&gt; GrossenChar</A></H5>
<BLOCKQUOTE>
Given an elliptic curve over Q with complex multiplication by
an imaginary quadratic order, return the associated Gr&ouml;ssencharacter.
</BLOCKQUOTE>
<H5><A NAME = "4378">EllipticCurve(GR) : GrossenChar -&gt; CrvEll</A></H5>
<BLOCKQUOTE>
Given a suitable Gr&ouml;ssencharacter, in particular of &infin;-type [1, 0]
over an imaginary quadratic field, with the underlying character of order 2,
return an elliptic curve in the associated isogeny class.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "4379">Example <TT>Char_grossenchar-and-ec (H41E17)</TT></A></H3>
<P>
<P>
<P>
<PRE>
&gt; E := EllipticCurve("49a"); // cm by -7
&gt; G := Grossencharacter(QuadraticTwist(E,5*29));
&gt; Conductor(QuadraticTwist(EllipticCurve(G),5*29));
49
&gt; //
&gt; E := EllipticCurve([2^2 * 3 * 5^3 * 7 * 11^2 * 13^3, 0]);
&gt; G := Grossencharacter(E);
&gt; assert IsIsogenous(E,EllipticCurve(G));
&gt; //
&gt; E := EllipticCurve([0, 2 * 3^5 * 5^3 * 7^4 * 11^2 * 13^5]);
&gt; G := Grossencharacter(E);
&gt; assert IsIsogenous(E,EllipticCurve(G));
&gt; //
&gt; K := QuadraticField(-163);
&gt; p := Factorization(163*Integers(K))[1][1];
&gt; psi := HeckeCharacterGroup(p).0;
&gt; G := Grossencharacter(psi,[[1,0]]);
&gt; E := EllipticCurve(G);
&gt; b, cm := HasComplexMultiplication(E);
&gt; assert b; assert cm eq -163;
&gt; Conductor(E);
26569
</PRE>
<PRE></PRE> <A  HREF = "text416.htm">[Next]</A><A  HREF = "text417.htm">[Prev]</A> <A  HREF = "text416.htm">[Right]</A> [____] <A  HREF = "text417.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<br><small>Version: V2.22 of <I>
Thu Jun  9 16:37:49 EST 2016
</I></small>
</body></html>