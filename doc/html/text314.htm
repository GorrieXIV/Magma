<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <link rel='stylesheet' href='help.css' type='text/css'>
  <TITLE>Theta Series as Modular Forms</TITLE>
</head>
<body BGCOLOR="#FFFFFF">

 <A  HREF = "text315.htm">[Next]</A><A  HREF = "text313.htm">[Prev]</A> <A  HREF = "text315.htm">[Right]</A> <A  HREF = "text313.htm">[Left]</A> <A  HREF = "text305.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<PRE></PRE><H3><A NAME = "3018">Theta Series as Modular Forms</A></H3>

<P>
<P>
The theta series of an integral lattice L is (the q-expansion of) 
a modular form whose weight is half the dimension of the lattice, 
and whose level and nebentypus are determined by the quotient L^# /L.
The space of forms with given weight, level and character is finite dimensional, 
which means the theta series is uniquely characterised as an element 
of that space from knowledge of finitely many of its coefficients. 
<P>
The routine described below carries this out explicitly: given an 
integral lattice, it returns an element of a Magma space of modular forms, 
Moreover this is done with the least possible effort spent determining 
coefficients via lattice enumeration.  Several ideas are used here,
the most important of which is that linear constraints can be obtained
from knowing coefficients of the theta series of L <I>and</I> of its 
partial dual lattices; in practice, one needs a certain number of
coefficients in total, and the <TT>EnumerationCost</TT> functionality
is useful for balancing how many to compute for each of the duals. 
<P>
We say L is <I>q-modular</I> if it is isomorphic to its 
qth partial dual L<sub>q</sub>. 
Knowledge that modularities exist is of some use in the algorithm, 
because q-modularity clearly implies that L and L<sub>q</sub> have 
the same theta series.
<P>
<I>Normalisation of theta series:</I>
We use a normalisation that is most natural in this context, 
in order that the theta series is a modular form on &Gamma;<sub>0</sub>(N) 
with the level N as small as possible.
In this section, the theta series of an even integral lattice L 
will mean 
 &Sigma;<sub>v &isin;L</sub>  q<sup>1/2 |v|<sup>2</sup></sup>, 
while the theta series of an odd integral lattice L will mean
 &Sigma;<sub>v &isin;L</sub>  q<sup>|v|<sup>2</sup></sup>, 
where q = e<sup>2 i &pi; z</sup>.


<H5><A NAME = "3019">ThetaSeriesModularFormSpace(L) : Lat -&gt; ModFrm</A></H5>
<BLOCKQUOTE>
Given an integral lattice L, this returns the space of modular forms 
which contains the theta series of L.  
Note: the theta series is normalised as described above.
</BLOCKQUOTE>
<H5><A NAME = "3020">ThetaSeriesModularForm(L) : Lat -&gt; ModFrmElt</A></H5>

<PRE>    KnownTheta: RngSerPowElt            Default: </PRE>

<PRE>    KnownDualThetas: SeqEnum[Tup]       Default: </PRE>

<PRE>    KnownModularities: Set[RngIntElt]   Default: </PRE>

<PRE>    ComputeModularities: Set[RngIntElt] Default: </PRE>
<BLOCKQUOTE>
Given an integral lattice L, this returns the theta series of L 
as a modular form in the appropriate space: more precisely,
in <TT>ThetaSeriesModularFormSpace(L)</TT>. 
Note: the theta series is normalised as described above.
<P>
If some coefficients of the theta series of L are already known, 
this information may be specified by setting the optional argument 
<TT>KnownTheta</TT> to be a power series f, indicating that L has 
theta series equal to f up to the precision of f.
<P>
More generally, if coefficients are known for any partial dual lattices, 
these may be specified by setting <TT>KnownDualThetas</TT>.  This argument 
must be a sequence of tuples of the form &lt;q, f<sub>q</sub>&gt;, indicating that 
the qth partial dual L<sub>q</sub> has theta series equal to f<sub>q</sub> up to the 
precision of f<sub>q</sub>.  (<I>Warning:</I> care must be taken to use the 
expected normalisation of the partial duals here.)
<P>
If L is known to possess modularities, the optional argument 
<TT>KnownModularities</TT> may be set equal to any set of integers q 
such that L is q-modular (as defined above).   
In addition, <TT>ComputeModularities</TT> may be specified to control
whether the function checks for q-modularities (for possible q, 
that are not listed as <TT>KnownModularities</TT>); its value may be a
boolean, or a set of integers. 
</BLOCKQUOTE>
<PRE></PRE> <A  HREF = "text315.htm">[Next]</A><A  HREF = "text313.htm">[Prev]</A> <A  HREF = "text315.htm">[Right]</A> <A  HREF = "text313.htm">[Left]</A> <A  HREF = "text305.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<br><small>Version: V2.22 of <I>
Thu Jun  9 16:37:49 EST 2016
</I></small>
</body></html>