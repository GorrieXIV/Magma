<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <link rel='stylesheet' href='help.css' type='text/css'>
  <TITLE>Creation of Local Rings and  Fields</TITLE>
</head>
<body BGCOLOR="#FFFFFF">

 <A  HREF = "text486.htm">[Next]</A><A  HREF = "text484.htm">[Prev]</A> <A  HREF = "text486.htm">[Right]</A> <A  HREF = "text484.htm">[Left]</A> <A  HREF = "text481.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<PRE></PRE><H3><A NAME = "5226">Creation of Local Rings and  Fields</A></H3>

<P>
<P>
<P>
A local ring in Magma can be constructed in two ways: as either a p-adic
ring, or as an extension of another local ring.  Magma supports the
construction of towers of extensions of local rings; the only restriction is
that each extension must be either unramified or totally ramified.  As
discussed in Section <A  HREF = "text483.htm#5220">Background</A>, Magma requires that the
defining polynomial is either inertial or Eisenstein.
<P>
Additionally, the user must specify whether to construct a fixed precision or
free precision structure, and, if necessary, assign a precision to the
structure.  For local rings the precision is interpreted as an absolute
precision, specifying to what precision the element is known,
but for local fields it is interpreted as a relative precision, specifying to
what precision the unit part of the element is known.



<H5>Subsections</H5>
<UL>
<LI> <A  HREF = "text485.htm#5227">Creation Functions for the p-adics</A>
<LI> <A  HREF = "text485.htm#5233">Creation of Unramified Extensions</A>
<LI> <A  HREF = "text485.htm#5241">Creation of Totally Ramified Extensions</A>
<LI> <A  HREF = "text485.htm#5245">Creation of Unbounded Precision Extensions</A>
<LI> <A  HREF = "text485.htm#5248">Creation of Related Rings</A>
<LI> <A  HREF = "text485.htm#5254">Other Elementary Constructions</A>
<LI> <A  HREF = "text485.htm#5256">Attributes of Local Rings and Fields</A>
</UL>
<H4><A NAME = "5227">Creation Functions for the p-adics</A></H4>



<H5><A NAME = "5228">pAdicRing(p, k) : RngIntElt, RngIntElt -&gt; RngPad</A></H5>
<H5>pAdicField(p, k) : RngIntElt, RngIntElt -&gt; FldPad</H5>
<BLOCKQUOTE>
Given a prime integer p and non-negative single-precision integer k,
construct the bounded free precision ring (field) of p-adic integers with
maximum precision k.
</BLOCKQUOTE>
<H5><A NAME = "5229">pAdicRing(p) : RngIntElt -&gt; RngPad</A></H5>
<H5>pAdicField(p) : RngIntElt -&gt; FldPad</H5>

<PRE>    Precision: RngIntElt                Default: 20</PRE>
<BLOCKQUOTE>
Given a prime integer p, construct the unbounded free precision ring (field)
of p-adic numbers.  The optional parameter <TT>Precision</TT>, which must be a
non-negative single precision integer, controls the default precision to which
elements are created, e.g., when coercing precise elements such as integers or
rationals into the ring.
</BLOCKQUOTE>
<H5><A NAME = "5230">pAdicQuotientRing(p, k) : RngIntElt, RngIntElt -&gt; RngPadRes</A></H5>
<BLOCKQUOTE>
Given a prime integer p and non-negative single precision integer k,
construct the fixed precision quotient ring Z<sub>p</sub> / p<sup>k</sup> Z<sub>p</sub>.
</BLOCKQUOTE>
<H5><A NAME = "5231">quo&lt;L | x&gt; : RngPad, RngPadElt -&gt; .</A></H5>
<BLOCKQUOTE>
Given a local ring L, construct the quotient ring L / xL, where x is an
element of L.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "5232">Example <TT>RngLoc_el_creation_padic (H47E1)</TT></A></H3>
The creation of p-adic rings using the above functions is illustrated below.
<P>
<P>
<PRE>
&gt; R := pAdicRing(5);
&gt; R;
5-adic ring
&gt; R`DefaultPrecision;
20
&gt; R!1;
1 + O(5^20)
&gt; R := pAdicRing(5 : Precision := 20);
&gt; R!1;
1 + O(5^20)
&gt; Q := quo&lt;R | 5^20&gt;;
&gt; Q;
Quotient of the 5-adic ring modulo the ideal generated by 5^20
&gt; Q!1;
1
&gt; Q eq pAdicQuotientRing(5, 20);
true
</PRE>
<HR>
<H4><A NAME = "5233">Creation of Unramified Extensions</A></H4>



<H5><A NAME = "5234">UnramifiedExtension(L, n) : RngPad, RngIntElt -&gt; RngPad</A></H5>
<H5>UnramifiedExtension(L, n) : FldPad, RngIntElt -&gt; FldPad</H5>
<H5>UnramifiedExtension(L, n) : RngPadRes, RngIntElt -&gt; RngPadResExt</H5>
<H5>UnramifiedExtension(L, n) : RngPadResExt, RngIntElt -&gt; RngPadResExt</H5>
<H5>ext&lt;L | n&gt; : RngPad, RngIntElt -&gt; RngPad</H5>
<H5>ext&lt;L | n&gt; : FldPad, RngIntElt -&gt; FldPad</H5>
<H5>ext&lt;L | n&gt; : RngPadRes, RngIntElt -&gt; RngPadResExt</H5>
<H5>ext&lt;L | n&gt; : RngPadResExt, RngIntElt -&gt; RngPadResExt</H5>

<PRE>    Cyclotomic: BoolElt                 Default: <TT>false</TT></PRE>

<PRE>    GNBType: RngIntElt                  Default: 0</PRE>
<BLOCKQUOTE>
Given a local ring or field L and a positive single precision integer n,
construct the default unramified extension of L of degree n.  If K is the
residue class field of L, then the defining polynomial of the default degree
n extension of K is lifted to be an inertial polynomial of L; this
polynomial is used as the defining polynomial of the extension.  If <TT>Cyclotomic</TT> is <TT>true</TT>, then the lift of the defining polynomial will be such
that p<sup>n</sup> - 1-st root of unity will be adjoined to L (this representation
makes computation of the Frobenius automorphism particularly efficient).  The
angle bracket notation can be used to assign a name to the generator of the
extension, e.g. <TT>K&lt;t&gt; := UnramifiedExtension(L, n)</TT>.
If <TT>Cyclotomic</TT> is <TT>false</TT> but <TT>GNBType</TT> is t &gt; 0 then a Gaussian normal
basis of type t is used. This allows extremely fast multiple Frobenius
computations but multiplication is slower than the usual or <TT>Cyclotomic</TT>
representation if t &gt; 2. Because of this, currently only 1 or 2
are legal values for t. Only certain extension degrees will have a Gaussian
normal basis of type 1 or 2. To determine if this is true, the <TT>HasGNB</TT>
functions described below may be used.
</BLOCKQUOTE>
<H5><A NAME = "5235">UnramifiedQuotientRing(K, k) : FldFin, RngIntElt -&gt; Rng</A></H5>
<BLOCKQUOTE>
Given a finite field K and a non-negative single precision integer k,
construct the fixed precision quotient ring which has residue class field K
and precision k.  The angle bracket notation can be used to assign a name to
the generator of the extension, e.g. <TT>L&lt;t&gt; := UnramifiedExtension(K, f)</TT>.
</BLOCKQUOTE>
<H5><A NAME = "5236">UnramifiedExtension(L, f) : RngPad, RngUPolElt -&gt; RngPad</A></H5>
<H5>UnramifiedExtension(L, f) : FldPad, RngUPolElt -&gt; FldPad</H5>
<H5>UnramifiedExtension(L, f) : RngPadRes, RngUPolElt -&gt; RngPadResExt</H5>
<H5>UnramifiedExtension(L, f) : RngPadResExt, RngUPolElt -&gt; RngPadResExt</H5>
<H5>ext&lt;L | f&gt; : RngPad, RngUPolElt -&gt; RngPad</H5>
<H5>ext&lt;L | f&gt; : FldPad, RngUPolElt -&gt; FldPad</H5>
<H5>ext&lt;L | f&gt; : RngPadRes, RngUPolElt -&gt; RngPadResExt</H5>
<H5>ext&lt;L | f&gt; : RngPadResExt, RngUPolElt -&gt; RngPadResExt</H5>
<BLOCKQUOTE>
Given a local ring or field L and a polynomial f with coefficients
coercible to L, construct the unramified extension of L defined by f.
The polynomial f must be an inertial polynomial over L.  The angle bracket
notation can be used to assign a name to the generator of the extension, e.g.
<TT>K&lt;t&gt; := UnramifiedExtension(L, f)</TT>.  Free precision rings can only be
extended by a polynomial if they are of bounded precision, in which case f
must be specified to the maximum precision of the ring.
</BLOCKQUOTE>
<H5><A NAME = "5237">IsInertial(f) : RngUPolElt -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Given a polynomial f with coefficients over a local ring or field L, return
<TT>true</TT> if and only if f is an inertial polynomial.  A polynomial is inertial
over L if it is irreducible over the residue class field of L.
</BLOCKQUOTE>
<H5><A NAME = "5238"></A><A NAME = "has_gnb_func">HasGNB</A>(R, n, t) : RngPad, RngIntElt, RngIntElt -&gt; BoolElt</H5>
<H5>HasGNB(L, n, t) : FldPad, RngIntElt, RngIntElt -&gt; BoolElt</H5>
<H5>HasGNB(R, n, t) : RngPadRes, RngIntElt, RngIntElt -&gt; BoolElt</H5>
<H5>HasGNB(R, n, t) : RngPadResExt, RngIntElt, RngIntElt -&gt; BoolElt</H5>
<BLOCKQUOTE>
Given a local ring or field, returns <TT>true</TT> iff the unramified extension of
degree n can be generated by a Gaussian Normal Basis (GNB) of Type t.
A GNB allows particularly fast multiple Frobenius and Norm computations.
Multiplication will tend to be slower though, unless t = 1.
</BLOCKQUOTE>
<H5><A NAME = "5239">CyclotomicUnramifiedExtension(R, f) : FldPad, RngIntElt -&gt; FldPad</A></H5>
<H5>CyclotomicUnramifiedExtension(R, f) : RngPad, RngIntElt -&gt; RngPad</H5>
<H5>CyclotomicUnramifiedExtension(R, f) : RngPadRes, RngIntElt -&gt; RngPadRes</H5>
<H5>CyclotomicUnramifiedExtension(R, f) : RngPadResExt, RngIntElt -&gt; RngPadResExt</H5>
<BLOCKQUOTE>
Given a local ring of field R, construct the unramified degree f extension
by adjoining a p<sup>f</sup> - 1-th root of unity to R. Functionally equivalent to
calling <TT>UnramifiedExtension(R, f:Cyclotomic := true)</TT>.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "5240">Example <TT>RngLoc_el_creation_unram (H47E2)</TT></A></H3>
The creation of unramified extensions of local rings using the above functions
is illustrated below.
<P>
<P>
<PRE>
&gt; R1 := pAdicRing(2, 20);
&gt; R2 := ext&lt;R1 | 5&gt;;
&gt; R2;
Unramified extension defined by the polynomial x^5 + x^2 + 1
 over 2-adic ring mod 2^20
&gt; DefiningPolynomial(R2);
x^5 + x^2 + 1
&gt; R3 := ext&lt;R1 | 5 : Cyclotomic&gt;;
&gt; R3;
Cyclotomic unramified extension of degree 5 over 2-adic ring mod 2^20
&gt; DefiningPolynomial(R3);
x^5 + 426248*x^4 - 14172*x^3 - 147105*x^2 + 293314*x - 1
&gt; R3.1^(2^5-1);
1
&gt; P1&lt;x&gt; := PolynomialRing(R1);
&gt; f1 := x^3 + 3*x + 1;
&gt; IsInertial(f1);
true
&gt; R4 := ext&lt;R1 | f1&gt;;
&gt; R4;
Unramified extension defined by the polynomial x^3 + 3*x + 1
 over 2-adic ring mod 2^20
&gt; P2&lt;y&gt; := PolynomialRing(R2);
&gt; f2 := y^3 + 3*y + 1;
&gt; IsInertial(f2);
true
&gt; ext&lt;R2 | f2&gt;;
Unramified extension defined by the polynomial x^3 + 3*x + 1
 over Unramified extension defined by the polynomial x^5 + x^2 + 1
 over 2-adic ring mod 2^20
</PRE>
<HR>
<H4><A NAME = "5241">Creation of Totally Ramified Extensions</A></H4>



<H5><A NAME = "5242">TotallyRamifiedExtension(L, f) : RngPad, RngUPolElt -&gt; RngPad</A></H5>
<H5>TotallyRamifiedExtension(L, f) : FldPad, RngUPolElt -&gt; FldPad</H5>
<H5>TotallyRamifiedExtension(L, f) : RngPadRes, RngUPolElt -&gt; RngPadResExt</H5>
<H5>TotallyRamifiedExtension(L, f) : RngPadResExt, RngUPolElt -&gt; RngPadResExt</H5>
<H5>ext&lt;L | f&gt; : RngPad, RngUPolElt -&gt; RngPad</H5>
<H5>ext&lt;L | f&gt; : FldPad, RngUPolElt -&gt; FldPad</H5>
<H5>ext&lt;L | f&gt; : RngPadRes, RngUPolElt -&gt; RngPadResExt</H5>
<H5>ext&lt;L | f&gt; : RngPadResExt, RngUPolElt -&gt; RngPadResExt</H5>
<BLOCKQUOTE>
Given a local ring or field L and a polynomial f with coefficients
coercible to L, construct the totally ramified extension of L defined by
f.  The polynomial f must be an Eisenstein polynomial, that is, the leading
coefficient is a unit, the constant coefficient has valuation 1 and all other
coefficients have valuation greater than or equal to 1.  The angle bracket
notation can be used to assign a name to the generator of the extension, e.g.
<TT>K&lt;t&gt; := TotallyRamifiedExtension(L, f)</TT>.  Free precision rings can only be
extended by a polynomial if they are of bounded precision, in which case f
must be specified to the maximum precision of the ring.
</BLOCKQUOTE>
<H5><A NAME = "5243">IsEisenstein(f) : RngUPolElt -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Given a polynomial f with coefficients over a local ring or field L, return
<TT>true</TT> if and only if f is an Eisenstein polynomial over L.  An Eisenstein
polynomial satisfies the following properties: the leading coefficient is a
unit, the constant coefficient has valuation 1 and all other coefficients
have valuation greater than or equal to 1.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "5244">Example <TT>RngLoc_el_creation_ram (H47E3)</TT></A></H3>
The creation of totally ramified extensions of local rings using the above
functions is illustrated below.
<P>
<P>
<PRE>
&gt; L1&lt;a&gt; := ext&lt;pAdicRing(5, 20) | 4&gt;;
&gt; L1;
Unramified extension defined by the polynomial x^4 + 4*x^2 + 4*x + 2
 over 5-adic ring mod 5^20
&gt; L2&lt;b&gt; := ext&lt;L1 | x^4 + 125*x^2 + 5&gt;;
&gt; L2;
Totally ramified extension defined by the polynomial x^4 + 125*x^2 + 5
 over Unramified extension defined by the polynomial x^4 + 4*x^2 + 4*x + 2
 over 5-adic ring mod 5^20
&gt; P&lt;y&gt; := PolynomialRing(L2);
&gt; L3&lt;c&gt; := TotallyRamifiedExtension(L2, y^3 + b^4*a^5*y + b*a^2);
&gt; L3;
Totally ramified extension defined by the polynomial x^3 + ((500*a^3 + 500*a^2 +
    250*a)*b^2 + 20*a^3 + 20*a^2 + 10*a)*x + a^2*b
 over Totally ramified extension defined by the polynomial x^4 + 125*x^2 + 5
 over Unramified extension defined by the polynomial x^4 + 4*x^2 + 4*x + 2
 over 5-adic ring mod 5^20
</PRE>
If the precision of the base ring is only 1, then it is not possible to
construct a ramified extension, as there is not enough precision to allow the
constant coefficient to be non-zero to that precision.
<P>
<P>
<PRE>
&gt; R&lt;x&gt; := PolynomialRing(Integers());
&gt; L&lt;a&gt; := UnramifiedExtension(pAdicRing(5, 1), 3);
&gt; TotallyRamifiedExtension(L, x^4 + 5);

&gt;&gt; TotallyRamifiedExtension(L, x^4 + 5);
                           ^
Runtime error in 'TotallyRamifiedExtension': Polynomial must be Eisenstein
&gt; L&lt;a&gt; := UnramifiedExtension(pAdicRing(5, 2), x^5 + x^2 + 2);
&gt; TotallyRamifiedExtension(L, x^4 + 5);
Totally ramified extension defined by the polynomial x^4 + 5 over Unramified 
extension defined by the polynomial x^5 + x^2 + 2 over 5-adic ring mod 5^2
&gt; ext&lt;L | x^4 + 125*x^2 + 5&gt;;
Totally ramified extension defined by the polynomial x^4 + 5 over Unramified 
extension defined by the polynomial x^5 + x^2 + 2 over 5-adic ring mod 5^2
</PRE>
<HR>
<H4><A NAME = "5245">Creation of Unbounded Precision Extensions</A></H4>

<P>
<P>
<P>
<P>
Suppose we have an unbounded precision local ring or field L, and we wish to
create a finite extension of it.  If we need the default degree n unramified
extension, then we can use the construction functions defined in Section
<A  HREF = "text485.htm#5233">Creation of Unramified Extensions</A> to construct this extension.  However,
suppose we wish to define the extension by some polynomial f.  As there is no
upper bound on the precision of elements of L, it is impossible for us to
represent the polynomial f sufficiently precisely, and hence we cannot use the
creation functions defined in previous sections for this task.  To allow such
extensions to be created, Magma allows extensions to be defined by a map
&phi;: Z<sub>&ge;0</sub> to R[x], where R is a ring whose elements are coercible
to the quotient rings L / &pi;<sup>k</sup> L for all k &isin;Z<sub>&ge;0</sub>.  The map
&phi;, given an input precision k, returns the defining polynomial of the
extension to precision k.  Internally, whenever Magma needs to represent an
element of the extension to some precision, it will use &phi; to compute the
defining polynomial up to this precision.  Magma may call &phi; on any
precision between zero and the precision of the most precise element created
by the user.


<H5><A NAME = "5246">ext&lt;L | m&gt; : RngPad, Map -&gt; RngPad</A></H5>
<H5>ext&lt;L | m&gt; : FldPad, Map -&gt; RngPad</H5>
<BLOCKQUOTE>
Given a free precision local ring or field L and a map m with domain Z
and codomain R[x], where elements of R are coercible to the quotient rings
L / &pi;<sup>k</sup> L for all k &isin;Z<sub>&ge;0</sub>, construct an extension of L defined
by m.  Given a non-negative single precision integer k, the map m must
return the defining polynomial of the extension to precision k, as a
polynomial over R.  The map m's behaviour for other input values is
undefined.  Internally, Magma will coerce the value returned by the map m
to be a polynomial over L / &pi;<sup>k</sup> L.  Examples of suitable codomains R
include the integers, rationals, or L itself.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "5247">Example <TT>RngLoc_el_creation_map (H47E4)</TT></A></H3>
The creation of extensions of local rings using maps is illustrated below.  We
show how it is possible to define an extension of a free precision ring using
an "exact" polynomial.
<P>
<P>
<PRE>
&gt; R := pAdicRing(2);
&gt; Z := Integers();
&gt; P&lt;x&gt; := PolynomialRing(Z);
&gt; m := map&lt;Z -&gt; P | k :-&gt; x^3 + x + 1&gt;;
&gt; R2 := ext&lt;R | m&gt;;
&gt; R2;
Unramified extension defined by a map over 2-adic ring
&gt; DefiningPolynomial(R2);
(1 + O(2^20))*$.1^3 + O(2^20)*$.1^2 + (1 + O(2^20))*$.1 + 1 + O(2^20)
&gt; R2`DefaultPrecision := 1000;
&gt; DefiningPolynomial(R2);
(1 + O(2^1000))*$.1^3 + O(2^1000)*$.1^2 + (1 + O(2^1000))*$.1 + 1 + O(2^1000)
</PRE>
<HR>
<H4><A NAME = "5248">Creation of Related Rings</A></H4>



<H5><A NAME = "5249">IntegerRing(F) : FldPad -&gt; RngPad</A></H5>
<H5>Integers(F) : FldPad -&gt; RngPad</H5>
<H5>RingOfIntegers(F) : FldPad -&gt; RngPad</H5>
<BLOCKQUOTE>
Given a local field F, construct the ring of integers R of F.  The ring
R is the set of elements of F of non-negative valuation.
</BLOCKQUOTE>
<H5><A NAME = "5250">RingOfIntegers(R) : RngPad -&gt; RngPad</A></H5>
<BLOCKQUOTE>
Given a ring R, this function simply returns it, it is provided
to support generic functionality for finite extensions of rings and fields.
</BLOCKQUOTE>
<H5><A NAME = "5251">FieldOfFractions(R) : RngPad -&gt; FldPad</A></H5>
<BLOCKQUOTE>
Given a local ring R, construct the field of fractions F of R.  The
relative precision of F is equal to the precision of R. 
</BLOCKQUOTE>
<H5><A NAME = "5252">SplittingField(f, R) : RngUPolElt[RngInt], RngPad -&gt; RngPad</A></H5>
<BLOCKQUOTE>
Given a polynomial f over the integers and a p-adic ring R, 
compute an extension S over R such that f splits into linear 
factors over S. The algorithms uses the R4-methods as developed by
Pauli (<A  HREF = "text480.htm#bib_Pauli_R4">[Pau01b]</A>).
</BLOCKQUOTE>
<H5><A NAME = "5253">AbsoluteTotallyRamifiedExtension(R) : RngPad -&gt; RngPad, Map</A></H5>
<BLOCKQUOTE>
Given a tower of ramified extensions over some unramified ring S,
compute a more efficient representation of R, ie. an extension
of S that is totally ramified and defined by a single Eisenstein
polynomial. The map returned allows to convert between the new and old
representations.
</BLOCKQUOTE>
<H4><A NAME = "5254">Other Elementary Constructions</A></H4>



<H5><A NAME = "5255">Composite(R, S) : RngPad, RngPad -&gt; RngPad</A></H5>
<BLOCKQUOTE>
For two p-adic fields that are normal over Q<sub>p</sub>, compute the
compositum of R and S, ie. the smallest field containing both
R and S.
</BLOCKQUOTE>
<H4><A NAME = "5256">Attributes of Local Rings and Fields</A></H4>



<H5><A NAME = "5257">L`DefaultPrecision : RngPad -&gt; RngIntElt</A></H5>
<BLOCKQUOTE>
Used to retrieve or set the default precision of the local ring or field L.
This attribute is only relevant if L is an unbounded free precision ring, in
which case this will change the precision with which elements are created by
default.  For bounded precision structures, the default precision of the ring
is equal to the upper bound on precision; attempting to set this attribute will
result in an error in this case.
</BLOCKQUOTE>
<PRE></PRE> <A  HREF = "text486.htm">[Next]</A><A  HREF = "text484.htm">[Prev]</A> <A  HREF = "text486.htm">[Right]</A> <A  HREF = "text484.htm">[Left]</A> <A  HREF = "text481.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<br><small>Version: V2.22 of <I>
Thu Jun  9 16:37:49 EST 2016
</I></small>
</body></html>