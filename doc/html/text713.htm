<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <link rel='stylesheet' href='help.css' type='text/css'>
  <TITLE>Conjugacy</TITLE>
</head>
<body BGCOLOR="#FFFFFF">

 <A  HREF = "text714.htm">[Next]</A><A  HREF = "text712.htm">[Prev]</A> <A  HREF = "text714.htm">[Right]</A> <A  HREF = "text712.htm">[Left]</A> <A  HREF = "text706.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<PRE></PRE><H3><A NAME = "8071">Conjugacy</A></H3>



<H5><A NAME = "8072">Class(H, g) : GrpPC, GrpPCElt -&gt; { GrpPCElt }</A></H5>
<H5>Conjugates(H, g) : GrpPC, GrpPCElt -&gt; { GrpPCElt }</H5>
<H5>g ^ H : GrpPCElt, GrpPC -&gt; { GrpPCElt }</H5>
<BLOCKQUOTE>
Given a group H and an element g belonging to a group K such that
H and K are subgroups of some covering group, this function
returns the set of conjugates of g under the action of H. If H = K,
the function returns the conjugacy class of g in H.
</BLOCKQUOTE>
<H5><A NAME = "8073">ConjugacyClasses(G) : GrpPC -&gt; [ &lt;RngIntElt, RngIntElt, GrpPCElt&gt; ]</A></H5>
<H5>Classes(G) : GrpPC -&gt; [ &lt;RngIntElt, RngIntElt, GrpPCElt&gt; ]</H5>
<BLOCKQUOTE>
Construct a set of representatives for the conjugacy classes of G.
The classes are returned as a sequence of tuples containing the
order of the elements in the class, the class length and a representative
element for the class.  For non-p-groups,
the classes are computed using the homomorphism principle down a
series with elementary abelian factors and orbit-stabilizer in each
quotient. See <A  HREF = "text705.htm#bib_mecky-neubuser">[MN89]</A> for details.  For p-groups an
algorithm based on linear algebra developed
by Charles Leedham-Green is used.
</BLOCKQUOTE>
<H5><A NAME = "8074">ClassMap(G) : GrpPC -&gt; Map</A></H5>
<BLOCKQUOTE>
The class map M: G -&gt; {1, ..., n} for the group
G, where n is the number of conjugacy classes of G.
</BLOCKQUOTE>
<H5><A NAME = "8075">ClassRepresentative(G, x) : GrpPC, GrpPCElt -&gt; GrpPCElt</A></H5>
<H5>ClassRepresentative(G, i) : GrpPC, RngIntElt -&gt; GrpPCElt</H5>
<BLOCKQUOTE>
The designated representative for the conjugacy class of G containing 
the element x (relative to existing conjugacy classes) or the stored
representative for conjugacy class i.
</BLOCKQUOTE>
<H5><A NAME = "8076">ClassCentraliser(G, i) : GrpPC, RngIntElt -&gt; GrpPCElt</A></H5>
<H5>ClassCentralizer(G, i) : GrpPC, RngIntElt -&gt; GrpPCElt</H5>
<BLOCKQUOTE>
The centralizer in G of the designated representative for conjugacy
class i of G.
</BLOCKQUOTE>
<H5><A NAME = "8077">IsConjugate(G, g, h) : GrpPC, GrpPCElt, GrpPCElt -&gt; BoolElt, GrpPCElt</A></H5>
<BLOCKQUOTE>
Given a group G and elements g and h belonging to G, return the
value true if g and h are conjugate in G. The function also
returns a second value in the event that the elements are conjugate: an
element z which conjugates g into h.
</BLOCKQUOTE>
<H5><A NAME = "8078">NumberOfClasses(G) : GrpPC -&gt; RngIntElt</A></H5>
<H5>Nclasses(G) : GrpPC -&gt; RngIntElt</H5>
<BLOCKQUOTE>
The number of conjugacy classes of elements of the group G.
</BLOCKQUOTE>
<H5><A NAME = "8079">PowerMap(G) : GrpPC -&gt; Map</A></H5>
<BLOCKQUOTE>
The power map M: {1 ... n} x Z -&gt; {1 ... n} 
associated with the conjugacy classes of G.
The map M describes where the elements of the conjugacy classes of
G move under powers.  That is, &lt;c, n&gt;@M returns the class
number where class c moves under the power n.  The value of c must be
in the range [1 ... <TT>Nclasses(G)</TT>].
</BLOCKQUOTE>
<HR>
<H3><A NAME = "8080">Example <TT>GrpPC_class_map (H68E12)</TT></A></H3>
Let G be a pc-representation of SL(2,3).  We can compute the conjugacy
classes of G.  Notice that the conjugacy class object has a special
printing routine, but you can still access individual entries.
<P>
<P>
<PRE>
&gt; G := PCGroup(SpecialLinearGroup(2,GF(3)));
&gt; G;
GrpPC : G of order 24 = 2^3 * 3
PC-Relations:
    G.1^3 = Id(G),
    G.2^2 = G.4,
    G.3^2 = G.4,
    G.4^2 = Id(G),
    G.2^G.1 = G.3 * G.4,
    G.3^G.1 = G.2 * G.3 * G.4,
    G.3^G.2 = G.3 * G.4
&gt; Nclasses(G);
7
&gt; cc := Classes(G);
&gt; cc;
Conjugacy Classes of group G
----------------------------
[1]     Order 1       Length 1
        Rep Id(G)

[2]     Order 2       Length 1
        Rep G.4

[3]     Order 3       Length 4
        Rep G.1

[4]     Order 3       Length 4
        Rep G.1^2

[5]     Order 4       Length 6
        Rep G.2

[6]     Order 6       Length 4
        Rep G.1 * G.4

[7]     Order 6       Length 4
        Rep G.1^2 * G.4


&gt; cc[3];
&lt;3, 4, G.1&gt;
&gt; x := cc[3][3];
&gt; Class(G,x);
{ G.1 * G.2 * G.3 * G.4, G.1 * G.2 * G.4, G.1, G.1 * G.3 }
7
&gt;
</PRE>
We can use the <TT>ClassMap</TT> function to compute class multiplication
constants (structure constants for the center of the group algebra).
For example, we compute the decomposition of class 3 times class 5.
<P>
<P>
<PRE>
&gt; cm := ClassMap(G);
&gt; cm(G.1);
3
&gt; i := 3; j := 5;
&gt; t := [0: c in cc];
&gt; for x in Class(G,cc[i][3]), y in Class(G,cc[j][3]) do
&gt;   t[cm(x*y)] +:= 1;
&gt; end for;
&gt; t;
[ 0, 0, 12, 0, 0, 12, 0 ]
</PRE>
To get the actual structure constants, we need to divide each entry
in <TT>t</TT> by the corresponding class size.
<P>
<P>
<PRE>
&gt; [ t[i]/cc[i][2]: i in [1..#t] ];
[ 0, 0, 3, 0, 0, 3, 0 ]
</PRE>
<HR>
<PRE></PRE> <A  HREF = "text714.htm">[Next]</A><A  HREF = "text712.htm">[Prev]</A> <A  HREF = "text714.htm">[Right]</A> <A  HREF = "text712.htm">[Left]</A> <A  HREF = "text706.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<br><small>Version: V2.22 of <I>
Thu Jun  9 16:37:49 EST 2016
</I></small>
</body></html>