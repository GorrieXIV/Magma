<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <link rel='stylesheet' href='help.css' type='text/css'>
  <TITLE>Ideal Theory of Orders</TITLE>
</head>
<body BGCOLOR="#FFFFFF">

 <A  HREF = "text995.htm">[Next]</A><A  HREF = "text993.htm">[Prev]</A> <A  HREF = "text995.htm">[Right]</A> <A  HREF = "text993.htm">[Left]</A> <A  HREF = "text982.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<PRE></PRE><H3><A NAME = "11231">Ideal Theory of Orders</A></H3>

<P>
<P>
The right (or left) ideals of an R-order O in a quaternion algebra A
defined over a number field fall into finitely many isomorphism classes.  
Already, for the case of number rings, it is a computationally difficult 
problem to compute the class group, and due to the noncommutativity of 
quaternion algebras, the problem of enumerating ideal classes of 
quaternion orders is even more difficult because this set does not have 
the structure of a group.
<P>
All orders in this section are required to be <I>Eichler</I>. The reader
should recall that this includes the maximal orders.
<P>
The algorithms underpinning the intrinsics described in this section, 
in particular, those for determining ideal classes, are described in 
<A  HREF = "text981.htm#bib_kirschmer-voight">[KV10]</A>.  The methods depend on whether A is definite or 
indefinite.  For a definite algebra, we use a variation of Kneser's 
neighbouring method together with Eichler's mass formula 
(see <A  HREF = "text981.htm#bib_Vigneras80">[Vig80, Chapter 5]</A> and <A  HREF = "text981.htm#bib_Denert88">[DG88]</A>) to construct 
sufficient ideals to represent all ideal classes.  We then test if two 
right (or left) ideals I, J are isomorphic (Section <A  HREF = "text996.htm#11276">Isomorphisms of Ideals</A>).
<P>
For an indefinite quaternion algebra, we use a theorem of Eichler
<A  HREF = "text981.htm#bib_Reiner_MO">[Rei03, Th. 35.14]</A> which 
states that the reduced norm gives rise to a bijection of sets between
the class groups of the order and the number ring.  (Over Z or F<sub>q</sub>[X],
therefore, every ideal of an indefinite quaternion order is principal.)  
We may compute 
representative ideals I of O whose reduced norm is in a specified 
ideal class.  We then reduce the problem of testing for an isomorphism 
I isomorphic to J between two ideals to the similar problem over R.  Here, 
the problem of explicitly computing such an isomorphism is much less 
difficult, as an order (or ideal) will have infinitely many elements 
of bounded norm, and in most cases a search amongst reduced bases will 
find a desired element.
<P>
Ideals of quaternion orders belong to the types <TT>AlgQuatOrdIdl</TT> and
<TT>AlgAssVOrdIdl</TT> according as to whether the order O is defined over 
Z or F<sub>q</sub>[X] (both of type <TT>AlgQuatOrd</TT>) or over a number ring 
(of type <TT>AlgAssVOrd</TT>).  For more on the constructions and functions 
for ideals of the latter type, see Section <A  HREF = "text920.htm#10368">Orders</A>.



<H5>Subsections</H5>
<UL>
<LI> <A  HREF = "text994.htm#11232">Creation and Access Functions</A>
<LI> <A  HREF = "text994.htm#11242">Enumeration of Ideal Classes</A>
<LI> <A  HREF = "text994.htm#11251">Operations on Ideals</A>
</UL>
<H4><A NAME = "11232">Creation and Access Functions</A></H4>



<H5><A NAME = "11233">LeftIdeal(S, X) : AlgQuatOrd, [AlgQuatElt] -&gt; AlgQuatOrdIdl</A></H5>
<H5>lideal&lt;S | X&gt; : AlgQuatOrd, [AlgQuatElt] -&gt; AlgQuatOrdIdl</H5>
<H5>RightIdeal(S, X) : AlgQuatOrd, [AlgQuatElt] -&gt; AlgQuatOrdIdl</H5>
<H5>rideal&lt;S | X&gt; : AlgQuatOrd, [AlgQuatElt] -&gt; AlgQuatOrd</H5>
<H5>ideal&lt;S | X&gt; : AlgQuatOrd, [AlgQuatElt] -&gt; AlgQuatOrdIdl</H5>
<BLOCKQUOTE>
These intrinsics construct a left, right or two-sided ideal of the 
order S generated by the sequence X, which should contain elements 
that are coercible into the algebra of S.
<P>
In the case of the constructors <TT>lideal&lt; | &gt;</TT> and <TT>rideal&lt; | &gt;</TT>, 
the right hand side may also be a matrix or pseudo-matrix giving the 
basis of the ideal with respect to the basis of S.
</BLOCKQUOTE>
<H5><A NAME = "11234">PrimeIdeal(S, p) : AlgQuatOrd, RngElt -&gt; AlgQuatOrdIdl</A></H5>
<BLOCKQUOTE>
Given a quaternion order S over Z or F<sub>q</sub>[X], the function
returns the unique two-sided (integral) prime ideal P of S over 
the prime p of Z or F<sub>q</sub>[X].
If p exactly divides the discriminant of S, then P properly
contains pS and need not be principal, and otherwise P is equal
to pS. 
</BLOCKQUOTE>
<H5><A NAME = "11235">CommutatorIdeal(S) : AlgQuatOrd -&gt; AlgQuatOrdIdl</A></H5>
<H5>CommutatorIdeal(S) : AlgAssVOrd -&gt; AlgAssVOrdIdl</H5>
<BLOCKQUOTE>
The two-sided ideal of the quaternion order S 
generated by elements of the form xy - yx.
</BLOCKQUOTE>
<H5><A NAME = "11236">MaximalLeftIdeals(O, p) : AlgQuatOrd, RngElt -&gt; [AlgQuatOrdIdl]</A></H5>
<H5>MaximalLeftIdeals(O, p) : AlgAssVOrd, RngOrdIdl -&gt; [AlgAssVOrdIdl]</H5>
<H5>MaximalRightIdeals(O, p) : AlgQuatOrd, RngElt -&gt; [AlgQuatOrdIdl]</H5>
<H5>MaximalRightIdeals(O, p) : AlgAssVOrd, RngOrdIdl -&gt; [AlgAssVOrdIdl]</H5>
<BLOCKQUOTE>
The integral ideals of norm p with left or right order O.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "11237">Example <TT>AlgQuat_Elementary_Ideals (H91E16)</TT></A></H3>
We demonstrate the construction of the 2-sided prime ideals and their 
relationship with the commutator ideal.
<P>
<P>
<PRE>
&gt; S := QuaternionOrder(2*5*11);
&gt; P := PrimeIdeal(S, 2);
&gt; I := ideal&lt; S | [2] cat [ x*y-y*x : x, y in Basis(S) ] &gt;;
&gt; P eq I;
true
&gt; Q := PrimeIdeal(S, 5);
&gt; R := PrimeIdeal(S, 11);
&gt; P*Q*R eq CommutatorIdeal(S);
true
</PRE>
By way of explanation, we note that the composition of ideals is 
well-defined, since each of these ideals is a 2-sided ideal 
for S, that is, a left ideal whose right order is also S. 
The collection of all prime ideals over the ramified primes of a 
maximal order forms an elementary 2-abelian class group, and 
the commutator ideal is the product of these prime ideals.  
<HR>
<H3><A NAME = "11238">Example <TT>AlgQuat_Ideal_Bases (H91E17)</TT></A></H3>
First we create an integral ideal I of norm 2.
<P>
<P>
<PRE>
&gt; QQ:= Rationals();
&gt; A&lt;i,j&gt; := QuaternionAlgebra&lt; QQ | -1, -11 &gt;;
&gt; S := MaximalOrder(A);
&gt; P&lt;x&gt; := PolynomialRing(QQ);
&gt; P ! MinimalPolynomial(i);
x^2 + 1
&gt; I := lideal&lt; S | 2, 1+i &gt;;
&gt; Norm(I);
2
&gt; I in MaximalLeftIdeals(S, 2);
true
</PRE>
We now examine the basis of the ideal I.
<P>
<P>
<PRE>
&gt; Basis(I);
[ 2, 1 + i, i + k, 3/2 + 1/2*i + 1/2*j + 1/2*k ]
&gt; [ Eltseq(x) : x in Basis(I) ];
[
    [ 2, 0, 0, 0 ],
    [ 1, 1, 0, 0 ],
    [ 0, 1, 0, 1 ],
    [ 3/2, 1/2, 1/2, 1/2 ]
] 
&gt; BasisMatrix(I, A);
[  2   0   0   0]
[  1   1   0   0]
[  0   1   0   1]
[3/2 1/2 1/2 1/2]
</PRE>
If the ideal I is printed, the rational coordinates with
respect to the basis of the quaternion order S will be shown,
We can get this base change matrix if we call <TT>BasisMatrix</TT>
with no additional parameters.
<P>
<P>
<PRE>
&gt; I;
Left Ideal with basis Pseudo-matrix over Integer Ring
[2 0 0 0]
[1 1 0 0]
[0 0 2 0]
[1 0 1 1]
&gt; BasisMatrix(I);
[2 0 0 0]
[1 1 0 0]
[0 0 2 0]
[1 0 1 1]
</PRE>
<HR>
<H5><A NAME = "11239">LeftOrder(I) : AlgQuatOrdIdl -&gt; AlgQuatOrd</A></H5>
<H5>LeftOrder(I) : AlgAssVOrdIdl[RngOrd] -&gt; AlgAssVOrd</H5>
<BLOCKQUOTE>
Given an ideal I of a quaternion order defined over Z, F<sub>q</sub>[X]
or a number ring, this function returns the left order of I, defined 
as the ring of all elements of the quaternion algebra of I mapping I 
to itself under left multiplication.
</BLOCKQUOTE>
<H5><A NAME = "11240">RightOrder(I) : AlgQuatOrdIdl -&gt; AlgQuatOrd</A></H5>
<H5>RightOrder(I) : AlgAssVOrdIdl[RngOrd] -&gt; AlgAssVOrd</H5>
<BLOCKQUOTE>
Given an ideal I of a quaternion order defined over Z, F<sub>q</sub>[X]
or a number ring, this function returns the right order of I, defined 
as the ring of all elements of the quaternion algebra of I mapping I 
to itself under right multiplication.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "11241">Example <TT>AlgQuat_Left_Right_Quaternion_Ordre (H91E18)</TT></A></H3>
<P>
<P>
<PRE>
&gt; K := NumberField(Polynomial([5,0,1]));
&gt; K;
Number Field with defining polynomial $.1^2 + 5 over the Rational Field
&gt; A := QuaternionAlgebra&lt;K | 3, K.1&gt;;
&gt; O := MaximalOrder(A);
&gt; I := lideal&lt;O | O.2, Norm(O.2)&gt;;
&gt; Norm(I);
Principal Ideal
Generator:
    2/1*$.1
&gt; LeftOrder(I) eq O;
true
&gt; RightOrder(I) eq O;
true
</PRE>
<HR>
<H4><A NAME = "11242">Enumeration of Ideal Classes</A></H4>

<P>
<P>
<P>
The tools provided for calculating ideal classes in the case of a maximal 
or, more generally, an Eichler order S in a quaternion algebra over 
Q, F<sub>q</sub>(X) (with q odd) or a number field are described in this 
section.


<H5><A NAME = "11243">Mass(S) : AlgAssVOrd -&gt; FldRatElt</A></H5>
<BLOCKQUOTE>
Given a definite order S over R, this function returns the mass 
&sum;<sub>i</sub> 1 / [L(I<sub>i</sub>)<sup> * </sup>:R<sup> * </sup>]  where I<sub>1</sub>, ..., I<sub>h</sub> represent the 
isomorphism classes of invertible right ideal of S and L(I<sub>i</sub>)
denotes the left order of I<sub>i</sub>.
</BLOCKQUOTE>
<H5><A NAME = "11244">LeftIdealClasses(S) : AlgQuatOrd -&gt; [AlgQuatOrdIdl]</A></H5>
<H5>LeftIdealClasses(S) : AlgAssVOrd[RngOrd] -&gt; [AlgAssVOrdIdl]</H5>
<H5>RightIdealClasses(S) : AlgQuatOrd -&gt; [AlgQuatOrdIdl]</H5>
<H5>RightIdealClasses(S) : AlgAssVOrd[RngOrd] -&gt; [AlgAssVOrdIdl]</H5>

<PRE>    Support: [RngOrdIdl]                Default: </PRE>
<BLOCKQUOTE>
These intrinsics find representatives for the left or right locally 
free ideal classes of S, where S is an order in a quaternion 
algebra A defined over Q, F<sub>q</sub>(X) (with q odd) or a number 
field.  The algorithms are guaranteed to work correctly only when 
S is a maximal order or an Eichler order.  
<P>
For definite algebras, the support of the returned ideals may be 
specified using parameter <TT>Support</TT>; this should be a sequence 
of primes or prime ideals in the base ring which generate the narrow 
class group and which do not ramify in A.  In this case, the 
routine will find ideal class representatives whose norms are 
divisible only by primes in the specified support.  The algorithm 
usually runs faster if the support is either not specified or if 
the support includes the prime divisors of the discriminant of S.
<P>
For indefinite algebras, the representatives are obtained from a 
ray class group of the base field. 
</BLOCKQUOTE>
<H5><A NAME = "11245">TwoSidedIdealClasses(S) : AlgQuatOrd -&gt; [AlgQuatOrdIdl]</A></H5>
<H5>TwoSidedIdealClasses(S : Support) : AlgAssVOrd[RngOrd] -&gt; [AlgAssVOrdIdl]</H5>

<PRE>    Support: [RngOrdIdl]                Default: </PRE>
<BLOCKQUOTE>
Given an order S in a quaternion algebra, this function returns a 
sequence containing representatives for the two-sided locally free 
ideal classes of S. The algorithm is only guaranteed to work when 
S is a maximal order or an Eichler order.
<P>
If the optional argument <TT>Support</TT> is specified, Magma tries 
to construct representatives that have norm divisible by primes or 
prime ideals in the specified support. If this is not possible, 
the set specified using parameter <TT>Support</TT> will be enlarged by 
the prime divisors of the discriminant of S.  If this enlarged set 
is still not large enough (which can only happen if the set does not 
generate the class of group of the base ring of S) an error will
be raised.
</BLOCKQUOTE>
<H5><A NAME = "11246">TwoSidedIdealClassGroup(S : Support) : AlgAssVOrd -&gt; GrpAb, Map</A></H5>

<PRE>    Support: [RngOrdIdl]                Default: </PRE>
<BLOCKQUOTE>
Given an order S in a quaternion algebra, this returns the two-sided 
ideal class group of S as an abstract abelian group, together with 
a map from the group to the set of two-sided ideal classes of S.  
Inverses with respect to this map can be calculated in a very efficient 
way and thus may be used to compute discrete logarithms. The algorithm 
is only guaranteed to work when S is a maximal order or an Eichler order.
<P>
The optional parameter <TT>Support</TT> may be used to specify a support:
this should be a sequence of primes or prime ideals in the base ring 
which generate the narrow class group and which do not ramify in the
parent algebra.
</BLOCKQUOTE>
<H5><A NAME = "11247">ConjugacyClasses(S) : AlgAssVOrd -&gt; SeqEnum</A></H5>
<BLOCKQUOTE>
Given a maximal order (or an Eichler order S of level N) in a 
quaternion algebra A, this function returns representatives for 
the conjugacy classes of maximal orders (or orders of level N) in A.
<P>
For definite algebras, the algorithm involves computing the right 
ideal classes (in fact, the two problems are computationally equivalent 
in practice).
</BLOCKQUOTE>
<HR>
<H3><A NAME = "11248">Example <TT>AlgQuat_Ideal_Enumeration (H91E19)</TT></A></H3>
In the following example we construct a maximal order in the quaternion 
algebra ramified at 37, and enumerate its left ideal classes. 
<P>
<P>
<PRE>
&gt; S := QuaternionOrder(37);
&gt; ideals := LeftIdealClasses(S);
&gt; [ Basis(I) : I in ideals ];
[
  [ 1, i, j, k ],
  [ 2, 2*i, 1 + i + j, i + k ],
  [ 2, 2*i, i + j, k ]
]
</PRE>
We now compute the right orders of the two nontrivial left ideal classes.
<P>
<P>
<PRE>
&gt; _, I, J := Explode(ideals);
&gt; R1 := RightOrder(I);
&gt; R2 := RightOrder(J);
&gt; IsIsomorphic(R1,R2);
true
</PRE>
Although the ideals I and J are non-isomorphic left ideals over 
S, they have isomorphic right orders.  In the example following 
the next section we explore this phenomenon further.
<HR>
<H3><A NAME = "11249">Example <TT>AlgQuat_Ideal_Enumeration (H91E20)</TT></A></H3>
In this example, we enumerate ideal classes for a definite quaternion
algebra (over a totally real field). 
<P>
<P>
<PRE>
&gt; P&lt;x&gt; := PolynomialRing(Rationals());
&gt; F&lt;b&gt; := NumberField(x^3-3*x-1);
&gt; Z_F := MaximalOrder(F);
&gt; Foo := InfinitePlaces(F);
&gt; pp := Decomposition(Z_F, 17)[1][1];
&gt; A := QuaternionAlgebra(pp, Foo);
&gt; O := MaximalOrder(A);
&gt; time Rideals := RightIdealClasses(O);
Time: 0.870
&gt; #Rideals;
2
</PRE>
<HR>
<H3><A NAME = "11250">Example <TT>AlgQuat_Ideal_Enumeration (H91E21)</TT></A></H3>
In this example the classgroup of the base field is not trivial and 
there are some ramified prime ideals in the algebra. Hence we expect 
nontrivial two-sided ideal classes.
<P>
<P>
<PRE>
&gt; K:= QuadraticField(401);
&gt; A:= QuaternionAlgebra&lt; K | -1, -1&gt;;
&gt; RamifiedPlaces(A);
[
    Prime Ideal
    Two element generators:
        2
        $.2 + 1,
    Prime Ideal
    Two element generators:
        2
        $.2 + 2
]
[ 1st place at infinity, 2nd place at infinity ]
&gt; M:= MaximalOrder(A);
&gt; #TwoSidedIdealClasses(M);
10
&gt; time #RightIdealClasses(M);
140
Time: 6.470
</PRE>
<HR>
<H4><A NAME = "11251">Operations on Ideals</A></H4>

<P>
<P>
In addition to operations on ideals of orders over more general rings 
(see Section <A  HREF = "text920.htm#10368">Orders</A>), the following operations are defined for
ideals of quaternion orders over Z, F<sub>q</sub>[X] and number rings.


<H5><A NAME = "11252">I * J : AlgAssVOrdIdl, AlgAssVOrdIdl -&gt; AlgAssVOrdIdl</A></H5>
<BLOCKQUOTE>
The composite of I and J, where the right order of I equals the 
left order of J.   
</BLOCKQUOTE>
<H5><A NAME = "11253">I meet J : AlgQuatOrdIdl, AlgQuatOrdIdl -&gt; AlgQuatOrdIdl</A></H5>
<BLOCKQUOTE>
Given ideals or orders I and J, this function returns the 
intersection I &cap;J.
</BLOCKQUOTE>
<H5><A NAME = "11254">Conjugate(I) : AlgQuatOrdIdl -&gt; AlgQuatOrdIdl</A></H5>
<H5>Conjugate(I) : AlgAssVOrdIdl -&gt; AlgAssVOrdIdl</H5>
<BLOCKQUOTE>
Given an ideal I (of a quaternion algebra), 
this function returns the conjugate ideal.  
</BLOCKQUOTE>
<H5><A NAME = "11255">Norm(I) : AlgQuatOrdIdl -&gt; RngElt</A></H5>
<H5>Norm(I) : AlgAssVOrdIdl -&gt; RngOrdFracIdl</H5>
<BLOCKQUOTE>
Given an ideal I over Z, this function returns the reduced 
norm of the ideal, defined as the positive generator of the image 
of the reduced norm map in Q. 
<P>
Given an ideal I over F<sub>q</sub>[X], this function returns the 
reduced norm of the ideal, defined as the normalized generator 
of the image of the reduced norm map in F<sub>q</sub>(X).
<P>
Given an ideal I over a commutative order, this function 
returns the reduced norm of I as a fractional ideal of the order.
</BLOCKQUOTE>
<H5><A NAME = "11256">Factorization(I) : AlgQuatOrdIdl -&gt; SeqEnum</A></H5>
<H5>Factorization(I) : AlgAssVOrdIdl -&gt; SeqEnum</H5>
<BLOCKQUOTE>
Given a two-sided ideal I of an hereditary order O, this function 
returns the unique factorization of I into two-sided O-ideals. The 
result is a sequence of tuples. The first entry of each tuple is a 
two-sided ideal of O, the second is its exponent. (If the base ring 
of I is F<sub>q</sub>[X], then q is currently required to be odd.)
</BLOCKQUOTE>
<PRE></PRE> <A  HREF = "text995.htm">[Next]</A><A  HREF = "text993.htm">[Prev]</A> <A  HREF = "text995.htm">[Right]</A> <A  HREF = "text993.htm">[Left]</A> <A  HREF = "text982.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<br><small>Version: V2.22 of <I>
Thu Jun  9 16:37:49 EST 2016
</I></small>
</body></html>