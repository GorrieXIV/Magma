<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <link rel='stylesheet' href='help.css' type='text/css'>
  <TITLE>Subgroups</TITLE>
</head>
<body BGCOLOR="#FFFFFF">

 <A  HREF = "text662.htm">[Next]</A><A  HREF = "text660.htm">[Prev]</A> <A  HREF = "text662.htm">[Right]</A> <A  HREF = "text660.htm">[Left]</A> <A  HREF = "text653.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<PRE></PRE><H3><A NAME = "7556">Subgroups</A></H3>




<H5>Subsections</H5>
<UL>
<LI> <A  HREF = "text661.htm#7557">Construction of Subgroups</A>
<LI> <A  HREF = "text661.htm#7561">Elementary Properties of Subgroups</A>
<LI> <A  HREF = "text661.htm#7568">Standard Subgroups</A>
<LI> <A  HREF = "text661.htm#7579">Low Index Subgroups</A>
<LI> <A  HREF = "text661.htm#7584">Conjugacy Classes of Subgroups</A>
</UL>
<H4><A NAME = "7557">Construction of Subgroups</A></H4>



<H5><A NAME = "7558">sub&lt;G | L&gt; : GrpMat, List -&gt; GrpMat</A></H5>
<BLOCKQUOTE>
Given the matrix group G, construct the subgroup H of G
generated by the elements specified by the list L, where L is a
list of one or more items of the following types:
<DL COMPACT class='compact'>
<DT>(a)</DT><DD>A sequence of n integers defining a matrix of G;
<DT>(b)</DT><DD>A set or sequence of sequences of type (a);
<DT>(c)</DT><DD>An element of G;
<DT>(d)</DT><DD>A set or sequence of elements of G;
<DT>(e)</DT><DD>A subgroup of G;
<DT>(f)</DT><DD>A set or sequence of subgroups of G.
<P>
<P>
<P>
</DL>
Each element or group specified by the list must belong to the <I>same</I>
generic matrix group. The subgroup H will be constructed as a subgroup
of some group which contains each of the elements and groups specified in
the list.
<P>
The generators of H consist of the elements specified by the terms of
the list L together with the stored generators for groups
specified by terms of the list.  Repetitions of an element and occurrences
of the identity element are removed.
</BLOCKQUOTE>
<H5><A NAME = "7559">ncl&lt;G | L&gt; : GrpMat, List -&gt; GrpMat</A></H5>
<BLOCKQUOTE>
Given the matrix group G, construct the subgroup H of
G that is the <I>normal closure</I> of the subgroup H
generated by the elements specified by the list L,
where the possibilities for L are the same as for
the <TT>sub</TT>-constructor.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "7560">Example <TT>GrpMatGen_Subgroups (H64E15)</TT></A></H3>
We define O<sup> - </sup>(4, 2) as a subgroup of GL(4, 2). Recall
that O<sup> - </sup>(4, 2) is isomorphic to S<sub>5</sub>. We then locate a subset of 
its generators that lie within the subgroup isomorphic to A<sub>5</sub>.
<P>
<P>
<P>
<PRE>
&gt; GL42 := GeneralLinearGroup(4, GF(2));
&gt; Ominus42 := sub&lt; GL42 | [1,0,0,0, 1,1,0,1, 1,0,1,0, 0,0,0,1 ],
&gt;                               [0,1,0,0, 1,0,0,0, 0,0,1,0, 0,0,0,1 ],
&gt;                               [0,1,0,0, 1,0,0,0, 0,0,1,0, 0,0,1,1 ] &gt;;
&gt; Order(Ominus42);
120
&gt; H := sub&lt; Ominus42 | $.1, $.3 &gt;;
print Order(H);
10
&gt; N := ncl&lt; Ominus42 | $.1, $.3 &gt;;
&gt; Order(N);
60
</PRE>
<HR>
<H4><A NAME = "7561">Elementary Properties of Subgroups</A></H4>



<H5><A NAME = "7562">Index(G, H) : GrpMat, GrpMat -&gt; RngIntElt</A></H5>
<BLOCKQUOTE>
The index of the subgroup H in the group G. The index is
returned as an integer.  If the orders of G and H are not
known, they will be computed.
</BLOCKQUOTE>
<H5><A NAME = "7563">FactoredIndex(G, H) : GrpMat, GrpMat -&gt; [ &lt;RngIntElt, RngIntElt&gt; ]</A></H5>
<BLOCKQUOTE>
The index of the subgroup H in the group G. The index is
returned as a factored integer. The factorization is returned
in the form of a sequence Q which is defined as follows: If
[ G : H ]  = p<sub>1</sub><sup>e<sub>1</sub></sup> ... p<sub>n</sub><sup>e<sub>n</sub></sup>,   e<sub>i</sub> != 0,
then Q will be the integer sequence
 [ &lt;p<sub>1</sub>, e<sub>1</sub>&gt;, ..., &lt;p<sub>n</sub>, e<sub>n</sub>&gt; ]. If the orders of G and
H are not known, they will be computed.
</BLOCKQUOTE>
<H5><A NAME = "7564">IsCentral(G, H) : GrpMat, GrpMat -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if the subgroup H of the group G lies in the centre of
G, <TT>false</TT> otherwise.
</BLOCKQUOTE>
<H5><A NAME = "7565">IsMaximal(G, H) : GrpMat, GrpMat -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if the subgroup H of the group G is a maximal subgroup
of G.  This function is evaluated by constructing the
permutation representation of G on the cosets of H and
testing this representation for primitivity.  For this reason,
the use of <TT>IsMaximal</TT> should be avoided if the index of H
in G exceeds a few thousand.
</BLOCKQUOTE>
<H5><A NAME = "7566">IsNormal(G, H) : GrpMat, GrpMat -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if the subgroup H of the group G is a normal subgroup
of G, <TT>false</TT> otherwise.
</BLOCKQUOTE>
<H5><A NAME = "7567">IsSubnormal(G, H) : GrpMat, GrpMat -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if the subgroup H of the group G is subnormal in G,
<TT>false</TT> otherwise.
</BLOCKQUOTE>
<H4><A NAME = "7568">Standard Subgroups</A></H4>



<H5><A NAME = "7569">H ^ g : GrpMat, GrpMatElt -&gt; GrpMat</A></H5>
<H5>Conjugate(H, g) : GrpMat, GrpMatElt -&gt; GrpMat</H5>
<BLOCKQUOTE>
Construct the conjugate g<sup> - 1</sup> * H * g of the matrix group H by the matrix
g. The group H and the element g must belong to a common matrix group.
</BLOCKQUOTE>
<H5><A NAME = "7570">H meet K : GrpMat, GrpMat -&gt; GrpMat</A></H5>
<BLOCKQUOTE>
Given groups H and K which belong to the same matrix group, construct the
intersection of H and K.
</BLOCKQUOTE>
<H5><A NAME = "7571">CommutatorSubgroup(G, H, K) : GrpMat, GrpMat, GrpMat -&gt; GrpMat</A></H5>
<H5>CommutatorSubgroup(H, K) : GrpMat, GrpMat -&gt; GrpMat</H5>
<BLOCKQUOTE>
Given subgroups H and K of the group G, construct the commutator 
subgroup of H and K as a subgroup of G. If K is a subgroup of H,
then G may be omitted.
</BLOCKQUOTE>
<H5><A NAME = "7572">Centraliser(G, g) : GrpMat, GrpMatElt -&gt; GrpMat</A></H5>
<H5>Centralizer(G, g) : GrpMat, GrpMatElt -&gt; GrpMat</H5>
<BLOCKQUOTE>
Construct the centralizer of the matrix g in the group
G; g and G must belong to a common matrix group.
</BLOCKQUOTE>
<H5><A NAME = "7573">Centraliser(G, H) : GrpMat, GrpMat -&gt; GrpMat</A></H5>
<H5>Centralizer(G, H) : GrpMat, GrpMat -&gt; GrpMat</H5>
<BLOCKQUOTE>
Construct the centralizer of the group H in the group G;
G and H must belong to a common matrix group.
</BLOCKQUOTE>
<H5><A NAME = "7574">Core(G, H) : GrpMat, GrpMat -&gt; GrpMat</A></H5>
<BLOCKQUOTE>
Given a subgroup H of the matrix group G, construct
the maximal normal subgroup of G that is contained in the
subgroup H.
</BLOCKQUOTE>
<H5><A NAME = "7575">H ^ G : GrpMat, GrpMat -&gt; GrpMat</A></H5>
<H5>NormalClosure(G, H) : GrpMat, GrpMat -&gt; GrpMat</H5>
<BLOCKQUOTE>
Given a subgroup H of the matrix group G, construct
the normal closure of H in G.
</BLOCKQUOTE>
<H5><A NAME = "7576">Normalizer(G, H) : GrpMat, GrpMat -&gt; GrpMat</A></H5>
<BLOCKQUOTE>
Given a subgroup H of the group G, construct the normalizer
of H in G.
</BLOCKQUOTE>
<H5><A NAME = "7577">SylowSubgroup(G, p) : GrpMat, RngIntElt -&gt; GrpMat</A></H5>
<H5>Sylow(G, p) : GrpMat, RngIntElt -&gt; GrpMat</H5>
<BLOCKQUOTE>
Given a group G and a prime p, construct the Sylow
p-subgroup of G.
</BLOCKQUOTE>
<H5><A NAME = "7578">pCore(G, p) : GrpMat, RngIntElt -&gt; GrpMat</A></H5>
<BLOCKQUOTE>
Given a group G and a prime p dividing the order of G,
construct the maximal normal p-subgroup of G.
</BLOCKQUOTE>
<H4><A NAME = "7579">Low Index Subgroups</A></H4>



<H5><A NAME = "7580">LowIndexSubgroups(G,n: parameters) : GrpMat, RngIntElt -&gt; SeqEnum</A></H5>
<H5>LowIndexSubgroups(G,t: parameters) : GrpMat, Tup -&gt; SeqEnum</H5>
<BLOCKQUOTE>
Returns a sequence of subgroups of G, each with index at most n.
The sequence will contain one representative from each conjugacy
class  of G-subgroups satisfying the index constraint.
The algorithm used is described in Cannon, Holt, Slattery &amp; Steel
<A  HREF = "text652.htm#bib_CHSS-lix">[CHSS03]</A>.
<P>
The previous version of the algorithm is available by setting the
parameter <TT>Algorithm</TT> to the string <TT>"Subgroups"</TT>.
In this case the group G is subject to the same restrictions as the group
input to the <TT>Subgroups</TT> function above.
<P>
In the second form t should be a pair of integers &lt; a, b &gt;,
and subgroups with index in the interval [a, b] will be returned.
<P>
Other parameters are <TT>Presentation</TT> which may be set <TT>true</TT> to return
a second sequence of presentations of the groups found, and <TT>Print</TT>
which may be set to a positive integer to turn on diagnostic printing of
the progress of the algorithms.
</BLOCKQUOTE>
<H5><A NAME = "7581">LowIndexSubgroups(G, N, n: parameters) : GrpMat, RngIntElt -&gt; SeqEnum</A></H5>
<H5>LowIndexSubgroups(G, N, t: parameters) : GrpMat, Tup -&gt; SeqEnum</H5>
<BLOCKQUOTE>
Same as above, but only those subgroups containing the normal subgroup N
of G are returned. This is equivalent to computing the low index subgroups
of G/N. Only the <TT>Print</TT> parameter is available for this command.
</BLOCKQUOTE>
<H5><A NAME = "7582">LowIndexSubgroupsCT(G, R : parameters) : GrpMat, RngIntElt -&gt; [ GrpMat ]</A></H5>
<H5>LowIndexSubgroupsCT(G, R: parameters) : GrpMat, &lt;RngIntElt, RngIntElt&gt; -&gt; [ GrpMat ]</H5>
<BLOCKQUOTE>
Given a matrix group G, and an expression R defining a positive integer 
range (see below), determine the conjugacy classes of subgroups of G whose 
indices lie in the range specified by R. 
The subgroups are returned as a sequence of subgroups of G.
The argument R is one of the following:
<DL COMPACT class='compact'>
<DT>(a)</DT><DD>An integer n representing the range [1, n]; 
<DT>(b)</DT><DD>A tuple &lt;a, b&gt; representing the range [a, b].
<P>
<P>
<P>
</DL>
This is an alternative method for computing low index subgroups that
uses an algorithm due to Leedham-Green &amp; O'Brien <A  HREF = "text652.htm#bib_crlg-eaob">[LGO02]</A>.
In practice, the algorithm is most useful for small values of n,
say up to 8.
<P>
The algorithm proceeds by iteratively constructing better approximations
to finite presentations for G/K, where K is the intersection
of kernels of all homomorphisms from G into S<sub>n</sub>, and applying
<TT>LowIndexSubgroups</TT> to the resulting finitely-presented group. 
The output information displayed for various values of the <TT>Print</TT> 
parameter about the number and existence of putative subgroups of 
index at most n refers to the current finite presentation only, may 
change as this presentation is further refined, and need not be
reflected in the final answer.  
<P>
<P>
<PRE>
     Limit: RngIntElt                    Default: &infin;
</PRE>
Terminate after finding n conjugacy classes of subgroups satisfying 
the designated conditions. 
<P>
<P>
<PRE>
     Print: RngIntElt                    Default: 0
</PRE>
The <TT>Print</TT> parameter takes values from 0 to 3. 
The information displayed 
</BLOCKQUOTE>
<HR>
<H3><A NAME = "7583">Example <TT>GrpMatGen_LowIndexMatrixGroup (H64E16)</TT></A></H3>
<P>
<P>
<PRE>
&gt; G := GL (4, 5);
&gt; L := LowIndexSubgroups (G, 4);     
&gt; #L;
3
&gt; L[3]; 
MatrixGroup(4, GF(5))
Generators:
    [4 0 0 4]
    [1 0 0 0]
    [0 4 0 0]
    [0 0 4 0]


    [4 0 0 3]
    [3 0 0 0]
    [0 4 0 0]
    [0 0 4 0]


    [4 0 0 1]
    [4 0 0 0]
    [0 4 0 0]
    [0 0 4 0]


    [4 0 0 2]
    [2 0 0 0]
    [0 4 0 0]
    [0 0 4 0]
</PRE>
<HR>
<H4><A NAME = "7584">Conjugacy Classes of Subgroups</A></H4>



<H5><A NAME = "7585">SubgroupClasses(G: parameters) : GrpMat -&gt; [ rec&lt; GrpMat, RngIntElt, RngIntElt, GrpFP&gt; ]</A></H5>
<H5>Subgroups(G: parameters) : GrpMat -&gt; [ rec&lt; GrpMat, RngIntElt, RngIntElt, GrpFP&gt; ]</H5>
<BLOCKQUOTE>
Representatives for the conjugacy classes of subgroups for the
group G. The subgroups are returned as a sequence of records
where the i-th record contains:
<DL COMPACT class='compact'>
<DT>(a)</DT><DD>A representative subgroup H for the i-th conjugacy 
class (field name <TT>subgroup</TT>).
<DT>(b)</DT><DD>The order of the subgroup (field name <TT>order</TT>).
<DT>(c)</DT><DD>The number of subgroups in the class (field name <TT>length</TT>).
<DT>(d)</DT><DD>[Optional] A presentation for H (field name <TT>presentation</TT>).
<P>
<P>
<P>
<P>
<P>
</DL>
<PRE>
     Al: MonStgElt                       Default: "All"
</PRE>
<TT>Al := "All"</TT>: Construct all subgroups of G.
<P>
<TT>Al := "Maximal"</TT>: Only construct maximal subgroups of G. This option
reduces the number of intersections with any elementary abelian layer that 
need be considered and eliminates the need to recursively apply the algorithm.
<P>
<TT>Al := "Normal"</TT>: Only construct normal subgroups of G. This option
does not use database lookup to find the normal subgroups of the radical 
quotient of G and also reduces the number of intersections with any layer 
that need be considered.
<P>
<P>
<PRE>
     LayerSizes: SeqEnum                 Default: See below
</PRE>
<TT>LayerSizes := [ 2, 5, 3, 4, 7, 3, 11, 2, 17, 1]</TT> is equivalent to
the default. When constructing an Elementary Abelian series for the group,
attempt to split 2-layers of size gt 2<sup>5</sup>, 3-layers of size gt 3<sup>4</sup>,
etc. The implied exponent for 13 is 2 and for all primes greater than 17
the exponent is 1.
<P>
<P>
<PRE>
     Series: SeqEnum                     Default: See below
</PRE>
Use the given elementary abelian series rather than constructing the
default series. The first subgroup in the series must be the solvable
radical of G. The subgroups must form a descending chain of normal
subgroups of G, such that each quotient is elementary abelian. The last
subgroup in the series must be either elementary abelian or trivial.
<P>
<P>
<PRE>
     Presentation: BoolElt               Default: <TT>false</TT>
</PRE>
<TT>Presentation := true</TT>: Construct a presentation for each subgroup.
<P>
<P>
<PRE>
     OrderEqual: RngIntElt               Default: 
</PRE>
<TT>OrderEqual := n</TT>: Only construct subgroups having order equal to n.
<P>
<P>
<PRE>
     OrderDividing: RngIntElt            Default: 
</PRE>
<TT>OrderDividing := n</TT>: Only construct subgroups having order dividing n.
<P>
<P>
<PRE>
     OrderMultipleOf: RngIntElt          Default: 
</PRE>
<TT>OrderMultipleOf := n</TT>: Only construct subgroups having order a multiple
of n.
<P>
<P>
<PRE>
     IndexLimit: RngIntElt               Default: 
</PRE>
<TT>IndexLimit := n</TT>: Only construct subgroups having index in G less than
or equal to n.
<P>
<P>
<PRE>
     IsElementaryAbelian: BoolElt        Default: <TT>false</TT>
</PRE>
<TT>IsElementaryAbelian := true</TT>: Only construct elementary abelian subgroups 
of G.
<P>
<P>
<PRE>
     IsCyclic: BoolElt                   Default: <TT>false</TT>
</PRE>
<TT>IsCyclic := true</TT>: Only construct cyclic subgroups of G.
<P>
<P>
<PRE>
     IsAbelian: BoolElt                  Default: <TT>false</TT>
</PRE>
<TT>IsAbelian := true</TT>: Only construct abelian subgroups of G.
<P>
<P>
<PRE>
     IsNilpotent: BoolElt                Default: <TT>false</TT>
</PRE>
<TT>IsNilpotent := true</TT>: Only construct nilpotent subgroups of G.
<P>
<P>
<PRE>
     IsSolvable: BoolElt                 Default: <TT>false</TT>
</PRE>
<TT>IsSolvable := true</TT>: Only construct solvable subgroups of G.
<P>
<P>
<PRE>
     IsNotSolvable: BoolElt              Default: <TT>false</TT>
</PRE>
<TT>IsNotSolvable := true</TT>: Only construct insolvable subgroups of G.
<P>
<P>
<PRE>
     IsPerfect: BoolElt                  Default: <TT>false</TT>
</PRE>
<TT>IsPerfect := true</TT>: Only construct perfect subgroups of G.
<P>
<P>
<P>
<B>The Algorithm:</B> (See Cannon, Cox and Holt <A  HREF = "text652.htm#bib_subgroups-permg">[CCH01]</A>)
This command proceeds by first
constructing an elementary abelian series for G together with 
G's radical quotient Q as a permutation group.
(Thus this function is limited to matrix groups over fields, where the 
group has a BSGS.)
The required subgroups of Q are then found as for permutation groups.
We first attempt to locate the quotient in a 
database of groups with trivial Fitting subgroup. This database contains
all such groups of order up to 216 000, and all such which are 
perfect of order
up to 1 000 000. If Q is found then either all its subgroups,
or its maximal subgroups are read from the database. (In some cases only 
the maximal subgroups are stored.) If Q is not found then we attempt to
find the maximal subgroups of Q using a method of Derek Holt. For this to
succeed all simple factors of the socle of Q must be found in a second 
database which currently contains all simple groups of order less than 
1.6 x 10<sup>7</sup>, as well as M<sub>24</sub>, HS, J<sub>3</sub>,
McL, Sz(32) and L<sub>6</sub>(2). There are also special routines to handle 
numerous other groups. These include: A<sub>n</sub> for n &le;999, 
L<sub>2</sub>(q), L<sub>3</sub>(q), L<sub>4</sub>(q) and L<sub>5</sub>(q) for all q,
U<sub>3</sub>(q) for q prime and q=8, 9, 16, 25,
U<sub>4</sub>(q) for q=4, 5, 7,
S<sub>4</sub>(q) for all odd q and even q&le;16, 
L<sub>d</sub>(2) for d &le;14, and the following groups:
L<sub>6</sub>(3), L<sub>7</sub>(3), U<sub>6</sub>(2), S<sub>8</sub>(2), S<sub>10</sub>(2),
O<sup>&#8723;</sup><sub>8</sub>(2), O<sup>&#8723;</sup><sub>10</sub>(2), S<sub>6</sub>(3), O<sub>7</sub>(3), 
O^ - <sub>8</sub>(3), G<sub>2</sub>(4), G<sub>2</sub>(5), ()<sup>3</sup>D<sub>4</sub>(2), ()<sup>2</sup>F<sub>4</sub>(2)',
Co<sub>2</sub>, Co<sub>3</sub>, He, Fi<sub>22</sub>.
<P>
If we have only maximal subgroups of Q, and more are required, we apply
the algorithm recursively to the maximal subgroups to determine all subgroups
of Q. This may take some time.
<P>
The subgroups of Q are then pulled back to G and extended to the
whole group by stepwise extension through each layer of the elementary 
abelian series. For each layer this involves determining all possible 
intersections of a subgroup with this layer and all extensions with this 
intersection. 
<P>
The limitations are that the simple factors of the socle of Q must be in 
the list above.  Further, it may take
some time to construct all subgroups from the maximal subgroups first found,
and, if there is a large elementary abelian layer, there will be many 
possible intersections, which could also make the algorithm prohibitively slow.
<P>
There are numerous parameters for this function which allow the user to
place restrictions on which subgroup classes are constructed. Using these 
restrictions may help overcome the problems noted above.
</BLOCKQUOTE>
<H5><A NAME = "7586">MaximalSubgroups(G: parameters) : GrpMat -&gt; [ rec&lt; GrpMat, RngIntElt, RngIntElt, GrpFP&gt; ]</A></H5>
<BLOCKQUOTE>
Construct the sequence of maximal subgroup classes of the matrix group G.
This is equivalent to the command <TT>Subgroups(G: Al := "Maximal")</TT>. 
The same parameters as for <TT>Subgroups</TT> are available to limit
the search.
</BLOCKQUOTE>
<H5><A NAME = "7587">MaximalSubgroups(G,N: parameters) : GrpMat, GrpMat -&gt;                           [ rec&lt; GrpMat, RngIntElt, RngIntElt, GrpFP&gt; ]</A></H5>
<BLOCKQUOTE>
Construct the sequence of maximal subgroup classes of G that contain
the normal subgroup N of G. So this is equivalent to computing the
maximal subgroups of G that contain N. <I>Warning</I>: Some parameters
may have no effect.
</BLOCKQUOTE>
<H5><A NAME = "7588">SubgroupsLift(G, A, B, Q: parameters) : GrpMat, GrpMat, GrpMat, SeqEnum -&gt; SeqEnum</A></H5>
<BLOCKQUOTE>
This function isolates one step of the extension process used by the
<TT>Subgroups</TT> family of functions. Q is a sequence of records such
as returned by <TT>Subgroups(G)</TT>.
A and B are normal subgroups of G with A/B elementary abelian.
The records in Q are interpreted as subgroups of G/A,
which are lifted to all possible corresponding subgroups of G/B, subject 
to the parameters given.
</BLOCKQUOTE>
<PRE></PRE> <A  HREF = "text662.htm">[Next]</A><A  HREF = "text660.htm">[Prev]</A> <A  HREF = "text662.htm">[Right]</A> <A  HREF = "text660.htm">[Left]</A> <A  HREF = "text653.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<br><small>Version: V2.22 of <I>
Thu Jun  9 16:37:49 EST 2016
</I></small>
</body></html>