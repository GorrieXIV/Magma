<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <link rel='stylesheet' href='help.css' type='text/css'>
  <TITLE>Functionality</TITLE>
</head>
<body BGCOLOR="#FFFFFF">

 <A  HREF = "text1507.htm">[Next]</A><A  HREF = "text1505.htm">[Prev]</A> <A  HREF = "text1507.htm">[Right]</A> <A  HREF = "text1505.htm">[Left]</A> <A  HREF = "text1504.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<PRE></PRE><H3><A NAME = "17092">Functionality</A></H3>




<H5>Subsections</H5>
<UL>
<LI> <A  HREF = "text1506.htm#17093">Creation Functions</A>
<LI> <A  HREF = "text1506.htm#17102">Access Functions</A>
<LI> <A  HREF = "text1506.htm#17113">Functionality with L-series and Euler Factors</A>
<LI> <A  HREF = "text1506.htm#17121">Associated Schemes and Curves</A>
<LI> <A  HREF = "text1506.htm#17124">Utility Functions</A>
</UL>
<H4><A NAME = "17093">Creation Functions</A></H4>



<H5><A NAME = "17094">HypergeometricData(A, B) : SeqEnum, SeqEnum -&gt; HypGeomData</A></H5>
<H5>HypergeometricData(F, G) : RngUPolElt, RngUPolElt -&gt; HypGeomData</H5>

<PRE>    Print: MonStgElt                    Default: "cyclotomic"</PRE>
<BLOCKQUOTE>
These are two of the principal ways of specifying hypergeometric data.
The first takes two sequences A and B (of the same length) of 
rationals, which must be disjoint upon reduction modulo 1, and each 
of which must be Galois-invariant when taking the corresponding 
roots of unity (for instance, if (1/6) is specified, 
(5/6) is also given).
The second takes two products F and G of cyclotomic polynomials,
these products being coprime and of the same degree.
Previous Magma versions switches A and B in some cases;
this is no longer the case.
<P>
The default can be specified with the <TT>Print</TT> vararg,
the other option currently being <TT>"alpha_beta"</TT>.
<P>
There is now also some functionality for non-disjoint A and B,
which mainly manifests itself at the L-series level.
</BLOCKQUOTE>
<H5><A NAME = "17095">HypergeometricData(G) : SeqEnum[RngIntElt] -&gt; HypGeomData</A></H5>
<BLOCKQUOTE>
This is a third way to specify hypergeometric data, by giving 
a sequence of integers G such that &sum;<sub>v</sub> vG[v]=0.
Here we have P<sub>&alpha;</sub>(T)/P<sub>&beta;</sub>(T)=&prod;<sub>v</sub> (T<sup>v</sup> - 1)<sup>G[v]</sup>,
and the polynomials can be determined via M&ouml;bius inversion.
</BLOCKQUOTE>
<H5><A NAME = "17096">HypergeometricData(G) : List -&gt; HypGeomData</A></H5>
<BLOCKQUOTE>
This is a fourth way to specify hypergeometric data,
by giving a <I>list</I> G of nonzero integers (with repetition possible)
corresponding to the sequence G of the previous intrinsic,
with negative integers for those where G[v] is negative.
The sum of the members of the list must be 0.
</BLOCKQUOTE>
<H5><A NAME = "17097">HypergeometricData(F, G) : SeqEnum[RngIntElt], SeqEnum[RngIntElt] -&gt; HypGeomData</A></H5>
<BLOCKQUOTE>
This is a fifth way to specify hypergeometric data, by giving 
two arrays F and G of integers, corresponding to the
cyclotomic polynomials to be used.
</BLOCKQUOTE>
<H5><A NAME = "17098">HypergeometricData(E) : SeqEnum[SeqEnum] -&gt; HypGeomData</A></H5>
<BLOCKQUOTE>
This is a utility intrinsic that take a sequence E of two sequences
and then passes these two sequences to the intrinsics above.
</BLOCKQUOTE>
<H5><A NAME = "17099">Twist(H) : HypGeomData -&gt; HypGeomData</A></H5>
<BLOCKQUOTE>
This intrinsic takes hypergeometric data H, and adds 1/2 to every
element in &alpha; and &beta;, returning new hypergeometric data.
Magma no longer (ever) switches &alpha; and &beta; when twisting.
</BLOCKQUOTE>
<H5><A NAME = "17100">PrimitiveData(H) : HypGeomData -&gt; HypGeomData</A></H5>
<BLOCKQUOTE>
Given hypergeometric data H, return its primitive associated data.
This is most easily described in terms of <TT>GammaList</TT>,
where one divides all the elements by the gcd.
</BLOCKQUOTE>
<H5><A NAME = "17101">PossibleHypergeometricData(d) : RngIntElt -&gt; SeqEnum</A></H5>

<PRE>    Weight: RngIntElt                   Default: <TT>false</TT></PRE>

<PRE>    TwistMinimal: BoolElt               Default: <TT>false</TT></PRE>

<PRE>    CyclotomicData: BoolElt             Default: <TT>false</TT></PRE>

<PRE>    Primitive: RngIntElt                Default: 0</PRE>
<BLOCKQUOTE>
Given a degree d, generate all possible examples
of hypergeometric data of that degree, returned as a
sequence of pairs of sequences, each sequence therein having d rationals.
If <TT>Weight</TT> is specified, restrict to data of this weight.
If <TT>TwistMinimal</TT> is specified, only give twist-minimal data.
If <TT>CyclotomicData</TT> is specified, return the sequences of cyclotomic
data rather than rationals. If <TT>Primitive</TT> is {<TT>true</TT>}, only return
data that are primitive; if <TT>Primitive</TT> is a positive integer,
return the data that have this imprimitivity.
</BLOCKQUOTE>
<H4><A NAME = "17102">Access Functions</A></H4>



<H5><A NAME = "17103">Weight(H) : HypGeomData -&gt; RngIntElt</A></H5>
<BLOCKQUOTE>
The weight of the given hypergeometric data H.
</BLOCKQUOTE>
<H5><A NAME = "17104">Degree(H) : HypGeomData -&gt; RngIntElt</A></H5>
<BLOCKQUOTE>
The degree of the given hypergeometric data H.
</BLOCKQUOTE>
<H5><A NAME = "17105">DefiningPolynomials(H) : HypGeomData -&gt; RngUPolElt, RngUPolElt</A></H5>
<BLOCKQUOTE>
The (products of cyclotomic) polynomials corresponding to 
&alpha; and &beta; corresponding to hypergeometric data H.
</BLOCKQUOTE>
<H5><A NAME = "17106">CyclotomicData(H) : HypGeomData -&gt; SeqEnum, SeqEnum</A></H5>
<BLOCKQUOTE>
This returns two arrays of integers, specifying which cyclotomic
polynomials occur for &alpha; and &beta; corresponding to 
hypergeometric data H.  Thus, for example, 
&Phi;<sub>3</sub>&Phi;<sub>4</sub><sup>2</sup>&Phi;<sub>6</sub> would be represented by [3,4,4,6]).
</BLOCKQUOTE>
<H5><A NAME = "17107">AlphaBetaData(H) : HypGeomData -&gt; SeqEnum, SeqEnum</A></H5>
<BLOCKQUOTE>
This returns two arrays of rationals, giving the &alpha; and &beta;
of the hypergeometric data H.
</BLOCKQUOTE>
<H5><A NAME = "17108">MValue(H) : HypGeomData -&gt; FldRatElt</A></H5>
<BLOCKQUOTE>
This returns the scaling parameter M of the given hypergeometric data H.
This is defined by taking M<sub>n</sub>=&prod;<sub>d|n</sub> d<sup>d&mu;(n/d)</sup> for the nth
cyclotomic polynomial, and combining these into the products
for &alpha; and &beta;, and then dividing these.
Another definition is M=&prod;<sub>v</sub> v<sup>v&gamma;<sub>v</sub></sup>.
</BLOCKQUOTE>
<H5><A NAME = "17109">GammaArray(H) : HypGeomData -&gt; SeqEnum</A></H5>
<BLOCKQUOTE>
This returns an array of integers corresponding to &gamma;<sub>v</sub>,
where these are defined by P<sub>&alpha;</sub>(T)/P<sub>&beta;</sub>(T)=&prod;<sub>v</sub> (T<sup>v</sup> - 1)<sup>&gamma;<sub>v</sub></sup>.
We also have &sum;<sub>v</sub> v&gamma;<sub>v</sub>=0.
</BLOCKQUOTE>
<H5><A NAME = "17110">GammaList(H) : HypGeomData -&gt; List</A></H5>
<BLOCKQUOTE>
This returns a <I>list</I> of integers corresponding to &gamma;<sub>v</sub>,
where (sign)(&gamma;<sub>v</sub>).v appears in the list |&gamma;<sub>v</sub>| times.
</BLOCKQUOTE>
<H5><A NAME = "17111">H1 eq H2 : HypGeomData, HypGeomDat -&gt; BoolElt</A></H5>
<H5>H1 ne H2 : HypGeomData, HypGeomDat -&gt; BoolElt</H5>
<BLOCKQUOTE>
Two instances of hypergeometric data H1 and H2 are equal if they 
have the same &alpha; and &beta;.
</BLOCKQUOTE>
<H5><A NAME = "17112">IsPrimitive(H) : HypGeomData -&gt; BoolElt, RngIntElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if the given hypergeometric data H is primitive,
and the index of imprimitivity. The latter is the gcd
of the elements in the <TT>GammaList</TT>.
</BLOCKQUOTE>
<H4><A NAME = "17113">Functionality with L-series and Euler Factors</A></H4>



<H5><A NAME = "17114">EulerFactor(H, t, p) : HypGeomData, RngQZElt, RngIntElt -&gt; RngUPolElt</A></H5>

<PRE>    Degree: RngIntElt                   Default: 0</PRE>

<PRE>    Check: BoolElt                      Default: <TT>false</TT></PRE>

<PRE>    Fake: BoolElt                       Default: <TT>false</TT></PRE>
<BLOCKQUOTE>
This intrinsic is the heart of the hypergeometric motive package.
It takes hypergeometric data H, a rational t != 0, 1,
and a prime p, and computes the pth Euler factor of the
hypergeometric motive at t. This uses p-adic &Gamma;-functions,
as indicated by Cohen. The <TT>Degree</TT> vararg specifies how many terms
in the Euler factor should be computed -- if this is 0, then the whole
polynomial is computed. The <TT>Check</TT> vararg allows one to turn off
the use of the (local) functional equation that is used to expedite
the computation process.
<P>
The <TT>Fake</TT> vararg allows one to compute the hypergeometric trace(s)
for t with v<sub>p</sub>(Mt)=0 (including wild primes). Whether or not this is
the actual Euler factor depends on how inertia acts. The use of this
vararg inhibits the use of the local functional equation, but one can
curtail via <TT>Degree</TT>, and apply it manually (if known).
<P>
In general, the given prime must not be wild, that is, it must not
divide the denominator of any of the &alpha; or &beta;.
<P>
At other bad primes, the Euler factor will depend upon the relevant monodromy.
The primes for which v<sub>p</sub>(t - 1)&gt;0 can perhaps be called multiplicative,
in that p should divide the conductor only once (this is related to
the pseudoreflection). Since v<sub>p</sub>(Mt)=0 here, the Euler factor
(of degree d - 1) can be recovered by the p-adic &Gamma;-function
methods (even when p=2). Also it is often possible to relate the 
(presumed) hypergeometric motive to objects from a deformation.
When v<sub>p</sub>(t - 1) is even and the weight is also even, the prime p is
actually good and has a degree d Euler factor, even though the hypergeometric
trace only gives one of degree (d - 1). In such a case, the <TT>EulerFactor</TT>
intrinsic with the <TT>Fake</TT> vararg will return the part from the
hypergeometric trace.
<P>
The p with v<sub>p</sub>(1/t)&gt;0 correspond to monodromy at &infin;.
The associated inertia is given by the roots of unity with the &beta;,
with maximal Jordan blocks when eigenvalues are repeated.
The same is true for p with v<sub>p</sub>(t)&gt;0,
where the monodromy is around 0 (so that the &alpha; are used).
In Example <A  HREF = "text1507.htm#17134">H132E7</A>), an instance is given where the
inertia is trivialised due to having &zeta;<sup>v<sub>p</sub>(t)</sup>=1.
<P>
We can compute the Euler factors at such tame primes as follows.
Suppose that t=t<sub>0</sub>p<sup>vm</sup> with v&gt;0,
where m occurs as a denominator of the &alpha;
(similarly with v&lt;0 and &beta;).
Then one takes the smallest q=p<sup>f</sup> that is 1 mod m,
and from the hypergeometric trace formula extracts the terms
&omega;<sub>p</sub>(Mt<sub>0</sub>)<sup>j(q - 1)/m</sup>Q<sub>q</sub>biggl((j(q - 1)/m)biggr)
for 0&le;j&lt;m with gcd(j, m)=1.
Denoting these by &eta;, we then have that
&prod;<sub>&eta;</sub> (1 - &eta; T<sup>f</sup>) is an fth power
(due to repetitions in the above extraction),
and the fth root of this is the desired Euler factor of degree &phi;(m).
<P>
When m does not divide v<sub>p</sub>(t), the Euler factor from it is trivial.
One then multiplies together all such Euler factors corresponding to
the m from the &alpha; and &beta;. Each m is only considered once,
even if it appears multiple times in the <TT>CyclotomicData</TT>,
as the Jordan blocks of the eigenvalues are maximal.
Note that the local functional equation is not used for tame primes,
though the computation should not be too onerous unless q=p<sup>f</sup> is large.
</BLOCKQUOTE>
<H5><A NAME = "17115">LSeries(H, t) : HypGeomData, RngQZElt -&gt; LSer, LSer</A></H5>

<PRE>    BadPrimes: SeqEnum                  Default: []</PRE>

<PRE>    HodgeStructure: HodgeStruc          Default: <TT>false</TT></PRE>

<PRE>    GAMMA: SeqEnum                      Default: []</PRE>

<PRE>    Identify: BoolElt                   Default: <TT>true</TT></PRE>

<PRE>    Precision: RngIntElt                Default: 0</PRE>

<PRE>    Weight01: BoolElt                   Default: <TT>false</TT></PRE>

<PRE>    QuadraticTwist: Any                 Default: <TT>false</TT></PRE>

<PRE>    PoleOrder: RngIntElt                Default: 0</PRE>

<PRE>    SaveEuler: RngIntElt                Default: <TT>false</TT></PRE>
<BLOCKQUOTE>
Given hypergeometric data H and a rational t != 0, 1, try to construct
the L-series of the associated motive. This will usually need the
Euler factors at wild primes to be specified. Everything else, including
tame/multiplicative Euler factors and &gamma;-factors, can be computed
automatically by Magma (these can also be given respectively
via <TT>BadPrimes</TT>, and <TT>GAMMA</TT> and/or <TT>HodgeStructure</TT>).
<P>
The <TT>Identify</TT> vararg indicates whether an attempt should be made
to identify motives of weight 0 as Artin representations,
and similarly with (hyper)elliptic curves for weight 1.
The <TT>Weight01</TT> vararg when <TT>true</TT> will <TT>Translate</TT> the L-series
(essentially a Tate twist) so that the weight is 0 or 1.
Setting <TT>Weight01</TT> to an (odd) integer r will <TT>Translate</TT>
so that the (motivic) weight is r plus the number of zero
entries in the <TT>AlphaBetaData</TT>. A typical choice is r= - 1.
<P>
The <TT>QuadraticTwist</TT> vararg can be used to take the tensor product
with the given quadratic Dirichlet character. This can be given as a
nonzero rational or as a character, or alternatively can be set to <TT>true</TT>,
when Magma will use a default twisting factor.
However, this option can conflict with <TT>BadPrimes</TT>
(Magma does not know whether to apply such primes to the original
L-function or the twist), and so should be used sparingly.
<P>
The <TT>PoleOrder</TT> vararg allows the user to specify that the given
power of the (shifted) Riemann &zeta;-function is expected to divide
the L-series of the hypergeometric motive. The routines will then
act accordingly, decomposing the L-series into a factorisation and
moving the poles into the &zeta;-function part.
<P>
Finally, the <TT>SaveEuler</TT> option takes a nonnegative integer
(or a boolean), and indicates how large of primes should have their
<TT>EulerFactor</TT> saved when computed. This is useful when (say) dealing
with such L-function constructs as <TT>Symmetrization</TT>, for which the
underlying work with hypergeometric traces is being done on one L-function,
and then used multiple times.
This option will be (silently) ignored is Magma is able to <TT>Identify</TT>
the L-function as coming from somewhere else.
<P>
The intrinsic actually returns two L-series, the first corresponding to
the disjoint parts of A and B, and the second an Artin part (weight 0)
corresponding to the common part. For most purposes the second can
be ignored (it will typically be the trivial <TT>LSeries</TT>).
</BLOCKQUOTE>
<H5><A NAME = "17116">Identification of Hypergeometric Data as Other Objects</A></H5>



<H5><A NAME = "17117">ArtinRepresentation(H, t) : HypGeomData, RngQZElt -&gt; ArtRep</A></H5>

<PRE>    Check: BoolElt                      Default: <TT>true</TT></PRE>
<BLOCKQUOTE>
Given hypergeometric data H of weight 0 and a rational t != 0, 1,
try to determine the associated Artin representation. This is implemented
for all such H of degree 3 or less, and for some of degree 4 and higher.
The condition needed is that <TT>GammaList(H)</TT> have cardinality 3.
When <TT>Check</TT> is true, good primes up to 100 have their Euler factors
checked for correctness.
</BLOCKQUOTE>
<H5><A NAME = "17118">EllipticCurve(H) : HypGeomData -&gt; CrvEll</A></H5>
<H5>EllipticCurve(H, t) : HypGeomData, RngQZElt -&gt; CrvEll</H5>
<BLOCKQUOTE>
Given hypergeometric data H of degree 2 and weight 1
(there are 10 such families) and a rational t != 0, 1,
return the associated elliptic curve, as catalogued by Cohen.
When t is not given, return the result over a function field.
<P>
For each of the 10 families, the same function can be called for the
corresponding imprimitive data of index r, and the result will
generically be an elliptic curve over an extension of degree r.
However, when the x<sup>r</sup> - 1/Mt splits, the intrinsic will return an
array of elliptic curves corresponding to this splitting.
</BLOCKQUOTE>
<H5><A NAME = "17119">HyperellipticCurve(H) : HypGeomData -&gt; CrvHyp</A></H5>
<H5>HyperellipticCurve(H, t) : HypGeomData, RngQZElt -&gt; CrvHyp</H5>
<BLOCKQUOTE>
Given hypergeometric data H of degree 4 and weight 1
and a rational t != 0, 1, return the associated hyperelliptic curve,
if this data is known to correspond to such. When t is not given,
return the result over a function field. There are 18 cases
where one gets a genus 2 curve from the <TT>CanonicalCurve</TT>
(making 36 cases when twisting is considered),
and a few others where <TT>CanonicalCurve</TT> gives a higher genus curve
and there is a genus 2 quotient. In general, one can try to call
<TT>IsHyperelliptic</TT> on the <TT>CanonicalCurve</TT>.
</BLOCKQUOTE>
<H5><A NAME = "17120">Identify(H, t) : HypGeomData, RngQZElt -&gt; Any</A></H5>
<BLOCKQUOTE>
Given hypergeometric data H and a rational t != 0, 1,
return any known associated object (else returns <TT>false</TT>).
The return value can (currently) be: an Artin representation (weight 0);
an elliptic curve over <B>Q</B> (weight 1 in degree 2);
an elliptic curve over a number field (weight 1 in degree 2r
with imprimitivity r), or possibly multiple such curves;
or a hyperelliptic curve over <B>Q</B> (weight 1 in degree 4).
</BLOCKQUOTE>
<H4><A NAME = "17121">Associated Schemes and Curves</A></H4>



<H5><A NAME = "17122">CanonicalScheme(H) : HypGeomData -&gt; Sch</A></H5>
<H5>CanonicalScheme(H, t) : HypGeomData, RngQZElt -&gt; Sch</H5>
<BLOCKQUOTE>
Given hypergeometric data H, this constructs a canonical associated 
scheme.  When the parameter t is given, the specialization is returned, 
otherwise the result returned will be a scheme over a function field.
<P>
The scheme is determined from the <TT>GammaList</TT>,
with a variable (X<sub>i</sub> or Y<sub>j</sub>) for every element in the list.
The scheme is the intersection of &sum;<sub>i</sub> X<sub>i</sub>=&sum;<sub>j</sub> Y<sub>j</sub>=1
with &prod;<sub>i</sub> X<sub>i</sub><sup>g<sub>i</sub>^ + </sup>&prod;<sub>j</sub> Y<sub>j</sub><sup>g<sub>j</sub>^ - </sup>=(1/Mt),
where the g<sub>i</sub>^ + are the positive elements in the <TT>GammaList</TT>
and the g<sub>j</sub>^ - are the negative ones (one usually moves the latter
to the other side of the equation, to make the exponents positive).
</BLOCKQUOTE>
<H5><A NAME = "17123">CanonicalCurve(H) : HypGeomData -&gt; Crv</A></H5>
<H5>CanonicalCurve(H, t) : HypGeomData, RngQZElt -&gt; Crv</H5>
<BLOCKQUOTE>
Given suitable hypergeometric data H, this tries to construct an associated
plane curve. When the parameter t is given, the specialization at t is 
returned, otherwise the return value will be a plane curve over a function 
field.  The curve is constructed using the <TT>GammaList</TT> (which indicates
the Jacobi sums that need to be taken). When this list has four elements, 
it is always possible to get a curve. When the list has six elements, it is 
sometimes possible, depending on whether the largest element (in absolute 
value) is the negation of the sum of two of the other elements. If it is not
possible to construct such a curve, the intrinsic returns <TT>false</TT>.
</BLOCKQUOTE>
<H4><A NAME = "17124">Utility Functions</A></H4>



<H5><A NAME = "17125">HypergeometricMotiveSaveLimit(n) : RngIntElt -&gt;</A></H5>
<H5>HypergeometricMotiveClearTable() : -&gt;</H5>
<BLOCKQUOTE>
These are utility intrinsics that will cache the pre-computation of
p-adic &Gamma;-functions. The first indicates to save all computed
values when the prime power is less than n, and the second clears
the table. The qth table entry will have (q - 1) elements in it.looseness=-1
</BLOCKQUOTE>
<H5><A NAME = "17126">pPart(H, p) : HypGeomMot, RngIntElt -&gt; Tup</A></H5>
<H5>pParts(H) : HypGeomMot -&gt; List</H5>
<BLOCKQUOTE>
Given a hypergeometric datum, reduce the cyclotomic indices modulo
either the given prime or all wild primes.
</BLOCKQUOTE>
<PRE></PRE> <A  HREF = "text1507.htm">[Next]</A><A  HREF = "text1505.htm">[Prev]</A> <A  HREF = "text1507.htm">[Right]</A> <A  HREF = "text1505.htm">[Left]</A> <A  HREF = "text1504.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<br><small>Version: V2.22 of <I>
Thu Jun  9 16:37:49 EST 2016
</I></small>
</body></html>