<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <link rel='stylesheet' href='help.css' type='text/css'>
  <TITLE>Central Extensions</TITLE>
</head>
<body BGCOLOR="#FFFFFF">

 <A  HREF = "text722.htm">[Next]</A><A  HREF = "text720.htm">[Prev]</A> <A  HREF = "text722.htm">[Right]</A> <A  HREF = "text720.htm">[Left]</A> <A  HREF = "text706.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<PRE></PRE><H3><A NAME = "8245">Central Extensions</A></H3>

<P>
<P>
We now describe functions to construct H<sup>2</sup>(G, U) for a finite soluble 
group G and finite abelian group U (a trivial G-module).
We also present functions to construct central extensions of U by G.
<P>
Denote by Z<sup>2</sup>(G, U) the abelian group of all cocycles from G
to U, under pointwise multiplication.
The values &psi;(g, h) of &psi; &isin;Z<sup>2</sup>(G, U)
may be represented as a "cocyclic matrix" with entries in U.
<P>
If &phi; : G -&gt; U is a set map
with &phi; (1<sub>G</sub>) = 1<sub>U</sub>, 
then there is  a coboundary
&part;&phi; &isin;Z<sup>2</sup>(G, U) defined by &part;&phi;(g, h)
= &phi;(g) &phi; (h) &phi;(gh)<sup> - 1</sup>.
The group of all coboundaries from
G to U is denoted B<sup>2</sup>(G, U), and we have
H<sup>2</sup>(G, U) = Z<sup>2</sup>(G, U)/B<sup>2</sup>(G, U).
Then H<sup>2</sup>(G, U)=I x T, where I is the
(faithful) image of Ext(G/G', U)
&le;H<sup>2</sup>(G/G', U) under inflation, and T is the
(faithful) image of Hom(H<sub>2</sub>(G), U) under a certain
transgression homomorphism. Here we provide functions  which construct
representatives for the elements in a generating set for
each of these two  factors.                                   
<P>
For details of the theory and the algorithm used, see <A  HREF = "text705.htm#bib_fo_centex">[FO00]</A>.
<P>
<TT>SetVerbose ("Cocycle", 1)</TT> will provide additional 
information on the calculations in the functions.


<H5><A NAME = "8246">ExtGenerators(G, U) : GrpPC, GrpPC -&gt; [&lt;AlgMatElt, RngIntElt&gt;]</A></H5>
<BLOCKQUOTE>
Given a soluble group G and an abelian group U (both defined
by pc-presentations) the function returns a sequence of tuples 
describing generators for Ext(G/G', U) as cocyclic matrices;  
the first entry in each tuple is a representative of a generator, 
the second is the order of the coset of the representative in 
H<sup>2</sup>(G, U). 
</BLOCKQUOTE>
<H5><A NAME = "8247">HomGenerators(G, U) : GrpPC, GrpPC -&gt; [&lt;AlgMatElt, RngIntElt&gt;]</A></H5>
<BLOCKQUOTE>
Given a soluble group G and an abelian group U (both defined
by pc-presentations) the function returns a sequence of tuples 
describing generators for Hom(H<sub>2</sub> (G), U) as cocyclic matrices;  
the first entry in each tuple is a representative of a generator, 
the second is the order of the coset of the representative
in H<sup>2</sup>(G, U). 
</BLOCKQUOTE>
<H5><A NAME = "8248">ElementSequence(G) : GrpPC -&gt; SeqEnum</A></H5>
<BLOCKQUOTE>
For a soluble group G, the function returns an indexed set 
of elements of G listed in the order used by <TT>ExtGenerators</TT> 
and <TT>HomGenerators</TT>.
</BLOCKQUOTE>
<H5><A NAME = "8249">RepresentativeCocycles(G, U, Ext, Hom) : GrpPC, GrpPC, [AlgMatElt], [AlgMatElt]-&gt; [AlgMatElt]</A></H5>
<BLOCKQUOTE>
Let G be a soluble group G and U be an abelian group both defined
by pc-presentations. Let Ext and Hom be the values returned by
calling <TT>ExtGenerators</TT> and <TT>HomGenerators</TT> respectively.
The function <TT>RepresentativeCocycles</TT> returns a complete and 
irredundant set of representatives for the elements of H<sup>2</sup>(G, U) 
as cocyclic matrices.
</BLOCKQUOTE>
<H5><A NAME = "8250">CentralExtension(G, U, A) : GrpPC, GrpPC, AlgMatElt -&gt; GrpPC</A></H5>
<BLOCKQUOTE>
Let G be a soluble group G and U be an abelian group, both defined
by pc-presentations. Further, let A be a cocyclic matrix (as determined
by the function <TT>RepresentativeCocycles</TT>). Then, this function returns the
central extension of U by G determined by the cocyclic matrix A.
</BLOCKQUOTE>
<H5><A NAME = "8251">CentralExtensions(G, U, Q) : GrpPC, GrpPC, [AlgMatElt] -&gt; [GrpPC]</A></H5>
<BLOCKQUOTE>
If G is a soluble group G and U is an abelian group, both defined
by pc-presentations, and Q is a sequence of cocyclic matrices (as 
determined by the function <TT>RepresentativeCocycles</TT>), this function 
returns the corresponding sequence of central extension of U by G 
determined by the sequence of cocyclic matrices A.  Note that the 
central extensions thereby constructed need not be mutually non-isomorphic.
</BLOCKQUOTE>
<H5><A NAME = "8252">CentralExtensionProcess(G, U) : GrpPC, GrpPC -&gt; Proc</A></H5>
<BLOCKQUOTE>
Given a soluble group G and an abelian group U (both defined
by pc-presentations) the function creates a process P for central 
extensions of U by G.  Note that the list of central extensions 
constructed by this process will contain all isomorphism types but 
the extensions need not be mutually non-isomorphic.
</BLOCKQUOTE>
<H5><A NAME = "8253">NextExtension(~P) : Rec -&gt; GrpPC</A></H5>
<BLOCKQUOTE>
Given a central extension process P, construct the next central 
extension determined by P.
</BLOCKQUOTE>
<H5><A NAME = "8254">IsEmpty(P) : Rec -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Return <TT>true</TT> if all central extensions determined by the 
process P have been constructed; otherwise return <TT>false</TT>.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "8255">Example <TT>GrpPC_CentralExtension (H68E32)</TT></A></H3>
We compute the abelian invariants of H<sup>2</sup> (D<sub>4</sub>, C<sub>2</sub>). 
<P>
<P>
<PRE>
&gt; G := DihedralGroup(GrpPC, 4);
&gt; U := AbelianGroup(GrpPC, [2]);  
&gt; 
&gt; Ext := ExtGenerators(G, U);
&gt; Ext[1];
    &lt;[Id(U) Id(U) Id(U) Id(U) Id(U) Id(U) Id(U) Id(U)]
    [Id(U) Id(U) Id(U) Id(U) Id(U) Id(U) Id(U) Id(U)]
    [Id(U) Id(U) Id(U) Id(U) Id(U) Id(U) Id(U) Id(U)]
    [Id(U) Id(U) Id(U) Id(U) Id(U) Id(U) Id(U) Id(U)]
    [Id(U) Id(U) Id(U) Id(U) U.1 U.1 U.1 U.1]
    [Id(U) Id(U) Id(U) Id(U) U.1 U.1 U.1 U.1]
    [Id(U) Id(U) Id(U) Id(U) U.1 U.1 U.1 U.1]
    [Id(U) Id(U) Id(U) Id(U) U.1 U.1 U.1 U.1], 2&gt;,
&gt;
&gt; Hom := HomGenerators(G, U);
&gt; Hom;
[
    &lt;[Id(U) Id(U) Id(U) Id(U) Id(U) Id(U) Id(U) Id(U)]
    [Id(U) U.1 U.1 Id(U) Id(U) U.1 U.1 Id(U)]
    [Id(U) Id(U) Id(U) Id(U) Id(U) Id(U) Id(U) Id(U)]
    [Id(U) U.1 U.1 Id(U) Id(U) U.1 U.1 Id(U)]
    [Id(U) Id(U) Id(U) U.1 Id(U) U.1 U.1 U.1]
    [Id(U) U.1 Id(U) Id(U) U.1 U.1 Id(U) U.1]
    [Id(U) Id(U) Id(U) U.1 Id(U) U.1 U.1 U.1]
    [Id(U) U.1 Id(U) Id(U) U.1 U.1 Id(U) U.1], 2&gt;
]
&gt; 
&gt; AbelianInvariants(Ext, Hom);
[ 2, 2, 2 ]
</PRE>
We now compute the central extension of U by G determined by a single
cocyclic matrix.
<P>
<P>
<PRE>
&gt; A := RepresentativeCocycles(G, U, Ext, Hom);
&gt; E := CentralExtension(G, U, A[2]);  
&gt; E;
GrpPC : E of order 16 = 2^4
PC-Relations:
    E.1^2 = E.4, 
    E.2^2 = E.3 * E.4, 
    E.2^E.1 = E.2 * E.3
</PRE>
Alternatively we can build all central extensions of U by G.
<P>
<P>
<PRE>
&gt; E := CentralExtensions(G, U, A);   
&gt; "Number of extensions is ", #E;
Number of extensions is  8
</PRE>
Next, we provide an example of using the central extension process.
Firstly, we create the groups and initialize the process.
<P>
<P>
<PRE>
&gt; G := SmallGroup(12, 5);
&gt; U := AbelianGroup(GrpPC, [2, 3]);  
&gt; P := CentralExtensionProcess(G, U);
</PRE>
Now we run over the central extensions and count conjugacy classes.
<P>
<P>
<PRE>
&gt; C := [];
&gt; while IsEmpty(P) eq false do
&gt;    NextExtension(~P, ~E);
&gt;    Append(~C, #Classes (E));
&gt; end while;
&gt; "# conjugacy classes is ", C;
# conjugacy classes is  [ 45, 72, 45, 72, 45, 72, 45, 72, 45, 72, 45,
72, 45, 72, 45, 72, 45, 72, 45, 72, 45, 72, 45, 72 ]
</PRE>
<HR>
<PRE></PRE> <A  HREF = "text722.htm">[Next]</A><A  HREF = "text720.htm">[Prev]</A> <A  HREF = "text722.htm">[Right]</A> <A  HREF = "text720.htm">[Left]</A> <A  HREF = "text706.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<br><small>Version: V2.22 of <I>
Thu Jun  9 16:37:49 EST 2016
</I></small>
</body></html>