<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <link rel='stylesheet' href='help.css' type='text/css'>
  <TITLE>Pad&eacute;-Hermite Approximants</TITLE>
</head>
<body BGCOLOR="#FFFFFF">

 <A  HREF = "text433.htm">[Next]</A><A  HREF = "text438.htm">[Prev]</A> <A  HREF = "text433.htm">[Right]</A> <A  HREF = "text438.htm">[Left]</A> <A  HREF = "text434.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<PRE></PRE><H3><A NAME = "4490">Pad&eacute;-Hermite Approximants</A></H3>

<P>
<P>
-Hermite approximants}



<H5>Subsections</H5>
<UL>
<LI> <A  HREF = "text439.htm#4491">Introduction</A>
<LI> <A  HREF = "text439.htm#4492">Ordering of Sequences</A>
<LI> <A  HREF = "text439.htm#4502">Approximants</A>
</UL>
<H4><A NAME = "4491">Introduction</A></H4>

<P>
<P>
<P>
A given rational function F(z)&isin;k(z) over a field k
can be written as a power series f(z)
in the completion k((z)) of k(z) at the place (z). 
It thus is a good approximation of f(z) in the sense that F(z) is equal
to f(z) up to infinite order.
<P>
Pad&eacute;-Hermite approximants deal with the converse.
Given a (formal) power series f(z)&isin;k[[z]] and some non- negative integers
n<sub>P</sub> and n<sub>Q</sub>, find polynomials P(z), Q(z)&isin;k[z] of degrees at most n<sub>P</sub> and n<sub>Q</sub>, 
respectively, such that P(z) * f(z) - Q(z) = O(z<sup>n<sub>P</sub> + n<sub>Q</sub> + 1</sup>) holds.
In other words, P/Q(z) is an approximation for f(z)
for polynomials P and Q of limited degree in z.
In this notation the pair [P, Q] is known as the Pad&eacute;-Hermite approximant 
for the power series tuple (f, - 1).
<P>
The idea of approximating one power series by two polynomials can be extended to
approximating several power series at the same time as follows.
Consider the vector underline(f)<sup>T</sup>:= (f<sub>1</sub>, f<sub>2</sub>, ..., f<sub>m</sub>)<sup>T</sup> in the m-dimensional vector
space k((z))<sup>m</sup> over a power series ring.
Let underline(n)=(n<sub>1</sub>, n<sub>2</sub>, ..., n<sub>m</sub>) be an m-tuple of non-negative integers.
A <I>Pad&eacute;-Hermite approximant</I> of underline(f)<sup>T</sup>(z) of type 
underline(n) is a non-zero vector of
polynomials underline(P)=(P<sub>1</sub>, P<sub>2</sub>, ..., P<sub>m</sub>) 
in k[z]<sup>m</sup> such that underline(P).underline(f)<sup>T</sup> = O(z<sup>N</sup>) ,
N=n<sub>1</sub> + n<sub>2</sub> + ... + n<sub>m</sub> + m - 1, is satisfied.
A non-trivial Pad&eacute;-Hermite approximant always exists.
The approximant is contained in the sub-space
V_(underline(f), N)={ underline(Q)&isin;k[z]<sup>m</sup> : underline(Q).underline(f)<sup>T</sup> = O(z<sup>N</sup>)}.
<P>
The implementation of Pad&eacute;-Hermite approximants is based on 
<A  HREF = "text433.htm#bib_Derksen94">[Der94]</A> and <A  HREF = "text433.htm#bib_BL94">[BL94]</A>.
They are implemented in Magma as sequences rather than vectors.
<P>


<H4><A NAME = "4492">Ordering of Sequences</A></H4>

<P>
<P>
<P>
A Pad&eacute;-Hermite approximant to some sequence of power series does not have to be
unique. 
They can be ordered according to their maximum degree and their type of sequence.
A sequence underline(P)=[P<sub>1</sub>, P<sub>2</sub>, ..., P<sub>m</sub>] is of degree i if the maximum of the weak
degrees of P<sub>1</sub>, P<sub>2</sub>, ..., P<sub>m</sub> is i. 
An extension of the definition maximum degree  is when a distortion of
non-negative integers
underline(d)=[d<sub>1</sub>, d<sub>2</sub>, ..., d<sub>m</sub>] on the degrees is allowed.
In this case the maximum degree is defined as the maximum of deg(P<sub>i</sub>) - d<sub>i</sub>.
The type of underline(P) identifies the last P<sub>i</sub> in underline(P) 
whose weak degree equals the maximum degree of underline(P).
Again a distortion on the degrees is allowed.


<P>
<P>
<P>
The Pad&eacute;-Hermite approximant of underline(f) can be seen as an element
of the free module k[z]<sup>m</sup> of rank m, or as an element of the sub-space V_(underline(f), N).
<P>
A free sub-model V&sub;k[z]<sup>m</sup> is generated by m polynomial
vectors underline(Q)<sub>i</sub>, 1=1, 2, ..., m, such that 
underline(Q)<sub>1</sub>(z),  underline(Q)<sub>2</sub>(z), ..., underline(Q)<sub>m</sub>(z) form
a minimal vector sequence of V.
Such a sequence is defined as a sequence S of m vectors in V,
such that S[i] is a non-trivial polynomial vector in V of minimal degree
of type i, for i=1, 2, ..., m.
A minimal vector sequence is not unique.
<P>
Two variations on a minimal vector sequence are implemented. The
first allows a distortion as an attribute.  
The sequence is the based on the distorted maximal degree.
The second attribute sets the positive power p  of z in each of the
underline(Q)<sub>i</sub> as follows.
Instead of considering  underline(Q)<sub>i</sub>(z) for each i, one considers
underline(Q)<sub>i</sub>(z<sup>p</sup>).
<H5><A NAME = "4493">MaximumDegree(f) : SeqEnum -&gt; RngIntElt</A></H5>

<PRE>    Distortion: SeqEnum                 Default: []</PRE>
<BLOCKQUOTE>
MaximumDegree returns the degree of a sequence of polynomials or power series, 
defined as the maximum of the degrees of f[i] - d[i], where d is the distortion.
The value -infinity is returned in the case that f is weakly equal 
to the zero-sequence.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "4494">Example <TT>FldFunRat_degree-of-sequence (H43E4)</TT></A></H3>
<P>
<P>
<PRE>
&gt; S&lt;u&gt; := PowerSeriesRing(Rationals());
&gt; f := [u+u^2, 2+u^2+u^3,0];
&gt; MaximumDegree(f);
3
&gt; MaximumDegree(f:Distortion:=[]);
3
&gt; MaximumDegree(f:Distortion:=[0,2,1]);
2
&gt; MaximumDegree([S|0,0]);
-Infinity
&gt; MaximumDegree([O(u)]);
-Infinity
</PRE>
<HR>
<H5><A NAME = "4495">TypeOfSequence(f) : SeqEnum -&gt; RngIntElt, RngIntElt</A></H5>

<PRE>    Distortion: SeqEnum                 Default: []</PRE>
<BLOCKQUOTE>
Returns  the highest index i  for those f[i] whose (distorted) degree is weakly equal to 
the maximum of the degrees of all entries.
The second integer returned is the maximum degree of the sequence.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "4496">Example <TT>FldFunRat_type-of-sequence (H43E5)</TT></A></H3>
<P>
<P>
<PRE>
&gt; S&lt;u&gt; := PowerSeriesRing(Rationals());
&gt; f := [u+u^2, 2+u^2+u^3,0];
&gt; TypeOfSequence(f);
2 3
&gt; TypeOfSequence(f:Distortion:=[]);
2 3
&gt; TypeOfSequence(f:Distortion:=[0,2,1]);
1 2
&gt; TypeOfSequence([S|0,0]);
2 -Infinity
</PRE>
<HR>
<H5><A NAME = "4497">MinimalVectorSequence(f,n) : SeqEnum, RngIntElt -&gt; SeqEnum</A></H5>

<PRE>    Distortion: SeqEnum                 Default: []</PRE>

<PRE>    Power: RngIntElt                    Default: 1</PRE>
<BLOCKQUOTE>
A minimal sequence of vectors underline(Q)<sub>1</sub>, underline(Q)<sub>2</sub>, ..., underline(Q)<sub>m</sub> with respect to
the sequence f of length m whose entries are polynomials or power series. 
The order of  underline(Q)<sub>i</sub>.f is at least m.
<P>
</BLOCKQUOTE>
<HR>
<H3><A NAME = "4498">Example <TT>FldFunRat_minimal-vector-sequence (H43E6)</TT></A></H3>
<P>
<P>
<PRE>
&gt; S&lt;u&gt; := PowerSeriesRing(Rationals());
&gt; f := [u+u^2, 2+u^2+u^3];
&gt; seq := MinimalVectorSequence(f, 2);
&gt; seq;
[
    (u 0),
    (   -1 1/2*u)
]
&gt; sums := [&amp;+([Q[i]*f[i]: i in [1..#f]]) : Q in seq];
&gt; sums;
[
    u^2 + u^3,
    -u^2 + 1/2*u^3 + 1/2*u^4
]
&gt; seq := MinimalVectorSequence(f,3);
&gt; #seq eq 2,  seq[1], seq[2];
true (u^2   0)
(-1 + u  1/2*u)
</PRE>
<HR>
<H3><A NAME = "4499">Example <TT>FldFunRat_the-next_example (H43E7)</TT></A></H3>
<P>
<P>
<PRE>
&gt; L&lt;x&gt; := PolynomialRing(Rationals());
&gt; f := [1+x, 3-x^2, 5+x+x^3-x^5];
&gt; seq := MinimalVectorSequence(f, 10);
&gt; seq[1];
(-2*x^2 + 6   -2*x - 2          0)
&gt; sums := [&amp;+([Q[i]*f[i]: i in [1..#f]]) : Q in seq];
&gt; sums;
[
    0,
    0,
    x^10
]
</PRE>
<HR>
<H3><A NAME = "4500">Example <TT>FldFunRat_another-example (H43E8)</TT></A></H3>
<P>
<P>
<PRE>
&gt; S&lt;u&gt; := PowerSeriesRing(Rationals());
&gt; f := [2*u^4,2+u^3+u^6];
&gt; seq := MinimalVectorSequence(f, 10);
&gt; seq;
[
    (1/2*u^6       0),
    (-1/2 - 1/4*u^3        1/2*u^4)
]
&gt; sums := [&amp;+([Q[i]*f[i]: i in [1..#f]]) : Q in seq];
&gt; sums;
[
    u^10,
    1/2*u^10
]
</PRE>
<HR>
<H3><A NAME = "4501">Example <TT>FldFunRat_one-more (H43E9)</TT></A></H3>
<P>
<P>
<PRE>
&gt; S&lt;u&gt; := PowerSeriesRing(Rationals());
&gt; f :=  [1+u-7*u^2, 6-3*u+1/2*u^2-u^3, 5-u+u^2];
&gt; seq := MinimalVectorSequence(f, 5);
&gt;  [&amp;+([Q[i]*f[i]: i in [1..#f]]) : Q in seq];
[
    0,
    u^5,
    0
]
&gt; seq := MinimalVectorSequence(f, 5:Distortion:=[2,0,1]);
&gt; [&amp;+([Q[i]*f[i]: i in [1..#f]]) : Q in seq];
[
    -7/2*u^5,
    u^5,
    0
]
&gt; p:=2;
&gt; seq := MinimalVectorSequence(f, 5:Distortion:=[2,0,1], Power:=p);
&gt; sums := [&amp;+([Q[i]*f[i]: i in [1..#f]]) : Q in seq];
&gt; sums;
&gt; mp:= map&lt;S-&gt;S|  x :-&gt; (IsWeaklyZero(x) select 0 
&gt;     else  &amp;+([Coefficient(x,i)*(S.1)^(p*i) : i in Exponents(x)]))
&gt;       + (ISA(Type(v),RngIntElt) select O((S.1)^(p*v)) 
&gt;   else S!0 where v := AbsolutePrecision(x))&gt;;
&gt; sums := [&amp;+([mp(Q[i])*f[i]: i in [1..#f]]) : Q in seq];
&gt; sums;
[
    u^6 + u^7 - 7*u^8,
    u^5 - 23/3*u^6,
    -5/3*u^5 + 35/3*u^6
]                
</PRE>
<HR>
<H4><A NAME = "4502">Approximants</A></H4>

<P>
<P>
<P>
The Pad&eacute;-Hermite approximant of type underline(d)=[d<sub>1</sub>, d<sub>2</sub>, ..., d<sub>m</sub>]
with respect to the tuple underline(f)<sup>T</sup>&isin;k((z))<sup>m</sup> is an element
of the space V_(underline(f), N)={ underline(Q)&isin;k[z]<sup>m</sup> : underline(Q).underline(f)<sup>T</sup> = O(z<sup>N</sup>)} for N equal to d<sub>1</sub> + d<sub>2</sub> + ... + d<sub>m</sub> + m - 1.
This space 
is generated by the vectors in the minimal vector sequence with respect to 
underline(f) with distortion underline(d).
The routine  <A  HREF = "text439.htm#PadHermApp">PadeHermiteApproximant</A> returns one that is smallest with respect to the degree on sequences. 
The input sequence underline(f) must be a sequence of polynomial ring elements, or be a power series sequence.
While the Pad&eacute; Hermite approximants theoretically are polynomials, Magma returns
them as elements of the same ring the entries of underline(f) are contained in.


<P>
<P>
<P>
A variant of the Pad&eacute;-Hermite approximant is 
when the exponent in the order term is set rather that the type
of the sequence. 
It is also possible to let underline(f) be a sequence
such that its entries themselves are vectors of polynomials or power series.
<H5><A NAME = "4503"></A><A NAME = "PadHermApp">PadeHermiteApproximant</A>(f,d) : SeqEnum, SeqEnum -&gt; ModTupRngElt, SeqEnum, RngIntElt</H5>

<PRE>    Power: RngIntElt                    Default: 1</PRE>
<BLOCKQUOTE>
Returns a Pad&eacute;-Hermite form underline(P) of f with distortion d, smallest with respect
to the degree on sequences, and the corresponding minimal vector sequence.
The third argument returned is the order in the order term of underline(P).f.
<P>
<P>
</BLOCKQUOTE>
<HR>
<H3><A NAME = "4504">Example <TT>FldFunRat_pade-hermite-approximants (H43E10)</TT></A></H3>
This example can be found on page 813 in <A  HREF = "text433.htm#bib_BL94">[BL94]</A>.
<P>
<P>
<PRE>
&gt; S&lt;u&gt; := PowerSeriesRing(Rationals());
&gt; f := [1,u,u/(1-u^4)+u^10+O(u^16),u/(1+u^4)+u^12+O(u^16)];
&gt; pade, padebasis, ord := PadeHermiteApproximant(f,[2,2,2,2]);
&gt; pade, ord;
( u -1  0  0)
11
&gt; BaseRing(Parent(pade)) eq S;
true
&gt; MinimalVectorSequence(f,10);
[
    ( u -1  0  0),
    (   0  u^4 -1/2  1/2),
    (         0    1 - u^4 -1/2 + u^4       -1/2),
    (    0    -u 1/2*u 1/2*u)
]
&gt;
&gt; p := 2;
&gt; seq := MinimalVectorSequence(f,10: Distortion :=[2,2,2,2],Power := p);
&gt; seq;
[
    (u^5   0   0   0),
    (   0  u^2 -1/2  1/2),
    (         0    1 - u^2 -1/2 + u^2       -1/2),
    (    0    -u 1/2*u 1/2*u)
]
&gt; mp:= map&lt;S-&gt;S|  x :-&gt; (IsWeaklyZero(x) select 0 
&gt;     else  &amp;+([Coefficient(x,i)*(S.1)^(p*i) : i in Exponents(x)]))
&gt;       + (ISA(Type(v),RngIntElt) select O((S.1)^(p*v)) 
&gt;   else S!0 where v := AbsolutePrecision(x))&gt;;
&gt; sums := [&amp;+([mp(Q[i])*f[i]: i in [1..#f]]) : Q in seq];
&gt; [Valuation(v) : v in sums];
[ 10, 10, 10, 11 ]
&gt; sums;
[
    u^10,
    -1/2*u^10 + 1/2*u^12 - u^13 + O(u^16),
    -1/2*u^10 - 1/2*u^12 + u^13 + u^14 + O(u^16),
    u^11 + 1/2*u^12 + 1/2*u^14 + O(u^18)
]
</PRE>
<HR>
<H3><A NAME = "4505">Example <TT>FldFunRat_last-example (H43E11)</TT></A></H3>
This example covers the example on page 815 in <A  HREF = "text433.htm#bib_BL94">[BL94]</A>.
<P>
<P>
<PRE>
&gt; S&lt;u&gt; := PowerSeriesRing(Rationals());
&gt; f := [1,u, -1-u^4-2*u^8+u^10+u^11-u^12+O(u^16),-u-u^5-u^9-u^14-u^15+O(u^16)];
&gt; dist:=[2,2,3,3];
&gt; seq := MinimalVectorSequence(f,13:Distortion:=dist);
&gt; pade, padebasis, ord :=  PadeHermiteApproximant(f,dist);
&gt; pade, ord;
(-u  1  0  0)
13
&gt; padebasis;
[
    (-u  1  0  0),
    (1/2*u -1/2*u^4 1/2*u + 1/2*u^3 + 1/2*u^4 -1/2*u^2 - 1/2*u^3 - u^4),
    (-1/2 1/2*u^3 -1/2 - 1/2*u^2 - 1/2*u^3 - u^4 1/2*u + 1/2*u^2 + 2*u^3),
    (      -u        0        0 -1 + u^4)
]
&gt; padebasis eq seq;
true
&gt; [[Valuation(w[i]): i in [1..Degree(w)]] : w in seq]; 
[
    [ 1, 0, Infinity, Infinity ],
    [ 1, 4, 1, 2 ],
    [ 0, 3, 0, 1 ],
    [ 1, Infinity, Infinity, 0 ]
]
&gt; [[MaximumDegree([w[i]])-dist[i]: i in [1..Degree(w)] ] : w in seq]; 
[
    [ -1, -2, -Infinity, -Infinity ],
    [ -1, 2, 1, 1 ],
    [ -2, 1, 1, 0 ],
    [ -1, -Infinity, -Infinity, 1 ]
]
&gt; p:=2;
&gt; seq := MinimalVectorSequence(f,12:Distortion:=dist,Power:=p);
&gt; seq;
[
    (  u - u^3         0 u - 2*u^3         0),
    (-1 - u + u^2 -u^3 -1 - u + 2*u^2 + u^3 -u^3),
    (u + u^2 - u^3 0 u + u^2 - 2*u^3 - u^4 0),
    (      0       1       0 1 - u^2)
]
&gt; seq[1]-seq[3];
(      -u^2          0 -u^2 + u^4          0)
&gt; mp:= map&lt;S-&gt;S|  x :-&gt; (IsWeaklyZero(x) select 0 
&gt;     else  &amp;+([Coefficient(x,i)*(S.1)^(p*i) : i in Exponents(x)]))
&gt;       + (ISA(Type(v),RngIntElt) select O((S.1)^(p*v)) 
&gt;   else S!0 where v := AbsolutePrecision(x))&gt;;
&gt;  [Valuation(&amp;+([mp(Q[i])*f[i]: i in [1..#f]])) : Q in seq];
[ 12, 12, 13, 13 ]
</PRE>
<HR>
<H3><A NAME = "4506">Example <TT>FldFunRat_ (H43E12)</TT></A></H3>
This example considers the example on page 816 in <A  HREF = "text433.htm#bib_BL94">[BL94]</A>.
<P>
<P>
<PRE>
&gt; S&lt;u&gt; := PowerSeriesRing(Rationals());
&gt; f := [1,u,-1-u^4-2*u^8+u^10+O(u^12),-u-u^5-u^9+u^10+O(u^12)];
&gt; dist := [2,2,3,3];
&gt; seq := MinimalVectorSequence(f,12: Distortion := dist);
&gt; [[MaximumDegree([w[i]])-dist[i]: i in [1..Degree(w)] ] : w in seq]; 
[
    [ -1, -2, -Infinity, -Infinity ],
    [ -2, 1, 0, 0 ],
    [ -Infinity, -Infinity, 1, 0 ],
    [ -1, -Infinity, 0, 1 ]
]
&gt; [Valuation(&amp;+([(Q[i])*f[i]: i in [1..#f]]) ) : Q in seq];
[ Infinity, 12, 12, 12 ]
&gt; [MaximumDegree([ &amp;+([(Q[i])*f[i]: i in [1..#f]]) ]) : Q in seq];
[ -Infinity, -Infinity, 14, -Infinity ]
&gt; PadeHermiteApproximant(f,[2,2,3,3]);
&gt; p := 2;
&gt; seq := MinimalVectorSequence(f,12:Distortion:=[2,2,3,3],Power:=p);
&gt; seq;
[
    (  1 - u^2        -1 1 - 2*u^2  -1 + u^2),
    (   0 -u^4    0 -u^4),
    (      -u       -1 -u + u^3 -1 + u^2),
    (      0       u       0 u - u^3)
]
&gt; [[MaximumDegree([w[i]])-dist[i]: i in [1..Degree(w)] ] : w in seq]; 
[
    [ 0, -2, -1, -1 ],
    [ -Infinity, 2, -Infinity, 1 ],
    [ -1, -2, 0, -1 ],
    [ -Infinity, -1, -Infinity, 0 ]
]
&gt; mp:= map&lt;S-&gt;S|  x :-&gt; (IsWeaklyZero(x) select 0 
&gt;     else  &amp;+([Coefficient(x,i)*(S.1)^(p*i) : i in Exponents(x)]))
&gt;       + (ISA(Type(v),RngIntElt) select O((S.1)^(p*v)) 
&gt;   else S!0 where v := AbsolutePrecision(x))&gt;;
&gt;		  
&gt; [Valuation(&amp;+([mp(Q[i])*f[i]: i in [1..#f]])) : Q in seq];		  
[ 12, 13, 12, 12 ]
</PRE>
<HR>
<H5><A NAME = "4507">PadeHermiteApproximant(f,m) : SeqEnum, RngIntElt -&gt; ModTupRngElt, SeqEnum</A></H5>

<PRE>    Power: RngIntElt                    Default: 1</PRE>
<BLOCKQUOTE>
Returns a Pad&eacute;-Hermite form of minimal degree in the corresponding
minimal vector sequence, such that its inproduct with f has order at least m.
The second argument returned is the corresponding minimal vector sequence.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "4508">Example <TT>FldFunRat_pade-hermite-approximants-vectors (H43E13)</TT></A></H3>
This example can be found on page 813 in <A  HREF = "text433.htm#bib_BL94">[BL94]</A>.
<P>
<P>
<PRE>
&gt; S&lt;u&gt; := PowerSeriesRing(Rationals());
&gt; f := [Vector([1]), Vector([u])];
&gt; pade, seq := PadeHermiteApproximant(f,3);
Calculating the Pade'-Hermite approximant for the sequence [
    1,
    u
]
with order term 3 and power 1 .
&gt; pade;
( u -1)
&gt; seq;
[
    ( u -1),
    (  0 u^2)
]
&gt; mat := Matrix([Eltseq(v): v in f]);
&gt; pade*mat;
(0)
&gt; PadeHermiteApproximant([1,u],5);
( u -1)
[
    ( u -1),
    (  0 u^4)
]
&gt; PadeHermiteApproximant(f,3:Power:=2);
&gt; g:= [Vector([1,0,0]), Vector([0,1,0]), Vector([1+u,2+u^2,u^3])];
&gt; pade := PadeHermiteApproximant(g,5);
Calculating the Pade'-Hermite approximant for the sequence [
    1,
    u,
    1 + 2*u + u^3 + u^7 + u^11
]
with order term 15 and power 3 .
&gt; pade;
(-u^3 - u^4     -2*u^3        u^3)
&gt; pade*Matrix([Eltseq(v): v in g]);
(  0 u^5 u^6)
</PRE>
<HR>
<H3><A NAME = "4509">Example <TT>FldFunRat_ (H43E14)</TT></A></H3>
This example considers Pad&eacute;-Hermite approximants for some
series that have non-trivial power series expansions.
<P>
<P>
<PRE>
&gt; S&lt;u&gt; := PowerSeriesRing(Rationals());
&gt; f := [Sin(u), Cos(u), Exp(u)];
&gt; [Valuation(f[i]) : i in [1..#f]], [Degree(f[i]) : i in [1..#f]];
[ 1, 0, 0 ]
[ 19, 20, 20 ]
&gt; [AbsolutePrecision(f[i]) : i in [1..#f]];
[ 21, 22, 21 ]
&gt; dist := [3,2,5];
&gt; pade, seq, ord := PadeHermiteApproximant(f,dist);
&gt; 1/420*pade;
(-1275 - 255*u + 45*u^2 + 5*u^3 120 + 495*u + 75*u^2 -120 + 900*u - 600*u^2 + 
    160*u^3 - 20*u^4 + u^5)
&gt; ord eq &amp;+(dist)+#f-1, ord;
true 12
&gt; [Degree(pade[i]) : i in [1..Degree(pade)]];
[ 3, 2, 5 ]
&gt; g:= [Cos(2*u)*(u+1)+3,Cos(u)^2+u*Cos(u)+1,Cos(2*u)+1,Cos(u)];
&gt; pade, basis := PadeHermiteApproximant(g,20);
&gt; 131/75880*pade;
(          2    -4 + 2*u        -3*u 4*u - 2*u^2)
&gt; h := [ 1+u^2-u^7+u^12, Sin(u), Exp(u) ];
&gt; dist:=[3,1,2];
&gt; seq := MinimalVectorSequence(h,8:Distortion := dist);
&gt; sums := [&amp;+([Q[i]*h[i]: i in [1..#f]]) : Q in seq];
&gt; [Valuation(s) : s in sums];
[ 8, 8, 8 ]
&gt; [[MaximumDegree([w[i]]): i in [1..Degree(w)] ] : w in seq];        
[
    [ 4, 1, 2 ],
    [ 4, 2, 2 ],
    [ 3, 1, 2 ]
]
&gt;  [[MaximumDegree([w[i]])-dist[i]: i in [1..Degree(w)] ] : w in seq]; 
[
    [ 1, 0, 0 ],
    [ 1, 1, 0 ],
    [ 0, 0, 0 ]
]
</PRE>
<PRE></PRE> <A  HREF = "text433.htm">[Next]</A><A  HREF = "text438.htm">[Prev]</A> <A  HREF = "text433.htm">[Right]</A> <A  HREF = "text438.htm">[Left]</A> <A  HREF = "text434.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<br><small>Version: V2.22 of <I>
Thu Jun  9 16:37:49 EST 2016
</I></small>
</body></html>