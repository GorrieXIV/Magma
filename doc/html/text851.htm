<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <link rel='stylesheet' href='help.css' type='text/css'>
  <TITLE>Working with Elements of a  Braid Group</TITLE>
</head>
<body BGCOLOR="#FFFFFF">

 <A  HREF = "text852.htm">[Next]</A><A  HREF = "text850.htm">[Prev]</A> <A  HREF = "text852.htm">[Right]</A> <A  HREF = "text850.htm">[Left]</A> <A  HREF = "text847.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<PRE></PRE><H3><A NAME = "9790">Working with Elements of a  Braid Group</A></H3>




<H5>Subsections</H5>
<UL>
<LI> <A  HREF = "text851.htm#9791">Accessing Information</A>
<LI> <A  HREF = "text851.htm#9804">Computing Normal Forms of  Elements</A>
<LI> <A  HREF = "text851.htm#9812">Arithmetic Operators and Functions for Elements</A>
<LI> <A  HREF = "text851.htm#9832">Boolean Predicates for Elements</A>
<LI> <A  HREF = "text851.htm#9847">Lattice Operations</A>
<LI> <A  HREF = "text851.htm#9857">Invariants of Conjugacy Classes</A>
</UL>
<H4><A NAME = "9791">Accessing Information</A></H4>

<P>
<P>
<P>
<P>
This sections describes how the internal representations of an element
and a number of basic invariants can be accessed.


<H5><A NAME = "9792"></A><A NAME = "GrpBrd:Parent">Parent</A>(u) : GrpBrdElt -&gt; GrpBrd</H5>
<BLOCKQUOTE>
Given an element u of a braid group B, return the parent group of u,
that is B.
</BLOCKQUOTE>
<H5><A NAME = "9793"># u : GrpBrdElt -&gt; RngIntElt</A></H5>
<BLOCKQUOTE>
Given an element u of a braid group B, return the length of the
representing word in the generators corresponding to the presentation
selected for B.  Note that this is not an invariant of u.
</BLOCKQUOTE>
<H5><A NAME = "9794"></A><A NAME = "GrpBrd:CanonicalFactorRepresentation">CanonicalFactorRepresentation</A>(u: parameters) : GrpBrdElt -&gt; Tup</H5>
<H5>CFP(u: parameters) : GrpBrdElt -&gt; Tup</H5>

<PRE>    Presentation: MonStgElt             Default: </PRE>
<BLOCKQUOTE>
Given an element u of a braid group B, return a tuple T = &lt;s, l, S, r&gt;
describing the
representation in terms of simple elements for the presentation
indicated by the value of the parameter <TT>Presentation</TT>.  If no value
for <TT>Presentation</TT> is given, the presentation selected for B is used.
<P>
The interpretation of the components of T is as follows: s is a string,
either equal to <TT>"Artin"</TT> or equal to <TT>"BKL"</TT> indicating the presentation,
l and r are integers and S is a sequence [p<sub>1</sub>, ..., p<sub>k</sub>] of
permutations on n points, such that
 D<sup>l</sup> c<sub>1</sub> ... c<sub>k</sub> D<sup>r</sup> 
is the representation of u in terms of simple elements, where D is the
fundamental element and c<sub>j</sub> is the simple element defined by p<sub>j</sub>
(j=1, ..., k) in the presentation indicated by s.
</BLOCKQUOTE>
<H5><A NAME = "9795">WordToSequence(u: parameters) : GrpBrdElt -&gt; SeqEnum</A></H5>
<H5>ElementToSequence(u: parameters) : GrpBrdElt -&gt; SeqEnum</H5>
<H5>Eltseq(u: parameters) : GrpBrdElt -&gt; SeqEnum</H5>

<PRE>    Presentation: MonStgElt             Default: </PRE>
<BLOCKQUOTE>
Given an element u of a braid group B, return a sequence describing the
representing word in the generators corresponding to the presentation
indicated by the value of the parameter <TT>Presentation</TT>.  If no value
for <TT>Presentation</TT> is given, the presentation selected for B is used.
<P>
For a representing word
s_{i_1}^{e_1}...s_{i_k}^{e_k}
in the Artin generators with 0&lt;i<sub>j</sub>&lt;n and e<sub>j</sub>&isin;{-1, 1} for
j=1, ..., k, the sequence of integers
 [ e<sub>1</sub> i<sub>1</sub>, ..., e<sub>k</sub> i<sub>k</sub> ] 
is returned.
<P>
For a representing word
 a<sub>r<sub>1</sub>, t<sub>1</sub></sub><sup>e<sub>1</sub></sup>...a<sub>r<sub>k</sub>, t<sub>k</sub></sub><sup>e<sub>k</sub></sup> 
in the BKL generators with 1&le;t<sub>j</sub> &lt; r<sub>j</sub>&le;n and e<sub>j</sub>&isin;{-1, 1} for
j=1, ..., k, the sequence of tuples
 [ &lt;e<sub>1</sub> r<sub>1</sub>, e<sub>1</sub> t<sub>1</sub>&gt;, ..., &lt;e<sub>k</sub> r<sub>k</sub>, e<sub>k</sub> t<sub>k</sub>&gt; ] 
is returned.
</BLOCKQUOTE>
<H5><A NAME = "9796">InducedPermutation(u) : GrpBrdElt -&gt; GrpPermElt</A></H5>
<BLOCKQUOTE>
Given an element u of a braid group B on n strings, return the
permutation on n points induced by u acting on the strings on which B
is defined.
</BLOCKQUOTE>
<P>
In the following descriptions of the functions <A  HREF = "text851.htm#GrpBrd:CanonicalLength">CanonicalLength</A>,
<A  HREF = "text851.htm#GrpBrd:Infimum">Infimum</A> and <A  HREF = "text851.htm#GrpBrd:Supremum">Supremum</A>, let D be the fundamental
element and let  D<sup>l</sup> c<sub>1</sub> ... c<sub>k</sub>  be the left normal form of the element
u of the braid group B in the presentation indicated by the value of the
parameter <TT>Presentation</TT>.  If no value for <TT>Presentation</TT> is given,
the presentation selected for B is used.
<H5><A NAME = "9797"></A><A NAME = "GrpBrd:CanonicalLength">CanonicalLength</A>(u: parameters) : GrpBrdElt -&gt; RngIntElt</H5>

<PRE>    Presentation: MonStgElt             Default: </PRE>
<BLOCKQUOTE>
Given an element u of a braid group B, return the canonical length
k of u for the appropriate presentation of B.  The argument is
converted into left normal form.
</BLOCKQUOTE>
<H5><A NAME = "9798"></A><A NAME = "GrpBrd:Infimum">Infimum</A>(u: parameters) : GrpBrdElt -&gt; RngIntElt</H5>

<PRE>    Presentation: MonStgElt             Default: </PRE>
<BLOCKQUOTE>
Given an element u of a braid group B, return the infimum
l of u for the appropriate presentation of B.  The argument is
converted into left normal form.
</BLOCKQUOTE>
<H5><A NAME = "9799"></A><A NAME = "GrpBrd:Supremum">Supremum</A>(u: parameters) : GrpBrdElt -&gt; RngIntElt</H5>

<PRE>    Presentation: MonStgElt             Default: </PRE>
<BLOCKQUOTE>
Given an element u of a braid group B, return the supremum
l + k of u for the appropriate presentation of B.  The argument is
converted into left normal form.
</BLOCKQUOTE>
<P>
In the descriptions of the functions
<A  HREF = "text851.htm#GrpBrd:SuperSummitCanonicalLength">SuperSummitCanonicalLength</A>,
<A  HREF = "text851.htm#GrpBrd:SuperSummitInfimum">SuperSummitInfimum</A> and <A  HREF = "text851.htm#GrpBrd:SuperSummitSupremum">SuperSummitSupremum</A>
which follow,
let D be the fundamental
element and let  D<sup>l</sup> c<sub>1</sub> ... c<sub>k</sub>  be the normal form of a representative
of the super summit set the element u of the braid group B with respect
to the presentation indicated by the value of the
parameter <TT>Presentation</TT>.  If no value for <TT>Presentation</TT> is given,
the presentation selected for B is used.
<H5><A NAME = "9800"></A><A NAME = "GrpBrd:SuperSummitCanonicalLength">SuperSummitCanonicalLength</A>(u: parameters) : GrpBrdElt -&gt; RngIntElt</H5>

<PRE>    Presentation: MonStgElt             Default: </PRE>
<BLOCKQUOTE>
Given an element u of a braid group B, return the canonical length
k of a representative of the super summit set of u with respect to
the appropriate presentation of B, that is, the minimal canonical length
among all conjugates of u.  The argument is
converted into left normal form.
</BLOCKQUOTE>
<H5><A NAME = "9801"></A><A NAME = "GrpBrd:SuperSummitInfimum">SuperSummitInfimum</A>(u: parameters) : GrpBrdElt -&gt; RngIntElt</H5>

<PRE>    Presentation: MonStgElt             Default: </PRE>
<BLOCKQUOTE>
Given an element u of a braid group B, return the infimum
l of a representative of the super summit set of u with respect to
the appropriate presentation of B, that is, the maximal infimum
among all conjugates of u.  The argument is
converted into left normal form.
</BLOCKQUOTE>
<H5><A NAME = "9802"></A><A NAME = "GrpBrd:SuperSummitSupremum">SuperSummitSupremum</A>(u: parameters) : GrpBrdElt -&gt; RngIntElt</H5>

<PRE>    Presentation: MonStgElt             Default: </PRE>
<BLOCKQUOTE>
Given an element u of a braid group B, return the supremum
l + k of a representative of the super summit set of u with respect to
the appropriate presentation of B, that is, the minimal supremum
among all conjugates of u.  The argument is
converted into left normal form.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "9803">Example <TT>GrpBrd_Access (H78E2)</TT></A></H3>
We define the braid group B on 6 strings using the BKL presentation and
create an element u as a random word of length between 5 and 10 in the
BKL generators.
<P>
<P>
<PRE>
&gt; B := BraidGroup(6 : Presentation := "BKL");
&gt; u := RandomWord(B, 5, 10);
</PRE>
The parent group of u can be accessed using the function
<A  HREF = "text851.htm#GrpBrd:Parent">Parent</A>. 
<P>
<P>
<PRE>
&gt; Parent(u);
GrpBrd : B on 6 strings
</PRE>
As word in the BKL generators, u has length 5.  We define a sequence
describing the representation of u as word in the BKL generators.
<P>
<P>
<PRE>
&gt; #u;
5
&gt; seq_BKL := WordToSequence(u);
&gt; seq_BKL;
[ &lt;5, 1&gt;, &lt;5, 2&gt;, &lt;5, 4&gt;, &lt;4, 1&gt;, &lt;2, 1&gt; ]
</PRE>
When we ask for a representation as word in the Artin generators, such a
representation is created automatically.
<P>
<P>
<PRE>
&gt; seq_Artin := WordToSequence(u : Presentation := "Artin");
&gt; seq_Artin;
[ 4, 3, 2, 1, 2, 1, -2, -3, 1 ]
</PRE>
We now define the permutation p induced by u on the strings on which
B is defined.
<P>
<P>
<PRE>
&gt; p := InducedPermutation(u);
&gt; p;
(4, 5)
</PRE>
The representation of u in terms of simple elements for the Artin
presentation can be obtained using the function
<A  HREF = "text851.htm#GrpBrd:CanonicalFactorRepresentation">CanonicalFactorRepresentation</A>.
<P>
<P>
<PRE>
&gt; CanonicalFactorRepresentation(u : Presentation := "Artin");
&lt;Artin, 0, [
    (1, 5, 4, 3),
    (1, 2),
    (1, 6)(2, 5, 3),
    (5, 6)
], -1&gt;
</PRE>
We now compute the canonical lengths of u with respect to the Artin
presentation and with respect to the BKL presentation.  Note that these
lengths are different.
<P>
<P>
<PRE>
&gt; CanonicalLength(u : Presentation := "Artin");
4
&gt; CanonicalLength(u : Presentation := "BKL");
3
</PRE>
Finally, we compute for both presentations the canonical lengths of a
super summit representative of u.
<P>
<P>
<PRE>
&gt; SuperSummitCanonicalLength(u : Presentation := "Artin");
2
&gt; SuperSummitCanonicalLength(u : Presentation := "BKL");
3
</PRE>
Obviously, u does not belong to its super summit set with respect to the
Artin presentation.  (We cannot tell for the BKL presentation from the
information we have computed.)
<HR>
<H4><A NAME = "9804">Computing Normal Forms of  Elements</A></H4>

<P>
<P>
<P>
<P>
This section describes functions and procedures for computing various normal
forms of elements of a braid group B.  All normal forms are defined in
terms of representations of elements as products of simple elements and
depend on the presentation of B which is used.  The functions documented
in this section all accept a parameter <TT>Presentation</TT> which can be used
to specify the presentation of B with respect to which the computation
should be performed.  Possible values for this parameter are the strings
<TT>"Artin"</TT> and <TT>"BKL"</TT>  If no value is given for <TT>Presentation</TT>, the
presentation selected for B is used.


<H5><A NAME = "9805">LeftNormalForm(u: parameters) : GrpBrdElt -&gt; GrpBrdElt</A></H5>
<H5><A NAME = "GrpBrd:NormalForm">NormalForm</A>(u: parameters) : GrpBrdElt -&gt; GrpBrdElt</H5>

<PRE>    Presentation: MonStgElt             Default: </PRE>
<BLOCKQUOTE>
Given an element u of a braid group B, return a new element of B
defined by the left normal form of u with respect to the indicated
presentation.
</BLOCKQUOTE>
<H5><A NAME = "9806">LeftNormalForm(~u: parameters) : GrpBrdElt -&gt;</A></H5>
<H5>NormalForm(~u: parameters) : GrpBrdElt -&gt;</H5>

<PRE>    Presentation: MonStgElt             Default: </PRE>
<BLOCKQUOTE>
Given an element u of a braid group B, bring u into left normal
form with respect to the indicated presentation.
</BLOCKQUOTE>
<H5><A NAME = "9807">RightNormalForm(u: parameters) : GrpBrdElt -&gt; GrpBrdElt</A></H5>

<PRE>    Presentation: MonStgElt             Default: </PRE>
<BLOCKQUOTE>
Given an element u of a braid group B, return a new element of B
defined by the right normal form of u with respect to the indicated
presentation.
</BLOCKQUOTE>
<H5><A NAME = "9808">RightNormalForm(~u: parameters) : GrpBrdElt -&gt;</A></H5>

<PRE>    Presentation: MonStgElt             Default: </PRE>
<BLOCKQUOTE>
Given an element u of a braid group B, bring u into right normal
form with respect to the indicated presentation.
</BLOCKQUOTE>
<H5><A NAME = "9809">LeftMixedCanonicalForm(u: parameters) : GrpBrdElt -&gt; Tup, Tup</A></H5>
<H5>MixedCanonicalForm(u: parameters) : GrpBrdElt -&gt; Tup, Tup</H5>

<PRE>    Presentation: MonStgElt             Default: </PRE>
<BLOCKQUOTE>
Given an element u of a braid group B, return two tuples T<sub>1</sub> and
T<sub>2</sub> defining products v<sub>1</sub> ... v<sub>k</sub> and w<sub>1</sub> ... w<sub>l</sub>,
respectively, of simple elements for the indicated presentation,
such that v<sub>1</sub> ... v<sub>k</sub> and w<sub>1</sub> ... w<sub>l</sub> are in left normal form,
the left-gcd of v<sub>1</sub> and w<sub>1</sub> is trivial and
 u = (v<sub>1</sub> ... v<sub>k</sub>)<sup> - 1</sup> (w<sub>1</sub> ... w<sub>l</sub>).
<P>
See the entry for <A  HREF = "text851.htm#GrpBrd:CanonicalFactorRepresentation">CanonicalFactorRepresentation</A> for a
description of the tuple format.  Note that the tuples can
be coerced into elements of B using the coercion operator
`<A  HREF = "text850.htm#GrpBrd:coerce_tuple">!</A>'.
</BLOCKQUOTE>
<H5><A NAME = "9810">RightMixedCanonicalForm(u: parameters) : GrpBrdElt -&gt; Tup, Tup</A></H5>

<PRE>    Presentation: MonStgElt             Default: </PRE>
<BLOCKQUOTE>
Given an element u of a braid group B, return two tuples T<sub>1</sub> and
T<sub>2</sub> defining products v<sub>1</sub> ... v<sub>k</sub> and w<sub>1</sub> ... w<sub>l</sub>,
respectively, of simple elements for the indicated presentation,
such that v<sub>1</sub> ... v<sub>k</sub> and w<sub>1</sub> ... w<sub>l</sub> are in right normal form,
the right-gcd of v<sub>1</sub> and w<sub>1</sub> is trivial and
 u = (v<sub>1</sub> ... v<sub>k</sub>) (w<sub>1</sub> ... w<sub>l</sub>)<sup> - 1</sup>.
<P>
See the entry for <A  HREF = "text851.htm#GrpBrd:CanonicalFactorRepresentation">CanonicalFactorRepresentation</A> for a
description of the tuple format.  Note that the tuples can
be coerced into elements of B using the coercion operator
`<A  HREF = "text850.htm#GrpBrd:coerce_tuple">!</A>'.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "9811">Example <TT>GrpBrd_NormalForm (H78E3)</TT></A></H3>
We define the braid group B on 6 strings using the Artin presentation,
set the print format for elements to <TT>"CFP"</TT> and define an element u
of B.
<P>
<P>
<PRE>
&gt; B := BraidGroup(6);
&gt; SetElementPrintFormat(~B, "CFP");
&gt; 
&gt; u := B ! &lt;"Artin",
&gt;          0,
&gt;          [ Sym(6) | (1,6)(3,5,4), (1,3)(2,6)(4,5), (2,3)],
&gt;          0&gt;;
&gt; u;
&lt;Artin, 0, [
    (1, 6)(3, 5, 4),
    (1, 3)(2, 6)(4, 5),
    (2, 3)
], 0&gt;
</PRE>
We compute and print the left normal form of u with respect to the Artin
presentation of B.
<P>
<P>
<PRE>
&gt; u_Artin := LeftNormalForm(u);
&gt; u_Artin;
&lt;Artin, 1, [
    (1, 2, 6, 5, 4, 3),
    (2, 3)
], 0&gt;
</PRE>
We now compute the left normal form of u with respect to the BKL
presentation of B.  Since elements are printed with respect to the
presentation selected for the parent group, that is, in the Artin
presentation in our example, we use the function
<A  HREF = "text851.htm#GrpBrd:CanonicalFactorRepresentation">CanonicalFactorRepresentation</A> to print the representation
in terms of simple elements for the BKL presentation.
<P>
<P>
<PRE>
&gt; u_BKL := LeftNormalForm(u : Presentation := "BKL");
&gt; CFP(u_BKL : Presentation := "BKL");
&lt;BKL, 2, [
    (2, 6, 5, 4, 3),
    (2, 6, 5, 4),
    (2, 6, 5),
    (2, 6),
    (2, 3)
], 0&gt;
</PRE>
We define another element v of B in left normal form.
<P>
<P>
<PRE>
&gt; v := LeftNormalForm(B.5*B.2^-2*B.4*B.3^-1*B.5^-1*B.3^-1*B.5); 
&gt; v;
&lt;Artin, -3, [
    (1, 6)(2, 4, 3, 5),
    (1, 2, 6)(3, 5),
    (1, 6, 2, 5)(3, 4),
    (3, 5)(4, 6)
], 0&gt;
</PRE>
As can easily be read off the representation of v in terms of
simple elements which is in left normal form, v has infimum -3, canonical
length 4 and supremum 1 with respect to the Artin presentation.
<P>
<P>
<PRE>
&gt; Infimum(v);
-3
&gt; CanonicalLength(v);
4
&gt; Supremum(v);
1
</PRE>
Note that infimum, canonical length and supremum of an element can also be
obtained from its right normal form.
<P>
<P>
<PRE>
&gt; RightNormalForm(v);
&lt;Artin, 0, [
    (4, 6, 5),
    (1, 6)(2, 5, 3, 4),
    (1, 6)(2, 4, 5),
    (1, 6)(2, 5)
], -3&gt;
</PRE>
<HR>
<H4><A NAME = "9812">Arithmetic Operators and Functions for Elements</A></H4>

<P>
<P>
<P>
This section describes the basic arithmetic operations for elements of a
braid group.  Strictly speaking, all functions should be considered as
functions on <I>representatives</I> of elements, that is, words in the
generators or products of simple elements.
<P>
Unless stated otherwise, arithmetic operations with elements of a braid
group B are performed using representations with respect to the presentation
selected for B.  This presentation can be changed using the function
<A  HREF = "text849.htm#GrpBrd:SetPresentation">SetPresentation</A>.
<P>
By default, arithmetic operations with elements of B are performed using
representations in terms of simple elements; such representations are
created if necessary.  Experienced users can change this behaviour, if
desired, using the function <A  HREF = "text849.htm#GrpBrd:SetForceCFP">SetForceCFP</A>.
<P>
The complexity of all basic arithmetic operations is linear in the length
of the representations of the input elements.  No normalisations are performed
automatically, as doing so would restrict the user's control of operations
with elements.  It is, however, recommended to use the function
<A  HREF = "text851.htm#GrpBrd:NormalForm">NormalForm</A> or its procedural version in time critical
situations to limit the length of representations of elements; see
Example <A  HREF = "text851.htm#9831">H78E4</A>.


<H5><A NAME = "9813">u * v : GrpBrdElt, GrpBrdElt -&gt; GrpBrdElt</A></H5>
<BLOCKQUOTE>
Given elements u and v belonging to the same braid group B, return
the product uv as a new element of B.
</BLOCKQUOTE>
<H5><A NAME = "9814">u *:= v : GrpBrdElt, GrpBrdElt -&gt;</A></H5>
<BLOCKQUOTE>
Given elements u and v belonging to the same braid group B, replace u
with the product uv.
</BLOCKQUOTE>
<H5><A NAME = "9815">u / v : GrpBrdElt, GrpBrdElt -&gt; GrpBrdElt</A></H5>
<BLOCKQUOTE>
Given elements u and v belonging to the same braid group B, return
the product uv<sup> - 1</sup> as a new element of B.
</BLOCKQUOTE>
<H5><A NAME = "9816">u /:= v : GrpBrdElt, GrpBrdElt -&gt;</A></H5>
<BLOCKQUOTE>
Given elements u and v belonging to the same braid group B, replace u
with the product uv<sup> - 1</sup>.
</BLOCKQUOTE>
<H5><A NAME = "9817">u ^ n : GrpBrdElt, RngIntElt -&gt; GrpBrdElt</A></H5>
<BLOCKQUOTE>
Given an element u of a braid group B and an integer n, return
the power u<sup>n</sup> as a new element of B.
</BLOCKQUOTE>
<H5><A NAME = "9818">u ^:= n : GrpBrdElt, RngIntElt -&gt;</A></H5>
<BLOCKQUOTE>
Given an element u of a braid group B and an integer n, replace u
with the power u<sup>n</sup>.
</BLOCKQUOTE>
<H5><A NAME = "9819">u ^ v : GrpBrdElt, GrpBrdElt -&gt; GrpBrdElt</A></H5>
<BLOCKQUOTE>
Given elements u and v belonging to the same braid group B, return
the conjugate u<sup>v</sup> = v<sup> - 1</sup>uv as a new element of B.
</BLOCKQUOTE>
<H5><A NAME = "9820">u ^:= v : GrpBrdElt, GrpBrdElt -&gt;</A></H5>
<BLOCKQUOTE>
Given elements u and v belonging to the same braid group B, replace u
with the conjugate u<sup>v</sup> = v<sup> - 1</sup>uv.
</BLOCKQUOTE>
<H5><A NAME = "9821">Inverse(u) : GrpBrdElt -&gt; GrpBrdElt</A></H5>
<BLOCKQUOTE>
Given an element u of a braid group B, return its inverse u<sup> - 1</sup> as a
new element of B.
</BLOCKQUOTE>
<H5><A NAME = "9822">Inverse(~u) : GrpBrdElt -&gt;</A></H5>
<BLOCKQUOTE>
Given an element u of a braid group B, replace u with its inverse
u<sup> - 1</sup>.
</BLOCKQUOTE>
<H5><A NAME = "9823"></A><A NAME = "GrpBrd:LeftConjugate">LeftConjugate</A>(u, v) : GrpBrdElt, GrpBrdElt -&gt; GrpBrdElt</H5>
<BLOCKQUOTE>
Given elements u and v belonging to the same braid group B, return
the "left conjugate" vuv<sup> - 1</sup> as a new element of B.
</BLOCKQUOTE>
<H5><A NAME = "9824">LeftConjugate(~u, v) : GrpBrdElt, GrpBrdElt -&gt; GrpBrdElt</A></H5>
<BLOCKQUOTE>
Given elements u and v belonging to the same braid group B, replace u
with the "left conjugate" vuv<sup> - 1</sup>.
</BLOCKQUOTE>
<H5><A NAME = "9825">LeftDiv(u, v) : GrpBrdElt, GrpBrdElt -&gt; GrpBrdElt</A></H5>
<BLOCKQUOTE>
Given elements u and v belonging to the same braid group B, return
the product u<sup> - 1</sup>v as a new element of B.
</BLOCKQUOTE>
<H5><A NAME = "9826">LeftDiv(u, ~v) : GrpBrdElt, GrpBrdElt -&gt; GrpBrdElt</A></H5>
<BLOCKQUOTE>
Given elements u and v belonging to the same braid group B, replace v
with the product u<sup> - 1</sup>v.
</BLOCKQUOTE>
<P>
<P>
<P>
The following functions <A  HREF = "text851.htm#GrpBrd:Cycle">Cycle</A> and <A  HREF = "text851.htm#GrpBrd:Decycle">Decycle</A>
accept a parameter <TT>Presentation</TT> which can be set either to
<TT>"Artin"</TT> or to <TT>"BKL"</TT>.  The results of the cycling and decycling operations
are defined in terms of the left normal form  D<sup>l</sup> c<sub>1</sub> ... c<sub>k</sub>  of the
argument u&isin;B in terms of simple elements for a presentation of B
and the results in general depend on the presentation used.  The results
of these functions are returned in left normal form.
<P>
If no value for the parameter <TT>Presentation</TT> is given, the presentation
selected for the parent group of the argument will be used.
<H5><A NAME = "9827"></A><A NAME = "GrpBrd:Cycle">Cycle</A>(u: parameters) : GrpBrdElt -&gt; GrpBrdElt</H5>

<PRE>    Presentation: MonStgElt             Default: </PRE>
<BLOCKQUOTE>
Given an element u&isin;B with left normal form D<sup>l</sup> c<sub>1</sub> ... c<sub>k</sub>, return the
result of a cycling operation on u, that is,
 u^((c<sub>1</sub>^(D<sup> - l</sup>))) 
as new element of B in left normal form.
</BLOCKQUOTE>
<H5><A NAME = "9828">Cycle(~u: parameters) : GrpBrdElt -&gt;</A></H5>

<PRE>    Presentation: MonStgElt             Default: </PRE>
<BLOCKQUOTE>
Given an element u&isin;B with left normal form D<sup>l</sup> c<sub>1</sub> ... c<sub>k</sub>, replace
u by the result of a cycling operation on u, that is, by
 u^((c<sub>1</sub>^(D<sup> - l</sup>))) 
in left normal form.
</BLOCKQUOTE>
<H5><A NAME = "9829"></A><A NAME = "GrpBrd:Decycle">Decycle</A>(u: parameters) : GrpBrdElt -&gt; GrpBrdElt</H5>

<PRE>    Presentation: MonStgElt             Default: </PRE>
<BLOCKQUOTE>
Given an element u&isin;B with left normal form D<sup>l</sup> c<sub>1</sub> ... c<sub>k</sub>, return the
result of a decycling operation on u, that is,
 u^((c<sub>k</sub><sup> - 1</sup>)) 
as new element of B in left normal form.
</BLOCKQUOTE>
<H5><A NAME = "9830">Decycle(~u: parameters) : GrpBrdElt -&gt;</A></H5>

<PRE>    Presentation: MonStgElt             Default: </PRE>
<BLOCKQUOTE>
Given an element u&isin;B with left normal form D<sup>l</sup> c<sub>1</sub> ... c<sub>k</sub>, replace
u by the result of a decycling operation on u, that is, by
 u^((c<sub>k</sub><sup> - 1</sup>)) 
in left normal form.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "9831">Example <TT>GrpBrd_Arithmetic (H78E4)</TT></A></H3>
We illustrate the importance of limiting the length of representations of
elements using the function <A  HREF = "text851.htm#GrpBrd:NormalForm">NormalForm</A> when performing
a sequence of arithmetic operations on an element.
<P>
<P>
Consider the following computation in the braid group B on 6 strings.
Starting with an element w, we repeatedly replace w by the product w w<sup>s<sub>1</sub></sup> where s_1 is the first Artin generator of B.
<P>
A naive way of implementing this computation would be as follows.
<P>
<P>
<PRE>
&gt; B := BraidGroup(6);
&gt; u := B.5 * B.2^ - 2 * B.4 * B.3^ - 1;
&gt; v := B.1;
&gt; N := 14;
&gt; 
&gt; T := Cputime();
&gt; w := u;
&gt; for i := 1 to N do
&gt;    w := w * w<sup>v</sup>;
&gt; end for;
</PRE>
This, however, yields an extremely complicated representation for the result;
the representation in terms of simple elements has the length 114686.
<P>
<P>
<PRE>
&gt; #CFP(w)[3];
114686
</PRE>
Performing subsequent computations with the result, for example computing
its normal form, is very expensive.
<P>
<P>
<PRE>
&gt; NormalForm(~w);
&gt; print "total time used: ", Cputime() - T;
total time used:  149.229
</PRE>
One might be tempted to solve this problem by working only with elements
in normal form, that is, by bringing every result of an arithmetic operation
into normal form after computing it.
<P>
Using this approach, computing the result of the above iteration is indeed
much faster.
<P>
<P>
<PRE>
&gt; T := Cputime();
&gt; w := u;
&gt; for i := 1 to N do
&gt;    t := w<sup>v</sup>;
&gt;    NormalForm(~t);
&gt;    w := w * t;
&gt;    NormalForm(~w);
&gt; end for;
&gt; print "total time used: ", Cputime() - T;
total time used:  0.53
</PRE>
However, this strategy is not optimal either.  For the above example, the
optimal performance is obtained if the result is normalised every third
pass through the iteration.
<P>
<P>
<PRE>
&gt; T := Cputime();
&gt; w := u;
&gt; for i := 1 to N do
&gt;    w := w * w<sup>v</sup>;
&gt;    if i mod 3 eq 0 then
&gt;       NormalForm(~w);
&gt;    end if;
&gt; end for;
&gt; NormalForm(~w);
&gt; print "total time used: ", Cputime() - T;
total time used:  0.171
</PRE>
Unfortunately, the frequency of normalisation giving best results depends
heavily on the situation, that is, both on the arithmetic operations and
on the characteristics of the arguments.
<P>
As a rule of thumb, the effects of normalising results too frequently
are less of a problem than normalising results not often enough or not at
all..
<P>
A naive way of implementing this computation would be as follows.
<P>
<P>
<PRE>
&gt; B := BraidGroup(6);
&gt; u := B.5*B.2^-2*B.4*B.3^-1;
&gt; v := B.1;
&gt; N := 14;
&gt; 
&gt; T := Cputime();
&gt; w := u;
&gt; for i := 1 to N do
&gt;    w := w * w^v;
&gt; end for;
</PRE>
This, however, yields an extremely complicated representation for the result;
the representation in terms of simple elements has the length 114686.
<P>
<P>
<PRE>
&gt; #CFP(w)[3];
114686
</PRE>
Performing subsequent computations with the result, for example computing
its normal form, is very expensive.
<P>
<P>
<PRE>
&gt; NormalForm(~w);
&gt; print "total time used: ", Cputime()-T;
total time used:  149.229
</PRE>
One might be tempted to solve this problem by working only with elements
in normal form, that is, by bringing every result of an arithmetic operation
into normal form after computing it.
<P>
Using this approach, computing the result of the above iteration is indeed
much faster.
<P>
<P>
<PRE>
&gt; T := Cputime();
&gt; w := u;
&gt; for i := 1 to N do
&gt;    t := w^v;
&gt;    NormalForm(~t);
&gt;    w := w * t;
&gt;    NormalForm(~w);
&gt; end for;
&gt; print "total time used: ", Cputime()-T;
total time used:  0.53
</PRE>
However, this strategy is not optimal either.  For the above example, the
optimal performance is obtained if the result is normalised every third
pass through the iteration.
<P>
<P>
<PRE>
&gt; T := Cputime();
&gt; w := u;
&gt; for i := 1 to N do
&gt;    w := w * w^v;
&gt;    if i mod 3 eq 0 then
&gt;       NormalForm(~w);
&gt;    end if;
&gt; end for;
&gt; NormalForm(~w);
&gt; print "total time used: ", Cputime()-T;
total time used:  0.171
</PRE>
Unfortunately, the frequency of normalisation giving best results depends
heavily on the situation, that is, both on the arithmetic operations and
on the characteristics of the arguments.
<P>
As a rule of thumb, the effects of normalising results too frequently
are less of a problem than normalising results not often enough or not at
all.
<HR>
<H4><A NAME = "9832">Boolean Predicates for Elements</A></H4>

<P>
<P>
<P>
This section describes the tests for membership, equality and partial
orderings which are available for elements of a braid group B.
<P>
Unless stated otherwise, all computations are performed in the presentation
selected for B or in the presentation specified by the value of the
parameter <TT>Presentation</TT>, either <TT>"Artin"</TT> or <TT>"BKL"</TT> if a value for
this parameter is given.


<H5><A NAME = "9833">u in B : GrpBrdElt, GrpBrd -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Given an element u of a braid group and a braid group B, return <TT>true</TT> if
u&isin;B and <TT>false</TT> otherwise.
</BLOCKQUOTE>
<H5><A NAME = "9834">u notin B : GrpBrdElt, GrpBrd -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Given an element u of a braid group and a braid group B, return <TT>false</TT> if
u&isin;B and <TT>true</TT> otherwise.
</BLOCKQUOTE>
<H5><A NAME = "9835">IsEmptyWord(u: parameters) : GrpBrdElt -&gt; BoolElt</A></H5>

<PRE>    Presentation: MonStgElt             Default: </PRE>
<BLOCKQUOTE>
Given an element u of a braid group, return <TT>true</TT> if u is the
represented by the empty word in the specified presentation and <TT>false</TT>
otherwise.
</BLOCKQUOTE>
<H5><A NAME = "9836">AreIdentical(u, v: parameters) : GrpBrdElt, GrpBrdElt -&gt; BoolElt</A></H5>

<PRE>    Presentation: MonStgElt             Default: </PRE>
<BLOCKQUOTE>
Given elements u and v belonging to the same braid group B, return
<TT>true</TT> if u and v are represented by identical words in the specified
presentation and <TT>false</TT> otherwise.
</BLOCKQUOTE>
<H5><A NAME = "9837">IsSimple(u: parameters) : GrpBrdElt -&gt; BoolElt</A></H5>

<PRE>    Presentation: MonStgElt             Default: </PRE>
<BLOCKQUOTE>
Given an element u of a braid group, return <TT>true</TT> if u is a
simple element with respect to the specified presentation
and <TT>false</TT> otherwise.  The argument is converted into normal form.
</BLOCKQUOTE>
<H5><A NAME = "9838">IsSuperSummitRepresentative(u: parameters) : GrpBrdElt -&gt; BoolElt</A></H5>

<PRE>    Presentation: MonStgElt             Default: </PRE>
<BLOCKQUOTE>
Given an element u of a braid group, return <TT>true</TT> if u is an
element of its super summit set with respect to the specified presentation
and <TT>false</TT> otherwise.  The argument is converted into normal form.
</BLOCKQUOTE>
<H5><A NAME = "9839">IsUltraSummitRepresentative(u: parameters) : GrpBrdElt -&gt; BoolElt</A></H5>

<PRE>    Presentation: MonStgElt             Default: </PRE>
<BLOCKQUOTE>
Given an element u of a braid group, return <TT>true</TT> if u is an
element of its ultra summit set with respect to the specified presentation
and <TT>false</TT> otherwise.  The argument is converted into normal form.
</BLOCKQUOTE>
<H5><A NAME = "9840">IsIdentity(u: parameters) : GrpBrdElt -&gt; BoolElt</A></H5>
<H5>IsId(u: parameters) : GrpBrdElt -&gt; BoolElt</H5>

<PRE>    Presentation: MonStgElt             Default: </PRE>
<BLOCKQUOTE>
Given an element u of a braid group B, return <TT>true</TT> if u is the
identity element of B and <TT>false</TT> otherwise.  The argument is converted
into normal form.
</BLOCKQUOTE>
<H5><A NAME = "9841"></A>u <A NAME = "GrpBrd:eq">eq</A> v : GrpBrdElt, GrpBrdElt -&gt; BoolElt</H5>
<BLOCKQUOTE>
Given elements u and v belonging to the same braid group B, return
<TT>true</TT> if u = v and <TT>false</TT> otherwise.  Both arguments are converted
into normal form.
</BLOCKQUOTE>
<H5><A NAME = "9842">u ne v : GrpBrdElt, GrpBrdElt -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Given elements u and v belonging to the same braid group B, return
<TT>false</TT> if u = v and <TT>true</TT> otherwise.  Both arguments are converted
into normal form.
</BLOCKQUOTE>
<H5><A NAME = "9843"></A>u <A NAME = "GrpBrd:le">le</A> v : GrpBrdElt, GrpBrdElt -&gt; BoolElt</H5>
<H5>IsLE(u, v: parameters) : GrpBrdElt, GrpBrdElt -&gt; BoolElt</H5>
<H5>IsLe(u, v: parameters) : GrpBrdElt, GrpBrdElt -&gt; BoolElt</H5>

<PRE>    Presentation: MonStgElt             Default: </PRE>
<BLOCKQUOTE>
Given elements u and v belonging to the same braid group B, return
<TT>true</TT> if u preceq v, that is, if u<sup> - 1</sup>v is a positive element, with
respect to the specified presentation and <TT>false</TT> otherwise.
<P>
Note that the parameter <TT>Presentation</TT> is not available for the operator
version of this predicate.
</BLOCKQUOTE>
<H5><A NAME = "9844"></A>u <A NAME = "GrpBrd:ge">ge</A> v : GrpBrdElt, GrpBrdElt -&gt; BoolElt</H5>
<H5>IsGE(u, v: parameters) : GrpBrdElt, GrpBrdElt -&gt; BoolElt</H5>
<H5>IsGe(u, v: parameters) : GrpBrdElt, GrpBrdElt -&gt; BoolElt</H5>

<PRE>    Presentation: MonStgElt             Default: </PRE>
<BLOCKQUOTE>
Given elements u and v belonging to the same braid group B, return
<TT>true</TT> if u succeq v, that is, if uv<sup> - 1</sup> is a positive element, with
respect to the specified presentation and <TT>false</TT> otherwise.
<P>
Note that the parameter <TT>Presentation</TT> is not available for the operator
version of this predicate.
</BLOCKQUOTE>
<H5><A NAME = "9845"></A><A NAME = "GrpBrd:IsConjugate">IsConjugate</A>(u, v: parameters) : GrpBrdElt, GrpBrdElt -&gt; BoolElt, GrpBrdElt</H5>

<PRE>    Presentation: MonStgElt             Default: </PRE>
<BLOCKQUOTE>
Given elements u and v belonging to the same braid group B, return
<TT>true</TT> and an element c&isin;B satisfying u<sup>c</sup> = v if u and v are
conjugate and return <TT>false</TT> otherwise.
<P>
The function first computes representatives u<sub>s</sub> and v<sub>s</sub> of the ultra
summit sets of u and v, respectively, with respect to the specified
presentation.
If this does not prove that the elements are not conjugate, the function
tries to compute elements of the ultra summit set of u until either the
element v<sub>s</sub> is found, proving that u and v are conjugate, or the
ultra summit set of u is seen not to contain v<sub>s</sub>, proving that u and
v are not conjugate.  See Example <A  HREF = "text851.htm#9877">H78E8</A>
for a more detailed description.
<P>
Note that testing elements for conjugacy is a hard problem and may
require significant amounts of memory and CPU time.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "9846">Example <TT>GrpBrd_Boolean (H78E5)</TT></A></H3>
We define the braid group B on 6 strings using the Artin presentation
and set the print format for elements to <TT>"CFP"</TT>.
<P>
<P>
<PRE>
&gt; B:= BraidGroup(6);
&gt; SetElementPrintFormat(~B, "CFP");
</PRE>
<DL COMPACT class='compact'>
<DT>(1)</DT><DD>We create pseudo-random elements of B until we find an element u which is
contained in its super summit set with respect to the Artin presentation
of B.
<P>
<P>
</DL>
<PRE>
&gt; repeat
&gt;    u := Random(B, 5, 10);
&gt; until IsSuperSummitRepresentative(u);
&gt; NormalForm(u);
&lt;Artin, -2, [
    (1, 5)(2, 3, 6),
    (1, 5, 6, 3, 2, 4),
    (2, 6)(3, 4, 5)
], 0&gt;
</PRE>
u is not contained in its super summit set with respect to the BKL
presentation of B, showing that the super summit set of an element
in general depends on the presentation with respect to which it is defined.
<P>
<P>
<PRE>
&gt; IsSuperSummitRepresentative(u : Presentation := "Artin");
true
&gt; IsSuperSummitRepresentative(u : Presentation := "BKL");
false
</PRE>
<P>
<P>
<DL COMPACT class='compact'>
<DT>(2)</DT><DD>This example shows that the Artin presentation and the BKL presentation
give rise to distinct partial orderings on B.
<P>
</DL>
 s<sub>1</sub><sup> - 1</sup> s<sub>2</sub> s<sub>1</sub> has negative
infimum with respect to the Artin presentation and hence is not a positive
element with respect to this presentation.
<P>
<P>
<PRE>
&gt; Infimum(B.1^-1*B.2*B.1 : Presentation := "Artin");
-1
</PRE>
Consequently, s<sub>1</sub>not preceq s<sub>2</sub> s<sub>1</sub>
in the partial ordering defined with respect to the Artin presentation.
<P>
<P>
<PRE>
&gt; B.1 le B.2*B.1;
false
</PRE>
We can also use the function version to check this.
<P>
<P>
<PRE>
&gt; IsLE(B.1, B.2*B.1 : Presentation := "Artin");
false
</PRE>
However, s<sub>1</sub><sup> - 1</sup> s<sub>2</sub> s<sub>1</sub> is
equal to the BKL generator a<sub>3, 1</sub> and hence is, in particular, a positive
element with respect to the BKL presentation.
in the BKL generators.
<P>
<P>
<PRE>
&gt; B.1^-1*B.2*B.1 eq B.&lt;3,1&gt;;
true
</PRE>
Hence, s<sub>1</sub>preceq s<sub>2</sub> s<sub>1</sub>
in the partial ordering defined with respect to the BKL presentation.
<P>
<P>
<PRE>
&gt; IsLE(B.1, B.2*B.1 : Presentation := "BKL");
true
</PRE>
<P>
<P>
<DL COMPACT class='compact'>
<DT>(3)</DT><DD>We change the print format for elements of B so that only words in the
Artin generators are printed.
<P>
<P>
</DL>
<PRE>
&gt; SetElementPrintFormat(~B, "Word");
</PRE>
Inducing permutations with different cycle structure, s<sub>1</sub> and s<sub>1</sub> s<sub>2</sub> cannot be conjugate in B.
<P>
<P>
<PRE>
&gt; InducedPermutation(B.1);
(1, 2)
&gt; InducedPermutation(B.2*B.1);
(1, 2, 3)
&gt; IsConjugate(B.1, B.2*B.1);
false
</PRE>
s<sub>1</sub> and s<sub>2</sub>, however,
are conjugate in B.  We compute a conjugating element c.
<P>
<P>
<PRE>
&gt; res, c := IsConjugate(B.1, B.2);
&gt; res;
true
&gt; NormalForm(c);
B.2 * B.1
</PRE>
c, as desired, conjugates &sigma;<sub>1</sub>: s<sub>1</sub>: to &sigma;<sub>2</sub>: s<sub>2</sub>:.
<P>
<P>
<PRE>
&gt; B.1^c eq B.2;
true
</PRE>
<HR>
<H4><A NAME = "9847">Lattice Operations</A></H4>

<P>
<P>
<P>
This section describes the functions available for computing lattice
operations, least common multiple and greatest common divisor, for elements
of a braid group B.  The results of all lattice operations depend on
the presentation used for B and on the partial ordering considered.
<P>
The functions documented
in this section all accept a parameter <TT>Presentation</TT> which can be used
to specify the presentation of B with respect to which the computation
should be performed.  Possible values for this parameter are the strings
<TT>"Artin"</TT> and <TT>"BKL"</TT>.  If no value is given for <TT>Presentation</TT>, the
presentation selected for B is used.


<H5><A NAME = "9848">LeftGCD(u, v: parameters) : GrpBrdElt, GrpBrdElt -&gt; GrpBrdElt</A></H5>
<H5>LeftGcd(u, v: parameters) : GrpBrdElt, GrpBrdElt -&gt; GrpBrdElt</H5>
<H5>LeftGreatestCommonDivisor(u, v: parameters) : GrpBrdElt, GrpBrdElt -&gt; GrpBrdElt</H5>
<H5>GCD(u, v: parameters) : GrpBrdElt, GrpBrdElt -&gt; GrpBrdElt</H5>
<H5>Gcd(u, v: parameters) : GrpBrdElt, GrpBrdElt -&gt; GrpBrdElt</H5>
<H5>GreatestCommonDivisor(u, v: parameters) : GrpBrdElt, GrpBrdElt -&gt; GrpBrdElt</H5>

<PRE>    Presentation: MonStgElt             Default: </PRE>
<BLOCKQUOTE>
Given elements u and v belonging to the same braid group B, return the
left-gcd of u and v, that is, the with respect to preceq maximal element
d of B satisfying d preceq u and d preceq v.  Here, preceq is the
partial ordering on B defined as follows: a preceq b iff a<sup> - 1</sup>b is
representable as a positive word in the specified presentation of B.
</BLOCKQUOTE>
<H5><A NAME = "9849">RightGCD(u, v: parameters) : GrpBrdElt, GrpBrdElt -&gt; GrpBrdElt</A></H5>
<H5>RightGcd(u, v: parameters) : GrpBrdElt, GrpBrdElt -&gt; GrpBrdElt</H5>
<H5>RightGreatestCommonDivisor(u, v: parameters) : GrpBrdElt, GrpBrdElt -&gt; GrpBrdElt</H5>

<PRE>    Presentation: MonStgElt             Default: </PRE>
<BLOCKQUOTE>
Given elements u and v belonging to the same braid group B, return the
right-gcd of u and v, that is, the with respect to succeq maximal
element d of B satisfying u succeq d and v succeq d.  Here, succeq
is the partial ordering on B defined as follows: a succeq b iff ab<sup> - 1</sup>
is representable as a positive word in the specified presentation of B.
</BLOCKQUOTE>
<H5><A NAME = "9850">LeftGCD(S: parameters) : Setq -&gt; GrpBrdElt</A></H5>
<H5>LeftGcd(S: parameters) : Setq -&gt; GrpBrdElt</H5>
<H5>LeftGreatestCommonDivisor(S: parameters) : Setq -&gt; GrpBrdElt</H5>
<H5>GCD(S: parameters) : Setq -&gt; GrpBrdElt</H5>
<H5>Gcd(S: parameters) : Setq -&gt; GrpBrdElt</H5>
<H5>GreatestCommonDivisor(S: parameters) : Setq -&gt; GrpBrdElt</H5>

<PRE>    Presentation: MonStgElt             Default: </PRE>
<BLOCKQUOTE>
Given a set or a sequence S containing elements of a braid group B,
return the left-gcd of the elements of S, that is, the with respect to
preceq maximal element d of B satisfying d preceq s for all s&isin;S,
where preceq is defined as above.
</BLOCKQUOTE>
<H5><A NAME = "9851">RightGCD(S: parameters) : Setq -&gt; GrpBrdElt</A></H5>
<H5>RightGcd(S: parameters) : Setq -&gt; GrpBrdElt</H5>
<H5>RightGreatestCommonDivisor(S: parameters) : Setq -&gt; GrpBrdElt</H5>

<PRE>    Presentation: MonStgElt             Default: </PRE>
<BLOCKQUOTE>
Given a set or a sequence S containing elements of a braid group B,
return the right-gcd of the elements of S, that is, the with respect to
succeq maximal element d of B satisfying s succeq d for all s&isin;S,
where succeq is defined as above.
</BLOCKQUOTE>
<H5><A NAME = "9852">LeftLCM(u, v: parameters) : GrpBrdElt, GrpBrdElt -&gt; GrpBrdElt</A></H5>
<H5>LeftLcm(u, v: parameters) : GrpBrdElt, GrpBrdElt -&gt; GrpBrdElt</H5>
<H5>LeftLeastCommonMultiple(u, v: parameters) : GrpBrdElt, GrpBrdElt -&gt; GrpBrdElt</H5>
<H5>LCM(u, v: parameters) : GrpBrdElt, GrpBrdElt -&gt; GrpBrdElt</H5>
<H5>Lcm(u, v: parameters) : GrpBrdElt, GrpBrdElt -&gt; GrpBrdElt</H5>
<H5>LeastCommonMultiple(u, v: parameters) : GrpBrdElt, GrpBrdElt -&gt; GrpBrdElt</H5>

<PRE>    Presentation: MonStgElt             Default: </PRE>
<BLOCKQUOTE>
Given elements u and v belonging to the same braid group B, return the
left-lcm of u and v, that is, the with respect to preceq minimal element
d of B satisfying u preceq d and v preceq d, where preceq is
defined as above.
</BLOCKQUOTE>
<H5><A NAME = "9853">RightLCM(u, v: parameters) : GrpBrdElt, GrpBrdElt -&gt; GrpBrdElt</A></H5>
<H5>RightLcm(u, v: parameters) : GrpBrdElt, GrpBrdElt -&gt; GrpBrdElt</H5>
<H5>RightLeastCommonMultiple(u, v: parameters) : GrpBrdElt, GrpBrdElt -&gt; GrpBrdElt</H5>

<PRE>    Presentation: MonStgElt             Default: </PRE>
<BLOCKQUOTE>
Given elements u and v belonging to the same braid group B, return the
right-lcm of u and v, that is, the with respect to succeq minimal
element d of B satisfying d succeq u and d succeq v, where succeq
is defined as above.
</BLOCKQUOTE>
<H5><A NAME = "9854">LeftLCM(S: parameters) : Setq -&gt; GrpBrdElt</A></H5>
<H5>LeftLcm(S: parameters) : Setq -&gt; GrpBrdElt</H5>
<H5>LeftLeastCommonMultiple(S: parameters) : Setq -&gt; GrpBrdElt</H5>
<H5>LCM(S: parameters) : Setq -&gt; GrpBrdElt</H5>
<H5>Lcm(S: parameters) : Setq -&gt; GrpBrdElt</H5>
<H5>LeastCommonMultiple(S: parameters) : Setq -&gt; GrpBrdElt</H5>

<PRE>    Presentation: MonStgElt             Default: </PRE>
<BLOCKQUOTE>
Given a set or a sequence S containing elements of a braid group B,
return the left-gcd of the elements of S, that is, the with respect to
preceq minimal element d of B satisfying s preceq d for all s&isin;S,
where preceq is defined as above.
</BLOCKQUOTE>
<H5><A NAME = "9855">RightLCM(S: parameters) : Setq -&gt; GrpBrdElt</A></H5>
<H5>RightLcm(S: parameters) : Setq -&gt; GrpBrdElt</H5>
<H5>RightLeastCommonMultiple(S: parameters) : Setq -&gt; GrpBrdElt</H5>

<PRE>    Presentation: MonStgElt             Default: </PRE>
<BLOCKQUOTE>
Given a set or a sequence S containing elements of a braid group B,
return the right-lcm of the elements of S, that is, the with respect to
succeq minimal element d of B satisfying d succeq s for all s&isin;S,
where succeq is defined as above.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "9856">Example <TT>GrpBrd_Boolean (H78E6)</TT></A></H3>
We define the braid group B on 6 strings.
<P>
<P>
<PRE>
&gt; B := BraidGroup(6);
&gt; SetElementPrintFormat(~B, "CFP");
</PRE>
<DL COMPACT class='compact'>
<DT>(1)</DT><DD>For both Artin and BKL presentation, the fundamental element is the
(left or right) least common multiple of the generators.  We check this
for the Artin presentation ... <PRE>
&gt; D_Artin := LeftLCM({B.i : i in [1..NumberOfGenerators(B)]});
&gt; D_Artin eq FundamentalElement(B);
true
&gt; D_Artin eq RightLCM({B.i : i in [1..NumberOfGenerators(B)]}); 
true
</PRE> ... and for the BKL presentation.
<P>
<P>
</DL>
<PRE>
&gt; idx := { &lt;r,t&gt; : r,t in {1..NumberOfStrings(B)} | r gt t };
&gt; D_BKL := LeftLCM({B.T : T in idx} : Presentation := "BKL");
&gt; D_BKL eq FundamentalElement(B : Presentation := "BKL");
true
&gt; D_BKL eq RightLCM({B.T : T in idx} : Presentation := "BKL");
true
</PRE>
In general, left and right least common multiple of elements are different.
<P>
<P>
<PRE>
&gt; LeftLCM(B.1,B.1*B.2) eq RightLCM(B.1,B.1*B.2);
false
</PRE>
<DL COMPACT class='compact'>
<DT>(2)</DT><DD>For both Artin and BKL presentation, the following hold.  Let D denote
the fundamental element.
<DT>-</DT><DD>The simple elements are those positive
  elements s satisfying s preceq D (or D succeq s).
<DT>-</DT><DD>A product u<sub>1</sub> ... u<sub>r</sub> of simple elements is in left normal form,
  if and only if the left greatest common divisor of u<sub>i</sub><sup> - 1</sup>D and
  u<sub>i + 1</sub> is trivial for all i=1, ..., r - 1.
<P>
<P>
</DL>
We illustrate this for the Artin presentation.
<P>
<P>
<PRE>
&gt; D := FundamentalElement(B);
&gt; forall{ s : s in Sym(6) | B!1 le B!s and B!s le D };
true
&gt; forall{ s : s in Sym(6) | D ge B!s and B!s ge B!1 };
true
</PRE>
We create an element u as product of random simple elements.
<P>
<P>
<PRE>
&gt; u := Random(B, 0, 0, 3, 5);
&gt; u;
&lt;Artin, 0, [
    (1, 5, 2)(3, 6),
    (1, 6, 5, 3),
    (1, 6, 5, 3, 2)
], 0&gt;
</PRE>
We define a sequence of elements of B, containing the simple elements
of the above representation of u using the function
<A  HREF = "text851.htm#GrpBrd:CanonicalFactorRepresentation">CanonicalFactorRepresentation</A> and the coercion operator
<A  HREF = "text850.htm#GrpBrd:coerce_perm">!</A>.
<P>
<P>
<PRE>
&gt; cfu := [ B!x : x in CFP(u)[3] ];
</PRE>
This representation is not in left normal form, as the above condition
is violated for i=1.
<P>
<P>
<PRE>
&gt; IsId(LeftGCD(cfu[1]^-1*D, cfu[2]));
false
</PRE>
We now bring u into left normal form and extract again the sequence
of simple elements.
<P>
<P>
<PRE>
&gt; n := NormalForm(u);
&gt; n;
&lt;Artin, 0, [
    (1, 5, 3, 6, 2),
    (1, 6, 3, 2, 5)
], 0&gt;
&gt; cfn := [ B!x : x in CFP(n)[3] ];
</PRE>
This time, the above condition is satisfied.
<P>
<P>
<PRE>
&gt; IsId(LeftGCD(cfn[1]^-1*D, cfn[2]));
true
</PRE>
<HR>
<H4><A NAME = "9857">Invariants of Conjugacy Classes</A></H4>

<P>
<P>
<P>
This section describes the functions for computing the set
of positive conjugates, the super summit set and the ultra summit set
for an element of a braid group B as defined in
Section <A  HREF = "text848.htm#9760">Conjugacy Testing and Conjugacy  Search</A>, as well as related Magma functions.
<P>
All the class invariants in general depend on the presentation of B
used for their definition. Many functions
documented in this section accept a parameter <TT>Presentation</TT> which can
be used to specify the presentation of B with respect to which the
computation should be performed.  Possible values for this parameter are
the strings <TT>"Artin"</TT> and <TT>"BKL"</TT>.  If no value is given for
<TT>Presentation</TT>, the presentation selected for B is used.
<P>
For any given element u&isin;B, all the invariants defined in
Section <A  HREF = "text848.htm#9760">Conjugacy Testing and Conjugacy  Search</A> are finite and can be computed in
principle.  In practice, however, computations may fail because the sets
can get very large with increasing canonical length of u or with increasing
braid index of B.  This is in particular the case for sets of positive
conjuagtes and for super summit sets.


<H5><A NAME = "9858"></A><A NAME = "GrpBrd:PositiveConjugates">PositiveConjugates</A>(u: parameters) : GrpBrdElt -&gt; SetIndx</H5>

<PRE>    Presentation: MonStgElt             Default: </PRE>
<BLOCKQUOTE>
Given an element u of a braid group B, return an indexed set containing
the conjugates of u which can be represented as positive words in the
specified presentation of B.
</BLOCKQUOTE>
<H5><A NAME = "9859">SuperSummitRepresentative(u: parameters) : GrpBrdElt -&gt; GrpBrdElt, GrpBrdElt</A></H5>

<PRE>    Presentation: MonStgElt             Default: </PRE>
<BLOCKQUOTE>
Given an element u of a braid group B, return an element u<sub>s</sub> of the
super summit set of u with respect to the specified presentation of B
and an element c of B satisfying u<sup>c</sup> = u<sub>s</sub>.
<P>
Note that u<sub>s</sub> is a positive conjugate of u, if u<sub>s</sub> has non-negative
infimum and that u does not have any positive conjugates if the infimum
of u<sub>s</sub> is negative.
</BLOCKQUOTE>
<H5><A NAME = "9860"></A><A NAME = "GrpBrd:SuperSummitSet">SuperSummitSet</A>(u: parameters) : GrpBrdElt -&gt; SetIndx</H5>

<PRE>    Presentation: MonStgElt             Default: </PRE>
<BLOCKQUOTE>
Given an element u of a braid group B, return the super summit set of u
with respect to the specified presentation as indexed set of elements of B.
</BLOCKQUOTE>
<H5><A NAME = "9861">UltraSummitRepresentative(u: parameters) : GrpBrdElt -&gt; GrpBrdElt, GrpBrdElt</A></H5>

<PRE>    Presentation: MonStgElt             Default: </PRE>
<BLOCKQUOTE>
Given an element u of a braid group B, return an element u<sub>s</sub> of the
ultra summit set of u with respect to the specified presentation of B
and an element c of B satisfying u<sup>c</sup> = u<sub>s</sub>.
<P>
Note that u<sub>s</sub> is an element of the super summit set of u, that u<sub>s</sub>
is a positive conjugate of u, if u<sub>s</sub> has non-negative infimum and
that u does not have any positive conjugates if the infimum
of u<sub>s</sub> is negative.
</BLOCKQUOTE>
<H5><A NAME = "9862"></A><A NAME = "GrpBrd:UltraSummitSet">UltraSummitSet</A>(u: parameters) : GrpBrdElt -&gt; SetIndx</H5>

<PRE>    Presentation: MonStgElt             Default: </PRE>
<BLOCKQUOTE>
Given an element u of a braid group B, return the ultra summit set of u
with respect to the specified presentation as indexed set of elements of B.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "9863">Example <TT>GrpBrd_Conjugates (H78E7)</TT></A></H3>
<P>
<DL COMPACT class='compact'>
<DT>(1)</DT><DD>In the braid group B on 4 strings we compute the sets of positive conjugates
and the super summit sets of u = s<sub>1</sub> s<sub>2</sub> s<sub>1</sub>
with respect to both Artin presentation and BKL presentation.
<P>
<P>
</DL>
<PRE>
&gt; B := BraidGroup(4);
&gt; u := B.1*B.2*B.1;
&gt; p_Artin := PositiveConjugates(u : Presentation := "Artin");
&gt; p_BKL := PositiveConjugates(u : Presentation := "BKL");
&gt; s_Artin := SuperSummitSet(u : Presentation := "Artin");
&gt; s_BKL := SuperSummitSet(u : Presentation := "BKL");
</PRE>
Since the Artin generators form a subset of the BKL generators, every
element which is positive with respect to the Artin presentation is also
positive with respect to the BKL presentation. In particular,
<TT>p_Artin</TT> is a subset of <TT>p_BKL</TT>.
<P>
<P>
<PRE>
&gt; p_Artin subset p_BKL;
true
</PRE>
The converse inclusion does not hold.
<P>
<P>
<PRE>
&gt; #p_Artin;
10
&gt; #p_BKL;
36
</PRE>
For both presentations the super summit set is a subset of the set of
positive conjugates, as u is positive.  The converse inclusions do
not hold.
<P>
<P>
<PRE>
&gt; s_Artin subset p_Artin;
true
&gt; s_BKL subset p_BKL;
true
&gt; #s_Artin;
2
&gt; #s_BKL;
12
</PRE>
<P>
<P>
<DL COMPACT class='compact'>
<DT>(2)</DT><DD>As we have seen in Section <A  HREF = "text848.htm#9760">Conjugacy Testing and Conjugacy  Search</A>, we can decide
whether two braids are conjugate by checking whether
their super summit sets are equal.  
<P>
<P>
</DL>
We illustrate this approach with two elements of B, using the
Artin presentation of B.
<P>
<P>
<PRE>
&gt; u := B.2 * B.1 * B.2^2 * B.1 * B.2;
&gt; v := B.2^2 * B.1 * B.3 * B.1 * B.3;
</PRE>
Suppose we want to prove that u and v are not conjugate in B.  We could
start by checking the cycle structure of the induced permutations on the
strings on which B acts.
<P>
<P>
<PRE>
&gt; CycleStructure(InducedPermutation(u));                                       
[ &lt;1, 4&gt; ]
&gt; CycleStructure(InducedPermutation(v));
[ &lt;1, 4&gt; ]
</PRE>
This does not help.  Next we can check the infima and the suprema of super
summit representatives.
<P>
<P>
<PRE>
&gt; SuperSummitInfimum(u) eq SuperSummitInfimum(v);
true
&gt; SuperSummitSupremum(u) eq SuperSummitSupremum(v);
true
</PRE>
Again, we cannot conclude anything.  We decide to compare the super summit
sets of u and v.
<P>
<P>
<PRE>
&gt; SuperSummitSet(u) eq SuperSummitSet(v);                       
false
</PRE>
Success!  The super summit sets of u and v are different, proving that
u and v are not conjugate.
<P>
<P>
For a more efficient version of conjugacy testing see Example
<A  HREF = "text851.htm#9877">H78E8</A>.
<P>
<P>
<DL COMPACT class='compact'>
<DT>(3)</DT><DD>Finally, we illustrate the significant difference in the sizes of super
summit sets and ultra summit sets for slightly larger values of braid
index and canonical length.
<P>
<P>
</DL>
<PRE>
&gt; B := BraidGroup(8);
</PRE>
We create a pseudo-random element of B as product of 5 simple elements
independently chosen at random.
<P>
<P>
<PRE>
&gt; x := B.4 * B.3 * B.2 * B.1 * B.5 * B.4 * B.5 *
&gt; B.6 * B.7 * B.6 * B.5;
&gt; x := x^2;
&gt; Sx := SuperSummitSet(x);
&gt; #Sx;
10972
&gt; Ux := UltraSummitSet(x);
&gt; #Ux;
36
</PRE>
The ultra summit set is much smaller than the super summit set.  We try
again.
<P>
<P>
<PRE>
&gt; x := B.4 * B.3 * B.2 * B.1 * B.5 * B.4 * B.5;
&gt; x := x^3;
&gt; Sx := SuperSummitSet(x);
&gt; #Sx;
882
&gt; Ux := UltraSummitSet(x);
&gt; #Ux;
18
</PRE>
The difference in sizes is still large.  The behaviour exhibited
by these examples is quite typical.  In particular, the sizes of super
summit sets for braids on a given number of strings and with a given canonical
length show much larger fluctuations than the sizes of ultra summit sets.
For a more detailed analysis we refer to <A  HREF = "text846.htm#bib_braid_ultrasummit">[Geb03]</A>.
<HR>
<H5><A NAME = "9864">Computing Class Invariants Interactively</A></H5>

<P>
<P>
This section describes the functions relevant for interactive computation
of the set of positive conjugates, the super summit set and the
ultra summit set for a given element of a braid group B as defined in
Section <A  HREF = "text848.htm#9760">Conjugacy Testing and Conjugacy  Search</A>.
<P>
Process versions of the algorithms used by the functions
<A  HREF = "text851.htm#GrpBrd:PositiveConjugates">PositiveConjugates</A>, <A  HREF = "text851.htm#GrpBrd:SuperSummitSet">SuperSummitSet</A>
and <A  HREF = "text851.htm#GrpBrd:UltraSummitSet">UltraSummitSet</A> are available for computing these
invariants one element at a time.


<H5><A NAME = "9865"></A><A NAME = "GrpBrd:PositiveConjugatesProcess">PositiveConjugatesProcess</A>(u: parameters) : GrpBrdElt -&gt; GrpBrdClassProc</H5>

<PRE>    Presentation: MonStgElt             Default: </PRE>
<BLOCKQUOTE>
Given an element u of a braid group B, return a process for constructing
the conjugates of u which can be represented as positive words in the
specified presentation of B.
<P>
The returned process contains the first positive conjugate of u if
positive conjugates exist and is <I>empty</I> otherwise.
</BLOCKQUOTE>
<H5><A NAME = "9866"></A><A NAME = "GrpBrd:SuperSummitProcess">SuperSummitProcess</A>(u: parameters) : GrpBrdElt -&gt; GrpBrdClassProc</H5>

<PRE>    Presentation: MonStgElt             Default: </PRE>
<BLOCKQUOTE>
Given an element u of a braid group B, return a process for constructing
the super summit elements of u with respect to the specified presentation
of B.
<P>
The returned process contains the first super summit element of u.
</BLOCKQUOTE>
<H5><A NAME = "9867"></A><A NAME = "GrpBrd:UltraSummitProcess">UltraSummitProcess</A>(u: parameters) : GrpBrdElt -&gt; GrpBrdClassProc</H5>

<PRE>    Presentation: MonStgElt             Default: </PRE>
<BLOCKQUOTE>
Given an element u of a braid group B, return a process for constructing
the ultra summit elements of u with respect to the specified presentation
of B.
<P>
The returned process contains the first ultra summit element of u.
</BLOCKQUOTE>
<H5><A NAME = "9868">BaseElement(P) : GrpBrdClassProc -&gt; GrpBrdElt</A></H5>
<BLOCKQUOTE>
Return the element used for the construction of the process P.
</BLOCKQUOTE>
<H5><A NAME = "9869"># P : GrpBrdClassProc -&gt; RngIntElt</A></H5>
<BLOCKQUOTE>
Return the number of elements that have been found by the process P.
</BLOCKQUOTE>
<H5><A NAME = "9870"></A><A NAME = "GrpBrd:Representative">Representative</A>(P) : GrpBrdClassProc -&gt; GrpBrdElt</H5>
<H5>Rep(P) : GrpBrdClassProc -&gt; GrpBrdElt</H5>
<BLOCKQUOTE>
Given a non-empty process P, return the element most recently found by P.
<P>
If P is empty, a runtime error will occur.  The function
<A  HREF = "text851.htm#GrpBrd:IsEmpty">IsEmpty</A> can be used for checking whether a process is
empty, in order to avoid runtime errors in loops and user written functions.
</BLOCKQUOTE>
<H5><A NAME = "9871"></A><A NAME = "GrpBrd:IsEmpty">IsEmpty</A>(P) : GrpBrdClassProc -&gt; BoolElt</H5>
<BLOCKQUOTE>
Return <TT>true</TT> if P is empty and <TT>false</TT> otherwise.
<P>
This function can be used to check whether <A  HREF = "text851.htm#GrpBrd:Representative">Representative</A> can
be called for a process P.
</BLOCKQUOTE>
<H5><A NAME = "9872"></A><A NAME = "GrpBrd:Elements">Elements</A>(P) : GrpBrdClassProc -&gt; SetIndx</H5>
<BLOCKQUOTE>
Return an indexed set containing the elements found so far by the process P.
</BLOCKQUOTE>
<H5><A NAME = "9873">u in P : GrpBrdElt, GrpBrdClassProc -&gt; BoolElt, GrpBrdElt</A></H5>
<BLOCKQUOTE>
Given an element u of a braid group and a process P for computing positive
conjugates or super summit elements of the element b, return <TT>true</TT> and an
element c satisfying b<sup>c</sup> = u if u is one of the elements that have been
constructed by P and <TT>false</TT> otherwise.
</BLOCKQUOTE>
<H5><A NAME = "9874">u notin P : GrpBrdElt, GrpBrdClassProc -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Given an element u of a braid group and a process P, return <TT>false</TT> if
u is one of the elements that have been constructed by P and
<TT>true</TT> otherwise.
</BLOCKQUOTE>
<H5><A NAME = "9875">NextElement(~P) : GrpBrdClassProc -&gt;</A></H5>
<BLOCKQUOTE>
Given a process P, continue searching for elements until the next
element is found or the search completes without finding a new element.
<P>
If a new element if found, it can subsequently be accessed using the
function <A  HREF = "text851.htm#GrpBrd:Representative">Representative</A>.  If the search completes without
finding a new element, P is marked as <I>empty</I>.
Calling <TT>NextElement</TT> on an empty process has no effect.
</BLOCKQUOTE>
<H5><A NAME = "9876">Complete(~P) : GrpBrdClassProc -&gt;</A></H5>
<BLOCKQUOTE>
Given a process P, complete the search for elements.  After executing
this procedure, P is <I>empty</I> and the set of all elements found by
P can be accessed using the function <A  HREF = "text851.htm#GrpBrd:Elements">Elements</A>.
Calling <TT>Complete</TT> on an empty process has no effect.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "9877">Example <TT>GrpBrd_ConjugatesProcess (H78E8)</TT></A></H3>
We sketch how the functions described in the preceding section could be
used for testing whether two elements are conjugate and for computing a
conjugating element if they are.
<P>
<P>
<P>
The approach outlined here is basically the algorithm used by the
function <A  HREF = "text851.htm#GrpBrd:IsConjugate">IsConjugate</A>.
<P>
<P>
<PRE>
&gt; function MyIsConjugate(u, v)
&gt; 
&gt;  // check obvious invariants
&gt;  infu := SuperSummitInfimum(u);
&gt;  infv := SuperSummitInfimum(v);
&gt;  supu := SuperSummitSupremum(u);
&gt;  supv := SuperSummitSupremum(v);
&gt;  if infu ne infv or supu ne supv then
&gt;     return false, _;
&gt;  end if;
&gt; 
&gt;  // compute an ultra summit element for v
&gt;  sv, cv := UltraSummitRepresentative(v);
&gt; 
&gt;  // set up a process for computing the ultra summit set of u
&gt;  P := UltraSummitProcess(u);
&gt; 
&gt;  // compute ultra summit elements of u until sv is found
&gt;  //    or sv is seen not to be in the ultra summit set of u
&gt;  while sv notin P and not IsEmpty(P) do
&gt;     NextElement(~P);
&gt;  end while;
&gt; 
&gt;  print #P, "elements computed";
&gt;  isconj, c := sv in P;
&gt;  if isconj then
&gt;     // return true and an element conjugating u to v
&gt;     return true, c*cv^-1;
&gt;  else
&gt;     return false, _;
&gt;  end if;
&gt; 
&gt; end function;
</PRE>
We test our function using two pairs of elements of the braid group B on
4 strings.
<P>
<P>
<PRE>
&gt; B := BraidGroup(4);
</PRE>
As we have seen in Example <A  HREF = "text851.htm#9863">H78E7</A>, the following
elements u and v are not conjugate.
<P>
<P>
<PRE>
&gt; u := B.2 * B.1 * B.2^2 * B.1 * B.2;
&gt; v := B.2^2 * B.1 * B.3 * B.1 * B.3;
</PRE>
To prove this, our function has to compute the whole ultra summit set of u.
<P>
<P>
<PRE>
&gt; MyIsConjugate(u,v);
2 elements computed
false
&gt; #UltraSummitSet(u);
2
</PRE>
We try our function on another pair of elements.
<P>
<P>
<PRE>
&gt; r := B.3*B.2*B.3*B.2^2*B.1*B.3*B.1*B.2;
&gt; s := B.3^-1*B.2^-1*B.3*B.2*B.3*B.2^2*B.1*B.3*B.1*B.2^2*B.3;
&gt; isconj, c := MyIsConjugate(r,s);
3 elements computed
&gt; isconj;
true
&gt; r^c eq s;
true
</PRE>
The ultra summit representative of s was the 3rd ultra summit element
of r found.  Note that the function did not have to compute the whole
ultra summit set of r to find the answer.
<P>
<P>
<PRE>
&gt; #UltraSummitSet(r);
6
</PRE>
In this small example, we could also have used super summit sets for
conjugacy testing, as the super summit set of r is not much larger
than its ultra summit set.
<P>
<P>
<PRE>
&gt;  #SuperSummitSet(r);
22
</PRE>
A more challenging application of the function <TT>MyIsConjugate</TT>
from above will be presented in Example <A  HREF = "text852.htm#9896">H78E10</A>.
<HR>
<H5><A NAME = "9878">Computing Minimal Simple Elements</A></H5>

<P>
<P>
This section describes the functions for computing minimal simple elements
as introduced in Section <A  HREF = "text848.htm#9762">Computing the Class Invariants</A> and functions for
computing the <I>transport</I> and the <I>pullback</I> as defined in
<A  HREF = "text846.htm#bib_braid_ultrasummit">[Geb03]</A>.
<P>
<P>
<P>
All functions documented in this section accept two parameters,
<TT>Presentation</TT> and <TT>CheckArguments</TT>.  The parameter <TT>Presentation</TT>
can be used to specify the presentation of a braid group B with respect
to which the
computation should be performed.  Possible values for this parameter are
the strings <TT>"Artin"</TT> and <TT>"BKL"</TT>.  If no value is given for
<TT>Presentation</TT>, the presentation selected for B is used.
The parameter <TT>CheckArguments</TT> can be used to turn off argument checking
for performance reasons.  It should be noted that the results are undefined
if functions are called with invalid arguments and argument checking is
disabled.


<H5><A NAME = "GrpBrd:MinimalElementConjugatingToPositive"></A><A NAME = "9879">MinimalElementConjugatingToPositive(x, s: parameters) : GrpBrdElt, GrpBrdElt -&gt; GrpBrdElt</A></H5>

<PRE>    Presentation: MonStgElt             Default: </PRE>

<PRE>    CheckArguments: BoolElt             Default: <TT>true</TT></PRE>
<BLOCKQUOTE>
Given a positive element x of a braid group B and a simple element s,
return the minimal simple element r<sub>x</sub>(s) satisfying s preceq r<sub>x</sub>(s) and
x<sup>r<sub>x</sub>(s)</sup> &isin;B^ +.
</BLOCKQUOTE>
<H5><A NAME = "GrpBrd:MinimalElementConjugatingToSuperSummit"></A><A NAME = "9880">MinimalElementConjugatingToSuperSummit(x, s: parameters) : GrpBrdElt, GrpBrdElt -&gt; GrpBrdElt</A></H5>

<PRE>    Presentation: MonStgElt             Default: </PRE>

<PRE>    CheckArguments: BoolElt             Default: <TT>true</TT></PRE>
<BLOCKQUOTE>
Given an element x of a braid group B which is contained in its super
summit set S<sub>x</sub> and a simple element s, return the minimal simple element
&rho;<sub>x</sub>(s) satisfying s preceq &rho;<sub>x</sub>(s) and x<sup>&rho;<sub>x</sub>(s)</sup> &isin;S<sub>x</sub>.
</BLOCKQUOTE>
<H5><A NAME = "GrpBrd:MinimalElementConjugatingToUltraSummit"></A><A NAME = "9881">MinimalElementConjugatingToUltraSummit(x, s: parameters) : GrpBrdElt, GrpBrdElt -&gt; GrpBrdElt</A></H5>

<PRE>    Presentation: MonStgElt             Default: </PRE>

<PRE>    CheckArguments: BoolElt             Default: <TT>true</TT></PRE>
<BLOCKQUOTE>
Given an element x of a braid group B which is contained in its ultra
summit set U<sub>x</sub> and a simple element s, return the minimal simple element
c<sub>x</sub>(s) satisfying s preceq c<sub>x</sub>(s) and x<sup>c<sub>x</sub>(s)</sup> &isin;U<sub>x</sub>.
</BLOCKQUOTE>
<H5><A NAME = "9882"></A><A NAME = "GrpBrd:Transport">Transport</A>(x, s: parameters) : GrpBrdElt, GrpBrdElt -&gt; GrpBrdElt</H5>

<PRE>    Presentation: MonStgElt             Default: </PRE>

<PRE>    CheckArguments: BoolElt             Default: <TT>true</TT></PRE>
<BLOCKQUOTE>
Given an element x of a braid group B and a simple element s such
that both x and x<sup>s</sup> are super summit elements, return the <I>transport</I>
of s along x -&gt; cyc(x), that is, the element
&phi;<sub>x</sub>(s) = (D  ^<sub>l</sub> xD<sup> - inf(x)</sup>)<sup> - 1</sup> .s .(D  ^<sub>l</sub> x<sup>s</sup>D<sup> - inf(x)</sup>),
 where D is the fundamental element of B.
The transport is a simple element satisfying
cyc(x<sup>s</sup>) = cyc(x)<sup>&phi;<sub>x</sub>(s)</sup> <A  HREF = "text846.htm#bib_braid_ultrasummit">[Geb03]</A>.
</BLOCKQUOTE>
<H5><A NAME = "9883"></A><A NAME = "GrpBrd:Pullback">Pullback</A>(x, s: parameters) : GrpBrdElt, GrpBrdElt -&gt; GrpBrdElt</H5>

<PRE>    Presentation: MonStgElt             Default: </PRE>

<PRE>    CheckArguments: BoolElt             Default: <TT>true</TT></PRE>
<BLOCKQUOTE>
Given an element x of a braid group B which is contained in its super
summit set S<sub>x</sub> and a simple element s, return the <I>pullback</I>
of s along x -&gt; cyc(x), that is, the unique preceq-minimal
element &pi;<sub>x</sub>(s) satisfying x<sup>&pi;<sub>x</sub>(s)</sup> &isin;S<sub>x</sub> and
s preceq &phi;<sub>x</sub>(&pi;<sub>x</sub>(s)) <A  HREF = "text846.htm#bib_braid_ultrasummit">[Geb03]</A>.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "9884">Example <TT>GrpBrd_MinimalSimpleElements (H78E9)</TT></A></H3>
<P>
The following function uses the technique sketched in
Section <A  HREF = "text848.htm#9760">Conjugacy Testing and Conjugacy  Search</A> for computing the ultra summit set of
a given braid.  This is basically the algorithm used by the Magma
function <TT>UltraSummitSet</TT>.
<P>
<P>
<PRE>
&gt; function MyUltraSummitSet(x)
&gt; 
&gt; // create a subset of the ultra summit set of x
&gt; U := {@ UltraSummitRepresentative(x) @};
&gt; gens := Generators(Parent(x));
&gt; pos := 1;
&gt; 
&gt; // close U under conjugation with minimal simple elements
&gt; while pos le #U do
&gt;    y := U[pos];
&gt;    // add missing conjugates of y
&gt;    for z in { y^MinimalElementConjugatingToUltraSummit(y, s)
&gt; : s in gens } do
&gt;       if z notin U then
&gt;          Include(~U, z);
&gt;       end if;
&gt;    end for;
&gt;    pos +:= 1;
&gt; end while;
&gt; 
&gt; return U;
&gt; 
&gt; end function;
</PRE>
<HR>
<PRE></PRE> <A  HREF = "text852.htm">[Next]</A><A  HREF = "text850.htm">[Prev]</A> <A  HREF = "text852.htm">[Right]</A> <A  HREF = "text850.htm">[Left]</A> <A  HREF = "text847.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<br><small>Version: V2.22 of <I>
Thu Jun  9 16:37:49 EST 2016
</I></small>
</body></html>