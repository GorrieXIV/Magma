<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <link rel='stylesheet' href='help.css' type='text/css'>
  <TITLE>Duals and Injectives</TITLE>
</head>
<body BGCOLOR="#FFFFFF">

 <A  HREF = "text977.htm">[Next]</A><A  HREF = "text975.htm">[Prev]</A> <A  HREF = "text977.htm">[Right]</A> <A  HREF = "text975.htm">[Left]</A> <A  HREF = "text966.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<PRE></PRE><H3><A NAME = "11053">Duals and Injectives</A></H3>

<P>
<P>
<P>
If k is the base
ring for the algebra A then the k-dual Hom<sub>k</sub>(M, k) for a 
right module M over A is a right module over the opposite algebra OA of
A. Furthermore, the dual of a projective OA-module is an injective
A-module and the dual of a projective OA-resolution of a module
M is an A-injective resolution of the dual of M.



<H5>Subsections</H5>
<UL>
<LI> <A  HREF = "text976.htm#11056">Injective Modules</A>
</UL>
<H5><A NAME = "11054">Dual(M) : ModAlg -&gt; ModAlg</A></H5>
<BLOCKQUOTE>
Given a module M defined over a basic algebra M, this function returns
the dual of M as a module over the opposite of the algebra of M.
Note that the opposite of the algebra of M is created if it does not
already exist.
</BLOCKQUOTE>
<H5><A NAME = "11055">BaseChangeMatrix(A) : AlgBas -&gt; ModAlg</A></H5>
<BLOCKQUOTE>
Given a basic algebra A that has opposite algebra O, the function creates 
the change of basis matrix B from the vector space of A to the vector 
space of O, so that if x, y are in A then (xy)B is the same as 
(yB)(xB) &isin;O.
</BLOCKQUOTE>
<H4><A NAME = "11056">Injective Modules</A></H4>

<P>
<P>
<P>
Injective hulls, and injective resolutions of a module are computed by 
taking the projective cover or projective resolution of the dual module
over the opposite algebra and then again taking the dual to retrieve 
modules or complexes over the original algebra. If  the opposite algebra
of the  module has not been computed then it will be created in the evaluation
of any of the injective module functions. 


<H5><A NAME = "11057">InjectiveModule(B, i) : AlgBas, RngIntElt -&gt; ModAlg</A></H5>
<BLOCKQUOTE>
The i<sup>th</sup> injective module of the algebra B.
</BLOCKQUOTE>
<H5><A NAME = "11058">InjectiveHull(M) : ModAlg -&gt; ModAlg, ModMatFldElt,             SeqEnum[ModMatFldElt], SeqEnum[ModMatFldElt], SeqEnum[RngIntElt]</A></H5>
<BLOCKQUOTE>
The injective hull of the module M is the injective module I of minimal 
dimension such that there is an inclusion &iota;: M -&gt; I. The function
returns I, &iota;, the sequences of inclusions and projections from and
to the indecomposable injective summands of I, and the type of I as
a sequence T := [t<sub>1</sub> ..., t<sub>s</sub>] where I has t<sub>1</sub> summands of type  1,
t<sub>2</sub> of type  2, etc.
</BLOCKQUOTE>
<H5><A NAME = "11059">InjectiveResolution(M, n) : ModAlg, RngIntElt -&gt; ModCpx, ModMatFldElt</A></H5>
<BLOCKQUOTE>
The complex giving the minimal injective resolution of the module 
M together with the inclusion homomorphism from M into its 
injective hull. Note that homomorphisms go from left to
right so that the kernel of the first homomorphism in the 
complex is M. The function computes the compact injective
resolution and creates the complex of the injective resolution
from that. 
<P>
<P>
</BLOCKQUOTE>
<H5><A NAME = "11060">CompactInjectiveResolution(M, n) : ModAlg, RngIntElt -&gt; Rec</A></H5>
<BLOCKQUOTE>
A  minimal injective resolution for the module M out to n steps in compact 
form 
together with the coaugmentation map (M -&gt; I<sub>0</sub>). The compact form of 
the resolution is a list of the minimal pieces of information needed 
to reconstruct the boundary maps in the resolution. That is, the boundary map
(I<sub>i - 1</sub> mapright(&part;<sub>i</sub>) I<sub>i</sub>) is recorded as 
a matrix whose entries are the images of the generators 
for indecomposable injective modules making 
up I<sub>i - 1</sub> in the indecomposable 
projective modules making up I<sub>i</sub>. The actual return of the function is the 
compact projective resolution of the dual module of M over the opposite 
algebra of the algebra of M. The return is a record with the fields:
<DL COMPACT class='compact'>
<DT>(a)</DT><DD>The list of isomorphism types of the injective modules in 
the resolution, each given as a sequence of integers giving the number
of direct summands of each indecomposable injective in the module
(field name <TT>BettiNumbers</TT>).
<DT>(b)</DT><DD>The record of the boundary maps (field name <TT>ResolutionRecord</TT>).
<DT>(c)</DT><DD>The module M (field name <TT>Module</TT>).
<DT>(d)</DT><DD>The coaugmentation map (field name <TT>CoaugmentationMap</TT>). 
<DT>(e)</DT><DD>The type of the resolution, whether projective or injective
(field name <TT>Typ</TT>).</DL>
</BLOCKQUOTE>
<H5><A NAME = "11061">InjectiveSyzygyModule(M, n) : ModAlg, RngIntElt -&gt; ModAlg</A></H5>
<BLOCKQUOTE>
The n<sup>th</sup> injective-syzygy module of M. The module is constructed 
from the compact injective resolution of M. The compact resolution is 
constructed if it does not already exist. 
</BLOCKQUOTE>
<H5><A NAME = "11062">SimpleCohomologyDimensions(M) : ModAlg -&gt; SeqEnum</A></H5>
<BLOCKQUOTE>
The sequence of sequences of dimensions of the cohomology groups 
Ext<sup>j</sup>(S<sub>i</sub>, M) for simple modules S<sub>i</sub> and module M, to the extent that they have
been computed.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "11063">Example <TT>AlgBas_Opposite (H90E20)</TT></A></H3>
We create the basic algebra of a quiver over a field with 8 elements. The 
quiver has two nodes and three arrows, going from node 1 to node 2, from
2 to 1 and from 1 to 1. The relations are given in the sequence cs{rrr}.
<P>
<P>
<PRE>
&gt; ff := GF(8);
&gt; FA&lt;e1,e2,a,b,c&gt; := FreeAlgebra(ff,5);
&gt; rrr := [a*b*a*b*a, c*c*c*c, a*b*c - c*a*b];
&gt; B := BasicAlgebra(FA,rrr,2,[&lt;1,2&gt;,&lt;2,1&gt;,&lt;1,1&gt;]);
&gt; B;
Basic algebra of dimension 41 over GF(2^3)
Number of projective modules: 2
Number of generators: 5
&gt; DimensionsOfProjectiveModules(B);
[ 20, 21 ]
&gt; DimensionsOfInjectiveModules(B);
[ 24, 17 ]
&gt; P1 := ProjectiveModule(B,1);
&gt; Socle(P1);
AModule of dimension 1 over GF(2^3)
</PRE>
We consider the injective resolution of the first projective module.
<P>
<P>
<PRE>
&gt; time in1 := CompactInjectiveResolution(P1,10);
reverse trees
Time: 3.850
</PRE>
Note that part of the time was required to create the opposite algebra
of cs{B}.
<P>
<P>
<PRE>
&gt; SimpleCohomologyDimensions(P1);
[
    [ 1, 0 ],
    [ 0, 4 ],
    [ 4, 0 ],
    [ 4, 0 ],
    [ 4, 0 ],
    [ 4, 0 ],
    [ 4, 0 ],
    [ 4, 0 ],
    [ 4, 0 ],
    [ 4, 0 ]
]
</PRE>
The injective resolution appears to be periodic. Now we look at a module 
constructed from the resolution. 
<P>
<P>
<PRE>
&gt; M := InjectiveSyzygyModule(P1,6);
&gt; M;
AModule M of dimension 64 over GF(2^3)
</PRE>
Consider the space of endomorphisms of M.
<P>
<P>
<PRE>
&gt; hh := AHom(M,M);
&gt; hh;
KMatrixSpace of 64 by 64 matrices and dimension 128 over GF(2^3)
&gt; [Rank(hh.i): i in [1 .. Dimension(hh)]];
[ 16, 16, 16, 16, 12, 12, 12, 12, 8, 8, 8, 8, 8, 8, 8, 8, 6, 6, 6, 6, 4, 4, 4, 
4, 4, 4, 4, 4, 2, 2, 2, 2, 4, 8, 12, 16, 16, 12, 8, 4, 8, 4, 12, 16, 4, 8, 12, 
16, 16, 16, 16, 16, 2, 4, 6, 8, 8, 6, 4, 2, 4, 2, 6, 8, 2, 4, 6, 8, 12, 12, 12, 
12, 8, 8, 8, 8, 8, 8, 8, 8, 6, 6, 6, 6, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 16, 
16, 16, 16, 12, 12, 12, 12, 8, 8, 8, 8, 8, 8, 8, 8, 6, 6, 6, 6, 4, 4, 4, 4, 4, 
4, 4, 4, 2, 2, 2, 2 ]
</PRE>
Note that no generator of the endomorphism ring has rank more than 16. 
This would
indicate that the module is decomposable since the identity map must be a sum
of homomorphisms of smaller rank.
<P>
How can we produce a decomposition? One method is the following.
<P>
<P>
<PRE>
&gt; vv := Random(hh);
&gt; Rank(vv);
64
&gt; vv*vv eq vv;
false
&gt; [Rank(vv*vv-u*vv):u in ff];
[ 60, 64, 64, 64, 64, 64, 64, 64 ]
&gt; [u:u in ff];
[ 1, ff.1, ff.1^2, ff.1^3, ff.1^4, ff.1^5, ff.1^6, 0 ]
&gt; Rank(vv*vv - vv);
60
&gt; U := vv*vv - vv;
&gt; Rank(U);
60
&gt; Rank(U*U);
56
&gt; Rank(U*U*U);
52
&gt; Rank(U*U*U*U);
48
&gt; Rank(U*U*U*U*U);
48
&gt; Rank(U*U*U*U*U*U);
48
&gt; T := U*U*U*U;
&gt; N1 := Kernel(T);
&gt; N2 := Image(T);
&gt; Dimension(N1);
16
&gt; Dimension(N2);
48
&gt; Dimension(N1+N2);
64
</PRE>
So the sum of cs{N1} and cs{N2} must be all of cs{M} and by counting
dimensions, it must be a direct sum.
<HR>
<PRE></PRE> <A  HREF = "text977.htm">[Next]</A><A  HREF = "text975.htm">[Prev]</A> <A  HREF = "text977.htm">[Right]</A> <A  HREF = "text975.htm">[Left]</A> <A  HREF = "text966.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<br><small>Version: V2.22 of <I>
Thu Jun  9 16:37:49 EST 2016
</I></small>
</body></html>