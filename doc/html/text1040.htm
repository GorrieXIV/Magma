<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <link rel='stylesheet' href='help.css' type='text/css'>
  <TITLE>Creation Functions</TITLE>
</head>
<body BGCOLOR="#FFFFFF">

 <A  HREF = "text1041.htm">[Next]</A><A  HREF = "text1039.htm">[Prev]</A> <A  HREF = "text1041.htm">[Right]</A> [____] <A  HREF = "text1039.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<PRE></PRE><H3><A NAME = "11722">Creation Functions</A></H3>




<H5>Subsections</H5>
<UL>
<LI> <A  HREF = "text1040.htm#11723">Structure Creation</A>
<LI> <A  HREF = "text1040.htm#11726">Element Creation</A>
<LI> <A  HREF = "text1040.htm#11731">The Table of Irreducible Characters</A>
</UL>
<H4><A NAME = "11723">Structure Creation</A></H4>



<H5><A NAME = "11724">ClassFunctionSpace(G) : Grp -&gt; AlgChtr</A></H5>
<H5>CharacterRing(G) : Grp -&gt; AlgChtr</H5>
<BLOCKQUOTE>
Given a finite group G, create the ring of complex-valued class functions.
This function will trigger the computation of the conjugacy classes of G
if these are not yet known. Information about the irreducible characters
is stored in the ring when it is computed.
</BLOCKQUOTE>
<H5><A NAME = "11725">ClassFunctionSpace(Q) : SeqEnum -&gt; AlgChtr</A></H5>
<H5>CharacterRing(Q) : SeqEnum -&gt; AlgChtr</H5>
<BLOCKQUOTE>
Construct the ring of complex-valued class functions for a group that has 
classes data as given in Q. The sequence Q must be a sequence of
pairs <TT>&lt;o, n&gt;</TT>, each representing one conjugacy class, where o is the
order of the elements in the class, and n is the length of the class.
The first class must be the class of the group identity element.
This is a sequence as returned by the <A  HREF = "text1041.htm#Chtr:ClassesData">ClassesData</A> intrinsic.
<P>
This function allows the creation of a space to work with characters
without the attached group. 
</BLOCKQUOTE>
<H4><A NAME = "11726">Element Creation</A></H4>

<P>
<P>
The elementary constructions for class functions are listed. Other
useful ways of defining class functions and characters are defined
in sections discussing the permutation character, the (de)composition
functions, and the sections on the conjugating, restricting and inducing of
class functions.


<H5><A NAME = "11727">elt&lt; R | a<sub>1</sub>, ..., a<sub>k</sub> :parameters&gt; : AlgChtr, FldCycElt, ..., FldCycElt -&gt; AlgChtrElt</A></H5>
<H5>R ! [ a<sub>1</sub>, ..., a<sub>k</sub> ] : AlgChtr, SeqEnum -&gt; AlgChtrElt</H5>
<BLOCKQUOTE>
Given the ring of class functions R of
a finite group G with k conjugacy 
classes and k elements a<sub>i</sub> contained in some common cyclotomic field,
create a class function on G for which the value on the i-th
class is equal to the i-th term a<sub>i</sub>.
<P>
<P>
<PRE>
     Character: BoolElt                  Default: <TT>false</TT>
</PRE>
If <TT>Character := true</TT>, then the resulting character is flagged to be
a proper character.
</BLOCKQUOTE>
<H5><A NAME = "11728">R ! a : AlgChtr, RngIntElt -&gt; AlgChtrElt</A></H5>
<H5>R ! a : AlgChtr, FldRatElt -&gt; AlgChtrElt</H5>
<H5>R ! a : AlgChtr, FldCycElt -&gt; AlgChtrElt</H5>
<BLOCKQUOTE>
Define a constant class function for the ring of class functions R
of the group G. Here a is allowed to be an integer, a rational field
element or a cyclotomic field element.
</BLOCKQUOTE>
<H5><A NAME = "11729">Id(R) : AlgChtr -&gt; AlgChtrElt</A></H5>
<H5>Identity(R) : AlgChtr -&gt; AlgChtrElt</H5>
<H5>One(R) : AlgChtr -&gt; AlgChtrElt</H5>
<H5>PrincipalCharacter(G) : Grp -&gt; AlgChtrElt</H5>
<BLOCKQUOTE>
Given the finite group G or its ring of class functions R, create
the principal character (which takes on the value 1 on every element
of G).
</BLOCKQUOTE>
<H5><A NAME = "11730">Zero(R) : AlgChtr -&gt; AlgChtrElt</A></H5>
<BLOCKQUOTE>
Given a ring of class functions R create its zero element (which
is the class function that takes on the value 0 on every element
of the group).
</BLOCKQUOTE>
<H4><A NAME = "11731">The Table of Irreducible Characters</A></H4>

<P>
<P>
The function <TT>CharacterTable</TT> can be invoked to determine
the complete or a partial table of irreducible characters on
a finite group G. If necessary, an existing character table
can be supplemented by another call to the function. The known
irreducible characters are stored in the character ring of G.
<P>
The default algorithm for character tables is Unger's Induce/Reduce algorithm,
described in detail in <A  HREF = "text1038.htm#bib_chtr-table-unger">[Ung06]</A>.
Computing character tables assumes that the classes
of the group can be computed and stored, along with a class representative
for each class, as well as the power map of the group.
Unger's algorithm constructs elementary subgroups of the group
(where elementary means direct product of cyclic group with p-group), and
constructs characters of these subgroups (using Conlon's algorithm for the 
character table of the p-part of the group). Following Brauer's theorem on
induced characters, these characters are induced
to the full group and all irreducible characters of the full group are found
in the integral span of the induced characters (using LLL reduction to maintain
a manageable basis of the character space found). The two potentially most
time-consuming parts of the algorithm are the computation of fusion in the
elementary subgroups, which is necessary for induction, and repeated use
of LLL to maintain a basis of the space of generalised characters found to date.
Arithmetic with generalised characters is done quickly by using a finite field
representation of these characters, as in Dixon's work <A  HREF = "text1038.htm#bib_Dixon67">[Dix67]</A>, but here
the prime used may be twice the length of Dixon's.
<P>
The Dixon-Schneider algorithm for computing character tables
<A  HREF = "text1038.htm#bib_Dixon67">[Dix67]</A>, <A  HREF = "text1038.htm#bib_Schn90">[Sch90]</A> is also available.
See below for details on how to access it. This was the previous default
algorithm for character tables.
As indicated above,
Conlon's algorithm for the character table of a p-group
<A  HREF = "text1038.htm#bib_conlon_chtrs">[Con90]</A> is also implemented, and may be accessed directly as
indicated below.
<P>
The functions in this section return character tables, which are
enumerated sequences of characters that are flagged to allow
printing in a special format.


<H5><A NAME = "11732">KnownIrreducibles(R) : AlgChtr -&gt; SeqEnum</A></H5>
<H5>KnownIrreducibles(G) : Grp -&gt; SeqEnum</H5>
<BLOCKQUOTE>
Given a finite group G, or a class function space R of G,
return the table of irreducible characters currently stored.
Such a table is a sequence of characters with specially formatted
printing.
<P>
It should be noted that characters are stored with some information
about whether they are characters, generalized characters or
class functions.  From this information, it is often possible to deduce
with little effort that a character is, in fact, irreducible.  When
a new irreducible is found this way, it is immediately inserted into
the table of irreducible characters.
</BLOCKQUOTE>
<H5><A NAME = "11733"></A><A NAME = "CharacterTable:Grp">CharacterTable</A>(G :parameters) : Grp -&gt; SeqEnum</H5>
<BLOCKQUOTE>
Construct the table of ordinary irreducible characters for the group G.
<P>
<P>
<P>
<PRE>
     Al: MonStgElt                       Default: "Default"
</PRE>
This parameter controls the algorithm used. The string <TT>"DS"</TT>
forces use of the Dixon-Schneider algorithm.
The string <TT>"IR"</TT> forces the use of Unger's
Induce/Reduce algorithm <A  HREF = "text1038.htm#bib_chtr-table-unger">[Ung06]</A>. The string 
<TT>"Conlon"</TT> forces the use of Conlon's algorithm. This last is only
valid when the group is a p-group.
The <TT>"Default"</TT> algorithm is to use Dixon-Schneider for groups of order
&le;5000, Conlon's algorithm for larger p-groups and Unger's algorithm
for other groups. This may change in future.
<P>
<P>
<PRE>
     DSSizeLimit: RngIntElt              Default: 0
</PRE>
When the algorithm selected is either "Default" or "IR", a positive value n
for <TT>DSSizeLimit</TT>
means that before using ithe Induce/Reduce algorithm, the full possible
character space is split by some passes of the Dixon-Schneider algorithm,
restricted to using class matrices corresponding to conjugacy classes with
size at most n.
</BLOCKQUOTE>
<H5><A NAME = "11734">CharacterTableDS(G :parameters) : Grp -&gt; SeqEnum, SeqEnum</A></H5>

<PRE>    ClassMatrices: SeqEnum              Default: []</PRE>

<PRE>    ClassMatrixLimit: RngIntElt         Default: &infin;</PRE>

<PRE>    ClassSizeLimit: RngIntElt           Default: &infin;</PRE>

<PRE>    MinChars: RngIntElt                 Default: &infin;</PRE>

<PRE>    Modulus: RngIntElt                  Default: 0</PRE>
<BLOCKQUOTE>
Given a finite group G, construct the table of
irreducible characters of G using the Dixon-Schneider algorithm 
<A  HREF = "text1038.htm#bib_Dixon67">[Dix67]</A>, <A  HREF = "text1038.htm#bib_Schn90">[Sch90]</A>.
The conjugacy classes of
G will be computed if necessary; if the user wishes to exert control
over the computation of the classes, the function <TT>Classes</TT> can
be invoked on G before calling <TT>CharacterTableDS</TT>.
<P>
There are several optional parameters for <TT>CharacterTableDS</TT>.
Assigning a non-negative integer value m to  <TT>MinChars</TT>,
indicates that the computation is to be terminated as soon as 
m or more additional characters have been found.
By setting <TT>ClassMatrixLimit</TT> to a positive integer n,
the user can limit the number of class matrices used.
If the calculation of all irreducible characters (or at least 
m of them if <TT>MinChars</TT> has been set) cannot be completed 
by using k class matrices, an incomplete character table
is returned. Setting <TT>ClassSizeLimit</TT> to an integer n
restricts the algorithm to computing class matrices corresponding to classes
of size at most n. Again, if the calculation of all irreducible characters
cannot be completed using class matrices from these small classes,
an incomplete character table is returned.
The optional argument <TT>ClassMatrices</TT> (a sequence of integers
in the range 1 ... k, where k is the number of conjugacy classes
of G) can be used to specify a preference for the order in which
class matrices should be used. Finally the <TT>Modulus</TT> argument can be used
to set which prime field is used for the internal computations of the
Dixon-Schneider algorithm. The value used must be a prime equivalent to
1 modulo the group exponent and greater than twice the square root of the
group order.
<P>
The second return argument is the sequence of unsplit character spaces
remaining at the point the algorithm terminated.
This is empty when the algorithm returns a complete character table, but may
be useful when an incomplete character table is returned.
</BLOCKQUOTE>
<H5><A NAME = "11735">Basis(R) : AlgChtr -&gt; SeqEnum</A></H5>
<BLOCKQUOTE>
The function <TT>Basis</TT> takes the character ring R of G as input
and performs the same computation to find the basis for R consisting
of the irreducible characters.
<P>
Both <TT>CharacterTable</TT> and <TT>Basis</TT> return a character table,
which is an enumerated sequence of elements
of the character ring over G (if necessary, the ring is created)
that only differs from arbitrary sequences of class functions with
respect to printing.
</BLOCKQUOTE>
<H5><A NAME = "11736">CharacterTableConlon(G) : Grp -&gt; SeqEnum</A></H5>
<BLOCKQUOTE>
Compute the character table of group G using Conlon's algorithm for
p-groups. The group G must thus be a p-group for some prime p.
</BLOCKQUOTE>
<H5><A NAME = "11737">LinearCharacters(G): Grp -&gt; SeqEnum</A></H5>
<BLOCKQUOTE>
Given a finite group G, determine the (partial) character table containing
only the linear characters.
</BLOCKQUOTE>
<H5><A NAME = "11738">CharacterDegrees(G): GrpPerm -&gt; SeqEnum</A></H5>
<H5>CharacterDegrees(G): GrpPC -&gt; SeqEnum</H5>
<H5>CharacterDegrees(G): GrpMat -&gt; SeqEnum</H5>
<H5>CharacterDegrees(G): GrpAb -&gt; SeqEnum</H5>
<BLOCKQUOTE>
Returns the degrees of the ordinary irreducible characters of the finite group G.
The sequence returned has form
[&lt;d<sub>1</sub>, c<sub>1</sub>&gt;, &lt;d<sub>2</sub>, c<sub>2</sub>&gt;, ... ] where c<sub>i</sub> is the number of characters of degree d<sub>i</sub>.
For p-groups Slattery's algorithm is used, for other soluble groups Conlon's counting
algorithm is used, and for insoluble groups the character table of G is computed.
</BLOCKQUOTE>
<H5><A NAME = "11739">CharacterDegrees(G, z, p): GrpPC, GrpPCElt, RngIntElt -&gt; SeqEnum</A></H5>
<BLOCKQUOTE>
Returns the degrees of the absolutely irreducible characters of G lying over a
faithful linear character of &lt; z &gt;, where z is a central element of G
and p is zero or a prime. 
</BLOCKQUOTE>
<H5><A NAME = "11740">CharacterDegreesPGroup(G): GrpPC -&gt; SeqEnum</A></H5>
<BLOCKQUOTE>
Returns the degrees of the ordinary irreducible characters of the finite p-group
G. The sequence returned has form [c<sub>0</sub>, c<sub>1</sub>, c<sub>2</sub> ... ], where c<sub>i</sub> is the number
of characters of degree p<sup>i</sup>. Slattery's counting algorithm is used.
</BLOCKQUOTE>
<H5><A NAME = "11741">RationalCharacterTable(G): GrpFin -&gt; SeqEnum</A></H5>
<BLOCKQUOTE>
Returns a sequence of minimal rational characters of G. These are the sums
of the Galois orbits on the character table of G.
</BLOCKQUOTE>
<H5><A NAME = "11742">SaveCharacterTable(T, F): SeqEnum[AlgChtrElt], MonStgElt -&gt;</A></H5>
<BLOCKQUOTE>
Write the character table T to the file named by the string F.
The command
<P>
texttt{&gt; T := eval Read(F);}
<P>
will read T in, as a character table without group attached.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "11743">Example <TT>Chtr_CharacterTable (H97E1)</TT></A></H3>
We use the texttt{CharacterTable} function and print the resulting table.
Character tables have a special print format.
<P>
<P>
<PRE>
&gt; G := Alt(5);
&gt; CT := CharacterTable(G);
&gt; CT;




Character Table of Group G
--------------------------




---------------------------
Class |   1  2  3    4    5
Size  |   1 15 20   12   12
Order |   1  2  3    5    5
---------------------------
p  =  2   1  1  3    5    4
p  =  3   1  2  1    5    4
p  =  5   1  2  3    1    1
---------------------------
X.1   +   1  1  1    1    1
X.2   +   3 -1  0   Z1 Z1#2
X.3   +   3 -1  0 Z1#2   Z1
X.4   +   4  0  1   -1   -1
X.5   +   5  1 -1    0    0




Explanation of Character Value Symbols
--------------------------------------


# denotes algebraic conjugation, that is,
#k indicates replacing the root of unity w by w^k


Z1     = (CyclotomicField(5: Sparse := true)) ! [
RationalField() | 1, 0, 1, 1 ]


&gt; CT[2];
( 3, -1, 0, zeta(5)_5^3 + zeta(5)_5^2 + 1, -zeta(5)_5^3 -
  zeta(5)_5^2 )
&gt; CT[2]:Minimal;
( 3, -1, 0, Z1, Z1#2 )
</PRE>
The character table is represented as a sequence of characters.
Non-rational values in a character table are printed symbolically.
This same printing can be forced on an individual character by
using texttt{Minimal} printing.
<HR>
<H3><A NAME = "11744">Example <TT>Chtr_CharacterTable2 (H97E2)</TT></A></H3>
The texttt{CharacterTable} algorithm can handle quite large groups.
We illustrate this by computing the character table of the almost simple
group P&Gamma; U<sub>5</sub>(4).
<P>
<P>
<PRE>
&gt; G := PGammaU(5,4);
&gt; G;
Permutation group G acting on a set of cardinality 17425
Order = 2^22 * 3^2 * 5^5 * 13 * 17 * 41
&gt; time CT := CharacterTable(G);
Time: 22.220
&gt; #CT;
160
&gt; Degree(CT[160]);
5227500
</PRE>
<HR>
<PRE></PRE> <A  HREF = "text1041.htm">[Next]</A><A  HREF = "text1039.htm">[Prev]</A> <A  HREF = "text1041.htm">[Right]</A> [____] <A  HREF = "text1039.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<br><small>Version: V2.22 of <I>
Thu Jun  9 16:37:49 EST 2016
</I></small>
</body></html>