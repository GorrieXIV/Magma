<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <link rel='stylesheet' href='help.css' type='text/css'>
  <TITLE>Element Operations</TITLE>
</head>
<body BGCOLOR="#FFFFFF">

 <A  HREF = "text238.htm">[Next]</A><A  HREF = "text236.htm">[Prev]</A> <A  HREF = "text238.htm">[Right]</A> <A  HREF = "text236.htm">[Left]</A> <A  HREF = "text233.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<PRE></PRE><H3><A NAME = "2066">Element Operations</A></H3>




<H5>Subsections</H5>
<UL>
<LI> <A  HREF = "text237.htm#2067">Generic Element Functions and Predicates</A>
<LI> <A  HREF = "text237.htm#2068">Comparison of and Membership</A>
<LI> <A  HREF = "text237.htm#2069">Other Predicates</A>
<LI> <A  HREF = "text237.htm#2072">Arithmetic</A>
<LI> <A  HREF = "text237.htm#2073">Conversions</A>
<LI> <A  HREF = "text237.htm#2081">Rounding</A>
<LI> <A  HREF = "text237.htm#2086">Precision</A>
<LI> <A  HREF = "text237.htm#2091">Constants</A>
<LI> <A  HREF = "text237.htm#2095">Simple Element Functions</A>
<LI> <A  HREF = "text237.htm#2104">Roots</A>
<LI> <A  HREF = "text237.htm#2110">Continued Fractions</A>
<LI> <A  HREF = "text237.htm#2114">Linear and Algebraic Dependencies</A>
</UL>
<H4><A NAME = "2067">Generic Element Functions and Predicates</A></H4>

<P>
<P>
All predicates on real or complex numbers that check
whether these numbers are equal to an integer do so
within the given precision of the parent field. Thus
<TT>IsOne(c)</TT> for an element of a complex domain of
precision 20 returns true if and only if the real part
equals one and the imaginary part equals 0 up to 20 decimals.


<H5>Parent(r) : FldReElt -&gt; Rng</H5>

<H5>Parent(r) : FldComElt -&gt; Rng</H5>

<H5>Category(r) : FldReElt -&gt; Cat</H5>

<H5>Category(r) : FldComElt -&gt; Cat</H5><P>

<H5>IsZero(r) : FldReElt -&gt; BoolElt</H5>

<H5>IsZero(r) : FldComElt -&gt; BoolElt</H5>

<H5>IsOne(r) : FldReElt -&gt; BoolElt</H5>

<H5>IsOne(r) : FldComElt -&gt; BoolElt</H5>

<H5>IsMinusOne(r) : FldReElt -&gt; BoolElt</H5>

<H5>IsMinusOne(r) : FldComElt -&gt; BoolElt</H5><P>

<H5>IsUnit(r) : FldReElt -&gt; BoolElt</H5>

<H5>IsUnit(r) : FldComElt -&gt; BoolElt</H5>

<H5>IsZeroDivisor(r) : FldReElt -&gt; BoolElt</H5>

<H5>IsZeroDivisor(r) : FldComElt -&gt; BoolElt</H5><P>

<H5>IsIdempotent(r) : FldReElt -&gt; BoolElt</H5>

<H5>IsIdempotent(r) : FldComElt -&gt; BoolElt</H5>

<H5>IsNilpotent(r) : FldReElt -&gt; BoolElt</H5>

<H5>IsNilpotent(r) : FldComElt -&gt; BoolElt</H5><P>

<H5>IsIrreducible(r) : FldReElt -&gt; BoolElt</H5>

<H5>IsIrreducible(r) : FldComElt -&gt; BoolElt</H5>

<H5>IsPrime(r) : FldReElt -&gt; BoolElt</H5>

<H5>IsPrime(r) : FldComElt -&gt; BoolElt</H5><P>

<H4><A NAME = "2068">Comparison of and Membership</A></H4>

<P>
<P>
The (in)equality test on real numbers of only test for equality up to the given
precision.  Equality testing on complex numbers is done by testing the real and
imaginary parts.
<P>
The comparison functions <TT>gt, ge, lt, le</TT> are not defined for complex
numbers.


<H5>a eq b : FldReElt, FldReElt -&gt; BoolElt</H5>

<H5>a ne b : FldReElt, FldReElt -&gt; BoolElt</H5>

<H5>a eq b : FldComElt, FldComElt -&gt; BoolElt</H5>

<H5>a ne b : FldComElt, FldComElt -&gt; BoolElt</H5><P>

<H5>a in R : FldReElt, FldRe -&gt; BoolElt</H5>

<H5>a notin R : FldReElt, FldRe -&gt; BoolElt</H5>

<H5>a in R : FldComElt, FldCom -&gt; BoolElt</H5>

<H5>a notin R : FldComElt, FldCom -&gt; BoolElt</H5><P>

<H5>a gt b : FldReElt, FldReElt -&gt; BoolElt</H5>

<H5>a ge b : FldReElt, FldReElt -&gt; BoolElt</H5>

<H5>a lt b : FldReElt, FldReElt -&gt; BoolElt</H5>

<H5>a le b : FldReElt, FldReElt -&gt; BoolElt</H5><P>

<H5>Maximum(a, b) : FldReElt, FldReElt -&gt; FldReElt</H5>

<H5>Minimum(a, b) : FldReElt, FldReElt -&gt; FldReElt</H5><P>

<H5>Maximum(Q) : [FldReElt] -&gt; FldReElt</H5>

<H5>Minimum(Q) : [FldReElt] -&gt; FldReElt</H5><P>

<H4><A NAME = "2069">Other Predicates</A></H4>



<H5><A NAME = "2070">IsIntegral(c) : FldReElt -&gt; BoolElt</A></H5>
<H5>IsIntegral(c) : FldComElt -&gt; BoolElt</H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if and only if the real or complex number c is a rational integer.
</BLOCKQUOTE>
<H5><A NAME = "2071">IsReal(c) : FldComElt -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if the complex number c is real, <TT>false</TT> otherwise. This checks whether
the digits of the imaginary part of c are 0 up to the
precision of the parent complex field.
</BLOCKQUOTE>
<H4><A NAME = "2072">Arithmetic</A></H4>

<P>
<P>
The binary operations <TT>+, -, *, /</TT> allow combinations of arguments
from the integers, the rationals, and real and complex fields; automatic
coercion is applied where necessary (see the Introduction).


<H5>+ r : FldReElt -&gt; FldReElt</H5>

<H5>+ r : FldComElt -&gt; FldComElt</H5>

<H5>- r : FldReElt -&gt; FldReElt</H5>

<H5>- r : FldComElt -&gt; FldComElt</H5><P>

<H5>r + s : FldReElt, FldReElt -&gt; FldReElt</H5>

<H5>r + s : FldComElt, FldComElt -&gt; FldComElt</H5>

<H5>r - s : FldReElt, FldReElt -&gt; FldReElt</H5>

<H5>r - s : FldComElt, FldComElt -&gt; FldComElt</H5>

<H5>r * s : FldReElt, FldReElt -&gt; FldReElt</H5>

<H5>r * s : FldComElt, FldComElt -&gt; FldComElt</H5>

<H5>r / s : FldReElt, FldReElt -&gt; FldReElt</H5>

<H5>r / s : FldComElt, FldComElt -&gt; FldComElt</H5>

<H5>r ^ k : FldReElt, FldReElt -&gt; FldReElt</H5>

<H5>r ^ k : FldReElt, RngIntElt -&gt; FldReElt</H5>

<H5>r ^ k : FldComElt, RngIntElt -&gt; FldComElt</H5>

<H5>r ^ k : FldComElt, FldComElt -&gt; FldComElt</H5><P>

<H5>r +:= s : FldReElt, FldReElt -&gt; FldReElt</H5>

<H5>r +:= s : FldComElt, FldComElt -&gt; FldComElt</H5>

<H5>r -:= s : FldReElt, FldReElt -&gt; FldReElt</H5>

<H5>r -:= s : FldComElt, FldComElt -&gt; FldComElt</H5>

<H5>r *:= s : FldReElt, FldReElt -&gt; FldReElt</H5>

<H5>r *:= s : FldComElt, FldComElt -&gt; FldComElt</H5>

<H5>r /:= s : FldReElt, FldReElt -&gt; FldReElt</H5>

<H5>r /:= s : FldComElt, FldComElt -&gt; FldComElt</H5>

<H5>r ^:= s : FldReElt, FldReElt -&gt; FldReElt</H5>

<H5>r ^:= s : FldComElt, FldComElt -&gt; FldComElt</H5>
<P>

<H4><A NAME = "2073">Conversions</A></H4>

<P>
<P>
Here we list various ways to convert between integers,
reals of fixed precision, complexes and their
various representations, other than by
the creation functions and <TT>!</TT>. See also the rounding functions
in a later section.


<H5><A NAME = "2074">MantissaExponent(r) : FldReElt -&gt; RngIntElt, RngIntElt</A></H5>
<BLOCKQUOTE>
Given a real number r, this function returns an integer m
(the mantissa of r) and an integer e (the exponent of r) 
such that r approx m x 2<sup>e</sup>, with the size of m being the
same as that of the internal representation of r.
</BLOCKQUOTE>
<H5><A NAME = "2075">ComplexToPolar(c) : FldComElt -&gt; FldReElt, FldReElt</A></H5>
<BLOCKQUOTE>
Given a complex number c, return the
modulus m&ge;0 and the
argument a (with -&pi;&le;a&le;&pi;)
of c as real numbers to the same precision
as c.
</BLOCKQUOTE>
<H5><A NAME = "2076">PolarToComplex(m, a) : FldReElt, FldReElt -&gt; FldComElt</A></H5>
<BLOCKQUOTE>
Given 
real numbers m and a, construct
the complex number me<sup>ia</sup>.
The
result will have the smaller of the precisions
of m and a; each of m and a is allowed to be an integer or rational
number; if both are integral or rational then the result will have
the default precision, otherwise the result will be of the same precision
as the real argument.
</BLOCKQUOTE>
<H5><A NAME = "2077">Argument(c) : FldComElt -&gt; FldReElt</A></H5>
<H5>Arg(c) : FldComElt -&gt; FldReElt</H5>
<BLOCKQUOTE>
Given a complex number c, return the real number (to the same precision)
that is the argument (in radians between -&pi; and &pi;) of c.
</BLOCKQUOTE>
<H5><A NAME = "2078">Modulus(c) : FldComElt -&gt; FldReElt</A></H5>
<BLOCKQUOTE>
Given a complex number c, return the real number (to the same precision
as c) that is the modulus of c.
</BLOCKQUOTE>
<H5><A NAME = "2079">Real(c) : FldComElt -&gt; FldReElt</A></H5>
<H5>Re(c) : FldComElt -&gt; FldReElt</H5>
<BLOCKQUOTE>
Given a complex number c=x + y i, return the real part x of c 
(as a real number to the same precision as c).
</BLOCKQUOTE>
<H5><A NAME = "2080">Imaginary(c) : FldComElt -&gt; FldReElt</A></H5>
<H5>Im(c) : FldComElt -&gt; FldReElt</H5>
<BLOCKQUOTE>
Given a complex number c=x + y i, return the imaginary part y of c 
(as a real number to the same precision as c).
</BLOCKQUOTE>
<H4><A NAME = "2081">Rounding</A></H4>



<H5><A NAME = "2082">Round(r) : FldReElt  -&gt; FldReElt</A></H5>
<H5>Round(r) : FldComElt  -&gt; RngQuadElt</H5>
<BLOCKQUOTE>
Given a real number r, return the integer i for which |r - i| is 
a minimum. i.e., the integer closest to r.
If there are two such integers, the one of larger magnitude is chosen
(rounding away from zero).
Given a (non-real) complex number r,
return the Gaussian integer i for which |r - i| is 
a minimum, i.e. the Gaussian integer closest to r.
</BLOCKQUOTE>
<H5><A NAME = "2083">Truncate(r) : FldReElt -&gt; RngIntElt</A></H5>
<BLOCKQUOTE>
Given a real number r, return &lfloor;r&rfloor; if r is positive, 
and return -&lfloor; - r&rfloor; + 1 if r is negative. Thus, the effect 
of this function is to round towards zero.
</BLOCKQUOTE>
<H5><A NAME = "2084">Ceiling(r) : Infty -&gt; Infty</A></H5>
<H5>Ceiling(r) : FldReElt  -&gt; RngIntElt</H5>
<BLOCKQUOTE>
The ceiling of the real number r, i.e. the smallest integer greater 
than or equal to r.
</BLOCKQUOTE>
<H5><A NAME = "2085">Floor(r) : Infty  -&gt; Infty</A></H5>
<H5>Floor(r) : FldReElt  -&gt; RngIntElt</H5>
<BLOCKQUOTE>
The floor of the real number r, i.e. the greatest integer less than 
or equal to r.
</BLOCKQUOTE>
<H4><A NAME = "2086">Precision</A></H4>



<H5><A NAME = "2087">Precision(r) : FldReElt  -&gt; RngIntElt</A></H5>
<H5>Precision(c) : FldComElt -&gt; RngIntElt</H5>
<BLOCKQUOTE>
Given a real or complex number c belonging to the
real or complex field C, return the decimal precision p to which 
calculations are performed in C.
</BLOCKQUOTE>
<H5><A NAME = "2088">BitPrecision(r) : FldReElt  -&gt; RngIntElt</A></H5>
<H5>BitPrecision(c) : FldComElt -&gt; RngIntElt</H5>
<BLOCKQUOTE>
Given a real or complex number c belonging to the real or complex field C,
return the (internally used) bit precision p to which calculations are
performed in C.
</BLOCKQUOTE>
<H5><A NAME = "2089">Precision(L) : [FldReElt] -&gt; RngIntElt</A></H5>
<H5>Precision(L) : [FldComElt] -&gt; RngIntElt</H5>
<BLOCKQUOTE>
Gives a sequence of real or complex numbers, return the precision p
of their parent field.
</BLOCKQUOTE>
<H5><A NAME = "2090">ChangePrecision(r, n) : FldReElt, RngIntElt -&gt; FldReElt</A></H5>
<H5>ChangePrecision(c, n) : FldComElt, RngIntElt -&gt; FldComElt</H5>
<BLOCKQUOTE>
Coerces the real (r) or complex (c) number into a field of
precision n.
</BLOCKQUOTE>
<H4><A NAME = "2091">Constants</A></H4>

<P>
<P>
Let R denote a real or complex field.
The functions described below
will return an approximation of certain constants
to the precision associated with
a given real or complex field R.
If R is real, a real number is returned; if R is complex,
a complex number with imaginary part zero is returned.


<H5><A NAME = "2092">Catalan(R) : FldRe -&gt; FldReElt</A></H5>
<H5>Catalan(R) : FldCom -&gt; FldComElt</H5>
<BLOCKQUOTE>
The value of Catalan's constant computed to the accuracy associated 
with the real or complex field R.
Catalan's constant is the sum from k equals 0 to infinity of ( - 1)<sup>k</sup> by (2k + 1)<sup> - 2</sup>. 
MPFR calculates this constant using formula (31) of Victor Adamchik's document
"33 representations for Catalan's constant"footnote{*}
<TT>{http://www-2.cs.cmu.edu/~{</TT>adamchik/articles/catalan/catalan.htm}},
for more information see <TT>mpfr.org</TT>.
</BLOCKQUOTE>
<H5><A NAME = "2093">EulerGamma(R) : FldRe -&gt; FldReElt</A></H5>
<H5>EulerGamma(R) : FldCom -&gt; FldComElt</H5>
<BLOCKQUOTE>
The value of Euler's constant 
computed to the precision of R.
</BLOCKQUOTE>
<H5><A NAME = "2094">Pi(R) : FldRe -&gt; FldReElt</A></H5>
<H5>Pi(R) : FldCom -&gt; FldComElt</H5>
<BLOCKQUOTE>
The value of &pi; computed
to the precision of R.
</BLOCKQUOTE>
<H4><A NAME = "2095">Simple Element Functions</A></H4>



<H5><A NAME = "2096">AbsoluteValue(r) : FldReElt-&gt; FldReElt</A></H5>
<H5>AbsoluteValue(r) : FldComElt-&gt; FldReElt</H5>
<H5>Abs(r) : FldReElt-&gt; FldReElt</H5>
<H5>Abs(r) : FldComElt-&gt; FldReElt</H5>
<BLOCKQUOTE>
The absolute value of the real or complex number r.
</BLOCKQUOTE>
<H5><A NAME = "2097">Sign(r) : FldReElt  -&gt; RngIntElt</A></H5>
<BLOCKQUOTE>
Return one of the integer values +1, 0, -1 depending upon whether 
the real number r is positive, zero or negative, respectively.
</BLOCKQUOTE>
<H5><A NAME = "2098">ComplexConjugate(r) : FldReElt -&gt; FldReElt</A></H5>
<H5>ComplexConjugate(c) : FldComElt -&gt; FldComElt</H5>
<H5>Conjugate(c) : FldComElt -&gt; FldComElt</H5>
<BLOCKQUOTE>
The complex conjugate x - y i of a complex number x + y i.
</BLOCKQUOTE>
<H5><A NAME = "2099">Norm(c) : FldComElt -&gt; FldReElt</A></H5>
<H5>Norm(r) : FldReElt -&gt; FldReElt</H5>
<BLOCKQUOTE>
The real norm of a real or complex number c; note that for complex
c=x + y i this returns x<sup>2</sup> + y<sup>2</sup>, while for elements of real domains
it just returns the absolute value. The result lies in the same field as the
argument.
</BLOCKQUOTE>
<H5><A NAME = "2100">Root(r, n) : FldReElt, RngIntElt -&gt; FldReElt</A></H5>
<H5>Root(r, n) : FldComElt, RngIntElt -&gt; FldComElt</H5>
<BLOCKQUOTE>
Given a real number R and a positive
integer n, calculate the n-th root of r 
(using Newton's method without divisions) with the same precision.
If n is even then r must be non-negative.
</BLOCKQUOTE>
<H5><A NAME = "2101">SquareRoot(c) : FldComElt -&gt; FldComElt</A></H5>
<H5>Sqrt(c) : FldComElt -&gt; FldComElt</H5>
<H5>SquareRoot(r) : FldReElt -&gt; FldReElt</H5>
<H5>Sqrt(r) : FldReElt -&gt; FldReElt</H5>
<BLOCKQUOTE>
Given a real or complex number c,
return the square root of r as an element of the same field
to which r belongs.
</BLOCKQUOTE>
<H5><A NAME = "2102">Distance(x, L) : FldReElt, [FldReElt] -&gt; FldReElt, RngIntElt</A></H5>
<H5>Distance(x, L) : FldReElt, [FldComElt] -&gt; FldReElt, RngIntElt</H5>
<H5>Distance(x, L) : FldComElt, [FldReElt] -&gt; FldReElt, RngIntElt</H5>
<H5>Distance(x, L) : FldComElt, [FldComElt] -&gt; FldReElt, RngIntElt</H5>

<PRE>    Max: ExtReElt                       Default: &infin;</PRE>
<BLOCKQUOTE>
Given a sequence L of real or complex numbers and an additional
number x compute the distance between x and L, ie.  
min<sub>y&isin;L</sub> |x - y|, that is the shortest distance between
x and any element of L. Furthermore, the index in L of an
element realising the distance is returned as a second argument.
<P>
Note: prior to V2.21, the <TT>Distance</TT> was only to be used for <I>short</I>
distances, and thus a maximum of 1 was returned. Through the use of a new
<TT>Max</TT> vararg (setting this equal to 1), this old behaviour can be obtained.
</BLOCKQUOTE>
<H5><A NAME = "2103">Diameter(L) : [FldReElt] -&gt; FldReElt</A></H5>
<H5>Diameter(L) : [FldComElt] -&gt; FldReElt</H5>

<PRE>    Max: ExtReElt                       Default: &infin;</PRE>
<BLOCKQUOTE>
Given a sequence L of real of complex numbers, compute the diameter
of the set defined by L, ie. the smallest distance between distinct
elements of L.
<P>
Note: prior to V2.21, the <TT>Diameter</TT> was only to be used for <I>short</I>
distances, and thus a maximum of 1 was returned. Through the use of a new
<TT>Max</TT> vararg (setting this equal to 1), this old behaviour can be obtained.
</BLOCKQUOTE>
<H4><A NAME = "2104">Roots</A></H4>

<P>
<P>
Magma contains a very powerful algorithm for finding highly
accurate approximations
to the complex roots of a polynomial; it is based on Xavier Gourdon's
implementation of Sch&ouml;nhage's algorithm, which we will summarize below.
<P>
Given a polynomial p = a<sub>0</sub> + a<sub>1</sub> z + ... + a<sub>n</sub> z<sup>n</sup> &isin;C[z], define the norm of p, |p|, by
<P>
|p| = |a<sub>0</sub>| + |a<sub>1</sub>| + ... + |a<sub>n</sub>|.
<P>
Sch&ouml;nhage's algorithm (given in his technical report of 1982
<A  HREF = "text232.htm#bib_schoenhage82">[Sch82]</A>)
takes as input a univariate polynomial p in C[z] and a positive real number &epsilon;, and finds linear factors L<sub>j</sub> = u<sub>j</sub> z - v<sub>j</sub> (j = 1, ..., n = deg(p)) such that 
<P>
|p - L<sub>1</sub> ... L<sub>n</sub>| &lt; &epsilon; |p|.
<P>
The parameter &epsilon; may be chosen so as to find the roots of p to within a certain &epsilon;', and this is how the function <TT>Roots</TT> described
below works (when run with Sch&ouml;nhage's algorithm).
<P>
The algorithm uses the concept of a `splitting circle' to find polynomials F and G such that |p - FG| &lt; &epsilon;<sub>1</sub> |p| for some &epsilon;<sub>1</sub> depending on &epsilon;.
<P>
This splitting circle method can then be applied recursively to F and G until we have only linear factors, as required.
<P>
The splitting circle method works as follows.
For the purposes of this discussion assume that p is monic.
Suppose we know a circle &Gamma; such that, for some integer k with 0 &lt; k &lt; n, there are k roots of p (say u<sub>1</sub>, ..., u<sub>k</sub>) which lie inside &Gamma;, and the other n - k roots (u<sub>k + 1</sub>, ..., u<sub>n</sub>) lie outside &Gamma;. Note that the circle &Gamma; is chosen so that the roots of p are not too close to it. Then we can write p = FG, where F = (z - u<sub>1</sub>) ... (z - u<sub>k</sub>) and G = (z - u<sub>k + 1</sub>) ... (z - u<sub>n</sub>).
Through shifts and scalings, we may assume that &Gamma; = {c&isin;C: | z|  = 1}.
<P>
For m in {1, ..., k}, let s<sub>m</sub> denote the m-th power sum of the roots of p which lie inside the splitting circle. That is,
s<sub>m</sub> = u<sub>1</sub><sup>m</sup> + ... + u<sub>k</sub><sup>m</sup>.
The residue theorem can then be used to calculate s<sub>m</sub> (1 &le;m &le;k):
s<sub>m</sub> = (1 /2&pi; i) int<sub>&Gamma;</sub> z<sup>m</sup> (p'(z) /p(z)) dz.
where the integration can be computed to the required precision by the discrete sum
s<sub>m</sub> approx (1 /N) &sum;<sub>j=0</sub><sup>N - 1</sup> (p'(&omega;<sup>j</sup>) /p(&omega;<sup>j</sup>)) &omega;<sup>(m + 1)j</sup>.
for a large enough integer N, where &omega; = exp(2&pi; i/N).
<P>
The coefficients of the polynomial F can then be computed from the Newton sums s<sub>m</sub> (1 &le;m &le;k) using the classical Newton formulae.
Then set G = p/F.
<P>
The integer N above needed to get F and G to the required precision can be quite large. It is more efficient to use a smaller value of N to give an approximation F<sub>0</sub> of F, and then use the following refining technique.
<P>
Define G<sub>0</sub> (an approximation of G) by 
p = F<sub>0</sub> G<sub>0</sub> + r, where deg(r) &lt; deg(F<sub>0</sub>). We want polynomials f and g such that F<sub>1</sub> = F<sub>0</sub> + f and G<sub>1</sub> = G<sub>0</sub> + g are better approximations of F and G.
Now
p - F<sub>1</sub> G<sub>1</sub> = p - F<sub>0</sub> G<sub>0</sub> - f G<sub>0</sub> - g F<sub>0</sub> - fg.
Hence choosing f and g such that
p - F<sub>0</sub> G<sub>0</sub> = f G<sub>0</sub> + g F<sub>0</sub>
will lead to a second order error.
<P>
The Euclidean algorithm could be used to find f and g, but this is numerically unstable. It suffices to find polynomials H (called the
auxiliary polynomial) and L such that
1 = H G<sub>0</sub> + L F<sub>0</sub>,  where deg(H)&lt;deg(F<sub>0</sub>) and deg(L)&lt;deg(G<sub>0</sub>).
<P>
The polynomial H can be calculated using the formula
H(z) = (1/2&pi; i) int<sub>&Gamma;</sub> (1 /(F<sub>0</sub> G<sub>0</sub>)(t)) (F<sub>0</sub>(z) - F<sub>0</sub>(t)/z - t) dt.
Again, rather than computing the integral to the required precision directly, we find only an approximation H<sub>0</sub> and then refine it using Newton iteration:
H<sub>m + 1</sub> &equiv; H<sub>m</sub> (2 - H<sub>m</sub> G<sub>0</sub>) mod (F<sub>0</sub>).
Assuming that |H - H<sub>0</sub>| is small, the sequence (H<sub>m</sub>) converges quadratically to H.
<P>
Once H is known to a large enough precision, f can be computed by
f &equiv; H (p - F<sub>0</sub> G<sub>0</sub>) mod (F<sub>0</sub>).
<P>
This gives us the new approximation F<sub>1</sub> of F, and G<sub>1</sub> is computed by division of p by F<sub>1</sub>.
We repeat this process until
|p - FG| &lt; &epsilon;<sub>1</sub> |p|
and we are done.
<P>
<P>
The problem remains to find the splitting circle.
<P>
This relies mainly on the computation of the moduli of the roots of p.
Let r<sub>1</sub>(p) &le;r<sub>2</sub>(p) &le; ... &le;r<sub>n</sub>(p)
denote the moduli of the roots of p in ascending order. For each k, the computation of r<sub>k</sub>(p) with a small number of digits can be achieved in a reliable way using the Graeffe process. The Graeffe process is a root squaring step transforming any given polynomial p into a polynomial q of the same degree whose roots are the square of the roots of p.
<P>
By the use of a suitable shift, we may assume that the sum of the roots of p is zero.
If p(0)=0, then we have found a factorization p approx FG with F=z and G=p/z. If not, then the computation of the maximum root modulus r<sub>n</sub>(p) allows us to scale p so that its maximum root modulus is now close to 1.
For j = 0, 1, 2, 3, set
q<sub>j</sub>(z)=p(z + 2 i<sup>j</sup>).
Then amongst these four polynomials there exists q such that 
(r<sub>n</sub>(q) /r<sub>1</sub>(q)) = exp(&Delta;),
with &Delta; &gt; 0.3.
A dichotomic process from the computation of
some r<sub>j</sub>(q) can then be applied to find k (1 &le;k &le;n - 1) such that
<P>
(r<sub>k + 1</sub>(q) /r<sub>k</sub>(q)) &gt; exp((&Delta; /n - 1)).
<P>
Then the circle {c: |c|=Sqrt(r<sub>k</sub>(q) r<sub>k + 1)(q)</sub>} is a suitable splitting circle, with the roots not too close to it.


<P>
<P>
The function <TT>RootsNonExact</TT> (below) is more suitable for non-exact polynomials.
<H5><A NAME = "2105"></A><A NAME = "FldRe:Roots">Roots</A>(p) : RngUPolElt -&gt; [ &lt;FldComElt, RngIntElt&gt; ]</H5>

<PRE>    Al: MonStgElt                       Default: "Schonhage"</PRE>

<PRE>    Digits: RngIntElt                   Default: </PRE>
<BLOCKQUOTE>
Given a univariate polynomial p over a real or complex field, this
returns a sequence of complex approximations 
to the roots of p. The elements of this sequence are of the form
&lt;r, m&gt;, where r is a root and m its multiplicity.
<P>
The algorithm used
to find the roots of p may be specified by using the optional argument
<TT>Al</TT>. This must be one of <TT>"Schonhage"</TT> (which is the default),
<TT>"Laguerre"</TT>, <TT>"NewtonRaphson"</TT> or <TT>"Combination"</TT>
(a combination of Laguerre and Newton-Raphson).
When using the (default) Sch&ouml;nhage algorithm, the roots given are
correct to within an absolute error of 10<sup> - d</sup>, where
d is the value of <TT>Digits</TT>.
This algorithm gives correct results in all cases. When using the
other algorithms (for which correct answers are not guaranteed in all
cases), the results are found with <TT>Digits</TT> significant figures.
The default value for <TT>Digits</TT> is the current precision of
the free real field.
<P>
Pari is used here for complex polynomials.
</BLOCKQUOTE>
<P>
<P>
<P>
<P>
<I>Warning</I>: Beware of the problems of floating point numbers.
Because real numbers are stored in the computer with finite precision, you may not be finding the roots of the polynomial you want.
If you know the polynomial exactly, you should enter it with exact (that is, integer or rational) coefficients.
This is illustrated in the following example.
<HR>
<H3><A NAME = "2106">Example <TT>FldRe_Roots (H25E5)</TT></A></H3>
<P>
<P>
<PRE>
&gt; P&lt;z&gt; := PolynomialRing(ComplexField());
&gt; p := (z-1.1)^6;
&gt; p;
z^6 - 6.60000000000000000000000000001*z^5 +
    18.1500000000000000000000000000*z^4 -
    26.6200000000000000000000000000*z^3 +
    21.9615000000000000000000000000*z^2 -
    9.66306000000000000000000000003*z +
    1.77156100000000000000000000001
&gt; R := Roots(p);
&gt; R;
[ &lt;1.10001330596590605421651999857, 1&gt;,
&lt;1.10000665289430860969298668917 +
1.15233044958179825651486651257E-5*i, 1&gt;,
&lt;1.10000665289430860969298668917 -
1.15233044958179825651486651257E-5*i, 1&gt;,
&lt;1.09998669421138030521834731234, 1&gt;,
&lt;1.09999334701704821058957965537 +
1.15231509613269858004669167711E-5*i, 1&gt;,
&lt;1.09999334701704821058957965537 -
1.15231509613269858004669167711E-5*i, 1&gt; ]
&gt; P&lt;x&gt; := PolynomialRing(Rationals());
&gt; q := (x-11/10)^6;
&gt; Roots(q);
[ &lt;11/10, 6&gt; ]
</PRE>
<HR>
<H5><A NAME = "2107">RootsNonExact(p) : RngUPolElt[FldRe] -&gt; [ FldComElt ], [ FldComElt ]</A></H5>
<H5>RootsNonExact(p) : RngUPolElt[FldCom] -&gt; [ FldComElt ], [ FldComElt ]</H5>
<BLOCKQUOTE>
Given a polynomial p of degree n defined over a real or complex field,
returns a sequence [v<sub>1</sub>, ..., v<sub>n</sub>] of complex numbers such that
|p - a(z - v<sub>1</sub>) ... (z - v<sub>n</sub>)| &lt; 10<sup> - d</sup> |p|,
where a is the leading coefficient of p, and d is the precision of the
field.
<P>
A second sequence [e<sub>1</sub>, ..., e<sub>n</sub>] of (free) real numbers may also be returned. Given any polynomial hat p such that |p - hat p| &lt; 10<sup> - d</sup> |p|, we can write hat p = a(z - u<sub>1</sub>) ... (z - u<sub>n</sub>) with |v<sub>i</sub> - u<sub>i</sub>| &lt; e<sub>i</sub>.
In some cases, such error bounds cannot be derived, because the value
d of <TT>Digits</TT> is too small for the given polynomial. In these cases, this second sequence is not returned.
<P>
This function acknowledges the fact that the polynomial p may not be the exact polynomial wanted, but only an approximation (to a certain number of decimal places), and so the roots of the true polynomial can only be found to a limited number of decimal places. 
Increasing the precision will decrease the errors on the `roots'.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "2108">Example <TT>FldRe_RootsNonExact (H25E6)</TT></A></H3>
<P>
<P>
<PRE>
&gt; P&lt;z&gt; := PolynomialRing(ComplexField());
&gt; p := (z-1.1)^6;
&gt; R, E := RootsNonExact(p);
&gt; R;   
[ 1.10001483296913451410370191006 -
8.56404454142796527111307103383E-6*i,
1.10001483296913451410370191006 +
8.56404454142796527111304767692E-6*i,
1.09998516742199321904393975959 +
8.56336708832137724325720239457E-6*i,
1.09999999960887226685235833026 +
1.71274116266516824685125851069E-5*i,
1.09998516742199321904393771623 -
8.56336708832137723945115457519E-6*i,
1.09999999960887226685236037365 -
1.71274116266516824723187272572E-5*i ]
&gt; E;
[ 0.00482314415421569719910621643066,
0.00482314415421569719910621643066,
0.00482301408919738605618476867676,
0.00482307911261159460991621017456,
0.00482301408919738605618476867676,
0.00482307911261159460991621017456 ]
</PRE>
<HR>
<H5><A NAME = "2109">HenselLift(f, R, k) : RngUPolElt, FldReElt, RngIntElt -&gt; FldReElt</A></H5>
<H5>HenselLift(f, R, k) : RngUPolElt, FldComElt, RngIntElt -&gt; FldComElt</H5>
<BLOCKQUOTE>
Let f be a real or complex polynomial and x an approximation to
a single zero of f. This function will apply the Newton-iteration to 
improve the accuracy of the root to the precision indicated by k.
</BLOCKQUOTE>
<H4><A NAME = "2110">Continued Fractions</A></H4>

<P>
<P>
The following functions use the continued fraction expansion of
real numbers to get Diophantine approximations. They were obtained
from corresponding Pari implementations.


<H5><A NAME = "2111">ContinuedFraction(r) : FldRatElt -&gt; [ RngIntElt ]</A></H5>
<H5>ContinuedFraction(r) : FldReElt -&gt; [ RngIntElt ]</H5>

<PRE>    Bound: RngIntElt                    Default: -1</PRE>
<BLOCKQUOTE>
Given an element r from a real field, return a sequence of integers
s that form the partial quotient for the (regular) continued fraction
expansion for r, so r is approximately equal to
<PRE>
s_1 + 1/( s_2 + 1/( s_3 + ... + 1/(s_n))) 
</PRE>
The length n of the sequence is determined in such a way that the last
significant partial quotient is obtained (determined by the precision
with which r is known), unless the optional integer
argument <TT>Bound</TT> is used to limit the length.
</BLOCKQUOTE>
<H5><A NAME = "2112">BestApproximation(r, n) : FldReElt, RngIntElt -&gt; FldReElt</A></H5>
<BLOCKQUOTE>
Given an element r from a real field and a positive integer
n, this function determines a rational approximation to r with
denominator not exceeding n. The approximation is at least as close
as the best continued fraction convergent with denominator not exceeding n.
Pari is used here.
</BLOCKQUOTE>
<H5><A NAME = "2113">Convergents(s) : [ RngIntElt ] -&gt; ModMatRngElt</A></H5>
<BLOCKQUOTE>
Given a sequence s of n non-negative integers (forming the partial
fractions of a real number r, say), this function returns a 2 x 2
matrix with integer coefficients 
pmatrix(p<sub>n</sub>&amp;p<sub>n - 1</sub>cr q<sub>n</sub>&amp;q<sub>n - 1</sub>cr);
the quotients p<sub>n - 1</sub>/q<sub>n - 1</sub> and p<sub>n</sub>/q<sub>n</sub> form the last two
convergents for r as provided by s.
</BLOCKQUOTE>
<H4><A NAME = "2114">Linear and Algebraic Dependencies</A></H4>



<H5><A NAME = "2115"></A><A NAME = "LinearRelationlabel">LinearRelation</A>(q: parameters) : [ FldComElt ] -&gt; [ RngIntElt ]</H5>
<H5>LinearRelation(v: parameters) : ModTupRngElt -&gt; ModTupRngElt</H5>

<PRE>    Al: MonStgElt                       Default: "LLL"</PRE>
<BLOCKQUOTE>
(Deprecated). Given a sequence q or a vector v with entries from a 
complex field, return an integer sequence or vector forming the
coefficients for a (small) linear dependency among the entries.
The algorithm now only uses <TT>"LLL"</TT> (not "Hastad"), and this
function is deprecated in any case.
The new version of this function is <TT>IntegerRelation</TT>.
</BLOCKQUOTE>
<H5><A NAME = "2116">AllLinearRelations(q,p): SeqEnum, RngIntElt -&gt; Lat</A></H5>
<BLOCKQUOTE>
Given a sequence q with entries from a real or complex field, return
the lattice of all (small) integer linear dependencies among the entries.
The precision p is used both in the relation-detection, and to define
"small" dependencies.
</BLOCKQUOTE>
<H5><A NAME = "2117">IntegerRelation(q): SeqEnum -&gt; SeqEnum, FldReElt</A></H5>
<H5>IntegerRelation(q,N): SeqEnum, RngIntElt -&gt; SeqEnum,FldReElt</H5>

<PRE>    Delta: FldReElt                     Default: 0.75</PRE>
<BLOCKQUOTE>
Given a sequence q=(q<sub>1</sub>, ..., q<sub>d</sub>) with entries from a real or complex 
field, along possibly with an integer N&gt;0, return a sequence
(n<sub>1</sub>, ..., n<sub>d</sub>) of integers such that: any n<sub>i</sub> has magnitude less
or equal to N and the quantity |&sum;n<sub>i</sub> q<sub>i</sub>| is small.
The routine is based on the LLL lattice reduction algorithm <A  HREF = "text232.htm#bib_LLL">[LLL82]</A>
(see Chapter <A  HREF = "text312.htm#2946">Reduction of Matrices and Lattices</A>). 
The second return value is a measure of goodness-of-fit, and the second input
value will be determined from the input precision of real/complex numbers
if it is omitted.
</BLOCKQUOTE>
<H5><A NAME = "2118">PowerRelation(r, k: parameters) : FldReElt, RngIntElt -&gt; RngUPolElt</A></H5>
<H5>PowerRelation(r, k: parameters) : FldComElt, RngIntElt -&gt; RngUPolElt</H5>

<PRE>    Al: MonStgElt                       Default: "LLL"</PRE>

<PRE>    Precision: RngIntElt                Default: </PRE>
<BLOCKQUOTE>
(Deprecated). Given an element r from a real or complex field, and
an integer k&gt;0, return a univariate integer polynomial of degree
at most k having r as an approximate root.
The parameters here have the same usage and meaning
as for <TT>LinearRelation</TT>. Pari is used here.
The new version of this function is <TT>MinimalPolynomial</TT>.
</BLOCKQUOTE>
<H5><A NAME = "2119">MinimalPolynomial(r,d,N) : FldReElt, RngIntElt, RngIntElt -&gt; RngUPolElt, FldReElt</A></H5>
<H5>MinimalPolynomial(r,d,N) : FldComElt, RngIntElt, RngIntElt -&gt; RngUPolElt, FldReElt</H5>
<H5>MinimalPolynomial(r,d) : FldReElt, RngIntElt -&gt; RngUPolElt -&gt; FldReElt</H5>
<H5>MinimalPolynomial(r,d) : FldComElt, RngIntElt -&gt; RngUPolElt -&gt; FldReElt</H5>

<PRE>    Delta: FldReElt                     Default: 0.75</PRE>

<PRE>    ExactDegree: BoolElt                Default: <TT>false</TT></PRE>

<PRE>    Squarefree: BoolElt                 Default: <TT>true</TT></PRE>
<BLOCKQUOTE>
Given an element r from a real or complex field and two integers d&ge;1
and N&ge;1, tries to compute a univariate integer polynomial of degree at 
most d and coefficients of absolute values no greater than N which 
is the minimal polynomial of a number close to r.
The routine relies on the LLL lattice reduction algorithm <A  HREF = "text232.htm#bib_LLL">[LLL82]</A>
(see Chapter <A  HREF = "text312.htm#2946">Reduction of Matrices and Lattices</A>). 
When N is not given, it is determined from the precision of r.
The <TT>ExactDegree</TT> vararg requires that the output degree be exactly
as stated, and <TT>Squarefree</TT> removes any repeated factors. The second
return value is a measure of goodness-of-fit.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "2120">Example <TT>FldRe_LLLPolFact (H25E7)</TT></A></H3>
This example illustrates the <TT>MinimalPolynomial</TT> routine. It describes
informally the Kannan-Lenstra-Lov&aacute;sz algorithm to factor univariate integer 
polynomials <A  HREF = "text232.htm#bib_KaLeLo84">[KLL84]</A>. The idea is to compute a complex root of the 
polynomial P to be factored, and then compute the minimal polynomial Q 
of this root. This polynomial is irreducible and divides P. We then continue
recursively with P/Q. 
<P>
Notice that the polynomial factorisation routine <TT>Factorization</TT> 
(see Section <A  HREF = "text217.htm#1856">Factorization</A>) relies upon Van Hoeij's 
algorithm <A  HREF = "text232.htm#bib_vHoeij1">[vH02]</A>, <A  HREF = "text232.htm#bib_vHoeij2">[vH01]</A>. Though both approaches have polynomial 
time complexities, Van Hoeij's algorithm is significantly faster.
<P>
<P>
<PRE>
&gt; C&lt;i&gt; := ComplexField(1000);
&gt; P&lt;X&gt; := PolynomialRing(Integers());
&gt; P_C&lt;Z&gt; := PolynomialRing(C);
&gt; p0 := 5*X^12 + 64*X^11 + 51*X^10 + 38*X^9 - 60*X^8 - 56*X^7 
&gt;     - 51*X^6 - 14*X^5 - X^4 + 12*X^3 + 8*X^2 + 4*X;
&gt; R := Roots (P_C!p0);
&gt; root := R[1][1];
&gt; res0 := MinimalPolynomial (root, 12, 100);
&gt; p1 := P!(p0/res0);
&gt; //
&gt; R := Roots (P_C!p1);
&gt; root := R[1][1];
&gt; res1 := MinimalPolynomial (root, 11, 100);
&gt; p2 := P!(p1/res1);
&gt; //
&gt; R := Roots (P_C!p2);
&gt; root := R[1][1];
&gt; res2 := MinimalPolynomial (root, 5, 100);
&gt; p3 := P!(p2/res2);
&gt; //
&gt; R := Roots (P_C!p3);
&gt; root := R[1][1];
&gt; res3 := MinimalPolynomial (root, 4, 100);
&gt; //
&gt; assert p0 eq res0*res1*res2*res3;
&gt; res0, res1, res2, res3;
X
X^6 + 13*X^5 + 13*X^4 + 13*X^3 - 4*X^2 - 4*X - 4
X - 1
5*X^4 + 4*X^3 + 3*X^2 + 2*X + 1
</PRE>
<HR>
<PRE></PRE> <A  HREF = "text238.htm">[Next]</A><A  HREF = "text236.htm">[Prev]</A> <A  HREF = "text238.htm">[Right]</A> <A  HREF = "text236.htm">[Left]</A> <A  HREF = "text233.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<br><small>Version: V2.22 of <I>
Thu Jun  9 16:37:49 EST 2016
</I></small>
</body></html>