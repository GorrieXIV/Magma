<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <link rel='stylesheet' href='help.css' type='text/css'>
  <TITLE>Homomorphisms </TITLE>
</head>
<body BGCOLOR="#FFFFFF">

 <A  HREF = "text1640.htm">[Next]</A><A  HREF = "text1638.htm">[Prev]</A> <A  HREF = "text1640.htm">[Right]</A> <A  HREF = "text1638.htm">[Left]</A> <A  HREF = "text1635.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<PRE></PRE><H3><A NAME = "18163">Homomorphisms </A></H3>

<P>
<P>
<P>
<P>



<H5>Subsections</H5>
<UL>
<LI> <A  HREF = "text1639.htm#18164">Creation</A>
<LI> <A  HREF = "text1639.htm#18169">Restriction, Evaluation, and Other Manipulations</A>
<LI> <A  HREF = "text1639.htm#18182">Kernels</A>
<LI> <A  HREF = "text1639.htm#18187">Images</A>
<LI> <A  HREF = "text1639.htm#18193">Cokernels</A>
<LI> <A  HREF = "text1639.htm#18196">Matrix Structure</A>
<LI> <A  HREF = "text1639.htm#18206">Arithmetic</A>
<LI> <A  HREF = "text1639.htm#18224">Polynomials</A>
<LI> <A  HREF = "text1639.htm#18229">Invariants</A>
<LI> <A  HREF = "text1639.htm#18240">Predicates</A>
</UL>
<H4><A NAME = "18164">Creation</A></H4>

<P>
<P>
<P>
  The commands below create the multiplication by n map on an abelian
  variety, for any n.  Other ways to create homomorphisms are 
  described in other sections of this chapter.  These include computing
  Hecke operators, Atkin-Lehner operators, and computing the full 
  endomorphism and homomorphism rings, and choosing elements in them.


<H5><A NAME = "18165">IdentityMap(A) : ModAbVar -&gt;  MapModAbVar</A></H5>
<BLOCKQUOTE>
The identity homomorphism from the modular abelian variety A to A.  
</BLOCKQUOTE>
<H5><A NAME = "18166">ZeroMap(A) : ModAbVar -&gt;  MapModAbVar</A></H5>
<BLOCKQUOTE>
The zero homomorphism from the modular abelian variety A to A.  
</BLOCKQUOTE>
<H5><A NAME = "18167">nIsogeny(A, n) : ModAbVar, FldRatElt -&gt;  MapModAbVar</A></H5>
<H5>nIsogeny(A, n) : ModAbVar, RngIntElt -&gt;  MapModAbVar</H5>
<BLOCKQUOTE>
The multiplication by n isogeny on the modular abelian variety A,
where n is a rational number or an integer.  
</BLOCKQUOTE>
<HR>
<H3><A NAME = "18168">Example <TT>ModAbVar_Morphisms-Creation (H142E52)</TT></A></H3>
<P>
<P>
<P>
<PRE>
&gt; A := JZero(23);
&gt; IdentityMap(A);
Homomorphism from JZero(23) to JZero(23) given on integral homology by:
[1 0 0 0]
[0 1 0 0]
[0 0 1 0]
[0 0 0 1]
&gt; ZeroMap(A);
Homomorphism from JZero(23) to JZero(23) given on integral homology by:
[0 0 0 0]
[0 0 0 0]
[0 0 0 0]
[0 0 0 0]
&gt; nIsogeny(A,3);
Homomorphism from JZero(23) to JZero(23) given on integral homology by:
[3 0 0 0]
[0 3 0 0]
[0 0 3 0]
[0 0 0 3]
&gt; nIsogeny(A,1/3);
Homomorphism from JZero(23) to JZero(23) (up to isogeny) on integral 
homology by:
[1/3   0   0   0]
[  0 1/3   0   0]
[  0   0 1/3   0]
[  0   0   0 1/3]
</PRE>
<HR>
<H4><A NAME = "18169">Restriction, Evaluation, and Other Manipulations</A></H4>

<P>
<P>
<P>
  Suppose A is an abelian variety, B is an abelian subvariety of A, 
  and &phi; is a homomorphism from A.  Then the <TT>Restriction</TT>
  command computes the restriction of &phi; to B.  If, moreover,
  &phi; is an endomorphism of A (i.e., also has codomain A) and
  &phi;(B) is contained in B, then <TT>RestrictEndomorphism</TT>
  computes the endomorphism of B induced by &phi;.
<P>
  If f is a polynomial over the integers or rational numbers and
  &phi; is an endomorphism of an abelian variety, then the 
  <TT>Evaluate</TT> command computes the endomorphism f(&phi;) (if 
  f has denominators, then f(&phi;) might only be a morphism
  on abelian varieties up to isogeny).   Together with the <TT>Kernel</TT>
  command, <TT>Evaluate</TT> is useful for cutting out subvarieties of 
  an abelian variety.  
<P>
  The <TT>SurjectivePart</TT>, <TT>DivideOutIntegers</TT>, and 
  <TT>UniversalPropertyOfCokernel</TT> commands can also all be
  useful in various contexts for constructing homomorphisms.


<H5><A NAME = "18170">Restriction(phi, B) : MapModAbVar, ModAbVar -&gt;  MapModAbVar</A></H5>
<BLOCKQUOTE>
The restriction of the map of abelian varieties &phi;  to a morphism from 
the abelian variety B to the codomain of 
&phi; , if this obviously makes sense.  
</BLOCKQUOTE>
<H5><A NAME = "18171">RestrictEndomorphism(phi, B) : MapModAbVar, ModAbVar -&gt;  MapModAbVar</A></H5>
<BLOCKQUOTE>
The restriction of the map of abelian varieties &phi;  to an endomorphism of 
the abelian variety B, if this 
obviously makes sense. If B is not left invariant by &phi; , an error 
may occur.  
</BLOCKQUOTE>
<H5><A NAME = "18172">RestrictEndomorphism(phi, i) : MapModAbVar, MapModAbVar -&gt;  MapModAbVar</A></H5>
<BLOCKQUOTE>
Suppose &phi;  is an endomorphism of an abelian variety A and 
i:B to A is an injective morphism of abelian varieties such that 
i(B) is invariant under &phi;. This intrinsic computes the endomorphism 
&psi;  of B induced by &phi;. If i(B) is not left invariant by 
&phi; , an error may occur.  
</BLOCKQUOTE>
<H5><A NAME = "18173">RestrictionToImage(phi, i) : MapModAbVar, MapModAbVar -&gt;  MapModAbVar</A></H5>
<BLOCKQUOTE>
Suppose i:A to D and &phi; :D to B are morphisms of abelian 
varieties. This intrinsic computes the restriction of &phi;  to the image of 
i. The resulting map is an endomorphism of the image of i.  
</BLOCKQUOTE>
<H5><A NAME = "18174">Evaluate(f, phi) : RngUPolElt, MapModAbVar -&gt;  MapModAbVar</A></H5>
<BLOCKQUOTE>
The endomorphism f(&phi; ) of A, where f is a univariate 
polynomial and &phi;  is an endomorphism of a modular abelian variety A.  
</BLOCKQUOTE>
<H5><A NAME = "18175">DivideOutIntegers(phi) : MapModAbVar -&gt;  MapModAbVar, RngIntElt</A></H5>
<BLOCKQUOTE>
If &phi; :A to B is a homomorphism of abelian varieties, find 
the largest integer n such that &psi; =(1/n) * &phi;  is also a 
homomorphism from A to B and return &psi;  and n.  
</BLOCKQUOTE>
<H5><A NAME = "18176">SurjectivePart(phi) : MapModAbVar -&gt;  MapModAbVar</A></H5>
<BLOCKQUOTE>
Let &phi; :A to B be a homomorphism. This intrinsic returns the 
<I>surjective</I> homomorphism &pi; :A to &phi; (A) induced by &phi; .  
</BLOCKQUOTE>
<H5><A NAME = "18177">UniversalPropertyOfCokernel(pi, f) : MapModAbVar, MapModAbVar -&gt;  MapModAbVar</A></H5>
<BLOCKQUOTE>
Uses the universal property of the cokernel to find the unique 
morphism with a certain property. More precisely, suppose &pi; :B to C is 
the cokernel of a morphism, so &pi;  is surjective with kernel K. 
Suppose f:B to D is a morphism whose kernel contains K. By 
definition of cokernel, there exists a unique morphism &psi; :C to D such 
that &pi; * &psi;  = f. This intrinsic returns &psi; . If we only have 
that the identity component of ker (&pi; ) is contained in <TT>ker(f)</TT>, 
then &psi;  will only be a homomorphism in the category of abelian 
varieties up to isogeny, i.e., it will have a nontrivial denominator.  
</BLOCKQUOTE>
<HR>
<H3><A NAME = "18178">Example <TT>ModAbVar_Morphisms-Restriction,_Evaluation,_and_Other_Manipulations (H142E53)</TT></A></H3>
We use the <TT>Evaluate</TT> and <TT>Kernel</TT>
commands to cut out a 2-dimensional abelian subvariety of 
J<sub>0</sub>(65).
<P>
<P>
<PRE>
&gt; J := JZero(65);
&gt; R&lt;x&gt; := PolynomialRing(RationalField());
&gt; T2 := HeckeOperator(J,2);
&gt; Factorization(CharacteristicPolynomial(T2));
[
    &lt;x + 1, 2&gt;,
    &lt;x^2 - 3, 2&gt;,
    &lt;x^2 + 2*x - 1, 2&gt;
]
&gt; phi := Evaluate(x^2-3,T2);
&gt; _,A := Kernel(phi);
&gt; A;
Modular abelian variety of dimension 2 and level 5*13 over Q
</PRE>
<HR>
<H3><A NAME = "18179">Example <TT>ModAbVar_Morphisms-Restriction,_Evaluation,_and_Other_Manipulations2 (H142E54)</TT></A></H3>
This example illustrates the universal property of the cokernel.
We decompose J=J<sub>0</sub>(65) as a product of simples A, B, and C,
of dimensions 1, 2, and 2, respectively.   Then we let &pi; be
a homomorphism from J onto B + C, and f a homomorphism
from J onto B.  The universal property supplies a morphism
&psi; from B + C to B such that &pi; * &psi; = f (i.e., 
f(x) = &psi;(&pi;(x)) for all x). 
<P>
<P>
<PRE>
&gt; J := JZero(65);
&gt; A,B,C := Explode(Decomposition(J));
&gt; pi := NaturalMap(J,B+C);
&gt; IsSurjective(pi);
true
&gt; f := NaturalMap(J,B);
&gt; psi := UniversalPropertyOfCokernel(pi,f); psi;
Homomorphism from modular abelian variety of dimension 4 to 65B 
(up to isogeny) on integral homology by:
 (not printing 8x4 matrix)
&gt; Matrix(psi);
[ 1/2    0    0 -1/2]
[ 1/2    0 -1/2  1/2]
[   0 -1/2  1/2    0]
[   0    0 -1/2    1]
[ 1/2 -1/2 -1/2  1/2]
[ 1/2    0 -1/2  1/2]
[   0  1/2    0    0]
[   0    0  1/2    0]
&gt; pi*psi eq f;    // apply pi then psi is the same as applying f.
true
&gt; Denominator(psi);   
2
</PRE>
Since &psi; has a denominator of 2, it is only
a morphism in the category of abelian varieties up to isogeny.  
This is because only the
connected component of the kernel of &pi; is contained in the
kernel of f.
<P>
<P>
<PRE>
&gt; G := Kernel(pi); G;
Finitely generated subgroup of abelian variety with invariants
[ 2, 2, 2, 2, 2, 2 ]
&gt; H, K := Kernel(f);
&gt; H;
{ 0 }: finitely generated subgroup of abelian variety with 
invariants []
&gt; G subset K;
false
</PRE>
<HR>
<H3><A NAME = "18180">Example <TT>ModAbVar_Morphisms-Restriction,_Evaluation,_and_Other_Manipulations3 (H142E55)</TT></A></H3>
Next we illustrate dividing out by integers, by dividing the 10 out
of 10T<sub>3</sub> acting on J<sub>0</sub>(23).  Note that this division occurs in
the full endomorphism ring, not just the Hecke algebra.
<P>
<P>
<PRE>
&gt; phi := 10*HeckeOperator(JZero(23),3); phi;
Homomorphism from JZero(23) to JZero(23) given on integral homology by:
[-10 -20  20   0]
[  0 -30  20 -20]
[ 20 -40  30 -20]
[ 20 -20   0  10]
&gt; DivideOutIntegers(phi);
Homomorphism from JZero(23) to JZero(23) given on integral homology by:
[-1 -2  2  0]
[ 0 -3  2 -2]
[ 2 -4  3 -2]
[ 2 -2  0  1]
10
</PRE>
<HR>
<H3><A NAME = "18181">Example <TT>ModAbVar_Morphisms-Restriction,_Evaluation,_and_Other_Manipulations4 (H142E56)</TT></A></H3>
Next we illustrate the restriction commands using
factors of J<sub>0</sub>(65).
<P>
<P>
<PRE>
&gt; J := JZero(65);
&gt; A := Decomposition(J)[2]; A;
Modular abelian variety 65B of dimension 2, level 5*13 and 
conductor 5^2*13^2 over Q
&gt; T := HeckeOperator(J,3);
&gt; Factorization(CharacteristicPolynomial(T));
[
    &lt;x + 2, 2&gt;,
    &lt;x^2 - 2*x - 2, 2&gt;,
    &lt;x^2 - 2, 2&gt;
]
&gt; Restriction(T,A); 
Homomorphism from modular abelian variety of dimension 2 to 
JZero(65) given on integral homology by:
[-1  0  0  1  0 -1  0  0  0  0]
[-1  3 -1  1 -3 -1  1  2 -1 -2]
[-1  1 -1  3 -1 -1 -1  0  1 -2]
[-1  0  0  3  0 -1 -2  0  2 -2]
&gt; TonA := RestrictEndomorphism(T,A); TonA;
Homomorphism from 65B to 65B given on integral homology by:
[-1  0  0  1]
[-1  3 -1  1]
[-1  1 -1  3]
[-1  0  0  3]
&gt; Factorization(CharacteristicPolynomial(TonA));
[
    &lt;x^2 - 2*x - 2, 2&gt;
]
</PRE>
Finally, we illustrate the <TT>SurjectivePart</TT> command
on the non-surjective morphism T<sub>3</sub> + 2  of J<sub>0</sub>(65).
<P>
<P>
<PRE>
&gt; phi := T+2;
&gt; IsSurjective(phi);
false
&gt; pi := SurjectivePart(phi);
&gt; IsSurjective(pi);
true
&gt; Codomain(pi);
Modular abelian variety of dimension 4 and level 5*13 over Q
</PRE>
<HR>
<H4><A NAME = "18182">Kernels</A></H4>

<P>
<P>
<P>
<P>
The category of abelian varieties is not an abelian category because
kernels need not exist in this category.  More precisely, if &phi; is
a homomorphism A to B of abelian varieties, then the kernel of &phi; is usually
not an abelian variety because it is rarely connected.  Instead, the
kernel fits into an exact sequence
<P>
  0 to C to ker(&phi;) to G to 0,
<P>
where C is an abelian variety and G is a finite group, both
defined over the same field as &phi;.  
<P>
The <TT>ConnectedKernel</TT> command returns C.
<P>
The <TT>ComponentGroupOfKernel</TT> command returns G
as a subgroup of A/C.
<P>
The <TT>Kernel</TT> command returns a finite subgroup
of A that maps to G,
the abelian variety C, and a map from C into A.  
<P>
Note that if C != 0 then the finite group that the <TT>Kernel</TT> 
command returns is <I>not canonical</I>, since it is just some
finite group that maps onto G via quotienting out by C.
For the canonical component group, use the 
<TT>ComponentGroupOfKernel</TT> command, which gives a group defined
over the same base field as &phi;, whose main drawback is
that the component group is not contained in A.


<H5><A NAME = "18183">ComponentGroupOfKernel(phi) : MapModAbVar -&gt;  ModAbVarSubGrp</A></H5>
<BLOCKQUOTE>
Component group of ker (&phi; ) where &phi; is a homomorphism of
abelian varieties.  
</BLOCKQUOTE>
<H5><A NAME = "18184">ConnectedKernel(phi) : MapModAbVar -&gt;  ModAbVar, MapModAbVar</A></H5>
<BLOCKQUOTE>
The connected component C of ker (&phi; ) and a morphism from C 
to the domain of &phi;  where &phi; is a homomorphism of
abelian varieties.  
</BLOCKQUOTE>
<H5><A NAME = "18185">Kernel(phi) : MapModAbVar -&gt;                            ModAbVarSubGrp, ModAbVar, MapModAbVar</A></H5>
<BLOCKQUOTE>
Let &phi; be a homomorphism of abelian varieties. This intrinsic returns 
a finite subgroup G of A (the domain of &phi;) as a subgroup of an abelian
variety, an abelian 
variety C such that ker (&phi; ) equals f(C) + G, and an injective map 
f from C to A. If C=0, then G has the same field of definition 
as &phi; ; otherwise, G is only known to be defined over the 
algebraic closure.  
</BLOCKQUOTE>
<HR>
<H3><A NAME = "18186">Example <TT>ModAbVar_Morphisms-Kernels (H142E57)</TT></A></H3>
The kernel of T<sub>2</sub> - 3 on J<sub>0</sub>(65) is an extension of an abelian
surface by a finite group isomorphic to (Z/2Z)<sup>4</sup>.
<P>
<P>
<P>
<PRE>
&gt; J := JZero(65);
&gt; T := HeckeOperator(J,2);
&gt; phi := T^2-3;
&gt; ConnectedKernel(phi);
Modular abelian variety of dimension 2 and level 5*13 over Q
Homomorphism from modular abelian variety of dimension 2 to 
JZero(65) given on integral homology by:
[ 1  0  0  0  0  1 -1  0  1 -1]
[ 0  1  0  0 -1  0  0  1  0 -1]
[ 0  0  1  0  0  0 -1  1  1 -1]
[ 0  0  0  1  0  0 -1  0  1 -1]
&gt; Kernel(phi);
Finitely generated subgroup of abelian variety with 
invariants [ 2, 2, 2, 2 ]
Modular abelian variety of dimension 2 and level 5*13 over Q
Homomorphism from modular abelian variety of dimension 2 to 
JZero(65) given on integral homology by:
[ 1  0  0  0  0  1 -1  0  1 -1]
[ 0  1  0  0 -1  0  0  1  0 -1]
[ 0  0  1  0  0  0 -1  1  1 -1]
[ 0  0  0  1  0  0 -1  0  1 -1]
&gt; G := ComponentGroupOfKernel(phi); G;
Finitely generated subgroup of abelian variety with 
invariants [ 2, 2, 2, 2 ]
&gt; FieldOfDefinition(G);
Rational Field
</PRE>
Though G is defined over Q, the ambient variety of G is the quotient
of J<sub>0</sub>(65) by the two dimensional connected component of the kernel
of T<sub>2</sub> - 3.
<P>
<P>
<PRE>
&gt; AmbientVariety(G);
Modular abelian variety of dimension 3 and level 5*13 over Q
</PRE>
On the other hand, the group returned by the <TT>Kernel</TT> command
is a subgroup of J<sub>0</sub>(65).
<P>
<P>
<PRE>
&gt; H, C := Kernel(phi);
&gt; H;
Finitely generated subgroup of abelian variety with invariants 
[ 2, 2, 2, 2 ]
&gt; FieldOfDefinition(H);
Algebraically closed field with no variables
&gt; AmbientVariety(H);
Modular abelian variety JZero(65) of dimension 5 and level 5*13 
over Q
</PRE>
<HR>
<H4><A NAME = "18187">Images</A></H4>

<P>
<P>
<P>
These commands compute the image of a modular abelian variety or
a finite group under a homomorphism &phi; of modular abelian varieties.
Using <TT>@@</TT>, one can also compute a group lifting a given group.
Note that this lift is not canonical unless &phi; has finite kernel,
in which case <TT>G@@phi</TT> is the full inverse image of G.


<H5><A NAME = "18188">A @ phi : ModAbVar, MapModAbVar -&gt; ModAbVar</A></H5>
<H5>phi(A) : ModAbVar, MapModAbVar -&gt;  ModAbVar</H5>
<BLOCKQUOTE>
The image of the abelian variety A under the map &phi;  of abelian varieties,
if this makes sense, i.e., if A is 
the domain of &phi; , or A has dimension 0, or one of the embeddings 
of A has codomain equal to the domain of &phi; .  
</BLOCKQUOTE>
<H5><A NAME = "18189">G @ phi : ModAbVarSubGrp, MapModAbVar -&gt; ModAbVarSubGrp</A></H5>
<H5>phi(G) : ModAbVarSubGrp, MapModAbVar -&gt;  ModAbVarSubGrp</H5>
<BLOCKQUOTE>
The image of the subgroup G of an abelian variety 
under the map &phi;  of abelian varieties, 
if this makes sense. If A is the 
ambient variety of G, then this makes sense if A is the domain of 
&phi; , or A has dimension 0, or one of the embeddings of A has 
codomain equal to the domain of &phi; .  
</BLOCKQUOTE>
<H5><A NAME = "18190">Image(phi) : MapModAbVar -&gt;  ModAbVar, MapModAbVar, MapModAbVar</A></H5>
<BLOCKQUOTE>
The image C of the morphism &phi; of abelian varieties, 
which is a modular abelian subvariety 
contained in the codomain of &phi; , a morphism from C to the codomain of 
&phi; , and a surjective morphism from the domain of &phi;  to C.  
</BLOCKQUOTE>
<H5><A NAME = "18191">G @@ phi : ModAbVarSubGrp, MapModAbVar -&gt;  ModAbVarSubGrp</A></H5>
<BLOCKQUOTE>
A finite group whose image under &phi;, a morphism of abelian varieties, 
is equal to the subgroup G of a modular abelian variety, if 
possible. If &phi;  has finite kernel, then this is the exact inverse image of 
G under &phi; . If not, then this is a group generated by a choice of 
torsion inverse image for each generator of G, which may not be canonical.  
</BLOCKQUOTE>
<HR>
<H3><A NAME = "18192">Example <TT>ModAbVar_Morphisms-Images (H142E58)</TT></A></H3>
The image of J<sub>0</sub>(37) under T<sub>2</sub> is an elliptic curve.
<P>
<P>
<PRE>
&gt; J := JZero(37);
&gt; phi := HeckeOperator(J,2);
&gt; phi(J);
Modular abelian variety of dimension 1 and level 37 over Q
&gt; Image(phi);
Modular abelian variety of dimension 1 and level 37 over Q
Homomorphism from modular abelian variety of dimension 1 to 
JZero(37) given on integral homology by:
[ 1 -1  1  0]
[ 1 -1 -1  1]
Homomorphism from JZero(37) to modular abelian variety of dimension 
1 given on integral homology by:
[ 0 -1]
[ 1  0]
[-1  1]
[ 0  0]
</PRE>
The Hecke operator T<sub>2</sub> maps the 
2-torsion subgroup of J<sub>0</sub>(37) maps onto the 2-torsion 
subgroup of the image of T<sub>2</sub>.
<P>
<P>
<PRE>
&gt; G := nTorsionSubgroup(J,2); G;
Finitely generated subgroup of abelian variety with invariants
[ 2, 2, 2, 2 ]
&gt; phi(G);
Finitely generated subgroup of abelian variety with invariants
[ 2, 2 ]
</PRE>
The homomorphism T<sub>2</sub> - 1 is surjective, and the inverse image
of the 2-torsion is a subgroup isomorphic to 
(Z/2Z)<sup>2</sup> x (Z/6Z)<sup>2</sup>.
<P>
<P>
<PRE>
&gt; IsSurjective(phi-1);
true
&gt; psi := phi-1;
&gt; H := G@@(psi); H;  
Finitely generated subgroup of abelian variety with invariants
[ 2, 2, 6, 6 ]
&gt; psi(H);
Finitely generated subgroup of abelian variety with invariants 
[ 2, 2, 2, 2 ]
&gt; H := G@@psi; H;
Finitely generated subgroup of abelian variety with invariants
[ 2, 2, 6, 6 ]
&gt; psi(H);
Finitely generated subgroup of abelian variety with invariants
[ 2, 2, 2, 2 ]
</PRE>
<HR>
<H4><A NAME = "18193">Cokernels</A></H4>



<H5><A NAME = "18194">Cokernel(phi) : MapModAbVar -&gt;  ModAbVar, MapModAbVar</A></H5>
<BLOCKQUOTE>
The cokernel of the morphism &phi;  of abelian varieties
and a morphism from the codomain of &phi;  
to the cokernel.  
</BLOCKQUOTE>
<HR>
<H3><A NAME = "18195">Example <TT>ModAbVar_Morphisms-Cokernels (H142E59)</TT></A></H3>
We compute a 2-dimensional quotient of the 3-dimensional abelian
variety J<sub>0</sub>(33) using the Hecke operator T<sub>2</sub> and the <TT>Cokernel</TT>
command.  
<P>
<P>
<PRE>
&gt; J := JZero(33);
&gt; T := HeckeOperator(J,2);
&gt; Factorization(CharacteristicPolynomial(T));
[
    &lt;x - 1, 2&gt;,
    &lt;x + 2, 4&gt;
]
&gt; phi := T + 2;
&gt; A, pi := Cokernel(phi);
&gt; A;
Modular abelian variety of dimension 2 and level 3*11 over Q
&gt; pi;
Homomorphism from JZero(33) to modular abelian variety of dimension 
2 (not printing 6x4 matrix)
</PRE>
<HR>
<H4><A NAME = "18196">Matrix Structure</A></H4>

<P>
<P>
<P>
Homomorphisms are stored and worked with internally using
the linear maps they induce on homology.  The commands
below provide access to those matrices. 


<H5><A NAME = "18197">Matrix(phi) : MapModAbVar -&gt;  ModMatFldElt</A></H5>
<BLOCKQUOTE>
The matrix on the chosen basis of rational homology that defines the morphism
&phi; of abelian varieties.  
</BLOCKQUOTE>
<H5><A NAME = "18198">Eltseq(phi) : MapModAbVar -&gt;  SeqEnum</A></H5>
<BLOCKQUOTE>
The <TT>Eltseq</TT> of the underlying matrix that defines the morphism &phi;
of abelian varieties. This is a 
sequence of integers or rational numbers.  
</BLOCKQUOTE>
<H5><A NAME = "18199">Ncols(phi) : MapModAbVar -&gt;  RngIntElt</A></H5>
<BLOCKQUOTE>
The number of columns of the matrix which defines the morphism &phi; of
abelian varieties. This is 
also the dimension of the homology of the codomain of &phi; .  
</BLOCKQUOTE>
<H5><A NAME = "18200">Nrows(phi) : MapModAbVar -&gt;  RngIntElt</A></H5>
<BLOCKQUOTE>
The number of rows of the matrix that defines the morphism &phi; of abelian
varieties. This is also 
the dimension of the homology of the domain of &phi; .  
</BLOCKQUOTE>
<H5><A NAME = "18201">Rows(phi) : MapModAbVar -&gt;  SeqEnum</A></H5>
<BLOCKQUOTE>
The sequence rows of the matrix that defines the morphism &phi; of abelian varieties.  
</BLOCKQUOTE>
<H5><A NAME = "18202">IntegralMatrix(phi) : MapModAbVar -&gt;  ModMatRngElt</A></H5>
<BLOCKQUOTE>
The matrix which defines the morphism &phi; of abelian varieties, written with respect to integral 
homology.  
</BLOCKQUOTE>
<H5><A NAME = "18203">IntegralMatrixOverQ(phi) : MapModAbVar -&gt;  ModMatFldElt</A></H5>
<BLOCKQUOTE>
The matrix which defines the morphism &phi; of abelian varieties, written with respect to integral 
homology.  
</BLOCKQUOTE>
<H5><A NAME = "18204">RealMatrix(phi) : MapModAbVar -&gt;   ModMatFldElt</A></H5>
<BLOCKQUOTE>
The matrix which defines the morphism &phi; of abelian varieties, written with respect to real 
homology.  
</BLOCKQUOTE>
<HR>
<H3><A NAME = "18205">Example <TT>ModAbVar_Morphisms-Matrix_Structure (H142E60)</TT></A></H3>
The following example demonstrates each of the commands for
the Hecke operator T<sub>2</sub> on J<sub>0</sub>(23). 
<P>
<P>
<PRE>
&gt; phi := HeckeOperator(JZero(23),2); phi;
Homomorphism T2 from JZero(23) to JZero(23) given on integral homology by:
[ 0  1 -1  0]
[ 0  1 -1  1]
[-1  2 -2  1]
[-1  1  0 -1]
&gt; Eltseq(phi);
[ 0, 1, -1, 0, 0, 1, -1, 1, -1, 2, -2, 1, -1, 1, 0, -1 ]
&gt; IntegralMatrix(phi);
[ 0  1 -1  0]
[ 0  1 -1  1]
[-1  2 -2  1]
[-1  1  0 -1]
&gt; Parent($1);
Full RMatrixSpace of 4 by 4 matrices over Integer Ring
&gt; IntegralMatrixOverQ(phi);
[ 0  1 -1  0]
[ 0  1 -1  1]
[-1  2 -2  1]
[-1  1  0 -1]
&gt; Parent($1);
Full Matrix Algebra of degree 4 over Rational Field
&gt; Matrix(phi);
[ 0  1 -1  0]
[ 0  1 -1  1]
[-1  2 -2  1]
[-1  1  0 -1]
&gt; Ncols(phi);
4
&gt; Nrows(phi);
4
&gt; RealMatrix(phi);
[   0    1   -1    0]
[   0    1   -1    1]
[  -1  2/1 -2/1    1]
[  -1    1    0   -1]
&gt; Parent($1);
Full KMatrixSpace of 4 by 4 matrices over Real Field
&gt; Rows(phi);
[
    ( 0  1 -1  0),
    ( 0  1 -1  1),
    (-1  2 -2  1),
    (-1  1  0 -1)
]
</PRE>
<HR>
<H4><A NAME = "18206">Arithmetic</A></H4>

<P>
<P>
<P>
Magma supports many standard arithmetic operations with homomorphisms
of abelian varieties, including composition, addition, subtraction,
and exponentiation.


<H5><A NAME = "18207">Inverse(phi) : MapModAbVar -&gt;  MapModAbVar, RngIntElt</A></H5>
<BLOCKQUOTE>
The inverse of &phi;  and an integer d such that d * &phi; <sup> - 1</sup> is a 
morphism of abelian varieties. More precisely, if &phi;  is an isogeny, then 
the inverse of &phi;  is a morphism in the category of abelian varieties 
up to isogeny. This intrinsic returns such a morphism or the actual 
inverse of &phi;  if &phi;  has degree 1.  
</BLOCKQUOTE>
<H5><A NAME = "18208">phi * psi : MapModAbVar, MapModAbVar -&gt;  MapModAbVar</A></H5>
<BLOCKQUOTE>
The composition of the homomorphisms &phi;  and &psi;  of abelian varieties.  
</BLOCKQUOTE>
<H5><A NAME = "18209">a * phi : FldRatElt, MapModAbVar -&gt;  MapModAbVar</A></H5>
<H5>a * phi : RngIntElt, MapModAbVar -&gt;  MapModAbVar</H5>
<BLOCKQUOTE>
The product of the rational number or integer a and the homomorphism &phi;
of abelian varieties. 
The result might only be a homomorphism, up to isogeny.  
</BLOCKQUOTE>
<H5><A NAME = "18210">phi * psi : MapModAbVar, AlgMatElt -&gt;  AlgMatElt</A></H5>
<H5>phi * psi : MapModAbVar, ModMatFldElt -&gt;  ModMatFldElt</H5>
<BLOCKQUOTE>
The product of the matrix that defines the morphism &phi;  of
abelian varieties and the matrix &psi; .  
</BLOCKQUOTE>
<H5><A NAME = "18211">psi * phi : AlgMatElt, MapModAbVar -&gt;  AlgMatElt</A></H5>
<H5>psi * phi : ModMatFldElt, MapModAbVar -&gt;  ModMatFldElt</H5>
<BLOCKQUOTE>
The product of the matrix &psi;  and the matrix that defines 
the morphism &phi; of abelian varieties.  
</BLOCKQUOTE>
<H5><A NAME = "18212">phi ^ n : MapModAbVar, RngIntElt -&gt;  MapModAbVar</A></H5>
<BLOCKQUOTE>
The n-fold composition &phi; <sup>n</sup> of the endomorphism &phi;  of an abelian 
variety with 
itself. If n= - 1, then this is the inverse of &phi; , in which case &phi;  
must be an isogeny or an error occurs.  
</BLOCKQUOTE>
<H5><A NAME = "18213">phi + psi : MapModAbVar, MapModAbVar -&gt;  MapModAbVar</A></H5>
<BLOCKQUOTE>
The sum of the homomorphisms &phi;  and &psi;   
</BLOCKQUOTE>
<H5><A NAME = "18214">n + phi : FldRatElt, MapModAbVar -&gt;  MapModAbVar</A></H5>
<H5>n + phi : RngIntElt, MapModAbVar -&gt;  MapModAbVar</H5>
<BLOCKQUOTE>
The sum of the morphism multiplication by the rational number or integer
n and the endomorphism &phi; of an abelian variety.  
</BLOCKQUOTE>
<H5><A NAME = "18215">phi + n : MapModAbVar, RngIntElt -&gt;  MapModAbVar</A></H5>
<BLOCKQUOTE>
The sum of the endomorphism &phi; of an abelian variety and the endomorphism 
multiplication-by-n where n is an integer.  
</BLOCKQUOTE>
<H5><A NAME = "18216">phi + psi : MapModAbVar, AlgMatElt -&gt;  AlgMatElt</A></H5>
<H5>phi + psi : MapModAbVar, ModMatFldElt -&gt;  ModMatFldElt</H5>
<BLOCKQUOTE>
The sum of the matrix that defines the morphism &phi; of abelian
varieties and the matrix &psi;.  
</BLOCKQUOTE>
<H5><A NAME = "18217">psi + phi : AlgMatElt, MapModAbVar -&gt;  AlgMatElt</A></H5>
<H5>psi + phi : ModMatFldElt, MapModAbVar -&gt;  ModMatFldElt</H5>
<BLOCKQUOTE>
The sum of the matrix &psi; and the matrix which defines the morphism &phi;
of abelian varieties.  
</BLOCKQUOTE>
<H5><A NAME = "18218">phi - psi : MapModAbVar, MapModAbVar -&gt;  MapModAbVar</A></H5>
<BLOCKQUOTE>
The difference between the homomorphisms &phi;  and &psi; of abelian 
varieties. 
</BLOCKQUOTE>
<H5><A NAME = "18219">n - phi : FldRatElt, MapModAbVar -&gt;  MapModAbVar</A></H5>
<H5>n - phi : RngIntElt, MapModAbVar -&gt;  MapModAbVar</H5>
<BLOCKQUOTE>
The difference between the morphism multiplication-by-n, 
where n is a rational
number or an integer, and the endomorphism &phi; of an abelian variety.  
</BLOCKQUOTE>
<H5><A NAME = "18220">phi - n : MapModAbVar, FldRatElt -&gt;  MapModAbVar</A></H5>
<H5>phi - n : MapModAbVar, RngIntElt -&gt;  MapModAbVar</H5>
<BLOCKQUOTE>
The difference between the endomorphism &phi; of an abelian variety
and the endomorphism 
multiplication-by-n where n is a rational number or an integer.  
</BLOCKQUOTE>
<H5><A NAME = "18221">phi - psi : MapModAbVar, AlgMatElt -&gt;  AlgMatElt</A></H5>
<H5>phi - psi : MapModAbVar, ModMatFldElt -&gt;  ModMatFldElt</H5>
<BLOCKQUOTE>
The difference between the matrix that defines the morphism &phi; of
abelian varieties and the matrix &psi; .  
</BLOCKQUOTE>
<H5><A NAME = "18222">psi - phi : AlgMatElt, MapModAbVar -&gt;  AlgMatElt</A></H5>
<H5>psi - phi : ModMatFldElt, MapModAbVar -&gt;  ModMatFldElt</H5>
<BLOCKQUOTE>
The difference between the matrix &psi; and the matrix which defines 
the morphism &phi; of abelian varieties.  
</BLOCKQUOTE>
<HR>
<H3><A NAME = "18223">Example <TT>ModAbVar_Morphisms-Arithmetic (H142E61)</TT></A></H3>
We illustrate several arithmetic operations use the Hecke operators
T<sub>2</sub> and T<sub>3</sub> on J<sub>0</sub>(23).
<P>
<P>
<PRE>
&gt; J := JZero(23);
&gt; phi := HeckeOperator(J,2);
&gt; psi := HeckeOperator(J,3);
&gt; Matrix(phi)*Matrix(psi);
[-2  1 -1  0]
[ 0 -1 -1  1]
[-1  2 -4  1]
[-1  1  0 -3]
&gt; phi*psi;
Homomorphism from JZero(23) to JZero(23) given on integral homology by:
[-2  1 -1  0]
[ 0 -1 -1  1]
[-1  2 -4  1]
[-1  1  0 -3]
&gt; Inverse(phi);
Homomorphism from JZero(23) to JZero(23) given on integral homology by:
[ 1  1 -1  0]
[ 0  2 -1  1]
[-1  2 -1  1]
[-1  1  0  0]
1
&gt; 1/3*phi;
Homomorphism from JZero(23) to JZero(23) (up to isogeny) on integral 
homology by:
[   0  1/3 -1/3    0]
[   0  1/3 -1/3  1/3]
[-1/3  2/3 -2/3  1/3]
[-1/3  1/3    0 -1/3]
&gt; 2+phi;
Homomorphism from JZero(23) to JZero(23) given on integral homology by:
[ 2  1 -1  0]
[ 0  3 -1  1]
[-1  2  0  1]
[-1  1  0  1]
&gt; phi+psi;
Homomorphism from JZero(23) to JZero(23) given on integral homology by:
[-1 -1  1  0]
[ 0 -2  1 -1]
[ 1 -2  1 -1]
[ 1 -1  0  0]
&gt; phi^4;
Homomorphism from JZero(23) to JZero(23) given on integral homology by:
[ 2 -3  3  0]
[ 0 -1  3 -3]
[ 3 -6  8 -3]
[ 3 -3  0  5]
1
&gt; phi^(-4);
Homomorphism from JZero(23) to JZero(23) given on integral homology by:
[ 5  3 -3  0]
[ 0  8 -3  3]
[-3  6 -1  3]
[-3  3  0  2]
1
</PRE>
<HR>
<H4><A NAME = "18224">Polynomials</A></H4>

<P>
<P>
<P>
The polynomial commands compute the characteristic and minimal
polynomials of endomorphisms of modular abelian varieties.  Each
command requires that the input homomorphism be a genuine homomorphism
(not just a morphism up to isogeny).  The same computation could be
done by first extracting the matrix of the endomorphism and using the
analogous command on the matrix.  However, in some special cases there
may be special techniques which can be used to do the computation more
quickly, so there can be some advantage to using the commands below.


<H5><A NAME = "18225">CharacteristicPolynomial(phi) : MapModAbVar -&gt;  RngUPolElt</A></H5>
<BLOCKQUOTE>
The characteristic polynomial of the endomorphism &phi; of an abelian variety. 
We can sometimes use extra information about &phi; (e.g., how it was 
constructed, Deligne bounds) to gain an answer faster.
</BLOCKQUOTE>
<H5><A NAME = "18226">FactoredCharacteristicPolynomial(phi) : MapModAbVar -&gt;  RngUPolElt</A></H5>
<BLOCKQUOTE>
The factorization of the characteristic polynomial of the 
endomorphism &phi; of an abelian variety. We can sometimes use extra information about 
&phi;  (e.g., how it was constructed, Deligne bounds), to gain an answer faster.
These factored polynomials 
are cached.  
</BLOCKQUOTE>
<H5><A NAME = "18227">MinimalPolynomial(phi) : MapModAbVar -&gt;  RngUPolElt</A></H5>
<BLOCKQUOTE>
The minimal polynomial of the endomorphism &phi; of an abelian variety. We can 
sometimes use extra information about &phi;  (e.g., how it was constructed, Deligne 
bounds), to gain an answer faster.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "18228">Example <TT>ModAbVar_Morphisms-Polynomials (H142E62)</TT></A></H3>
This example illustrates each of the polynomial commands
for the Hecke operator T<sub>2</sub> on J<sub>0</sub>(66). 
<P>
<P>
<PRE>
&gt; J := JZero(66);
&gt; phi := HeckeOperator(J,2);
&gt; R&lt;x&gt; := PolynomialRing(RationalField());
&gt; CharacteristicPolynomial(phi);
x^18 + 4*x^17 + 8*x^16 + 8*x^15 + 6*x^14 - 20*x^12 - 56*x^11 - 
    55*x^10 - 4*x^9 + 36*x^8 + 48*x^7 + 104*x^6 + 128*x^5 - 
    32*x^4 - 192*x^3 - 112*x^2 + 64*x + 64
&gt; CharacteristicPolynomial(Matrix(phi));
x^18 + 4*x^17 + 8*x^16 + 8*x^15 + 6*x^14 - 20*x^12 - 56*x^11 - 
    55*x^10 - 4*x^9 + 36*x^8 + 48*x^7 + 104*x^6 + 128*x^5 - 
    32*x^4 - 192*x^3 - 112*x^2 + 64*x + 64
&gt; FactoredCharacteristicPolynomial(phi);
[
    &lt;x - 1, 4&gt;,
    &lt;x + 1, 2&gt;,
    &lt;x^2 - x + 2, 2&gt;,
    &lt;x^2 + 2*x + 2, 4&gt;
]
&gt; MinimalPolynomial(phi);
x^6 + x^5 + x^4 + x^3 + 2*x^2 - 2*x - 4
&gt; Factorization(MinimalPolynomial(phi));
[
    &lt;x - 1, 1&gt;,
    &lt;x + 1, 1&gt;,
    &lt;x^2 - x + 2, 1&gt;,
    &lt;x^2 + 2*x + 2, 1&gt;
]
</PRE>
<HR>
<H4><A NAME = "18229">Invariants</A></H4>

<P>
<P>
<P>
It is possible to retrieve the domain and codomain of homomorphisms
between abelian varieties. The degrees of such homomorphisms can be computed.
Denominators of homomorphisms can be determined and cleared. A field
over which a homomorphism is defined is available. The rank, nullity 
and trace of a homomorphism can also be computed.


<H5><A NAME = "18230">Domain(phi) : MapModAbVar -&gt;  ModAbVar</A></H5>
<BLOCKQUOTE>
The domain of the morphism &phi;  of abelian varieties.  
</BLOCKQUOTE>
<H5><A NAME = "18231">Codomain(phi) : MapModAbVar -&gt;  ModAbVar</A></H5>
<BLOCKQUOTE>
The codomain of the morphism &phi;  of abelian varieties.  
</BLOCKQUOTE>
<H5><A NAME = "18232">Degree(phi) : MapModAbVar -&gt;  RngIntElt</A></H5>
<BLOCKQUOTE>
The degree of the morphism &phi;  of abelian varieties, i.e. the cardinality
of the kernel of &phi;.
If the kernel of &phi;  is not 
finite, then the degree is defined to be 0.  
</BLOCKQUOTE>
<H5><A NAME = "18233">Denominator(phi) : MapModAbVar -&gt;  RngIntElt</A></H5>
<BLOCKQUOTE>
Given a morphism &phi; of abelian varieties return the smallest positive 
integer n such that n * &phi;  is a 
homomorphism. This is also the denominator of the matrix that defines &phi; .  
</BLOCKQUOTE>
<H5><A NAME = "18234">ClearDenominator(phi) : MapModAbVar -&gt;  MapModAbVar</A></H5>
<BLOCKQUOTE>
Return the morphism n * &phi; where &phi; is a morphism of abelian 
varieties and n is positive and the smallest such that n * &phi; is a 
genuine homomorphism.  
</BLOCKQUOTE>
<H5><A NAME = "18235">FieldOfDefinition(phi) : MapModAbVar -&gt;  ModAbVar</A></H5>
<BLOCKQUOTE>
A field of definition of the morphism &phi;  of abelian varieties.  
This is only some field over which &phi; is defined, it is not guaranteed
to be minimal.
</BLOCKQUOTE>
<H5><A NAME = "18236">Nullity(phi) : MapModAbVar -&gt;  RngIntElt</A></H5>
<BLOCKQUOTE>
The dimension of the kernel of the morphism &phi;  of abelian varieties.  
</BLOCKQUOTE>
<H5><A NAME = "18237">Rank(phi) : MapModAbVar -&gt;  RngIntElt</A></H5>
<BLOCKQUOTE>
The dimension of the kernel of the morphism &phi;  of abelian varieties.  
</BLOCKQUOTE>
<H5><A NAME = "18238">Trace(phi) : MapModAbVar -&gt;  FldRatElt</A></H5>
<BLOCKQUOTE>
The trace of any matrix which represents the action of the morphism &phi; 
of abelian varieties on integral homology. For example, the trace
of multiplication by n on A is 2n dim(A).
</BLOCKQUOTE>
<HR>
<H3><A NAME = "18239">Example <TT>ModAbVar_Morphisms-Invariants (H142E63)</TT></A></H3>
<P>
<P>
<PRE>
&gt; phi := NaturalMap(JZero(11),JZero(33));
&gt; Codomain(phi);
Modular abelian variety JZero(33) of dimension 3 and level 3*11 over Q
&gt; Domain(phi);
Modular abelian variety JZero(11) of dimension 1 and level 11 over Q
&gt; Degree(phi);
1
&gt; Denominator(1/5*phi);
5
&gt; FieldOfDefinition(phi);
Rational Field
&gt; Nullity(phi);
0
&gt; Rank(phi);
1
&gt; Trace(HeckeOperator(JZero(33),2));
-6
&gt; Trace(nIsogeny(JZero(33),5));
30
</PRE>
<HR>
<H4><A NAME = "18240">Predicates</A></H4>

<P>
<P>
<P>
A range of predicates are provided allowing a morphism to be checked for
whether it is an actual morphism or not, whether its kernel is finite,
and whether it is injective or surjective or an isogeny.
There are also commands for testing equality of homomorphisms and
inclusion in a list.


<H5><A NAME = "18241">IsMorphism(phi) : MapModAbVar -&gt;  BoolElt</A></H5>
<BLOCKQUOTE>
Return <TT>true</TT> if and only if the map &phi; between abelian varieties
is a morphism in the category of abelian 
varieties (not just in the category of abelian varieties up to isogeny).  
</BLOCKQUOTE>
<H5><A NAME = "18242">OnlyUpToIsogeny(phi) : MapModAbVar -&gt;  BoolElt</A></H5>
<BLOCKQUOTE>
Return <TT>true</TT> if the map &phi; between abelian varieties
is not a homomorphism, but n * &phi;  is a 
homomorphism for some positive integer n, 
i.e., &phi;  is only a homomorphism 
in the category of abelian varieties up to isogeny.  
</BLOCKQUOTE>
<H5><A NAME = "18243">HasFiniteKernel(phi) : MapModAbVar -&gt;  BoolElt</A></H5>
<BLOCKQUOTE>
Return <TT>true</TT> if the kernel of the homomorphism &phi; of abelian varieties
is finite.  
</BLOCKQUOTE>
<H5><A NAME = "18244">IsInjective(phi) : MapModAbVar -&gt;  BoolElt</A></H5>
<BLOCKQUOTE>
Return <TT>true</TT> if the map &phi; between abelian varieties 
is an injective homomorphism.  
</BLOCKQUOTE>
<H5><A NAME = "18245">IsSurjective(phi) : MapModAbVar -&gt;  BoolElt</A></H5>
<BLOCKQUOTE>
Return <TT>true</TT> if the homomorphism &phi; between abelian varieties
is surjective.  
</BLOCKQUOTE>
<H5><A NAME = "18246">IsEndomorphism(phi) : MapModAbVar -&gt;  BoolElt</A></H5>
<BLOCKQUOTE>
Return <TT>true</TT> if the morphism &phi; between abelian varieties is an endomorphism, i.e., the domain and codomain of 
&phi;  are equal.  
</BLOCKQUOTE>
<H5><A NAME = "18247">IsInteger(phi) : MapModAbVar -&gt;  BoolElt, RngIntElt</A></H5>
<BLOCKQUOTE>
Return <TT>true</TT> if the morphism &phi; between abelian varieties 
is multiplication by n for some integer n. If 
so, returns that n as well, otherwise, returns <TT>false</TT>.
</BLOCKQUOTE>
<H5><A NAME = "18248">IsIsogeny(phi) : MapModAbVar -&gt;  BoolElt</A></H5>
<BLOCKQUOTE>
Return <TT>true</TT> if the morphism &phi; between abelian varieties
is a surjective homomorphism with finite kernel. Note 
that this definition differs from the one in Silverman's books on elliptic 
curves, agrees with the one in Milne's articles, and is an equivalence 
relation.  
</BLOCKQUOTE>
<H5><A NAME = "18249">IsIsomorphism(phi) : MapModAbVar -&gt;  BoolElt</A></H5>
<BLOCKQUOTE>
Return <TT>true</TT> if the morphism &phi; between abelian varieties
is an isomorphism of abelian varieties.  
</BLOCKQUOTE>
<H5><A NAME = "18250">IsOptimal(phi) : MapModAbVar -&gt;  BoolElt</A></H5>
<BLOCKQUOTE>
Return <TT>true</TT> if the morphism &phi; between abelian varieties
is an optimal quotient map, i.e., &phi;  is 
surjective and has connected kernel.  
</BLOCKQUOTE>
<H5><A NAME = "18251">IsHeckeOperator(phi) : MapModAbVar -&gt;  BoolElt, RngIntElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if the morphism &phi; between abelian varieties
was computed using the <TT>HeckeOperator</TT> command, 
and the argument n passed to the <TT>HeckeOperator</TT> command when &phi; 
was created, otherwise <TT>false</TT>.
</BLOCKQUOTE>
<H5><A NAME = "18252">IsZero(phi) : MapModAbVar -&gt;  BoolElt</A></H5>
<BLOCKQUOTE>
Return <TT>true</TT> if the morphism &phi; of abelian varieties
is the zero morphism.  
</BLOCKQUOTE>
<H5><A NAME = "18253">phi eq psi : MapModAbVar, MapModAbVar -&gt;  BoolElt</A></H5>
<BLOCKQUOTE>
Return <TT>true</TT> if the two homomorphisms of abelian varieties 
&phi;  and &psi;  are equal.  
</BLOCKQUOTE>
<H5><A NAME = "18254">n eq phi : RngIntElt, MapModAbVar -&gt;  BoolElt</A></H5>
<H5>phi eq n : MapModAbVar, RngIntElt -&gt;  BoolElt</H5>
<BLOCKQUOTE>
Return <TT>true</TT> if the morphism &phi; between abelian varieties
is equal to multiplication by the integer n.  
</BLOCKQUOTE>
<H5><A NAME = "18255">phi in X : MapModAbVar, List -&gt;  BoolElt</A></H5>
<BLOCKQUOTE>
Return <TT>true</TT> if the morphism &phi; between abelian varieties
is one of the homomorphisms in the list X of 
homomorphisms.  
</BLOCKQUOTE>
<HR>
<H3><A NAME = "18256">Example <TT>ModAbVar_Morphisms-Predicates (H142E64)</TT></A></H3>
<P>
<P>
<PRE>
&gt; phi := HeckeOperator(JZero(65),2)-1;
&gt; HasFiniteKernel(phi);
true
&gt; IsEndomorphism(phi);
true
&gt; IsHeckeOperator(phi);
false 0
&gt; IsInjective(phi);
false
&gt; IsInteger(phi);
false
&gt; IsIsogeny(phi);
true
&gt; IsIsomorphism(phi);
false
&gt; IsMorphism(phi);
true
&gt; IsMorphism(1/2*phi);
false
&gt; IsSurjective(phi);
true
&gt; IsZero(phi);
false
&gt; OnlyUpToIsogeny(phi);
false
&gt; 2 eq phi;
false
&gt; phi eq 2;
false
&gt; 2 eq nIsogeny(JZero(65),2);
true
&gt; phi eq nIsogeny(JZero(65),2);
false
&gt; phi in [* phi, nIsogeny(JZero(65),2) *];
true
&gt; IsIsomorphism(NaturalMap(JZero(11),JOne(11)));
false
&gt; IsIsomorphism(NaturalMap(JZero(11)^2,JZero(22)));
false
&gt; IsIsomorphism(NaturalMap(JZero(11),JZero(11)));
true
</PRE>
<HR>
<PRE></PRE> <A  HREF = "text1640.htm">[Next]</A><A  HREF = "text1638.htm">[Prev]</A> <A  HREF = "text1640.htm">[Right]</A> <A  HREF = "text1638.htm">[Left]</A> <A  HREF = "text1635.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<br><small>Version: V2.22 of <I>
Thu Jun  9 16:37:49 EST 2016
</I></small>
</body></html>