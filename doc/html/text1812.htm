<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <link rel='stylesheet' href='help.css' type='text/css'>
  <TITLE>The Vertex--Set and Edge--Set of Multigraphs</TITLE>
</head>
<body BGCOLOR="#FFFFFF">

 <A  HREF = "text1813.htm">[Next]</A><A  HREF = "text1811.htm">[Prev]</A> <A  HREF = "text1813.htm">[Right]</A> <A  HREF = "text1811.htm">[Left]</A> <A  HREF = "text1809.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<PRE></PRE><H3><A NAME = "20052">The Vertex--Set and Edge--Set of Multigraphs</A></H3>

<P>
<P>
<P>
<P>
<P>
<P>
Much of  the functionality  for simple graphs 
  (see Section <A  HREF = "text1786.htm#19716">The Vertex--Set and Edge--Set of a Graph</A>) also applies to multigraphs.
We will not repeat here the functions pertaining to the vertex-set
  and edge-set of a graph, but concentrate instead on the edges.
Indeed, there is a difference in the manner in which 
  multigraph edges are created and 
  accessed when compared to simple graph edges.
<P>
<P>
Since multigraphs may have multiple edges from u to v, it is necessary 
  to know
  how many of these edges there are, and how each can be accessed.
More importantly a scheme is required to uniquely identify an edge.
<P>
Recall that a multigraph is represented by means of an adjacency list,
so any edge from u to v can be identified by its index in this list.
If there is more than one edge from u to v, then 
  a list of indices will identify each edge from u to v.
Thus, the index of the edge in the adjacency list will be 
  the means by which this edge can be <I>uniquely</I> identified.
<P>
This has a bearing on how an edge can be coerced into a multigraph:
  Successful coercion will require two vertices u and v
    so that v is a neighbour of u, and a valid index i in
    the multigraph's adjacency list.
  That is, the position i in the list is the index of an edge
    from u to v.


<H5><A NAME = "20053">EdgeIndices(u, v) : GrphVert, GrphVert -&gt; SeqEnum</A></H5>
<H5>Indices(u, v) : GrphVert, GrphVert -&gt; SeqEnum</H5>
<BLOCKQUOTE>
Given vertices u and v of a multigraph G, returns 
       the indices of the possibly multiple edge from u to v.
</BLOCKQUOTE>
<H5><A NAME = "20054">EdgeMultiplicity(u, v) : GrphVert, GrphVert -&gt; RngIntElt</A></H5>
<H5>Multiplicity(u, v) : GrphVert, GrphVert -&gt; RngIntElt</H5>
<BLOCKQUOTE>
Given vertices u and v of a multigraph G, returns 
       the multiplicity of the possibly multiple edge from u to v.
Returns 0 if u is not adjacent to v.
</BLOCKQUOTE>
<H5><A NAME = "20055">Edges(u, v) : GrphVert, GrphVert -&gt; SeqEnum</A></H5>
<BLOCKQUOTE>
Given vertices u and v of a multigraph G, returns 
   all the edges from u to v as a sequence of elements 
   of the edge-set of G.
</BLOCKQUOTE>
<H5><A NAME = "20056">IncidentEdges(u) : GrphVert  -&gt; SetEnum</A></H5>
<BLOCKQUOTE>
Given a vertex u of an undirected multigraph G, returns 
   all the edges incident to u as a set of elements 
   of the edge-set of G.
If G is a multidigraph,  the function returns 
   all the edges incident to <I>and</I> from u as a set of elements 
   of the edge-set of G.
</BLOCKQUOTE>
<H5><A NAME = "20057">E ! &lt; { u, v }, i &gt; : GrphEdgeSet, &lt; . &gt; -&gt; GrphEdge</A></H5>
<BLOCKQUOTE>
Given the edge-set E of the undirected multigraph G and objects u, v 
belonging to the support of G corresponding to adjacent 
vertices, returns the edge from u to v which corresponds 
to the edge with index i in the adjacency list of G.
This requires that the edge at i in the adjacency list of G is an edge
from u to v.
</BLOCKQUOTE>
<H5><A NAME = "20058">E ! &lt; [ u, v ], i &gt; : GrphEdgeSet, &lt; . &gt; -&gt; GrphEdge</A></H5>
<BLOCKQUOTE>
Given the edge-set E of the multidigraph G and objects u, v 
belonging to the support of G corresponding to adjacent 
vertices, returns the edge from u to v which corresponds 
to the edge with index i in the adjacency list of G.
This requires that the edge at i in the adjacency list of G is an edge
from u to v.
</BLOCKQUOTE>
<H5><A NAME = "20059"></A><A NAME = "MultiGraph:E.i"></A> {E . i} : GrphEdgeSet, RngIntElt -&gt; GrphEdge</H5>
<BLOCKQUOTE>
Let E be the edge-set of G.
If G is a simple graph (digraph) then this function is as 
  described in Subsection <A  HREF = "text1786.htm#19718">Creating Edges and Vertices</A>.
<P>
If G is a multigraph or multidigraph, then this function returns the edge
  at index i in the adjacency list of G, provided i is a valid
  index.
</BLOCKQUOTE>
<H5><A NAME = "20060">EndVertices(e) : GrphEdge -&gt;{ GrphVert, GrphVert }</A></H5>
<H5>EndVertices(e) : GrphEdge -&gt; [ GrphVert, GrphVert ]</H5>
<BLOCKQUOTE>
Given an edge e in an undirected multigraph G,
  returns the end vertices of e as a set of vertices {u, v}.
If G is a multidigraph, returns e's end vertices
  as a sequence of vertices [u, v].
</BLOCKQUOTE>
<H5><A NAME = "20061">InitialVertex(e) : GrphEdge -&gt; GrphVert</A></H5>
<BLOCKQUOTE>
Given an edge e = {u, v} or e = [u, v], returns  vertex u. 
This is useful in the undirected case since it indicates, where relevant,
  the direction
  in which the edge has been traversed.
</BLOCKQUOTE>
<H5><A NAME = "20062">TerminalVertex(e) : GrphEdge -&gt; GrphVert</A></H5>
<BLOCKQUOTE>
Given an edge e = {u, v}  or e = [u, v], returns  vertex v. 
This is useful in the undirected case since it indicates, where relevant,
  the direction
  in which the edge has been traversed.
</BLOCKQUOTE>
<H5><A NAME = "20063">Index(e) : GrphEdge -&gt; RngIntElt</A></H5>
<BLOCKQUOTE>
Given an edge e in a multi(di)graph G,
  returns the index of e in the 
  adjacency list of G.
</BLOCKQUOTE>
<H5><A NAME = "20064">s eq t : GrphEdge, GrphEdge -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if the edge s is equal to the edge t.
It s and t are edges in a multi(di)graph G, 
  returns <TT>true</TT> if and only if 
  s and t have the same index in the adjacency list of G.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "20065">Example <TT>MultiGraph_GrphMult_Edges (H156E4)</TT></A></H3>
<P>
<P>
<PRE>
&gt; G := MultiGraph&lt; 3 | &lt; 1, {2, 3} &gt;, &lt; 1, {2} &gt;, &lt; 2, {2, 3} &gt; &gt;;
</PRE>
The graph G has a loop at vertex 2:
<P>
<P>
<PRE>
&gt; Edges(G);
{@ &lt; {1, 2}, 1 &gt;, &lt; {1, 2}, 5 &gt;, &lt; {1, 3}, 3 &gt;, &lt; {2, 2}, 7 &gt;, &lt; {2,
3}, 9 &gt; @}
&gt; E := EdgeSet(G);
&gt; E.7;
&lt; {2, 2}, 7 &gt;
&gt; assert InitialVertex(E.7) eq TerminalVertex(E.7);
</PRE>
The graph G has a multiple edge from vertex 1 to vertex 2:
<P>
<P>
<PRE>
&gt; u := VertexSet(G)!1;
&gt; v := VertexSet(G)!2;
&gt; I := EdgeIndices(u, v);
&gt; I;
[ 5, 1 ]
&gt; assert #I eq Multiplicity(u, v);
&gt; 
&gt; E := EdgeSet(G);
&gt; e1 := E!&lt; { 1, 2 }, I[1] &gt;;
&gt; e2 := E!&lt; { 1, 2 }, I[2] &gt;;
&gt; e1, e2;
&lt; {1, 2}, 5 &gt; &lt; {1, 2}, 1 &gt;
&gt; EndVertices(e1);
{ 1, 2 }
&gt; EndVertices(e2);
{ 1, 2 }
&gt; assert Index(e1) eq I[1];
&gt; assert Index(e2) eq I[2];
&gt; 
&gt; assert e1 eq E.I[1];
&gt; assert not e2 eq E.I[1];
&gt; assert e2 eq E.I[2];
&gt; assert not e1 eq E.I[2];
</PRE>
We have seen that these two edges can be accessed directly:
<P>
<P>
<PRE>
&gt; Edges(u, v);
[ &lt; {1, 2}, 5 &gt;, &lt; {1, 2}, 1 &gt; ]
</PRE>
<HR>
<PRE></PRE> <A  HREF = "text1813.htm">[Next]</A><A  HREF = "text1811.htm">[Prev]</A> <A  HREF = "text1813.htm">[Right]</A> <A  HREF = "text1811.htm">[Left]</A> <A  HREF = "text1809.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<br><small>Version: V2.22 of <I>
Thu Jun  9 16:37:49 EST 2016
</I></small>
</body></html>