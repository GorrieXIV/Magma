<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <link rel='stylesheet' href='help.css' type='text/css'>
  <TITLE>Fans in Toric Lattices</TITLE>
</head>
<body BGCOLOR="#FFFFFF">

 <A  HREF = "text1406.htm">[Next]</A><A  HREF = "text1404.htm">[Prev]</A> <A  HREF = "text1406.htm">[Right]</A> <A  HREF = "text1404.htm">[Left]</A> <A  HREF = "text1403.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<PRE></PRE><H3><A NAME = "15734">Fans in Toric Lattices</A></H3>

<P>
<P>
A <I>fan</I> F (in a toric lattice L) is a collection of cones in L
satisfying typical conditions of cell decompositions (the inclusion
of faces of cones is part of the data, and the requirement that any
two cones of the fan intersect in a common face is enforced, for instance).
The <I>support</I> of F is the union of all the cones as a subset of L.
The main two cases are when either the support of F is the support
of a single cone (which is regarded as being subdivided by the cones
of the fan) or it is the whole of L.
Other cases do occur and are allowed by our package---even having
cones of different dimensions lying in complementary linear subspaces
of L, although that is not commonly interpreted geometrically.
<P>
There are several constructors for well-known fans, and also
standard methods for modifying fans.
If these are not enough, then one can simply list the top-dimensional
cones of a fan; Magma will check that they intersect correctly
and will add the lower-dimensional cones as necessary.
<P>
Fans are of type <TT>TorFan</TT>.



<H5>Subsections</H5>
<UL>
<LI> <A  HREF = "text1405.htm#15735">Construction of Fans</A>
<LI> <A  HREF = "text1405.htm#15755">Components of Fans</A>
<LI> <A  HREF = "text1405.htm#15782">Properties of Fans</A>
<LI> <A  HREF = "text1405.htm#15793">Maps of Fans</A>
</UL>
<H4><A NAME = "15735">Construction of Fans</A></H4>

<P>
<P>
We first list the comprehensive constructors for fans.
After that, we have a collection of constructors for
well-known fans, and there also are methods for modifying fans.


<H5><A NAME = "15736">Fan(Q) : [TorCon] -&gt; TorFan</A></H5>

<PRE>    define_fan: BoolElt                 Default: <TT>false</TT></PRE>

<PRE>    max_cones: BoolElt                  Default: <TT>false</TT></PRE>
<BLOCKQUOTE>
The fan generated by the cones in the sequence Q.
<P>
The optional parameter <TT>define_fan</TT> (by default <TT>false</TT>)
can be set to <TT>true</TT>, so that the verification whether the input
data is correct is skipped. The optional parameter <TT>max_cones</TT>
(by default <TT>false</TT>) can be set to <TT>true</TT> to skip the verification
whether the cones are maximal. Both will lead to errors later
if the cones do not in fact determine a fan as claimed.
</BLOCKQUOTE>
<H5><A NAME = "15737">Fan(R,S) : [TorLatElt],[[RngIntElt]] -&gt; TorFan</A></H5>

<PRE>    define_fan: BoolElt                 Default: <TT>false</TT></PRE>
<BLOCKQUOTE>
The fan whose rays are the sequence of toric lattice points R
(or sequences of sequences of integer coefficients of such points)
and whose maximal cones correspond to the sequence S of sequences of
integers: each such sequence is interpreted as the indices of
a collection of rays of R, and these rays are used to generate a cone.
<P>
This constructor checks that the given data does indeed define
a fan. This check can be lengthy. It can be omitted by setting the
parameter <TT>define_fan</TT> to be <TT>false</TT>, although this
should be used with extreme care: there is no telling what might
go wrong if incorrect data is assumed to be a fan.
</BLOCKQUOTE>
<H5><A NAME = "15738">Fan(C) : TorCon -&gt; TorFan</A></H5>
<BLOCKQUOTE>
The fan comprising all faces of the cone C.
</BLOCKQUOTE>
<H5><A NAME = "15739">FanOfAffineSpace(n) : RngIntElt -&gt; TorFac</A></H5>
<BLOCKQUOTE>
The standard fan of affine space of dimension n,
where n is a positive integer.
</BLOCKQUOTE>
<H5><A NAME = "15740">FanOfWPS(W) : SeqEnum -&gt; TorFan</A></H5>
<BLOCKQUOTE>
A standard fan for the weighted projective space with weights
W, a sequence of positive integers.
</BLOCKQUOTE>
<H5><A NAME = "15741">[Future release] FanOfProjectiveSpace(n) : RngIntElt -&gt; TorFac</A></H5>
<BLOCKQUOTE>
The standard fan of projective space of dimension n,
a positive integer.
</BLOCKQUOTE>
<H5><A NAME = "15742">FanOfFakeProjectiveSpace(W,Q) : SeqEnum, SeqEnum -&gt; TorFan</A></H5>
<BLOCKQUOTE>
A standard fan for the fake weighted projective space with weights
W, a sequence of positive integers, and finite cyclic group actions
given by Q, a sequence of sequences of rational numbers.
The finite cyclic actions are determined as follows: for Z/r
to act diagonally with weights (a<sub>1</sub>, ..., a<sub>n</sub>), include
the sequence <TT>[a1/r,...,an/r]</TT> as an element of Q.
</BLOCKQUOTE>
<H5><A NAME = "15743">ZeroFan(L) : TorLat -&gt; TorFan</A></H5>
<BLOCKQUOTE>
The fan in the toric lattice L supported at the origin.
</BLOCKQUOTE>
<H5><A NAME = "15744">NormalFan(F,C) : TorFan,TorCon -&gt; TorFan,Map</A></H5>
<BLOCKQUOTE>
The normal fan to a cone C in a fan F in the toric
lattice that is the quotient of the ambient lattice of F
by the span of C; the quotient map of lattices is the
second return value.
</BLOCKQUOTE>
<H5><A NAME = "15745">NormalFan(P) : TorPol -&gt; TorFan</A></H5>
<H5>DualFan(P) : TorPol -&gt; TorFan</H5>
<BLOCKQUOTE>
The normal fan to the polyhedron P; in particular, the rays of the fan are normal to the facets of P. The resulting fan lies in the lattice dual to the ambient lattice of P.
</BLOCKQUOTE>
<H5><A NAME = "15746">SpanningFan(P) : TorPol -&gt; TorFan</A></H5>
<BLOCKQUOTE>
The toric fan that spans the polyhedron P; in particular, the
rays of the fan are generated by the vertices of P. The resulting fan lies in the same ambient lattice as P.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "15747">Example <TT>Toric_toric-spanning-fan-example (H124E6)</TT></A></H3>
The spanning fan of a polytope P is a fan in the same
lattice as P with rays passing through its vertices.
Here we make the fan of the Hirzebruch surface F<sub>1</sub>
as a spanning fan.
<P>
<P>
<PRE>
&gt; P := Polytope([ [0,1], [1,0], [1,-1], [-1,0] ]);
&gt; SpanningFan(P);
Fan with 4 rays:
    ( 0,  1),
    ( 1,  0),
    ( 1, -1),
    (-1,  0)
and 4 cones with indices:
    [ 1, 4 ],
    [ 1, 2 ],
    [ 2, 3 ],
    [ 3, 4 ]
</PRE>
The dual fan of a polytope P is a fan in the dual lattice
to that of P whose rays are constant when evaluated on some
facet of P.
Here we make the fan of projective 3-space as a dual fan.
<P>
<P>
<PRE>
&gt; Q := StandardSimplex(3);
&gt; DualFan(Q);
Fan with 4 rays:
    (-1, -1, -1),
    ( 1,  0,  0),
    ( 0,  1,  0),
    ( 0,  0,  1)
and 4 cones with indices:
    [ 2, 3, 4 ],
    [ 1, 3, 4 ],
    [ 1, 2, 4 ],
    [ 1, 2, 3 ]
Mapping from: 3-dimensional toric lattice (Z^3)^* to 3-dimensional toric lattice
(Z^3)^* given by a rule
</PRE>
<HR>
<H5><A NAME = "15748">FanWithWeights(W) : SeqEnum -&gt; TorFan</A></H5>

<PRE>    ample: [RngIntElt]                  Default: the sum of weights</PRE>

<PRE>    define_fan: BoolElt                 Default: <TT>false</TT></PRE>
<BLOCKQUOTE>
The fan generated by the weights (or gradings) W, where W is a sequence of sequences of integers. The optional parameter <TT>ample</TT> can be used to specify the ample divisor to use. By default this is equal to the sum of the weights. If the optional parameter <TT>define_fan</TT> is set to <TT>true</TT> then the verification that the weights define a fan is skipped.
</BLOCKQUOTE>
<H5><A NAME = "15749">Blowup(F,v): TorFan,TorLatElt -&gt; TorFan</A></H5>
<BLOCKQUOTE>
The blowup of the toric fan F at the point v that
is an element of the ambient toric lattice of F.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "15750">Example <TT>Toric_toric-fan-with-weights-example (H124E7)</TT></A></H3>
We construct a toric Fano three-fold X directly from the weight (or grading) data:
<P>
<P>
<PRE>
&gt; F:=FanWithWeights([
&gt;     [ 1, 1,-1, 0,-2, 0 ],
&gt;     [ 0, 0, 1, 1, 0, 0 ],
&gt;     [ 0, 0, 0, 0, 1, 1 ]
&gt; ]);
&gt; X&lt;[x]&gt;:=ToricVariety(Rationals(),F);
&gt; X;
Toric variety of dimension 3 over Rational Field
Variables: x[1], x[2], x[3], x[4], x[5], x[6]
The components of the irrelevant ideal are:
    (x[4], x[3]), (x[5], x[2]), (x[3], x[2]), (x[6], x[5], x[1]),
    (x[6], x[4], x[1])
The 3 gradings are:
    0, 0, 1, 1, 0, 0,
    0, 1, 0, 0, 1, 0,
    1, 0, 0, 2, 1, 1
&gt; IsFano(X);
true
&gt; IsNonsingular(X);
false
&gt; IsQFactorial(X);
true
&gt; IsTerminal(X);
true
</PRE>
Now we begin by taking P = P(1, 1, 1, 2) and blowing up twice. We obtain a Q-factorial terminal Fano three-fold Y.
<P>
<P>
<PRE>
&gt; P:=WPS(Rationals(),[1,1,1,2]);
&gt; F:=Fan(P);
&gt; F;
Fan F with 4 rays:
    ( 0, -1, -1),
    (-1,  0,  1),
    (-1,  1,  0),
    ( 1,  0,  0)
and 4 cones with indices:
    [ 1, 2, 3 ],
    [ 1, 2, 4 ],
    [ 1, 3, 4 ],
    [ 2, 3, 4 ]
&gt; N:=Ambient(F);
&gt; pt1:=N ! [1,-1,0];
&gt; pt2:=N ! [-1,0,0];
&gt; Y1:=Blowup(P,pt1);
&gt; Y&lt;[y]&gt;:=Blowup(Y1,pt2);
&gt; Y;
Toric variety of dimension 3 over Rational Field
Variables: y[1], y[2], y[3], y[4], y[5], y[6]
The components of the irrelevant ideal are:
    (y[6], y[5]), (y[6], y[4]), (y[5], y[3]), (y[4], y[2], y[1]),
    (y[3], y[2], y[1])
The 3 gradings are:
    0, 0, 0, 1, 0, 1,
    0, 0, 1, 0, 1, 0,
    1, 1, 1, 2, 0, 0
&gt; IsFano(Y);
true
</PRE>
We want to show that X and Y are isomorphic. Since they are both Fano, we will work with the polytopes generated by the rays of the fans. It is then trivial to construct an isomorphism between these two polytopes; equivalently, we have an isomorphism between the fans of X and Y.
<P>
<P>
<PRE>
&gt; PX:=Polytope(Rays(Fan(X)));
&gt; PY:=Polytope(Rays(Fan(Y)));
&gt; bool,phi:=IsIsomorphic(PX,PY);
&gt; bool;
true
&gt; phi;
Mapping from: 3-dimensional toric lattice Z^3 to TorLat: N given by a rule
&gt; DefiningMatrix(phi);
[ 0 -1  0]
[-1  0  1]
[ 1 -1  0]
&gt; Image(phi,Fan(X)) eq Fan(Y);
true
</PRE>
<HR>
<H5><A NAME = "15751">IsInSupport(v,F) : TorLatElt,TorFan -&gt; BoolElt,RngIntElt</A></H5>
<BLOCKQUOTE>
Return <TT>true</TT> if and only if the support of the fan F contains
the element v of its ambient toric lattice.
In this case, the index of the first cone of F that
contains v is also returned.
</BLOCKQUOTE>
<H5><A NAME = "15752">OneSkeleton(F) : TorFan -&gt; TorFan</A></H5>
<BLOCKQUOTE>
The fan generated by the rays of the fan F.
</BLOCKQUOTE>
<H5><A NAME = "15753">Fan(F1,F2) : TorFan,TorFan -&gt; TorFan</A></H5>
<H5>F1 * F2 : TorFan,TorFan -&gt; TorFan</H5>
<H5>Fan(Q) : [TorFan] -&gt; TorFan</H5>
<H5>F ^ n : TorFan,RngIntElt -&gt; TorFan</H5>
<BLOCKQUOTE>
The nth Cartesian product of the fan F.
</BLOCKQUOTE>
<H5><A NAME = "15754">F eq G : TorFan,TorFan -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Return <TT>true</TT> if and only if the two fans F and G are equal as
objects in Magma (not simply isomorphic as fans).
</BLOCKQUOTE>
<H4><A NAME = "15755">Components of Fans</A></H4>

<P>
<P>
One can retrieve all the usual components of fans: their
cones, rays and other dimensional skeletons, and so on.
<P>
Note the novelty of `virtual' rays.
Virtual rays occur when the rays of the fan in question do not
span the ambient lattice, and so one may easily never encounter them.
They occur if and only if the underlying
toric variety is a product of C<sup> * </sup> times X for a smaller toric
variety X. If this the case, the fan is contained in a hyperplane (or
smaller linear space, if there are more factors of C<sup> * </sup>). Virtual rays
will be in the direction transversal to this hyperplane.
Thus a virtual ray is not an honest ray, but a formal object introduced to
allow C<sup> * </sup> as a toric variety and give meaning to its coordinate.
If virtual rays are not specified on creation,
then Magma will decide where to put them (later, when it needs them).


<H5><A NAME = "15756">Skeleton(F,n) : TorFan,RngIntElt -&gt; TorFan</A></H5>
<BLOCKQUOTE>
The fan generated by cones of the fan F of dimension at most
the integer n.
</BLOCKQUOTE>
<H5><A NAME = "15757">C in F : TorCon,TorFan -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Return <TT>true</TT> if and only if the cone C is one of the cones of the fan F.
</BLOCKQUOTE>
<H5><A NAME = "15758">Cones(F) : TorFan -&gt; SeqEnum</A></H5>
<BLOCKQUOTE>
A sequence of the maximal cones of the fan F.
</BLOCKQUOTE>
<H5><A NAME = "15759">Cones(F,i) : TorFan,RngIntElt -&gt; SeqEnum</A></H5>
<BLOCKQUOTE>
The sequence of all i-dimensional cones in the fan F.
</BLOCKQUOTE>
<H5><A NAME = "15760">ConesOfCodimension(F,i) : TorFan,RngIntElt -&gt; SeqEnum</A></H5>
<BLOCKQUOTE>
The sequence of all codimension i cones in the fan F.
</BLOCKQUOTE>
<H5><A NAME = "15761">MaxCones(F) : TorFan -&gt; SeqEnum</A></H5>
<BLOCKQUOTE>
The cones of maximum dimension in the fan F.
</BLOCKQUOTE>
<H5><A NAME = "15762">AllCones(F) : TorFan -&gt; SeqEnum</A></H5>
<BLOCKQUOTE>
A sequence of all the cones of the fan F.
</BLOCKQUOTE>
<H5><A NAME = "15763">Cone(F,i) : TorFan,RngIntElt -&gt; TorCon</A></H5>
<BLOCKQUOTE>
The ith cone of the sequence of maximal cones of the fan F.
</BLOCKQUOTE>
<H5><A NAME = "15764">Cone(F,S) : TorFan,[RngIntElt] -&gt; TorCon</A></H5>

<PRE>    in_fan: BoolElt                     Default: <TT>true</TT></PRE>

<PRE>    extend: BoolElt                     Default: <TT>false</TT></PRE>
<BLOCKQUOTE>
The cone C spanned by those rays in the fan F whose indices appear in S. By default C must be a cone in F. If the optional parameter <TT>extend</TT> is set to <TT>true</TT> then the smallest cone in F containing C will be found (if such a cone exists). If the parameter <TT>in_fan</TT> is set to <TT>false</TT> then the cone is forcibly created even if it failed previous tests.
</BLOCKQUOTE>
<H5><A NAME = "15765">NonSimplicialCones(F) : TorFan -&gt; SeqEnum, SeqEnum</A></H5>
<BLOCKQUOTE>
The minimum sequence of non-simplicial (i.e. non-Q-factorial) cones of the fan F. Also gives the sequences of indices of the rays of F defining each non-simplicial cone.
</BLOCKQUOTE>
<H5><A NAME = "15766">SingularCones(F) : TorFan -&gt; SeqEnum,SeqEnum</A></H5>
<BLOCKQUOTE>
A sequence containing the minimal singular cones of the fan F.
A second (parallel) sequence contains sets of the indices
of the rays that generate these cones.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "15767">Example <TT>Toric_toric-singular-cones-example (H124E8)</TT></A></H3>
The weighted projective space P(1, 2, 2, 3) has
a singular line (with stabiliser Z/2) and a singular point
(with stabiliser Z/3).
<P>
<P>
<PRE>
&gt; F := FanOfWPS([1,2,2,3]);
&gt; SingularCones(F);
[
    2-dimensional simplicial cone with 2 minimal generators:
        (-1, -1,  0),
        (-1,  1,  0),
    3-dimensional simplicial cone with 3 minimal generators:
        (-1, -1,  0),
        ( 1, -1, -1),
        ( 1,  0,  1)
]
[
    { 1, 4 },
    { 1, 2, 3 }
]
</PRE>
The two cones correspond to these two singular strata; the
point strata lying on the line are not returned, since they
can be recovered, if needed, as the cones having this
2-dimensional cone in their boundary.
<HR>
<H5><A NAME = "15768">ConeIndices(F) : TorFan -&gt; SeqEnum</A></H5>
<BLOCKQUOTE>
The sequence S of sets of integers, such that ith cone of the
fan F is generated by rays with indices S[i].
</BLOCKQUOTE>
<H5><A NAME = "15769">ConeIndices(F,C) : TorFan, TorCon -&gt; SeqEnum</A></H5>
<BLOCKQUOTE>
The sequence of integers that are the indices of the rays
which generate the cone C of the fan F.
</BLOCKQUOTE>
<H5><A NAME = "15770">ConeIntersection(F,C1,C2) : TorFan,TorCon,TorCon -&gt; TorCon</A></H5>
<BLOCKQUOTE>
The intersection of the two cones C<sub>1</sub> and C<sub>2</sub>, both of which
are members of the fan F.
(This is usually more efficient than <TT>C1 meet C2</TT> given
that the fan F exists.)
</BLOCKQUOTE>
<H5><A NAME = "15771">Face(F,C) : TorFan,TorCon -&gt; TorCon</A></H5>
<BLOCKQUOTE>
The smallest cone in the fan F which contains the cone C.
(An error is returned if there is no such cone in the fan.)
</BLOCKQUOTE>
<H5><A NAME = "15772">InnerNormals(F) : TorFan -&gt; SeqEnum</A></H5>
<H5>OuterNormals(F) : TorFan -&gt; SeqEnum</H5>
<BLOCKQUOTE>
If all the cones of the fan F are Q-Gorenstein, this returns a sequence of elements in the dual lattice where the i-th element is the inner (resp. outer) normal of the i-th cone of F.
</BLOCKQUOTE>
<H5><A NAME = "15773">DualFaceInDualFan(P,Q) : TorPol,[RngIntElt] -&gt; TorFan</A></H5>
<BLOCKQUOTE>
The cone in the toric fan dual to the polyhedron P which
is dual to the face of P determined by the sequence
of integers Q.
</BLOCKQUOTE>
<H5><A NAME = "15774">Rays(F) : TorFan -&gt; SeqEnum</A></H5>
<BLOCKQUOTE>
A sequence containing the rays of the fan F (as a sequence of primitive
lattice points on each ray).
</BLOCKQUOTE>
<H5><A NAME = "15775">Ray(F,i) : TorFan,RngIntElt -&gt; TorLatElt</A></H5>
<BLOCKQUOTE>
The ith ray of the fan F (regarded as the primitive ambient
toric lattice point on the ray).
</BLOCKQUOTE>
<H5><A NAME = "15776">AllRays(F) : TorFan -&gt; SeqEnum</A></H5>
<BLOCKQUOTE>
A sequence of the rays of the fan F (including all virtual
rays).
</BLOCKQUOTE>
<H5><A NAME = "15777">PureRays(F) : TorFan -&gt; SeqEnum</A></H5>
<BLOCKQUOTE>
A sequence of the (non-virtual) rays of the fan F.
</BLOCKQUOTE>
<H5><A NAME = "15778">PureRayIndices(F) : TorFan -&gt; SeqEnum</A></H5>
<BLOCKQUOTE>
A sequence of the indices of the non-virtual rays of the fan F
among all its rays.
</BLOCKQUOTE>
<H5><A NAME = "15779">CreateVirtualRays(S) : [TorLatElt] -&gt; SeqEnum</A></H5>
<BLOCKQUOTE>
Given a sequence S of rays of a fan, computes the remaining virtual rays  which form a basis of the lattice complementary to the linear span of S. Virtual rays are useful, for example, when calculating the coordinate ring of the toric variety associated to the fan when the variety is a product of a torus and a smaller toric variety.
</BLOCKQUOTE>
<H5><A NAME = "15780">VirtualRays(F) : TorFan -&gt; SeqEnum</A></H5>
<BLOCKQUOTE>
A sequence of the virtual rays of the fan F.
</BLOCKQUOTE>
<H5><A NAME = "15781">VirtualRayIndices(F) : TorFan -&gt; SeqEnum</A></H5>
<BLOCKQUOTE>
A sequence of the indices of the virtual rays of the fan F
among all its rays.
</BLOCKQUOTE>
<H4><A NAME = "15782">Properties of Fans</A></H4>



<H5><A NAME = "15783">Ambient(F) : TorFan -&gt; TorLat</A></H5>
<BLOCKQUOTE>
The ambient toric lattice of the toric fan F.
</BLOCKQUOTE>
<H5><A NAME = "15784">IsComplete(F) : TorFan -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Return <TT>true</TT> if and only if the toric fan F has its entire
ambient toric lattice; that is, the cones of F
cover the whole ambient space.
</BLOCKQUOTE>
<H5><A NAME = "15785">IsSingular(F) : TorFan -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Return <TT>false</TT> if and only if all the cones of the fan F are nonsingular.
</BLOCKQUOTE>
<H5><A NAME = "15786">IsNonSingular(F) : TorFan -&gt; BoolElt</A></H5>
<H5>IsNonsingular(F) : TorFan -&gt; BoolElt</H5>
<BLOCKQUOTE>
Return <TT>true</TT> if and only if all the cones of the fan F are nonsingular.
</BLOCKQUOTE>
<H5><A NAME = "15787">IsQFactorial(F) : TorFan -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Return <TT>true</TT> if and only if all the cones of the fan F are Q-factorial.
</BLOCKQUOTE>
<H5><A NAME = "15788">IsIsolated(F) : TorFan -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Return <TT>true</TT> if and only if all the cones of the fan F are isolated.
</BLOCKQUOTE>
<H5><A NAME = "15789">IsTerminal(F) : TorFan -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Return <TT>true</TT> if and only if all the cones of the fan F are terminal.
</BLOCKQUOTE>
<H5><A NAME = "15790">IsCanonical(F) : TorFan -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Return <TT>true</TT> if and only if all the cones of the fan F are canonical.
</BLOCKQUOTE>
<H5><A NAME = "15791">IsGorenstein(F) : TorFan -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Return <TT>true</TT> if and only if all the cones of the fan F are Gorenstein.
</BLOCKQUOTE>
<H5><A NAME = "15792">IsQGorenstein(F) : TorFan -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Return <TT>true</TT> if and only if all the cones of the fan F are Q-Gorenstein.
</BLOCKQUOTE>
<H4><A NAME = "15793">Maps of Fans</A></H4>



<H5><A NAME = "15794">F @ f : TorFan,Map -&gt; TorFan</A></H5>
<BLOCKQUOTE>
The image of the fan F by the map f of toric lattices.
</BLOCKQUOTE>
<H5><A NAME = "15795">SimplicialSubdivision(F) : TorFan -&gt; TorFan</A></H5>
<H5>SimplicialSubdivision(C) : TorCon -&gt; TorFan</H5>
<BLOCKQUOTE>
A toric fan that is a simplicial subdivision of the toric fan F
(or of the toric cone C).
</BLOCKQUOTE>
<HR>
<H3><A NAME = "15796">Example <TT>Toric_toric-simplicial-example (H124E9)</TT></A></H3>
If C is a cone on a square, then it has two small simplicial
subdivisions---the two sides of a standard flop, in fact.
The simplicial subdivision intrinsic selects one of these.
<P>
<P>
<PRE>
&gt; L := ToricLattice(3);
&gt; C := Cone([L| [1,0,0], [0,1,0], [0,0,1],[1,-1,1]]);
&gt; SiC := SimplicialSubdivision(C);
&gt; #Cones(SiC);
2
&gt; [ ZGenerators(B) : B in Cones(SiC) ];
[
    [
        (0, 1, 0),
        (1, -1, 1),
        (1, 0, 0)
    ],
    [
        (0, 1, 0),
        (1, -1, 1),
        (0, 0, 1)
    ]
]
</PRE>
<HR>
<H5><A NAME = "15797">IsFanMap(F1,F2) : TorFan,TorFan -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Return <TT>true</TT> if and only if the two fans F<sub>1</sub> and F<sub>2</sub> lie in the
same toric lattice, and each cone
of F<sub>1</sub> is a subcone of some cone of F<sub>2</sub>.
</BLOCKQUOTE>
<H5><A NAME = "15798">IsFanMap(F1,F2,f) : TorFan,TorFan,Map -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Return <TT>true</TT> if and only if the toric lattice map f between the
ambient toric lattices of the two fans F<sub>1</sub> and F<sub>2</sub>
maps every cone of F<sub>1</sub> into a cone of F<sub>2</sub>.
</BLOCKQUOTE>
<H5><A NAME = "15799">ResolveFanMap(F1,F2) : TorFan,TorFan -&gt; TorFan</A></H5>
<BLOCKQUOTE>
A toric fan F that resolves the identity map of lattices
restricted to the toric fans F<sub>1</sub> and F<sub>2</sub>.
The two fans F<sub>i</sub> are expected to lie in the same lattice and
to have the same support, and the resulting toric fan F
gives a common refinement of them; in particular, F
will admit a fan map into each of the F<sub>i</sub>.
(If the F<sub>i</sub> have different supports, the fan F will
be supported on their intersection and will only refine this
part of each of them. Geometrically speaking, this will
produce a non-proper resolution.)
</BLOCKQUOTE>
<H5><A NAME = "15800">Resolution(F) : TorFan -&gt; TorFan</A></H5>

<PRE>    deterministic: BoolElt              Default: <TT>true</TT></PRE>
<BLOCKQUOTE>
 A resolution of singularities of the fan F. If the optional parameter <TT>deterministic</TT> is set to <TT>false</TT> then a potentially much faster non-deterministic algorithm will be used to calculate the resolution.
</BLOCKQUOTE>
<H5><A NAME = "15801">Terminalisation(F) : TorFan -&gt; TorFan</A></H5>
<BLOCKQUOTE>
A Q-factorial terminal refinement of the fan F.
</BLOCKQUOTE>
<H5><A NAME = "15802">Canonicalisation(F) : TorFan -&gt; TorFan</A></H5>
<BLOCKQUOTE>
A Q-factorial canonical refinement of the fan F.
</BLOCKQUOTE>
<PRE></PRE> <A  HREF = "text1406.htm">[Next]</A><A  HREF = "text1404.htm">[Prev]</A> <A  HREF = "text1406.htm">[Right]</A> <A  HREF = "text1404.htm">[Left]</A> <A  HREF = "text1403.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<br><small>Version: V2.22 of <I>
Thu Jun  9 16:37:49 EST 2016
</I></small>
</body></html>