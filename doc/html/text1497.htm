<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <link rel='stylesheet' href='help.css' type='text/css'>
  <TITLE>Chabauty's Method</TITLE>
</head>
<body BGCOLOR="#FFFFFF">

 <A  HREF = "text1498.htm">[Next]</A><A  HREF = "text1496.htm">[Prev]</A> <A  HREF = "text1498.htm">[Right]</A> <A  HREF = "text1496.htm">[Left]</A> <A  HREF = "text1483.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<PRE></PRE><H3><A NAME = "16999">Chabauty's Method</A></H3>

<P>
<P>
This is a method for finding the rational points on a curve C
of genus at least 2, that applies when the Mordell-Weil
group of Jac(C) has rank less than the genus of C.
It involves doing local calculations at some prime 
where C has good reduction. 
<P>
For (hyperelliptic) curves of genus 2 over Q, two separate 
routines are available in Magma.
In the older one, the user specifies the prime, and the results
usually do not determine the set of rational points precisely.  
In the new implementation, which is far more powerful, Chabauty 
calculations are combined with a "Mordell-Weil sieve" which 
puts together information obtained using many different primes, 
to determine precisely the set of rational points on the curve.  
However, this routine does not apply to curves with no rational
points, in fact one rational point must be known, as this plays 
a role in the algorithm.
<P>
Both routines are applicable only when the Chabauty condition holds:
for a genus 2 curve, the Jacobian must have Mordell-Weil rank 1.
In addition a routine <TT>Chabauty0</TT> is provided for the easy case
where the Jacobian has rank 0.
<P>
<P>
<P>
<I>Brief description of Chabauty's method:</I> 
Under the assumption that the rank of J = Jac(C) is strictly less
than the genus of C,
the closure V of J(Q) in J(Q<sub>p</sub>) (in the p-adic topology)
can be described as the locus where certain power series vanish.
The dimension of V is at most the rank of J(Q). 
The image of C in J (under a natural embedding) will intersect V
in a finite set, and this set must contain C(Q).
By examining the power series that define this finite intersection, 
one obtains upper bounds for the number of points on C(Q) 
in each congruence class modulo p (or any power of p).


<H5><A NAME = "17000">Chabauty0(J) : JacHyp -&gt; SetIndx</A></H5>
<BLOCKQUOTE>
Given the Jacobian of a hyperelliptic curve C over Q, 
the function finds
all rational points on C, 
under the assumption that J(Q) has rank zero. 
<P>
The assumption is not checked. When it does not hold, 
the function computes a subset of C(Q) corresponding 
(in some sense) to the torsion in J(Q).
</BLOCKQUOTE>
<H5><A NAME = "17001">Chabauty(P : ptC) : JacHypPt -&gt; SetIndx</A></H5>

<PRE>    ptC: Pt                             Default: </PRE>
<BLOCKQUOTE>
For a curve C of genus 2 over Q, this uses Chabauty's method combined with 
the Mordell-Weil sieve to find rational points on C.
The argument P is a rational point of infinite order on the Jacobian J of C.
The function returns the set of points on C whose images in J(Q) lie in
the saturation in J(Q) of the group generated by P.
In particular when J(Q) has rank 1, all rational points on C are returned.
<P>
The algorithm makes use of one rational point on the curve.  Such a point may be
supplied as the optional argument <TT>ptC</TT>; otherwise, one is found by searching.
In particular, this routine cannot be used to show that a curve has no rational points.
</BLOCKQUOTE>
<H5><A NAME = "17002">Chabauty(P, p: Precision) : JacHypPt, RngIntElt -&gt; SetIndx</A></H5>

<PRE>    Precision: RngIntElt                Default: 5</PRE>
<BLOCKQUOTE>
Given a point on the Jacobian of a hyperelliptic curve C over Q, 
the function uses Chabauty's method (at the prime p) 
to bound the number of rational points on the curve C, 
The curve must have good reduction at the prime p, 
and the point P should generate a subgroup of index coprime to p
in J(Q)/J<sub>tors</sub>(Q). 
The algorithm assumes that C is in the simplified form  
y<sup>2</sup> = f(x), where f has integral coefficients.
<P>
The function returns an indexed set of tuples &lt; (x, z, v, k) &gt;
such that there are at most k pairs of rational points on C 
whose image in P<sup>1</sup> under the x-coordinate map are congruent to 
(x:z) modulo p<sup>v</sup>, and such that the only rational points on C
outside these congruences classes are Weierstrass points.  
<P>
If the optional parameter <TT>Precision</TT> is supplied, then in the returned 
data each of the v's will be greater than or equal to <TT>Precision</TT>. 
(This might take some time because the algorithm is not optimised for this.)
</BLOCKQUOTE>
<HR>
<H3><A NAME = "17003">Example <TT>CrvHyp_chabauty-method1 (H131E38)</TT></A></H3>
In this example, which continues Example <A  HREF = "text1495.htm#16978">H131E30</A>, we use
<P>
both implementations of Chabauty to prove that the curve y<sup>2</sup>=x<sup>6</sup> + x<sup>2</sup> + 2 
has only the obvious six rational points.
<P>
<P>
<PRE>
&gt; _&lt;x&gt; := PolynomialRing(Rationals());
&gt; C := HyperellipticCurve(x^6+x^2+2);
&gt; ptsC := Points(C : Bound:=1000); ptsC;
{@ (1 : -1 : 0), (1 : 1 : 0), (-1 : -2 : 1), 
   (-1 : 2 : 1), (1 : -2 : 1), (1 : 2 : 1) @}
&gt; J := Jacobian(C);
&gt; RankBound(J);
1
</PRE>
So the Jacobian has rank at most 1.
Next we ask whether any of the points on C give us
points of infinite order on J.
<P>
<P>
<PRE>
&gt; PJ1 := J! [ ptsC[3], ptsC[1] ]; 
&gt; Order(PJ1);
8
&gt; PJ2 := J! [ ptsC[5], ptsC[1] ]; 
&gt; Order(PJ2);
0
</PRE>
This means PJ2 has infinite order in J(Q). 
In Example <A  HREF = "text1495.htm#16978">H131E30</A> we proved that PJ2 is not divisible in J(Q).
Since J(Q) has rank 1, PJ2 is a generator of J(Q)/J(Q)<sub>tors</sub>.
<P>
<P>
<PRE>
&gt; all_pts := Chabauty(PJ2); all_pts;
{ (1 : -2 : 1), (-1 : -2 : 1), (1 : 2 : 1), 
  (1 : -1 : 0), (1 : 1 : 0), (-1 : 2 : 1) }
</PRE>
It still finds all points even if we do not give a generator for the free part:
a "saturation" step is built in.  Naturally, this takes slightly longer.
<P>
<P>
<PRE>
&gt; okay := all_pts eq Chabauty(12*PJ2);
&gt; assert okay; // Check that it is okay
</PRE>
So we find that we already had the full set of rational points on C.
We could have reached the same conclusion using the other implementation
of Chabauty, where we specify that the method be applied at the prime 3
(the most natural choice, since it is the smallest prime of good reduction).
<P>
<P>
<PRE>
&gt; BadPrimes(C);
[ 2, 7 ]
&gt; Chabauty(PJ2, 3);
{@ &lt;1, 1, 4, 1&gt;, &lt;80, 1, 4, 1&gt;, &lt;1, 0, 4, 1&gt; @}
</PRE>
This tells us that there are at most 3 pairs of rational points on C, 
apart from Weierstrass points. 
In fact, one can easily check that there are no rational Weierstrass points.
Therefore, the 6 known points are the only rational points on C.
<HR>
<H3><A NAME = "17004">Example <TT>CrvHyp_chabauty-method2 (H131E39)</TT></A></H3>
In this example we show that there are precisely 6 rational points 
on the curve y<sup>2</sup> = x<sup>6</sup> + 8.
<P>
<P>
<PRE>
&gt; _&lt;x&gt; := PolynomialRing(Rationals());
&gt; C := HyperellipticCurve(x^6+8);
&gt; ptsC := Points(C : Bound:= 1000); ptsC;
{@ (1 : -1 : 0), (1 : 1 : 0), (-1 : -3 : 1),
   (-1 : 3 : 1), (1 : -3 : 1), (1 : 3 : 1) @}
&gt; J := Jacobian(C);                
&gt; PJ := J! [ ptsC[5], ptsC[1]];
&gt; Order(PJ); 
0
&gt; RankBound(J);
1
</PRE>
This shows that J(Q) has rank 1, and PJ has infinite order.
Now we check that PJ generates J(Q)/J<sub>tors</sub>(Q), although this is not necessary. 
(For more explanation, see the similar calculation in Example <A  HREF = "text1495.htm#16978">H131E30</A>).
<P>
<P>
<PRE>
&gt; heightconst := HeightConstant(J : Effort:=2, Factor); 
&gt; LogarithmicBound := Height(PJ) + heightconst;  // Bound on h(Q)
&gt; AbsoluteBound := Ceiling(Exp(LogarithmicBound));
&gt; PtsUpToAbsBound := Points(J : Bound:=AbsoluteBound );  
&gt; ReducedBasis([ pt : pt in PtsUpToAbsBound ]);
[ (x^2 - x + 1, 3, 2) ]
[0.326617338771488428260076768590]
&gt; Height(PJ);
0.326617338771488428260076768590
</PRE>
This shows there are no points in J(Q) with canonical height
smaller than that of PJ, so PJ is a generator modulo torsion.
<P>
<P>
<PRE>
&gt; all_pts := Chabauty(PJ : ptC:=ptsC[1]); all_pts;
{@ (1 : -1 : 0), (-1 : -3 : 1), (1 : 3 : 1), 
   (-1 : 3 : 1), (1 : -3 : 1), (1 : 1 : 0) @}
&gt; assert all_pts eq Chabauty(2*PJ : ptC:=ptsC[1]);
</PRE>
<HR>
<H3><A NAME = "17005">Example <TT>CrvHyp_chabauty-method4 (H131E40)</TT></A></H3>
In Example <A  HREF = "text1495.htm#16991">H131E32</A> (in the section on 2-Selmer groups)
we found a curve of rank 2. Although Chabauty's method cannot be applied
to get information about the full set of rational points on C, we can still
find all points on C whose images on J lie in a given subgroup of rank 1.
<P>
<P>
<PRE>
&gt; _&lt;x&gt; := PolynomialRing(Rationals());
&gt; C := HyperellipticCurve( x*(x+1344^2)*(x+10815^2)*(x+5406^2)*(x+2700^2) );
&gt; J := Jacobian(C);
&gt; ptsC := Points(C : Bound := 10^6); ptsC;
{@ (1 : 0 : 0), (0 : 0 : 1), (43264 : -44828581639628800 : 1), 
   (43264 : 44828581639628800 : 1) @}
&gt; PJ := J! [ ptsC[3], ptsC[1] ];
&gt; Order(PJ);
0
</PRE>
Now consider the map from C into J that sends P to P - <TT>ptsC[1]</TT>.
We call Chabauty to find all points P &isin;C(Q) whose image lies in the
saturated subgroup spanned by <TT>PJ</TT>.
<P>
<P>
<PRE>
&gt; pts := Chabauty(PJ : ptC:=ptsC[1]); pts;
{ (1 : 0 : 0), (0 : 0 : 1), (-29224836 : 0 : 1), 
  (-7290000 : 0 : 1), (-1806336 : 0 : 1), (-116964225 : 0 : 1), 
  (43264 : 44828581639628800 : 1), (43264 : -44828581639628800 : 1) }
&gt; assert #pts eq 8;
</PRE>
<P>
<HR>
<H3><A NAME = "17006">Example <TT>CrvHyp_chabauty-method3 (H131E41)</TT></A></H3>
We find all rational points on C : y<sup>2</sup> = x<sup>6</sup> + 1.  There are only finitely 
many rational points on the Jac(C) which means we may use <TT>Chabauty0</TT>.
<P>
<P>
<PRE>
&gt; _&lt;x&gt; := PolynomialRing(Rationals());
&gt; C := HyperellipticCurve(x^6+1);
&gt; J := Jacobian(C);
&gt; RankBound(J);
0
&gt; Chabauty0(J);
{@ (1 : -1 : 0), (1 : 1 : 0), (0 : 1 : 1), (0 : -1 : 1) @}
</PRE>
The rank bound was obtained by computing the 2-Selmer group, which involved 
class group and unit computations in the fields given by roots of x<sup>6</sup> + 1.
<P>
vskip4pt
For this curve, there is an easier approach.  There is an obvious map from C
to the elliptic curve y<sup>2</sup> = x<sup>3</sup> + 1, which happens to have rank 0 over Q.
To define the map, note that C lives in a weighted projective space where Y
has weight 3.
<P>
<P>
<PRE>
&gt; E := EllipticCurve([0,1]);
&gt; Pr2&lt;X,Y,Z&gt; := Ambient(C);
&gt; CtoE := map&lt; C -&gt; E | [X^2*Z,Y,Z^3] &gt;;
</PRE>
The map is well-defined (Magma checks this by default).
Now we find the rational points on E.
<P>
<P>
<PRE>
&gt; Rank(E);
0
&gt; #TorsionSubgroup(E);
6
&gt; ptsE := Points(E : Bound:=100 ); ptsE;
{@ (0 : 1 : 0), (-1 : 0 : 1), (0 : 1 : 1), 
   (0 : -1 : 1), (2 : 3 : 1), (2 : -3 : 1) @}
</PRE>
So, these are all the rational points on E.
We can see with the naked eye that only those with X=0
pull back to rational points on C, giving us
the same six points on C that we found before.
<P>
We may also ask Magma to pull them back:
<P>
<P>
<PRE>
&gt; for P in ptsE do
&gt;     preimageofP := P @@ CtoE;
&gt;     Points(preimageofP);
&gt; end for;
{@ (1 : -1 : 0), (1 : 1 : 0) @}
{@ @}
{@ (0 : 1 : 1) @}
{@ (0 : -1 : 1) @}
{@ @}
{@ @}
</PRE>
<HR>
<PRE></PRE> <A  HREF = "text1498.htm">[Next]</A><A  HREF = "text1496.htm">[Prev]</A> <A  HREF = "text1498.htm">[Right]</A> <A  HREF = "text1496.htm">[Left]</A> <A  HREF = "text1483.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<br><small>Version: V2.22 of <I>
Thu Jun  9 16:37:49 EST 2016
</I></small>
</body></html>