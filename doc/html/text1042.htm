<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <link rel='stylesheet' href='help.css' type='text/css'>
  <TITLE>Element Operations</TITLE>
</head>
<body BGCOLOR="#FFFFFF">

 <A  HREF = "text1043.htm">[Next]</A><A  HREF = "text1041.htm">[Prev]</A> <A  HREF = "text1043.htm">[Right]</A> <A  HREF = "text1041.htm">[Left]</A> <A  HREF = "text1039.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<PRE></PRE><H3><A NAME = "11756">Element Operations</A></H3>




<H5>Subsections</H5>
<UL>
<LI> <A  HREF = "text1042.htm#11757">Arithmetic</A>
<LI> <A  HREF = "text1042.htm#11758">Predicates and Booleans</A>
<LI> <A  HREF = "text1042.htm#11769">Accessing Class Functions</A>
<LI> <A  HREF = "text1042.htm#11776">Conjugation of Class Functions</A>
<LI> <A  HREF = "text1042.htm#11783">Functions Returning a Scalar</A>
<LI> <A  HREF = "text1042.htm#11790">The Schur Index</A>
<LI> <A  HREF = "text1042.htm#11797">Attribute</A>
<LI> <A  HREF = "text1042.htm#11799">Induction, Restriction and Lifting</A>
<LI> <A  HREF = "text1042.htm#11804">Symmetrization</A>
<LI> <A  HREF = "text1042.htm#11811">Permutation Character</A>
<LI> <A  HREF = "text1042.htm#11814">Composition and Decomposition</A>
<LI> <A  HREF = "text1042.htm#11817">Finding Irreducibles</A>
<LI> <A  HREF = "text1042.htm#11821">Brauer Characters</A>
</UL>
<H4><A NAME = "11757">Arithmetic</A></H4>

<P>
<P>
<P>
<P>
In the list of arithmetic operations below x and y denote
class functions in the same ring, and a denotes a scalar, which is any element
coercible into a cyclotomic field. Also, j denotes an integer.


<H5>+ y : AlgChtrElt -&gt; AlgChtrElt</H5>

<H5>- y : AlgChtrElt -&gt; AlgChtrElt</H5><P>

<H5>x + y : AlgChtrElt, AlgChtrElt -&gt; AlgChtrElt</H5>

<H5>x - y : AlgChtrElt, AlgChtrElt -&gt; AlgChtrElt</H5>

<H5>x * y : AlgChtrElt, AlgChtrElt -&gt; AlgChtrElt</H5><P>

<H5>a * x : FldCycElt, AlgChtrElt -&gt; AlgChtrElt</H5>

<H5>x ^ j : AlgChtrElt, RngIntElt -&gt; AlgChtrElt</H5><P>


<H4><A NAME = "11758">Predicates and Booleans</A></H4>

<P>
<P>
The following Boolean-valued functions are available.
Note that with the exception of <TT>in</TT>, <TT>notin</TT>,
<TT>IsReal</TT> and <TT>IsFaithful</TT>,
these functions use the table of irreducible characters,
which will be created if it is not yet available.


<H5>a in F : FldFunElt, FldFun -&gt; BoolElt</H5>

<H5>a notin F : FldFunElt, FldFun -&gt; BoolElt</H5><P>

<H5>x eq y : AlgChtrElt, AlgChtrElt -&gt; BoolElt</H5>

<H5>x ne y : AlgChtrElt, AlgChtrElt -&gt; BoolElt</H5><P>




<H5>IsOne(x) : AlgChtrElt  -&gt; BoolElt</H5>

<H5>IsMinusOne(x) : AlgChtrElt  -&gt; BoolElt</H5>

<H5>IsZero(x) : AlgChtrElt  -&gt; BoolElt</H5><P>




<H5><A NAME = "11759">x in y : AlgChtrElt, AlgChtrElt -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if the inner product of class functions x and y is
non-zero, otherwise <TT>false</TT>. If x is irreducible
and y is a character, this tests whether or
not x is a constituent of y.
</BLOCKQUOTE>
<H5><A NAME = "11760">x notin y : AlgChtrElt, AlgChtrElt -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if the inner product of class functions x and y is
zero, otherwise <TT>false</TT>. If x is irreducible
and y is a character, this tests whether or
not x is not a constituent of y.
Returns <TT>true</TT> if the character x is not a constituent of 
the character y, otherwise <TT>false</TT>.
</BLOCKQUOTE>
<H5><A NAME = "11761">IsCharacter(x) : AlgChtrElt -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if the class function x is a character, otherwise <TT>false</TT>. A class function
is a character if and only if all inner products with the irreducible
characters are non-negative integers.
</BLOCKQUOTE>
<H5><A NAME = "11762">IsGeneralizedCharacter(x) : AlgChtrElt -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if the class function x is a generalized
character, otherwise <TT>false</TT>.
A class function is a generalized character if and only if all inner products
with the irreducible characters are integers.
</BLOCKQUOTE>
<H5><A NAME = "11763">IsIrreducible(x) : AlgChtrElt -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if the character x is an irreducible
character, otherwise <TT>false</TT>.
</BLOCKQUOTE>
<H5><A NAME = "11764">IsLinear(x) : AlgChtrElt -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if the character x is a linear character, otherwise <TT>false</TT>.
</BLOCKQUOTE>
<H5><A NAME = "11765">IsFaithful(x) : AlgChtrElt -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if the character x is faithful, i.e. has trivial kernel, otherwise <TT>false</TT>.
</BLOCKQUOTE>
<H5><A NAME = "11766">IsReal(x) : AlgChtrElt -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if the character x is a real character, i.e.
takes real values on all of the classes of G, otherwise <TT>false</TT>.
</BLOCKQUOTE>
<H5><A NAME = "11767">IsPermutationCharacter(c) : AlgChtrElt -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Test if a character c of G is a virtual permutation character, 
that is C[X] - C[Y] for some G-sets X and Y. (The implementation 
relies on <TT>BurnsideCokernel</TT>, and does not compute the subgroup lattice.)
</BLOCKQUOTE>
<HR>
<H3><A NAME = "11768">Example <TT>Chtr_grp-ispermutationcharacter (H97E3)</TT></A></H3>
In a symmetric group S<sub>n</sub> every character is a virtual permutation character,
but not in the quaternion group Q<sub>8</sub>.
<P>
<P>
<PRE>
&gt; C:=CharacterTable(Group("S5"));
&gt; [IsPermutationCharacter(c): c in C];
[ true, true, true, true, true, true, true ]
&gt; C:=CharacterTable(Group("Q8"));
&gt; [IsPermutationCharacter(c): c in C];
[ true, true, true, true, false ]
</PRE>
<HR>
<H4><A NAME = "11769">Accessing Class Functions</A></H4>

<P>
<P>
In this subsection T is a character table, and x is any class function.
A character table is an enumerated sequence of characters that has a 
special print function attached.
In particular, its entries can be
accessed with the ordinary sequence indexing operations.


<H5><A NAME = "11770">T[i] : TabChtr, RngIntElt -&gt; AlgChtrElt</A></H5>
<BLOCKQUOTE>
Given the table T of ordinary characters of G, 
return the i-th character of G, where i is an 
integer in the range [1...k].
</BLOCKQUOTE>
<H5><A NAME = "11771">T[i][j] : TabChtr, RngIntElt, RngIntElt -&gt; FldCycElt</A></H5>
<BLOCKQUOTE>
The value of the i-th irreducible character 
(from the character table T) on the j-th 
conjugacy class of G.
</BLOCKQUOTE>
<H5><A NAME = "11772"># T : SeqEnum -&gt; RngIntElt</A></H5>
<BLOCKQUOTE>
Given a character table T (or any sequence of characters), return
the number of entries.
</BLOCKQUOTE>
<H5><A NAME = "11773">x(g) : AlgChtrElt, GrpElt -&gt; FldCycElt</A></H5>
<H5>g @ x : GrpElt, AlgChtrElt -&gt; FldCycElt</H5>
<BLOCKQUOTE>
The value of the class function x on the element 
g of G.
</BLOCKQUOTE>
<H5><A NAME = "11774">x[i] : AlgChtrElt, RngIntElt -&gt; FldCycElt</A></H5>
<BLOCKQUOTE>
The value of the class function x on the i-th conjugacy class of G.
</BLOCKQUOTE>
<H5><A NAME = "11775"># x : AlgChtrElt -&gt; RngIntElt</A></H5>
<BLOCKQUOTE>
Given a class function x on G return its length (which equals the number
of conjugacy classes of the group G).
</BLOCKQUOTE>
<H4><A NAME = "11776">Conjugation of Class Functions</A></H4>



<H5><A NAME = "11777">x ^ g : AlgChtrElt, GrpElt -&gt; AlgChtrElt</A></H5>
<BLOCKQUOTE>
Given a class function x on a normal subgroup N
of the group G, and an element g of G, construct
the conjugate class function x<sup>g</sup> of x which is
defined as follows:
x<sup>g</sup>(n) = x( g<sup> - 1</sup>ng), for all n in N.
</BLOCKQUOTE>
<H5><A NAME = "11778">x ^ H : AlgChtrElt, Grp -&gt; { AlgChtrElt }</A></H5>
<BLOCKQUOTE>
Given a class function x on a normal subgroup N
of the group G, and a subgroup H of G, construct
the sequence of conjugates of x under the action of
the subgroup H. The action of an element of H on x
is that defined in the previous function.
</BLOCKQUOTE>
<H5><A NAME = "11779">GaloisConjugate(x, j) : AlgChtrElt, RngIntElt -&gt; AlgChtrElt</A></H5>
<BLOCKQUOTE>
Let Q(x) be the subfield of Qm generated by Q and
the values of the G-character x. This function
returns the Galois conjugate x<sup>j</sup> of x under the
action of the element of the Galois group
Gal(Q(x)/Q) determined by the integer j. The 
integer j must be coprime to m.
</BLOCKQUOTE>
<H5><A NAME = "11780">GaloisOrbit(x) : AlgChtrElt -&gt; { AlgChtrElt }</A></H5>
<BLOCKQUOTE>
Let Q(x) be the subfield of Qm generated by Q and
the values of the G-character x. This function
returns the sequence of Galois conjugates of x 
under the action of the Galois group  Gal(Q(x)/Q).
</BLOCKQUOTE>
<H5><A NAME = "11781">IsConjugate(x, y) : AlgChtrElt, AlgChtrElt -&gt; BoolElt, RngIntElt</A></H5>
<BLOCKQUOTE>
Determine if x and y are galois conjugate characters. Return <TT>false</TT> if not.
If so, return <TT>true</TT>, and j such that texttt{GaloisConjugate(x, j)} is y.
</BLOCKQUOTE>
<H5><A NAME = "11782">ClassPowerCharacter(x, j) : AlgChtrElt, RngIntElt -&gt; AlgChtrElt</A></H5>
<BLOCKQUOTE>
Given a class function x on the group G and a 
positive integer j, construct the class function
x<sup>j</sup> which is defined as follows:
x<sup>j</sup>(g) = x(g<sup>j</sup>).
</BLOCKQUOTE>
<H4><A NAME = "11783">Functions Returning a Scalar</A></H4>



<H5><A NAME = "11784">Degree(x) : AlgChtrElt -&gt; RngIntElt</A></H5>
<BLOCKQUOTE>
The degree of the class function x, i.e. the value of x
on the identity element of G.
</BLOCKQUOTE>
<H5><A NAME = "11785">InnerProduct(x, y) : AlgChtrElt, AlgChtrElt -&gt; FldCycElt</A></H5>
<BLOCKQUOTE>
The inner product of the class functions x and y,
where x and y are class functions belonging to 
the same character ring.
</BLOCKQUOTE>
<H5><A NAME = "11786">Order(x) : AlgChtrElt -&gt; RngIntElt</A></H5>
<BLOCKQUOTE>
Given a linear character of the group G, 
determine the order of x as an element of the 
group of linear characters of G.
</BLOCKQUOTE>
<H5><A NAME = "11787">Norm(x) : AlgChtrElt -&gt; FldCycElt</A></H5>
<BLOCKQUOTE>
Norm of the class function x (which is the inner product with itself).
</BLOCKQUOTE>
<H5><A NAME = "11788">Schur(x, k) : AlgChtrElt, RngIntElt -&gt; FldCycElt</A></H5>
<H5>Indicator(x) : AlgChtrElt -&gt; FldCycElt</H5>
<BLOCKQUOTE>
Given class function x and a positive
integer k, return the generalised Frobenius--Schur
indicator which is defined as follows: 
Suppose g is some element of G, and set
      T<sub>k</sub>(g) = |{ h&isin;G | h<sup>k</sup> = g}|. 
The value of <TT>Schur(x, k)</TT> is the coefficient 
a<sub>x</sub> in the expression
   T<sub>k</sub> = &sum;<sub> x&isin;Irr(G)</sub> a<sub>x</sub> x.
<P>
The call <TT>Indicator(x)</TT> is equivalent to <TT>Schur(x,2)</TT>.
</BLOCKQUOTE>
<H5><A NAME = "11789">StructureConstant(G, i, j, k) : Grp, RngIntElt, RngIntElt, RngIntElt -&gt; RngIntElt</A></H5>
<BLOCKQUOTE>
The structure constant a<sub>i, j, k</sub> for the centre
of the group algebra of the group G. If K<sub>i</sub> is the 
formal sum of the elements of the i-th conjugacy 
class, a<sub>i, j, k</sub> is defined by the equation
K<sub>i</sub> * K<sub>j</sub> = &sum;<sub>k</sub> a<sub>i, j, k</sub> * K<sub>k</sub>.
</BLOCKQUOTE>
<H4><A NAME = "11790">The Schur Index</A></H4>

<P>
<P>
Magma incorporates functions for computing the Schur index of an
ordinary irreducible character over various number fields and local fields.
The routines below are all based on the function <TT>SchurIndices(x)</TT>,
which computes the Schur Indices of the given character over all the
completions of the rationals.
<P>
The algorithm is based on calculations with characters, groups and fields,
and does not compute representations. The character table methods of S2 and
S3 of <A  HREF = "text1038.htm#bib_Feit-Schur-indices">[Fei83]</A> are used as much as possible to avoid
calculations in the group.
<P>
The algorithm was devised by Gabi Nebe and Bill Unger, with code written by
Bill Unger. The extension to compute a Schur index over a number field was
written by Claus Fieker.


<P>
The construction of the previous example is used in the following two
intrinsics.
<H5><A NAME = "11791">SchurIndex(x) : AlgChtrElt -&gt; RngIntElt</A></H5>
<H5>SchurIndex(x, Q) : AlgChtrElt, FldRat -&gt; RngIntElt</H5>
<H5>SchurIndex(x, F) : AlgChtrElt, FldAlg -&gt; RngIntElt</H5>
<BLOCKQUOTE>
The Schur index of the character x over the given field. When no
field is given, the Schur index over the rationals is returned.
The character x must be a complex irreducible character. The field F
must be an absolute number field.
</BLOCKQUOTE>
<H5><A NAME = "11792">SchurIndices(x) : AlgChtrElt -&gt; SeqEnum</A></H5>
<H5>SchurIndices(x, Q) : AlgChtrElt, FldRat -&gt; SeqEnum</H5>
<H5>SchurIndices(x, F) : AlgChtrElt, FldAlg -&gt; SeqEnum</H5>
<H5>SchurIndices(C, s, F) : FldAlg, SeqEnum, FldAlg -&gt; SeqEnum</H5>
<BLOCKQUOTE>
Compute the Schur indices of the character x over the completions of the given
field. The character x must be a complex irreducible character. The field F
must be an absolute number field.
When no field is specified the rational field is assumed.
The last form takes the character field, C, and the output from
<TT>SchurIndices(x)</TT>, s, as well as a number field.
This is sufficient to compute the Schur indices
over the number field without repeating group and character computations
when a number of fields are being considered for one character.
<P>
The return value is a sequence of pairs. Each pair gives a completion at
which the Schur index is not 1, followed by the Schur index  over the complete
field. For the rational field, a completion is specified by an integer.
The integer zero specifies the archimedean completion (the real numbers),
while a prime p specifies the p-adic field Q<sub>p</sub>.
When a number field is given, the completions are specified by a place of the
field, an object of type <TT>PlcNumElt</TT>.
<P>
If the character has Schur index 1 over the given field the return value will
be an empty sequence. Otherwise the Schur index over the given field is the
least common multiple of the second entries of the tuples returned.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "11793">Example <TT>Chtr_SchurIndex (H97E4)</TT></A></H3>
We first look at the faithful irreducible character of the Dihedral
group of order 8. It has Schur index 1.
<P>
<P>
<PRE>
&gt; T := CharacterTable(SmallGroup(8, 3));
&gt; T[5];
( 2, -2, 0, 0, 0 )
&gt; SchurIndex(T[5]);
1
&gt; SchurIndices(T[5]);
[]
</PRE>
The corresponding character of the quaternion group of order 8 
has non-trivial Schur index.
<P>
<P>
<PRE>
&gt; T := CharacterTable(SmallGroup(8, 4));
&gt; T[5];
( 2, -2, 0, 0, 0 )
&gt; SchurIndex(T[5]);
2
&gt; SchurIndices(T[5]);
[ &lt;0, 2&gt;, &lt;2, 2&gt; ]
</PRE>
The Schur index is 2 over the real numbers and Q<sub>2</sub>. For all odd primes p,
the Schur index over Q<sub>p</sub> is 1.
We look at the Schur index of this character over some number fields.
First we look at some cyclotomic fields.
<P>
<P>
<PRE>
&gt; [SchurIndex(T[5], CyclotomicField(n)):n in [3..20]];
[ 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1 ]
&gt; SchurIndices(T[5], CyclotomicField(7));
[ &lt;Place at Prime Ideal
Two element generators:
  [2, 0, 0, 0, 0, 0]
  [1, 1, 0, 1, 0, 0], 2&gt;, &lt;Place at Prime Ideal
Two element generators:
  [2, 0, 0, 0, 0, 0]
  [1, 0, 1, 1, 0, 0], 2&gt; ]
</PRE>
The cyclotomic field of order 7 gives Schur index 2. An archimedean
completion of this field is necessarily the field of complex numbers,
hence no infinite places give Schur index greater than 1. There are
now two 2-adic completions which give Schur index 2.
<P>
<P>
<PRE>
&gt; P&lt;t&gt; := PolynomialRing(Rationals());
&gt; F := ext&lt;Rationals()|t^3-2&gt;;
&gt; SchurIndex(T[5], F);
2
&gt; SchurIndices(T[5], F);
[ &lt;1st place at infinity, 2&gt;, &lt;Place at Prime Ideal
Two element generators:
  [2, 0, 0]
  [0, 1, 0], 2&gt; ]
</PRE>
For the non-normal field F, one archimedean completion is real, the other
complex. Thus the real field features in the output of <TT>SchurIndices</TT>,
along with the 2-adic completion.
<HR>
<H3><A NAME = "11794">Example <TT>Chtr_recipe-for-schur-index (H97E5)</TT></A></H3>
We will use a general construction for a character with given Schur index
over the rationals to construct a character with Schur index 6.
Given an integer n ge1, we select a prime p such that p = kn + 1
where k and n are coprime. We take an integer a such that a has order
n modulo p. We then consider the metacyclic group
G = &lt; &lt;x, y|x<sup>n<sup>2</sup></sup>, y<sup>p</sup>, y<sup>x</sup> = y<sup>a</sup> &gt;.
The order of G is n<sup>2</sup>p. The subgroup of G generated by x<sup>n</sup> and y
is cyclic, normal and self-centralizing in G with order np.
If &lambda; is any faithful linear character of this subgroup,
then &lambda;<sup>G</sup> is an irreducible character of G with Schur index n over
the rational field. The correctness of this construction is proved in
Lemma 3 of <A  HREF = "text1038.htm#bib_Turull2001">[Tur01]</A>.
<P>
We construct G in two stages. First as a finitely presented group as
described above.
Then we convert to a PC-presentation for further computations. We take
n=6, p=7 and a = 3.
<P>
<P>
<PRE>
&gt; G1 := Group&lt;x,y|x^36, y^7, y^x = y^3&gt;;
&gt; G, f := SolubleQuotient(G1, 36*7);
&gt; x := f(G1.1); y := f(G1.2);
&gt; C := sub&lt;G|x^6,y&gt;;
&gt; IsCyclic(C);
true
&gt; IsNormal(G, C);
true
&gt; Centralizer(G,C) eq C;
true
&gt; exists(l){l:l in LinearCharacters(C)|IsFaithful(l)};
true;
&gt; c := Induction(l, G);
&gt; IsIrreducible(c);
true
&gt; Degree(c);
6
&gt; CharacterField(c);
Cyclotomic Field of order 3 and degree 2 in sparse
representation
&gt; SchurIndex(c);
6
</PRE>
<HR>
<H5><A NAME = "11795">SchurIndexGroup(n: parameters) : RngIntElt -&gt; GrpPC</A></H5>

<PRE>    Prime: RngIntElt                    Default: </PRE>
<BLOCKQUOTE>
Return a group having a faithful character with Schur index n over the
rational field. The construction used is as in the previous example.
The parameter <TT>Prime</TT> may be used to supply the prime p. (The necessary
conditions on p are not checked. If these conditions are not met, an error
is possible.)
If <TT>Prime</TT> is not set, then the least prime meeting the conditions is used.
</BLOCKQUOTE>
<H5><A NAME = "11796">CharacterWithSchurIndex(n: parameters) : RngIntElt -&gt; AlgChtrElt. GrpPC</A></H5>

<PRE>    Prime: RngIntElt                    Default: </PRE>
<BLOCKQUOTE>
Return a character with Schur index n over the
rational field. The construction used is as in the previous example.
The second return value is the group of the character, equal to
<TT>SchurIndexGroup(n)</TT>.
The parameter <TT>Prime</TT> is as for <TT>SchurIndexGroup</TT>.
</BLOCKQUOTE>
<H4><A NAME = "11797">Attribute</A></H4>



<H5><A NAME = "11798">AssertAttribute(x, "IsCharacter", b) : AlgChtrElt, MonStgElt, BoolElt -&gt;</A></H5>
<BLOCKQUOTE>
Procedure that, given a class function x and a Boolean value b, 
stores with x the information
that the value of the predicate <TT>IsCharacter(x)</TT> equals b.
</BLOCKQUOTE>
<H4><A NAME = "11799">Induction, Restriction and Lifting</A></H4>



<H5><A NAME = "11800">Induction(x, G) : AlgChtrElt, Grp -&gt; AlgChtrElt</A></H5>
<H5>Induction(Q, G) : SeqEnum[AlgChtrElt], Grp -&gt; SeqEnum[AlgChtrElt]</H5>
<BLOCKQUOTE>
Given a class function x on the subgroup H of 
the group G, construct the  class function obtained
by induction of x to G. Note that if x is a character of H, 
then <TT>Induction(x, G)</TT> will return a character of G.
<P>
The <TT>Induction</TT> command may also be used to induce a sequence of characters
of a particular subgroup (such as a character table) to the given supergroup.
</BLOCKQUOTE>
<H5><A NAME = "11801">LiftCharacter(c, f, G) : AlgChtrElt, Map, Grp -&gt; AlgChtrElt</A></H5>
<BLOCKQUOTE>
Given a class function c of the quotient group Q 
of the group G and the natural homomorphism f : G -&gt; Q,
lift c to a class function of G.
</BLOCKQUOTE>
<H5><A NAME = "11802">LiftCharacters(T, f, G) : [AlgChtrElt], Map, Grp -&gt; AlgChtrElt</A></H5>
<BLOCKQUOTE>
Given a sequence T of class functions of the quotient group Q 
of the group G and the natural homomorphism f : G -&gt; Q,
lift T to a sequence of corresponding class functions of G.
Since a character table is just a sequence of class functions which 
is printed in a special way, this intrinsic may also be applied to it.
</BLOCKQUOTE>
<H5><A NAME = "11803">Restriction(x, H) : AlgChtrElt,  Grp -&gt; AlgChtrElt</A></H5>
<BLOCKQUOTE>
Given a class function x on the group G and a 
subgroup H of G, construct the restriction of x
to H (a class function). Note that if x is a 
character of G, then <TT>Restriction(x, H)</TT> will return a 
character of H.
</BLOCKQUOTE>
<H4><A NAME = "11804">Symmetrization</A></H4>

<P>
<P>
<P>
Let &lambda; be a partition. If we need to refer to the entries of &lambda;,
we shall do so with parenthesis, possibly also writing (&lambda;).
We write {&lambda;} for
the <TT>SymmetricCharacter</TT> associated to &lambda;.
<P>
Let &chi; be a character of a group.
We then have
&chi;<sup> tensor m</sup>=
bigoplus<sub>|&lambda;|=m</sub> c<sup>&lambda;</sup><sub>(1)<sup>m</sup></sub> &chi;^({&lambda;}),
where c<sup>&lambda;</sup><sub>(1)<sup>m</sup></sub> is a generalized Littlewood-Richardson coefficient
defined as the S<sub>&lambda;</sub> coefficient of S<sub>(1)</sub><sup>m</sup> for the Schur symmetric
functions S. For example,
&chi; tensor &chi; tensor &chi;=
&chi;<sup>(3)</sup> direct-sum 2&chi;<sup>(2, 1)</sup> direct-sum &chi;<sup>(1, 1, 1)</sup>.
<P>
The character &chi;^({&lambda;}) is then called the
&lambda;-symmetrization of &chi;, and can be defined as
&chi;^({&lambda;})(g)=(1/n!)
biggl(&sum;<sub>&rho;&isin;Sym(n)</sub>{&lambda;}(&rho;)
&prod;<sub>k=1</sub><sup>n</sup> &chi;(g<sup>k</sup>)<sup>a<sub>k</sub>(&rho;)</sup>biggr),
where n=|&lambda;| and a<sub>k</sub>(&rho;) is the number of cycles of length k
in &rho;. In practice, to compute this one sums over conjugacy classes
of Sym(n).
<P>
One can similarly define characters [&lambda;] or &lt; &lambda; &gt;
corresponding to orthogonal and symplectic components.
Here one has (see <A  HREF = "text1038.htm#bib_littlewood-book40">[Lit40, S11.9]</A>, though the formula II
erroneously has {&eta;} instead of [&eta;])
{&lambda;}=bigoplus<sub>&delta;</sub>bigoplus<sub>&eta;</sub>
c<sup>&lambda;</sup><sub>&delta;, &eta;</sub>[&eta;] (and)  
{&lambda;}=
bigoplus<sub>&beta;</sub>bigoplus<sub>&eta;</sub> c<sup>&lambda;</sup><sub>&beta;, &eta;</sub>&lt; &eta; &gt;
where &delta; runs over partitions into even parts only, while
&beta; runs over partitions where each part appears an even
number of times (conjugate partitions to the &delta;),
and &eta; runs over all partitions.
The significant property of these is
the multiplication rules (see <A  HREF = "text1038.htm#bib_littlewood-paper58">[Lit58, Theorems I,II]</A>).
Recalling the Littlewood-Richardson rule
{&lambda;}{&mu;}=&sum;<sub>&rho;</sub> c<sub>&lambda;, &mu;</sub><sup>&rho;</sup>{&rho;},
we define K<sub>&lambda;, &mu;</sub><sup>&rho;</sup> by
&sum;<sub>&xi;</sub>&sum;<sub>&zeta;, &nu;</sub>
c<sub>&xi;, &zeta;</sub><sup>&lambda;</sup> c<sub>&xi;, &nu;</sub><sup>&mu;</sup>{&zeta;}{&nu;}=
&sum;<sub>&rho;</sub> K<sub>&lambda;, &mu;</sub><sup>&rho;</sup>{&rho;}
and we then have
[&lambda;][&mu;]=&sum;<sub>&rho;</sub>K<sub>&lambda;, &mu;</sub><sup>&rho;</sup>[&rho;] (and) 
&lt; &lambda; &gt;&lt; &mu; &gt;=
&sum;<sub>&rho;</sub>K<sub>&lambda;, &mu;</sub><sup>&rho;</sup>&lt; &rho; &gt;.
As noted in <A  HREF = "text1038.htm#bib_newell51">[New51]</A>, there are "modification rules" for
[&lambda;] and &lt; &lambda; &gt; when twice the number of parts
of the partition exceeds the ambient dimension
of the orthogonal or symplectic group. Indeed, the [&lambda;]
or &lt; &lambda; &gt; with no more than k parts in dimension
2k or 2k + 1 form a basis, with the characters from partitions
with more parts being linearly dependent on them.
<P>
Given an orthogonal or respectively symplectic character &chi;, one can
then compute the symmetrization with respect to the character [&lambda;]
or &lt; &lambda; &gt;. See <A  HREF = "text1038.htm#bib_Frame82">[Fra82]</A> (or <A  HREF = "text1038.htm#bib_Murnaghan58">[Mur58]</A>).
<P>
Previously the Magma implementation had hand-coded formulas for partitions
of numbers no greater than 6. Furthermore, the cases of partitions of 6
had various bugs. Below we list the relevant formulas for these cases.
{1}=[1]=&lt; 1 &gt;
{2}=[2] + []=&lt; 2 &gt;
{1, 1}=[1, 1]=&lt; 1, 1 &gt; + &lt; &gt;
{3}=[3] + [1]=&lt; 3 &gt;
{2, 1}=[2, 1] + [1]=&lt; 2, 1 &gt; + &lt; 1 &gt;
{1, 1, 1}=[1, 1, 1] + [1]=&lt; 1, 1, 1 &gt;
<P>
{4}=[4] + [2] + []=&lt; 4 &gt;
{3, 1}=[3, 1] + [2] + [1, 1]=&lt; 3, 1 &gt; + &lt; 2 &gt;
{2, 2}=[2, 2] + [2] + []=&lt; 2, 2 &gt; + &lt; 1, 1 &gt; + &lt; &gt;
{2, 1, 1}=[2, 1, 1] + [1, 1]=
&lt; 2, 1, 1 &gt; + &lt; 2 &gt; + &lt; 1, 1 &gt;
{1, 1, 1, 1}=[1, 1, 1, 1]=
&lt; 1, 1, 1, 1 &gt; + &lt; 1, 1 &gt; + &lt; &gt;
<P>
{5}=[5] + [3] + [1]=&lt; 5 &gt;
{4, 1}=[4, 1] + [3] + [2, 1] + [1]=&lt; 4, 1 &gt; + &lt; 3 &gt;
{3, 2}=[3, 2] + [3] + [2, 1] + [1]=
&lt; 3, 2 &gt; + &lt; 2, 1 &gt; + &lt; 1 &gt;
{3, 1, 1}=[3, 1, 1] + [2, 1] + [1, 1, 1]=
&lt; 3, 1, 1 &gt; + &lt; 3 &gt; + &lt; 2, 1 &gt;
{2, 2, 1}=[2, 2, 1] + [2, 1] + [1]=
&lt; 2, 2, 1 &gt; + &lt; 2, 1 &gt; + &lt; 1, 1, 1 &gt; + &lt; 1 &gt;
{2, 1, 1, 1}=[2, 1, 1, 1] + [1, 1, 1]=
&lt; 2, 1, 1, 1 &gt; + &lt; 2, 1 &gt; +
&lt; 1, 1, 1 &gt; + &lt; 1 &gt;
{1, 1, 1, 1, 1}=[1, 1, 1, 1, 1]=
&lt; 1, 1, 1, 1, 1 &gt; + &lt; 1, 1, 1 &gt; + &lt; 1 &gt;
<P>
{6}=[6] + [4] + [2] + []=&lt; 6 &gt;
{5, 1}=[5, 1] + [4] + [3, 1] + [2] + [1, 1]=&lt; 5, 1 &gt; + &lt; 4 &gt;
{4, 2}=[4, 2] + [4] + [3, 1] + [2, 2] + 2[2] + []=
&lt; 4, 2 &gt; + &lt; 3, 1 &gt; + &lt; 2 &gt;
{4, 1<sup>2</sup>}=[4, 1, 1] + [3, 1] + [2, 1, 1] + [1, 1]=
&lt; 4, 1, 1 &gt; + &lt; 4 &gt; + &lt; 3, 1 &gt;
{3, 3}=[3, 3] + [3, 1] + [1, 1]=
&lt; 3, 3 &gt; + &lt; 2, 2 &gt; + &lt; 1, 1 &gt; + &lt; &gt;
{3, 2, 1}=[3, 2, 1] + [3, 1] + [2<sup>2</sup>] + [2, 1<sup>2</sup>] + [2] + [1<sup>2</sup>]=
&lt; 3, 2, 1 &gt; + &lt; 3, 1 &gt; + &lt; 2<sup>2</sup> &gt; +
&lt; 2, 1<sup>2</sup> &gt; + &lt; 2 &gt; + &lt; 1<sup>2</sup> &gt;
{3, 1<sup>3</sup>}=[3, 1<sup>3</sup>] + [2, 1, 1] + [1<sup>4</sup>]=
&lt; 3, 1<sup>3</sup> &gt; + &lt; 3, 1 &gt; + &lt; 2, 1, 1 &gt; + &lt; 2 &gt;
{2, 2, 2}=[2, 2, 2] + [2, 2] + [2] + []=
&lt; 2, 2, 2 &gt; + &lt; 2, 1, 1 &gt; + &lt; 2 &gt;
{2<sup>2</sup>, 1<sup>2</sup>}=[2<sup>2</sup>, 1<sup>2</sup>] + [2, 1<sup>2</sup>] + [1<sup>2</sup>]=
&lt; 2<sup>2</sup>, 1<sup>2</sup> &gt; + &lt; 2<sup>2</sup> &gt; + &lt; 2, 1<sup>2</sup> &gt; +
&lt; 1<sup>4</sup> &gt; + 2&lt; 1<sup>2</sup> &gt; + &lt; &gt;
{2, 1<sup>4</sup>}=[2, 1<sup>4</sup>] + [1<sup>4</sup>]=
&lt; 2, 1<sup>4</sup> &gt; + &lt; 2, 1, 1 &gt; + &lt; 1<sup>4</sup> &gt; +
&lt; 2 &gt; + &lt; 1, 1 &gt;
{1<sup>6</sup>}=[1<sup>6</sup>]=
&lt; 1<sup>6</sup> &gt; + &lt; 1<sup>4</sup> &gt; + &lt; 1<sup>2</sup> &gt; + &lt; &gt;


<P>
Finally, there are intrinsics to determine whether a character is
orthogonal or symplectic. For irreducible characters, this can be
determined simply by the Schur indicator. In general, the fact that
SO<sub>2n</sub>&cap;Sp<sub>2n</sub>=U<sub>n</sub> implies that for all &chi;
the character &chi; direct-sum bar&chi; is both orthogonal and symplectic
(orthogonal meaning that it preserves a full rank symmetric form,
the same with alternating for symplectic).
<P>
When &psi; is not real, then it is neither orthogonal nor symplectic.
We decompose &psi;=&sum;<sub>&chi;</sub> a<sub>&chi;</sub>&chi; into irreducibles,
and for &psi; real this implies a<sub>&chi;</sub>=a_(bar(&chi;)) for nonreal &chi;.
For real &chi; we can further reduce the a<sub>&chi;</sub> modulo 2.
For &psi; to be declared orthogonal, we then require every remaining
constituent to be itself orthogonal, and similarly for symplectic.
<H5><A NAME = "11805">Symmetrization(chi, p) : AlgChtrElt, [ RngIntElt ] -&gt; AlgChtrElt</A></H5>
<BLOCKQUOTE>
Given a character &chi; and partition p
return the symmetrized character &chi;^({p}).
The power map for the parent of &chi; must be available.
</BLOCKQUOTE>
<H5><A NAME = "11806">OrthogonalSymmetrization(chi, p) : AlgChtrElt, [ RngIntElt ] -&gt; AlgChtrElt</A></H5>
<BLOCKQUOTE>
Given an orthogonal character &chi; and a partition p
return the character &chi;<sup>[p]</sup>.
The power map for the parent of &chi; must be available.
</BLOCKQUOTE>
<H5><A NAME = "11807">SymplecticSymmetrization(chi, p) : AlgChtrElt, [ RngIntElt ] -&gt; AlgChtrElt</A></H5>
<BLOCKQUOTE>
Given a symplectic character &chi; and a partition p
return the character &chi;<sup>&lt; p &gt;</sup>.
The power map for the parent of &chi; must be available.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "11808">Example <TT>Chtr_tensprod-check (H97E6)</TT></A></H3>
This example verifies the previously stated tensor product rule for
some characters and partitions.
<P>
<P>
<P>
<PRE>
&gt; S := SFA(Integers());
&gt; function tensprod(chi,m)
&gt;   F := S.1^m;
&gt;   return &amp;+[Coefficient(F,p)*Symmetrization(chi,p) : p in Support(F)];
&gt;   end function;
&gt; CT := CharacterTable(SU(2,7));
&gt; for chi in CT,m in [1..6] do
&gt;   assert tensprod(chi,m) eq chi^m; end for;
</PRE>
<HR>
<H3><A NAME = "11809">Example <TT>Chtr_symp-and-orthog (H97E7)</TT></A></H3>
Here we compute the orthogonal and symplectic symmetrizations of some
characters. Note that these need not be characters (only virtual ones)
in cases where the degree of the character is smaller than
twice the number of parts in the partition. This is consistent with
the above-mentioned modification rules.
<P>
<P>
<P>
<PRE>
&gt; CT := CharacterTable(SU(2,5));
&gt; chi := rep{chi: chi in CT | Degree(chi) eq 4 and IsOrthogonalCharacter(chi)};
( 4, 4, 1, 0, -1, -1, 1, -1, -1 )
&gt; [OrthogonalSymmetrization(chi,p) : p in Partitions(6)];
[
    ( 49, 49, 1, 1, -1, -1, 1, -1, -1 ),
    ( 70, 70, -2, -2, 0, 0, -2, 0, 0 ),
    ( 42, 42, 0, 2, 2, 2, 0, 2, 2 ),
    ( 25, 25, 1, 1, 0, 0, 1, 0, 0 ),
    ( 14, 14, 2, -2, -1, -1, 2, -1, -1 ),
    ( 0, 0, 0, 0, 0, 0, 0, 0, 0 ),
    ( 0, 0, 0, 0, 0, 0, 0, 0, 0 ),
    ( -10, -10, 2, -2, 0, 0, 2, 0, 0 ),
    ( -9, -9, 0, -1, 1, 1, 0, 1, 1 ),
    ( -1, -1, -1, -1, -1, -1, -1, -1, -1 ),
    ( 0, 0, 0, 0, 0, 0, 0, 0, 0 )
]
&gt; CT := CharacterTable(SU(2,7));
&gt; chi := CT[7]; chi;
( 6, -6, 0, 0, 0, -1, -1, Sqrt(2), -Sqrt(2), 1, 1 )
&gt; [SymplecticSymmetrization(chi,p) : p in Partitions(6)];
[
    ( 462, 462, 3, -10, 3, 0, 0, -2, -2, 0, 0 ),
    ( 924, 924, -3, 4, -3, 0, 0, 0, 0, 0, 0 ),
    ( 924, 924, 0, -12, 0, 0, 0, 0, 0, 0, 0 ),
    ( 525, 525, 3, 5, 3, 0, 0, 1, 1, 0, 0 ),
    ( 385, 385, 4, 9, 4, 0, 0, 1, 1, 0, 0 ),
    ( 512, 512, -4, 0, -4, 1, 1, 0, 0, 1, 1 ),
    ( 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ),
    ( 84, 84, 3, -4, 3, 0, 0, 0, 0, 0, 0 ),
    ( 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ),
    ( -70, -70, -1, 2, -1, 0, 0, 2, 2, 0, 0 ),
    ( -14, -14, 1, -2, 1, 0, 0, 0, 0, 0, 0 )
]
</PRE>
<HR>
<H5><A NAME = "11810">IsOrthogonalCharacter(chi) : AlgChtrElt -&gt; BoolElt</A></H5>
<H5>IsSymplecticCharacter(chi) : AlgChtrElt -&gt; BoolElt</H5>
<BLOCKQUOTE>
Given a character of a finite group, determine whether it is
orthogonal or symplectic.
</BLOCKQUOTE>
<H4><A NAME = "11811">Permutation Character</A></H4>



<H5><A NAME = "11812">PermutationCharacter(G) : GrpPerm -&gt; AlgChtrElt</A></H5>
<BLOCKQUOTE>
Given group G represented as a permutation group, 
construct the character of G afforded by the
defining permutation representation of G.
</BLOCKQUOTE>
<H5><A NAME = "11813">PermutationCharacter(G, H) : Grp, Grp -&gt; AlgChtrElt</A></H5>
<BLOCKQUOTE>
Given a group G and some subgroup H of G, 
construct the character of G afforded by the 
permutation representation of G given by the 
action of G on the right cosets of H in G.
</BLOCKQUOTE>
<H4><A NAME = "11814">Composition and Decomposition</A></H4>



<H5><A NAME = "11815">Composition(T, q) : [ AlgChtrElt ], [RngElt] -&gt; AlgChtrElt</A></H5>
<BLOCKQUOTE>
Given a sequence or table of characters T for
the group G and a sequence q of k 
elements of Qm (possibly Q), create the class function
q<sub>1</sub> * T<sub>1</sub> + ... + q<sub>k</sub> * T<sub>k</sub>,
where T<sub>i</sub> is the i-th character in T.
</BLOCKQUOTE>
<H5><A NAME = "11816">Decomposition(T, y) : [AlgChtrElt], AlgChtrElt -&gt; [ FldCycElt ], AlgChtrElt</A></H5>
<BLOCKQUOTE>
Given a sequence or table of class functions T for G of length l
and a class function y on G, attempt to express y as a
linear combination of the elements of T. 
<P>
The function returns two values: a sequence q=[q<sub>1</sub>, ..., q<sub>l</sub>] of
cyclotomic field elements and a class function z.
For 1&le;i&le;l, the i-th term of q is defined to be
the ratio of inner products (y, T<sub>i</sub>)/(T<sub>i</sub>, T<sub>i</sub>), where T<sub>i</sub> is the 
i-th entry of T. The sequence q determines a class function 
x=q<sub>1</sub>.T<sub>1</sub> + ... + q<sub>l</sub>.T<sub>l</sub>
which will equal y if T is the complete table of irreducible characters.
The difference z=y - x is the second return value. If the entries in T are
mutually orthogonal, then z is the zero class function if and only if 
y is a linear combination of the T<sub>i</sub>.
</BLOCKQUOTE>
<H4><A NAME = "11817">Finding Irreducibles</A></H4>

<P>
<P>
A common approach to finding the irreducible characters of a group is
to start with an irreducible character and generate new characters by applying 
<TT>Symmetrization</TT>, or the orthogonal or symplectic variants.
Then, by examining norms and inner products, it  is often possible
to identify irreducible characters or at least characters with smaller norms.
There are two Magma intrinsics available to help with this task.


<H5><A NAME = "11818">RemoveIrreducibles(I, C) : [ AlgChtrElt ], [ AlgChtrElt ] -&gt; [ AlgChtrElt ], [ AlgChtrElt ]</A></H5>
<BLOCKQUOTE>
Remove occurrences of the irreducible characters in the sequence I from the characters
in the sequence C and look for characters of norm 1 among the reduced characters.
Return a sequence of new irreducibles found and the sequence of reduced
characters.
</BLOCKQUOTE>
<H5><A NAME = "11819">ReduceCharacters(I, C) : [ AlgChtrElt ], [ AlgChtrElt ] -&gt; [ AlgChtrElt ], [ AlgChtrElt ]</A></H5>
<BLOCKQUOTE>
Make the norms of the characters in the sequence C smaller by computing the differences
of appropriate pairs.  Return a sequence of new irreducibles found and a
sequence of reduced characters.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "11820">Example <TT>Chtr_A5 (H97E8)</TT></A></H3>
 This example shows
how the above functions can be used to construct the character table for A<sub>5</sub> 
(compare Isaacs, p64), using only characters on subgroups.
<P>
<P>
<PRE>
&gt; A := AlternatingGroup(GrpPerm, 5);
&gt; R := CharacterRing(A);
</PRE>
The first character will be the principal character
<P>
<P>
<PRE>
&gt; T1 := R ! 1;
&gt; T1;
( 1, 1, 1, 1, 1 )
</PRE>
Next construct the permutation character
<P>
<P>
<PRE>
&gt; pc := PermutationCharacter(A);
&gt; T2 := pc - T1;
&gt; InnerProduct(pc, T1), InnerProduct(T2, T2);
1 1
&gt; T2;
( 4, 0, 1, -1, -1 )
</PRE>
It follows that  pc - T1  is an irreducible character
<P>
<P>
<PRE>
&gt; B := Stabilizer(A, 5);
&gt; r := RootOfUnity(3, CyclotomicField(3));
&gt; S := CharacterRing(B);
&gt; lambda := S ! [1, 1, r, r^2 ];
&gt; IsLinear(lambda);
true
</PRE>
This defines a linear character on a subgroup of index 5 in A
<P>
<P>
<PRE>
&gt; T3 := Induction(lambda, A);
&gt; InnerProduct(T3, T3);
1
&gt; T3;
( 5, 1, -1, 0, 0 )
</PRE>
Finally we use characters on the cyclic subgroup of order 5:
<P>
<P>
<PRE>
&gt; K := sub&lt;A |  (1,2,3,4,5) &gt;;
&gt; Y := CharacterTable(K);
&gt; Y;


Character Table of Group K
--------------------------


-------------------------------
Class |   1    2    3    4    5
Size  |   1    1    1    1    1
Order |   1    5    5    5    5
-------------------------------
p  =  5   1    1    1    1    1
-------------------------------
X.1   +   1    1    1    1    1
X.2   0   1   Z1 Z1#2 Z1#3 Z1#4
X.3   0   1 Z1#2 Z1#4   Z1 Z1#3
X.4   0   1 Z1#3   Z1 Z1#4 Z1#2
X.5   0   1 Z1#4 Z1#3 Z1#2   Z1




Explanation of Symbols:
-----------------------


# denotes algebraic conjugation, that is,
# k indicates replacing the root of unity w by w^k


Z1     = -1 - zeta_5 - zeta_5^2 - zeta_5^3


&gt; mu := Induction(Y[2], A);
</PRE>
We subtract what we already know from mu and get a new irreducible.
We use decomposition with respect to a sequence.
<P>
<P>
<PRE>
&gt; _, T4 := Decomposition([T1, T2, T3], mu);
&gt; InnerProduct(T4, T4);
1
&gt; T4;
( 3, -1, 0, (1 + zeta_5^2 + zeta_5^3), (-zeta_5^2 - zeta_5^3) )
&gt; T5 := GaloisConjugate(T4, 2);
&gt; T5;
( 3, -1, 0, (-zeta_5^2 - zeta_5^3), (1 + zeta_5^2 + zeta_5^3) )
</PRE>
Compare this to the standard character table:
<P>
<P>
<PRE>
&gt; CharacterTable(A);


Character Table of Group A
--------------------------


---------------------------
Class |   1  2  3    4    5
Size  |   1 15 20   12   12
Order |   1  2  3    5    5
---------------------------
p  =  2   1  1  3    5    4
p  =  3   1  2  1    5    4
p  =  5   1  2  3    1    1
---------------------------
X.1   +   1  1  1    1    1
X.2   +   3 -1  0   Z1 Z1#2
X.3   +   3 -1  0 Z1#2   Z1
X.4   +   4  0  1   -1   -1
X.5   +   5  1 -1    0    0




Explanation of Symbols:
-----------------------


#  denotes algebraic conjugation, that is,
# k indicates replacing the root of unity w by w^k


Z1     =(1 + zeta_5^2 + zeta_5^3)
</PRE>
We now create a character ring, corresponding to the character ring for
A<sub>5</sub>, but without a group, using the data displayed above.
We then assert the irreducible of degree 4, and
produce another irreducible via asserting the power map for R and
looking at a symmetrized power.
<P>
<P>
<PRE>
&gt; Q := [&lt;1,1&gt;, &lt;2,15&gt;, &lt;3,20&gt;, &lt;5, 12&gt;, &lt;5,12&gt;];
&gt; R := CharacterRing(Q);
&gt; x := R![4,0,1,-1,-1];
&gt; x`IsIrreducible := true;
&gt; x;
( 4, 0, 1, -1, -1 )
&gt; #KnownIrreducibles(R);
2
&gt; pm := [[1],[2,1],[3,3,1],[4,5,5,4,1],[5,4,4,5,1]];
&gt; R`PowerMap := pm;
&gt; y := Symmetrization(x, [2]);
&gt; InnerProduct(y, R!1);
1
&gt; y := y - R!1;
&gt; InnerProduct(y, x);
1
&gt; y := y - x;
&gt; y;
( 5, 1, -1, 0, 0 )
&gt; Norm(y);
1
&gt; y`IsIrreducible := true;
&gt; #KnownIrreducibles(R);  
3
</PRE>
<HR>
<H4><A NAME = "11821">Brauer Characters</A></H4>

<P>
<P>
Magma has some support for the calculation of Brauer characters. These
functions are noted in this section. We anticipate considerable change
to the functionality described here in the near future.
<P>
A Brauer character modulo p in Magma is represented as a class function 
(that is, element of a character ring) which
is zero on p-singular group elements. In this format the standard character
operations of addition, multiplication, induction and restriction all
apply directly to Brauer characters as they do to other class functions.
<P>
Note that problems associated with choice of lifting from finite fields to
complex roots of unity have not yet been dealt with.


<H5><A NAME = "11822">BrauerCharacter(x, p) : AlgChtrElt, RngIntElt -&gt; AlgChtrElt</A></H5>
<BLOCKQUOTE>
The Brauer character modulo the prime p obtained by setting the value of
x on p-singular elements to be zero.
</BLOCKQUOTE>
<H5><A NAME = "11823">Blocks(T, p) : SeqEnum[AlgChtrElt], RngIntElt -&gt; SeqEnum, SeqEnum</A></H5>
<BLOCKQUOTE>
When T is the full ordinary character table of a group, return the partition
of T into p-blocks, where p is a given prime. The partition is returned as
a sequence of sets of integers which give the blocks by the positions of the
characters in T. The second return value is the corresponding
sequence of defects of the blocks. The blocks are ordered first by decreasing
defect, second by first character in the block.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "11824">Example <TT>Chtr_brauer (H97E9)</TT></A></H3>
We give an example of the use of these Brauer character functions.
We consider the 3-modular characters of the Higman-Sims simple group.
<P>
<P>
<PRE>
&gt; load hs176;
&gt; T := CharacterTable(G);
&gt; Blocks(T,3);
[
  { 1, 2, 5, 10, 18, 19, 21, 23, 24 },
  { 3, 4, 6, 7, 11, 12, 14, 15, 20 },
  { 8, 13, 16 },
  { 9 },
  { 17 },
  { 22 }
]
[ 2, 2, 1, 0, 0, 0 ]
</PRE>
The characters T[8], T[13], T[16] are the ordinary irreducible characters
in a 3-block of defect one.
In such a small block the two ordinary irreducibles of minimal degree will 
restrict to modular irreducibles.
<P>
<P>
<PRE>
&gt; [Degree(T[i]): i in [8, 13, 16]];
[ 231, 825, 1056 ]
&gt; BrauerCharacter(T[8], 3);
( 231, 7, -9, 0, 15, -1, -1, 6, 1, 1, 0, 0, 0, -1, -1, -1,
2, 1, 0, 0, 0, 0, 0, 0 )
&gt; BrauerCharacter(T[13], 3);
( 825, 25, 9, 0, -15, 1, 1, 0, -5, 0, 0, 0, -1, 1, 1, 1, 0,
-1, 0, 0, 0, 0, 0, 0 )
&gt; $1 + $2 eq BrauerCharacter(T[16], 3);
true
</PRE>
The projective indecomposable characters corresponding to these Brauer
irreducible characters are as follows.
<P>
<P>
<PRE>
&gt; T[8] + T[16];
( 1287, 39, -9, 0, 15, -1, -1, 12, -3, 2, 0, 0, -1, -1, -1,
-1, 4, 1, 0, 0, 0, 0, 0, 0 )
&gt; T[13] + T[16];
( 1881, 57, 9, 0, -15, 1, 1, 6, -9, 1, 0, 0, -2, 1, 1, 1, 2,
-1, 0, 0, 0, 0, 0, 0 )
</PRE>
<HR>
<PRE></PRE> <A  HREF = "text1043.htm">[Next]</A><A  HREF = "text1041.htm">[Prev]</A> <A  HREF = "text1043.htm">[Right]</A> <A  HREF = "text1041.htm">[Left]</A> <A  HREF = "text1039.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<br><small>Version: V2.22 of <I>
Thu Jun  9 16:37:49 EST 2016
</I></small>
</body></html>