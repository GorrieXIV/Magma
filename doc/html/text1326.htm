<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <link rel='stylesheet' href='help.css' type='text/css'>
  <TITLE>Basic Attributes of Schemes</TITLE>
</head>
<body BGCOLOR="#FFFFFF">

 <A  HREF = "text1327.htm">[Next]</A><A  HREF = "text1325.htm">[Prev]</A> <A  HREF = "text1327.htm">[Right]</A> <A  HREF = "text1325.htm">[Left]</A> <A  HREF = "text1321.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<PRE></PRE><H3><A NAME = "14450">Basic Attributes of Schemes</A></H3>

<P>
<P>
These intrinsics report on basic features of the ambient space of a scheme
or the equations defining a scheme.
In many cases they simply call the corresponding function of the ambient space;
the intrinsic <TT>BaseRing()</TT> is an example.
The first set of these functions consists of those that only make reference
to the ambient space, while the second set is concerned with the
defining equations of the scheme.



<H5>Subsections</H5>
<UL>
<LI> <A  HREF = "text1326.htm#14451">Functions of the Ambient Space</A>
<LI> <A  HREF = "text1326.htm#14461">Functions of the Equations</A>
</UL>
<H4><A NAME = "14451">Functions of the Ambient Space</A></H4>



<H5><A NAME = "14452">AmbientSpace(X) : Sch -&gt; Sch</A></H5>
<H5>Ambient(X) : Sch -&gt; Sch</H5>
<BLOCKQUOTE>
The ambient space containing the scheme X.
</BLOCKQUOTE>
<H5><A NAME = "14453">SuperScheme(X) : Sch -&gt; Sch</A></H5>
<BLOCKQUOTE>
The scheme X was created as a subscheme of.
</BLOCKQUOTE>
<H5><A NAME = "14454">BaseRing(X) : Sch -&gt; Rng</A></H5>
<H5>CoefficientRing(X) : Sch -&gt; Fld</H5>
<BLOCKQUOTE>
The base ring of the scheme X.
</BLOCKQUOTE>
<H5><A NAME = "14455">BaseField(X) : Sch -&gt; Fld</A></H5>
<H5>CoefficientField(X) : Sch -&gt; Fld</H5>
<BLOCKQUOTE>
The base ring of the scheme X if it is a field, otherwise an error.
</BLOCKQUOTE>
<H5><A NAME = "14456">IsAffine(X) : Sch -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if and only if the ambient space of the scheme X is affine.
</BLOCKQUOTE>
<H5><A NAME = "14457">IsProjective(X) : Sch -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if and only if the ambient space of the scheme X is projective.
</BLOCKQUOTE>
<H5><A NAME = "14458">IsOrdinaryProjective(X) : Sch -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if and only if the ambient space of the scheme X is an ordinary
projective space, that is, its coordinate ring is generated in degree 1
with respect to the grading on the space.
</BLOCKQUOTE>
<H5><A NAME = "14459">IsPlanar(X) : Sch -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Return <TT>true</TT> if the ambient of the scheme X is 2-dimensional.
</BLOCKQUOTE>
<H5><A NAME = "14460">IsSaturated(X) : Sch -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if and only if the current defining ideal of the scheme
X, as returned
by <TT>DefiningIdeal(X)</TT> is saturated (see Section <A  HREF = "text1324.htm#14418">Constructing Schemes</A>).
</BLOCKQUOTE>
<H4><A NAME = "14461">Functions of the Equations</A></H4>

<P>
<P>
There are many ways to recover the equations which define a scheme.
The standard method is to use the <TT>DefiningPolynomials</TT> function 
(or its singular versions) since it doesn't involve ideal theory 
overheads and certainly won't call any Gr&ouml;bner basis functions.


<H5><A NAME = "14462">DefiningPolynomials(X) : Sch -&gt; SeqEnum</A></H5>
<H5>Polynomials(X) : Sch -&gt; SeqEnum</H5>
<H5>DefiningEquations(X) : Sch -&gt; SeqEnum</H5>
<H5>Equations(X) : Sch -&gt; SeqEnum</H5>
<BLOCKQUOTE>
The defining polynomials for the ideal of the scheme X.
</BLOCKQUOTE>
<H5><A NAME = "14463">DefiningPolynomial(X) : Sch -&gt; RngMPolElt</A></H5>
<H5>Polynomial(X) : Sch -&gt; RngMPolElt</H5>
<H5>DefiningEquation(X) : Sch -&gt; RngMPolElt</H5>
<H5>Equation(X) : Sch -&gt; RngMPolElt</H5>
<BLOCKQUOTE>
The defining polynomial of the scheme X if it is a hypersurface.
If X is not a hypersurface, an error is reported.
</BLOCKQUOTE>
<H5><A NAME = "14464">DefiningIdeal(X) : Sch -&gt; RngMPol</A></H5>
<H5>Ideal(X) : Sch -&gt; RngMPol</H5>
<BLOCKQUOTE>
The ideal of a multivariate polynomial ring defining the scheme X.
</BLOCKQUOTE>
<H5><A NAME = "14465">CoordinateRing(X) : Sch -&gt; RngMPol</A></H5>
<BLOCKQUOTE>
The quotient of the coordinate ring of the ambient space of the scheme X by
the ideal of X.
</BLOCKQUOTE>
<H5><A NAME = "14466">Curve(X) : Sch -&gt; Crv</A></H5>
<BLOCKQUOTE>
The smallest scheme in the inclusion chain above the scheme X which is a curve.
</BLOCKQUOTE>
<H5><A NAME = "14467">GroebnerBasis(X) : Sch -&gt; SeqEnum</A></H5>
<BLOCKQUOTE>
Return a sequence containing the polynomials of a Gr&ouml;bner basis of the
defining ideal of the scheme X.  Note that the defining polynomials of 
X will not be changed, but that the basis of the ideal of X will be 
updated with the Gr&ouml;bner basis as is the standard in the multivariate 
polynomial ring module.
</BLOCKQUOTE>
<H5><A NAME = "14468">MinimalBasis(X) : Sch -&gt; [ RngMPolElt ]</A></H5>
<BLOCKQUOTE>
Return a minimal basis of the defining ideal of the scheme X, that is,
a sequence of polynomials, no subsequence of which forms a basis of the
ideal of X.  Note that the defining polynomials of X will not be 
changed. This is the best human readable basis that Magma can supply.
</BLOCKQUOTE>
<H5><A NAME = "14469">IsHypersurface(X) : Sch -&gt; BoolElt, RngMPolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if and only if the scheme X is definable by a 
single polynomial.  This function will perform a GCD calculation to 
simplify multiple defining polynomial if possible. The polynomial 
is returned as a second value.
</BLOCKQUOTE>
<H5><A NAME = "14470">JacobianIdeal(X) : Sch -&gt; RngMPol</A></H5>
<BLOCKQUOTE>
The ideal of partial derivatives of the polynomials which define
the scheme X.
</BLOCKQUOTE>
<H5><A NAME = "14471">JacobianMatrix(X) : Sch -&gt; ModMatRngElt</A></H5>
<BLOCKQUOTE>
The matrix (&part;f<sub>i</sub>/&part;x<sub>j</sub>) of partial derivatives of 
the defining polynomials of the scheme X.
</BLOCKQUOTE>
<H5><A NAME = "14472">HessianMatrix(X) : Sch -&gt; ModMatRngElt</A></H5>
<BLOCKQUOTE>
The hessian matrix (&part;<sup>2</sup>f/&part;x<sub>i</sub> &part;x<sub>j</sub>) of the
hypersurface X where f is the polynomial which defines X.
</BLOCKQUOTE>
<H5><A NAME = "14473">X eq Y : Sch,Sch -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if the schemes 
X and Y have the same types, ambients and ideals.
If Gr&ouml;bner basis calculations are not available this question may not be able
to be decided. If X and Y are projective then they are saturated before
ideal equality is tested for.
</BLOCKQUOTE>
<H5><A NAME = "14474">IsSubscheme(X, Y) : Sch,Sch -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if and only if the scheme X is contained, 
scheme-theoretically, in the scheme Y.  A Gr&ouml;bner basis 
calculation checks the reverse inclusion of the corresponding 
ideals. If X and Y are projective, then X is saturated
before the test for inclusion.
</BLOCKQUOTE>
<H5><A NAME = "14475">IsLinear(X) : Sch -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Return <TT>true</TT> if the scheme X is defined by linear equations, possibly
after taking a Gr&ouml;bner basis.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "14476">Example <TT>Scheme_scheme-equality (H118E14)</TT></A></H3>
In this example we first create some schemes and then test them for
inclusions and equality.
<P>
<P>
<PRE>
&gt; P&lt;u,v,w&gt; := ProjectiveSpace(GF(11),2);
&gt; C := Scheme(P,u^2 + u*w + 6*v^2);
&gt; Z := Scheme(C,[u,v]);
&gt; IsSubscheme(Z,C);
true
</PRE>
Now we will make another scheme which has the same polynomials as C but 
which is written in disguise.  While the disguise in this case is simply 
to multiply the polynomial by 2 --- the rather-too-obvious false nose 
and eyebrows among polynomials --- the point is to note that the equality 
test in Magma is not fooled.  The equality test identifies that the 
underlying defining ideals are the same and returns <TT>true</TT>.
<P>
<P>
<PRE>
&gt; D := Scheme(P,2*u^2 + 2*u*w + v^2);
&gt; D eq C;
true
&gt; IsSubscheme(C,D) and IsSubscheme(D,C);
true
&gt; DefiningIdeal(D) eq DefiningIdeal(C);
true
&gt; DefiningPolynomial(D) eq DefiningPolynomial(C);
false
</PRE>
As we see in the final line above, checking the equality of ideals 
corresponds to the natural interpretation of equality.  
<P>
There are a couple of caveats to this lesson, however.
For instance, it is necessary,  that the ideals to be comparable,
i.e. the schemes must be  embedded in the same ambient space.
<P>
<P>
<PRE>
&gt; X&lt;r,s,t&gt; := ProjectiveSpace(GF(11),2);
&gt; E := Scheme(P,r^2 + r*s + 6*t^2);
&gt; E eq C;
false
</PRE>
<HR>
<PRE></PRE> <A  HREF = "text1327.htm">[Next]</A><A  HREF = "text1325.htm">[Prev]</A> <A  HREF = "text1327.htm">[Right]</A> <A  HREF = "text1325.htm">[Left]</A> <A  HREF = "text1321.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<br><small>Version: V2.22 of <I>
Thu Jun  9 16:37:49 EST 2016
</I></small>
</body></html>