<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <link rel='stylesheet' href='help.css' type='text/css'>
  <TITLE>Polycyclic Groups and Polycyclic Presentations</TITLE>
</head>
<body BGCOLOR="#FFFFFF">

 <A  HREF = "text834.htm">[Next]</A><A  HREF = "text832.htm">[Prev]</A> <A  HREF = "text834.htm">[Right]</A> <A  HREF = "text832.htm">[Left]</A> <A  HREF = "text831.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<PRE></PRE><H3><A NAME = "9569">Polycyclic Groups and Polycyclic Presentations</A></H3>




<H5>Subsections</H5>
<UL>
<LI> <A  HREF = "text833.htm#9570">Introduction</A>
<LI> <A  HREF = "text833.htm#9571">Specification of Elements</A>
<LI> <A  HREF = "text833.htm#9574">Access Functions for Elements</A>
<LI> <A  HREF = "text833.htm#9580">Arithmetic Operations on Elements</A>
<LI> <A  HREF = "text833.htm#9590">Operators for Elements</A>
<LI> <A  HREF = "text833.htm#9594">Comparison Operators for Elements</A>
<LI> <A  HREF = "text833.htm#9598">Specification of a Polycyclic Presentation</A>
<LI> <A  HREF = "text833.htm#9603">Properties of a Polycyclic Presentation</A>
</UL>
<H4><A NAME = "9570">Introduction</A></H4>

<P>
<P>
A polycyclic group is a group G with a subnormal series
G = G<sub>1</sub> &gt; G<sub>2</sub> &gt; .. &gt; G<sub>n + 1</sub> = 1 in which every quotient
G<sub>i</sub> / G<sub>i + 1</sub> is cyclic. Every polycyclic group G has a presentation of
the form
<PRE>
 &lt; a_1,..,a_n | a_i ^(m_i)= w_(i,i)        (i in I) ,
                a_j ^(a_i)= w_(i,j)        (1 &lt;= i &lt; j &lt;= n),
                a_j ^(a_i^(-1))= w_(-i,j)  (1 &lt;= i &lt; j &lt;= n, i not in I) &gt;
</PRE>where
<DL COMPACT class='compact'>
<DT>(i)</DT><DD>I is a subset of {1, .., n},
<DT>(ii)</DT><DD>m<sub>i</sub> &gt; 1 for i in I, and
<DT>(iii)</DT><DD>the words w<sub>i, j</sub> are of the form w<sub>i, j</sub> = a<sub>|i| + 1</sub><sup>l(i, j, |i| + 1)</sup> ... a<sub>n</sub><sup>l(i, j, n)</sup>, with 0&le;l(i, j, k) &lt; m<sub>k</sub> if k&isin;I.
Such a presentation is called a <I>polycyclic presentation</I> for G. For 1&le;i&le;n, let G<sub>i</sub> be the subgroup of G generated by a<sub>i</sub>, ..., a<sub>n</sub> and define G<sub>n + 1</sub> to be the trivial group. The presentation is called <I>consistent</I>, if |G<sub>i</sub> / G<sub>i + 1</sub>|=m<sub>i</sub> whenever i is in I and the quotient G<sub>i</sub> / G<sub>i + 1</sub> is infinite whenever i is not in I. The generators a<sub>1</sub>, ... a<sub>n</sub> are referred to as <I>polycyclic generators</I> (<I>pc-generators</I>) for G and the values m<sub>i</sub> (i&isin;I) are called the corresponding <I>pc-exponents</I>.
In Magma, the user can define a polycyclic group by providing a consistent polycyclic presentation or by using one of the existing category transfer functions.
<P>
</DL>
Given a consistent polycyclic presentation for G, every element a of G can be written uniquely in the form a=a<sub>1</sub><sup>e<sub>1</sub></sup> ... a<sub>n</sub><sup>e<sub>n</sub></sup>, where the e<sub>i</sub> are integers satisfying 0 &le;e<sub>i</sub> &lt; m<sub>i</sub> if i&isin;I. This form is called <I>normal form</I>. There exists an algorithm (the <I>collection algorithm</I>), which given an arbitrary word in the generators a<sub>1</sub>, ..., a<sub>n</sub>, will determine the corresponding normal word.  Magma uses a collection algorithm written by Volker Gebhardt. The cost of collection for this algorithm grows logarithmically in a bound on the absolute values of the exponents e<sub>i</sub> occurring during the collection <A  HREF = "text830.htm#bib_polycyclic_collector">[Geb02]</A>.
<P>
Infinite polycyclic groups are a comparatively new topic in computational group theory and the number of available algorithms is much smaller than in the case of finite polycyclic groups. For this reason, the data type <TT>GrpPC</TT>
(cf. Chapter <A  HREF = "text706.htm#7978">FINITE SOLUBLE GROUPS</A>) should be preferred for finite polycyclic groups.


<H4><A NAME = "9571">Specification of Elements</A></H4>

<P>
<P>
Elements of polycyclic groups are words.
A <I>word</I> is defined inductively as follows:
<DL COMPACT class='compact'>
<DT>(i)</DT><DD>A generator is a word;
<DT>(ii)</DT><DD>The expression (u) is a word, where u
is a word;
<DT>(iii)</DT><DD>The product u * v of the words u and
v is a word;
<DT>(iv)</DT><DD>The conjugate u<sup>v</sup> of the word u by the
word v is a word (u<sup>v</sup> expands into the
word v<sup> - 1</sup> * u * v);
<DT>(v)</DT><DD>The power of a word u<sup>n</sup>, where u is a
word and n is an integer, is a word;
<DT>(vi)</DT><DD>The commutator (u, v) of the words u
and v is a word ( (u, v) expands into
the word u<sup> - 1</sup> * v<sup> - 1</sup> * u * v).</DL>


<H5><A NAME = "9572">G ! Q : GrpGPC, [RngIntElt] -&gt; GrpGPCElt</A></H5>
<BLOCKQUOTE>
Given the polycyclic group G and a sequence Q of length n, containing
integers e<sub>1</sub> ... e<sub>n</sub>, where 0&le;(e<sub>i</sub>) &lt; m<sub>i</sub> if i&isin;I, construct the element x of G given by
x = a<sub>1</sub><sup>e<sub>1</sub></sup> ... a<sub>n</sub><sup>e<sub>n</sub></sup>.
</BLOCKQUOTE>
<H5><A NAME = "9573">Identity(G) : GrpGPC -&gt; GrpGPCElt</A></H5>
<H5>Id(G) : GrpGPC -&gt; GrpGPCElt</H5>
<H5>G ! 1 : GrpGPC, RngIntElt -&gt; GrpGPCElt</H5>
<BLOCKQUOTE>
Construct the identity element of the polycyclic group G.
</BLOCKQUOTE>
<H4><A NAME = "9574">Access Functions for Elements</A></H4>

<P>
<P>
Throughout this subsection, G will be a polycyclic group with pc-generators
a<sub>1</sub>, ..., a<sub>n</sub>.


<H5><A NAME = "9575">ElementToSequence(x) : GrpGPCElt -&gt; [RngIntElt]</A></H5>
<H5>Eltseq(x) : GrpGPCElt -&gt; [RngIntElt]</H5>
<BLOCKQUOTE>
Given an element x belonging to the polycyclic group G, where
x = a<sub>1</sub><sup>e<sub>1</sub></sup> ... a<sub>n</sub><sup>e<sub>n</sub></sup> in normal form,
return the sequence Q of n
integers defined by Q[i] = (e<sub>i</sub>), for i = 1, ..., n.
</BLOCKQUOTE>
<H5><A NAME = "9576">LeadingTerm(x) : GrpGPCElt -&gt; GrpGPCElt</A></H5>
<BLOCKQUOTE>
Given an element x of a polycyclic group G with n pc-generators,
where x is of the form a<sub>1</sub><sup>e<sub>1</sub></sup> ... a<sub>n</sub><sup>e<sub>n</sub></sup>,
return a<sub>i</sub><sup>e<sub>i</sub></sup> for the smallest i such that e<sub>i</sub> &gt; 0.
If x is the identity of G, then the identity is returned.
</BLOCKQUOTE>
<H5><A NAME = "9577">LeadingGenerator(x) : GrpGPCElt -&gt; GrpGPCElt</A></H5>
<BLOCKQUOTE>
Given an element x of a polycyclic group G with n pc-generators,
where x is of the form a<sub>1</sub><sup>e<sub>1</sub></sup> ... a<sub>n</sub><sup>e<sub>n</sub></sup>,
return a<sub>i</sub> for the smallest i such that e<sub>i</sub> &gt; 0.
If x is the identity of G, then the identity is returned.
</BLOCKQUOTE>
<H5><A NAME = "9578">LeadingExponent(x) : GrpGPCElt -&gt; RngIntElt</A></H5>
<BLOCKQUOTE>
Given an element x of a polycyclic group G with n pc-generators,
where x is of the form a<sub>1</sub><sup>e<sub>1</sub></sup> ... a<sub>n</sub><sup>e<sub>n</sub></sup>,
return e<sub>i</sub> for the smallest i such that e<sub>i</sub> &gt; 0.
If x is the identity of G, then 0 is returned.
</BLOCKQUOTE>
<H5><A NAME = "9579">Depth(x) : GrpGPCElt -&gt; RngIntElt</A></H5>
<BLOCKQUOTE>
Given an element x of a polycyclic group G with n pc-generators,
where x is of the form a<sub>1</sub><sup>e<sub>1</sub></sup> ... a<sub>n</sub><sup>e<sub>n</sub></sup>,
return the smallest i such that e<sub>i</sub> &gt; 0.
If x is the identity of G, then n + 1 is returned.
<P>
 <TT>Depth</TT> returns the maximal value of i, such that x&isin;G<sub>i</sub>.
</BLOCKQUOTE>
<H4><A NAME = "9580">Arithmetic Operations on Elements</A></H4>

<P>
<P>
Throughout this subsection, G will be a polycyclic group with pc-generators
a<sub>1</sub>, ..., a<sub>n</sub>.


<H5><A NAME = "9581">g * h : GrpGPCElt, GrpGPCElt -&gt; GrpGPCElt</A></H5>
<BLOCKQUOTE>
Product of the element g and the element h, where g and h belong
to some common subgroup G of a polycyclic group U. If g and h are given
as elements belonging to the same proper subgroup G of U, then the
result will be returned as an element of G; if g and h  are given as
elements belonging to distinct subgroups H and K of U, then the
product is returned as an element of G, where G is the smallest
subgroup of U known to contain both elements.
</BLOCKQUOTE>
<H5><A NAME = "9582">g *:= h : GrpGPCElt, GrpGPCElt -&gt;</A></H5>
<BLOCKQUOTE>
Replace g with the product of element g and element h.
</BLOCKQUOTE>
<H5><A NAME = "9583">g ^ n: GrpGPCElt, RngIntElt -&gt; GrpGPCElt</A></H5>
<BLOCKQUOTE>
The n-th power of the element g, where n is a positive or negative integer.
</BLOCKQUOTE>
<H5><A NAME = "9584">g ^:= n: GrpGPCElt, RngIntElt -&gt;</A></H5>
<BLOCKQUOTE>
Replace g with the n-th power of the element g.
</BLOCKQUOTE>
<H5><A NAME = "9585">g / h : GrpGPCElt, GrpGPCElt -&gt; GrpGPCElt</A></H5>
<BLOCKQUOTE>
Quotient of the element g by the element h, i.e. the element g * h<sup> - 1</sup>.
Here g and h must belong to some common subgroup G
of a polycyclic group U. The rules for determining the parent group of g/h
are the same as for g * h.
</BLOCKQUOTE>
<H5><A NAME = "9586">g /:= h : GrpGPCElt, GrpGPCElt -&gt;</A></H5>
<BLOCKQUOTE>
Replace g with g * h<sup> - 1</sup>.
</BLOCKQUOTE>
<H5><A NAME = "9587">g ^ h : GrpGPCElt, GrpGPCElt -&gt; GrpGPCElt</A></H5>
<BLOCKQUOTE>
Conjugate of the element g by the element h, i.e. the element
h<sup> - 1</sup> * g * h. Here g and h must belong to some common subgroup G
of a polycyclic group U. The rules for determining the parent group of g<sup>h</sup>
are the same as for g * h.
</BLOCKQUOTE>
<H5><A NAME = "9588">g ^:= h : GrpGPCElt, GrpGPCElt -&gt;</A></H5>
<BLOCKQUOTE>
Replace g with the conjugate of the element g by the element h.
</BLOCKQUOTE>
<H5><A NAME = "9589">(g<sub>1</sub>, ..., g<sub>n</sub>) : List(GrpGPCElt) -&gt; GrpGPCElt</A></H5>
<BLOCKQUOTE>
Given the n words g<sub>1</sub>, ..., g<sub>n</sub> belonging to some common subgroup
G of a polycyclic group U, compute the <I>left-normed</I> commutator of
g<sub>1</sub>, ..., g<sub>n</sub>. This is defined inductively as follows: (g<sub>1</sub>, g<sub>2</sub>) = g<sub>1</sub><sup> - 1</sup> * g<sub>2</sub><sup> - 1</sup> * g<sub>1</sub> * g<sub>2</sub> and (g<sub>1</sub>, ..., g<sub>n</sub>) = ((g<sub>1</sub>, ..., g<sub>n - 1</sub>), g<sub>n</sub>).
<P>
If g<sub>1</sub>, ..., g<sub>n</sub> are given as elements
belonging to the same proper subgroup G of U, then the result will be
returned as an element of G; if g<sub>1</sub>, ..., g<sub>n</sub>  are given as
elements belonging to distinct subgroups of U, then the product is
returned as an element of G, where G is the smallest subgroup of
U known to contain all elements.
</BLOCKQUOTE>
<H4><A NAME = "9590">Operators for Elements</A></H4>



<H5><A NAME = "9591">Order(x) : GrpGPCElt -&gt; RngIntElt</A></H5>
<BLOCKQUOTE>
The order of the element x.
</BLOCKQUOTE>
<H5><A NAME = "9592">IsFinite(x) : GrpGPCElt -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if the order of the element x is finite, <TT>false</TT> otherwise.
</BLOCKQUOTE>
<H5><A NAME = "9593">Parent(x) : GrpGPCElt -&gt; GrpGPC</A></H5>
<BLOCKQUOTE>
The parent group G of the element x.
</BLOCKQUOTE>
<H4><A NAME = "9594">Comparison Operators for Elements</A></H4>



<H5><A NAME = "9595">g eq h : GrpGPCElt, GrpGPCElt -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Given elements g and h belonging to a common polycyclic group, return <TT>true</TT> if
g and h are the same element, <TT>false</TT> otherwise.
</BLOCKQUOTE>
<H5><A NAME = "9596">g ne h : GrpGPCElt, GrpGPCElt -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Given elements g and h belonging to a common polycyclic group, return <TT>true</TT> if
g and h are distinct elements, <TT>false</TT> otherwise.
</BLOCKQUOTE>
<H5><A NAME = "9597">IsIdentity(g) : GrpGPCElt -&gt; BoolElt</A></H5>
<H5>IsId(g) : GrpGPCElt -&gt; BoolElt</H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if g is the identity element, <TT>false</TT> otherwise.
</BLOCKQUOTE>
<H4><A NAME = "9598">Specification of a Polycyclic Presentation</A></H4>



<H5><A NAME = "9599"></A><A NAME = "GrpGPC:quo_def">quo</A>&lt; GrpGPC : F | R : parameters &gt; : GrpFP, List(GrpFPRel) -&gt; GrpGPC, Map</H5>

<PRE>    <A NAME = "GrpGPC:quo:Check">Check</A>: BoolElt Default: <TT>true</TT></PRE>
<BLOCKQUOTE>
Given a free group F of rank n with generating set X, and a collection
R of polycyclic relations on X, construct the polycyclic group G defined by the polycyclic presentation &lt; X | R &gt;.
<P>
The construct R denotes a list of polycyclic relations. Thus, an
element of R must be one of:
<DL COMPACT class='compact'>
<DT>(a)</DT><DD>A <I>power relation</I> a<sub>i</sub><sup>m<sub>i</sub></sup> = w<sub>i, i</sub>,  i&isin;I &sube;{1, ..., n}, where m<sub>i</sub>&gt;1 is an integer, and
w<sub>i, i</sub> is Id(F) or a word in the generators a<sub>i + 1</sub>, ..., a<sub>n</sub> for
i &lt; n, and w<sub>i, i</sub> = Id(F) for i = n.
<DT>(b)</DT><DD>A <I>conjugate relation</I> a<sub>j</sub><sup>a<sub>i</sub><sup>e</sup></sup> = w<sub>e.i, j</sub>, 1 &le;i &lt; j &le;n,
where w<sub>e.i, j</sub> is a word in the generators a<sub>i + 1</sub>, ..., a<sub>n</sub>,
e = 1 if i&isin;I and e&isin;{-1, 1} if i&notin;I.
<DT>(c)</DT><DD>A <I>power</I> a<sub>i</sub><sup>m<sub>i</sub></sup>,  i&isin;I &sube;{1, ..., n}, where m<sub>i</sub>&gt;1 is an integer, which is
treated as the <I>power relation</I> a<sub>i</sub><sup>m<sub>i</sub></sup> = Id(F).
<DT>(d)</DT><DD>A set of (a) -- (c).
<DT>(e)</DT><DD>A sequence of (a) -- (c).
<P>
<P>
<P>
<P>
</DL>
Note the following points:
<DL COMPACT class='compact'>
<DT>(i)</DT><DD>If there is no power relation for some generator
a<sub>i</sub>, i = 1, ..., n (i.e. i&notin;I), conjugate relations
a<sub>j</sub>^(a<sub>i</sub><sup> - 1</sup>) = w<sub> - i, j</sub> must be present for i&lt;j&le;n (except for pairs
of commuting generators). If there is a power relation for a<sub>i</sub>, on the other
hand, conjugate relations involving a<sub>i</sub><sup> - 1</sup> are not permitted.
<DT>(ii)</DT><DD>Conjugate relations for pairs of commuting generators may be
omitted. If no conjugate relations are given for a certain pair of generators,
the corresponding generators are assumed to commute.
<DT>(iii)</DT><DD>The words w_((i, j)) must be in normal form.
<DT>(iv)</DT><DD>The presentation must be consistent. In particular, right hand 
sides of conjugate relations must not be the empty word.
<P>
<P>
<P>
<P>
</DL>
This constructor returns a polycyclic group because the category <TT>GrpGPC</TT>
is stated. If no category were stated, it would return an fp-group.
<P>
The parameter <A  HREF = "text833.htm#GrpGPC:quo:Check">Check</A> may be used to indicate whether or not the presentation should be checked for consistency. Disabling this check can be useful for avoiding runtime errors if the constructor is called in user written loops or functions. The boolean valued function <A  HREF = "text833.htm#GrpGPC:IsConsistent">IsConsistent</A> is provided to check presentations obtained with disabled consistency check. It should be noted that the results of working with an inconsistent presentation are undefined, hence it is strongly advised to enable the consistency check in the constructor or to use the function <A  HREF = "text833.htm#GrpGPC:IsConsistent">IsConsistent</A>.
<P>
The natural homomorphism from F -&gt; G is returned as second return
value.
</BLOCKQUOTE>
<H5><A NAME = "9600"></A><A NAME = "GrpGPC:PolycyclicGroup">PolycyclicGroup</A>&lt; x<sub>1</sub>, ..., x<sub>n</sub> | R : parameters &gt; : List(Identifiers), List(GrpFPRel) -&gt; GrpGPC, Map</H5>

<PRE>    Check: BoolElt                      Default: <TT>true</TT></PRE>

<PRE>    Class: MonStgElt                    Default: </PRE>
<BLOCKQUOTE>
Construct the polycyclic group G defined by the consistent polycyclic
presentation &lt; x<sub>1</sub>, ..., x<sub>n</sub> | R &gt;.
<P>
The construct x<sub>1</sub>, ..., x<sub>n</sub> defines names for the generators of G
that are local to the constructor, i.e. they are used when writing down
the relations to the right of the bar. However, no assignment of names
to these generators is made. If the user wants to refer to
the generators by these (or other) names, then the <I>generators assignment</I>
construct must be used on the left hand side of an assignment statement.
<P>
The construct R denotes a list of polycyclic relations.
The syntax and semantics for the relations clause is identical to that
appearing in the <A  HREF = "text833.htm#GrpGPC:quo_def">quo</A>-constructor above.
<P>
A map f from the free group on x<sub>1</sub>, ..., x<sub>n</sub> to G is returned as
second return value.
<P>
The parameter <TT>Check</TT> may be used as described for the
<A  HREF = "text833.htm#GrpGPC:quo_def">quo</A>-constructor.
<P>
If R is both, a valid power-conjugate presentation for a finite soluble
group (cf. Chapter <A  HREF = "text706.htm#7978">FINITE SOLUBLE GROUPS</A>) and a consistent polycyclic presentation,
this constructor by default returns a group in the category <A  HREF = "text707.htm#GrpPC"> <TT>GrpPC</TT></A>. To
force creation of a group in the category <TT>GrpGPC</TT>, the parameter
<TT>Class</TT> must be set to <TT>"GrpGPC"</TT> in these situations.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "9601">Example <TT>GrpGPC_Constructor (H77E1)</TT></A></H3>
<DL COMPACT class='compact'>
<DT>(1)</DT><DD>Consider the infinite polycyclic group defined by the presentation
&lt; a, b, c  | b<sup>a</sup> = b * c, (a, c), (b, c) &gt;.
<P>
</DL>
Starting from a free group and giving the relations in the form of a sequence,
this presentation would be specified as follows:
<P>
<P>
<PRE>
&gt; F&lt;a,b,c&gt; := FreeGroup(3);
&gt; rels := [ b^a = b*c, b^(a^-1) = b*c^-1 ];
&gt; G&lt;a,b,c&gt; := quo&lt; GrpGPC : F | rels &gt;;
&gt; G;
GrpGPC : G of infinite order on 3 PC-generators
PC-Relations:
    b^a = b * c, 
    b^(a^-1) = b * c^-1
</PRE>
Note, that the relation b^(a<sup> - 1</sup>) = b * c<sup> - 1</sup> has to be included, although
 it can be derived from the relations b<sup>a</sup> = b * c and (a, b).
<P>
<P>
<P>
<DL COMPACT class='compact'>
<DT>(2)</DT><DD>The infinite dihedral group is obtained as epimorphic image of the 
free group of rank two as follows:
<P>
<P>
</DL>
<PRE>
&gt; F&lt;a,b&gt; := FreeGroup(2);
&gt; D&lt;u,v&gt;, pi := quo&lt;GrpGPC: F | a^2, b^a = b^-1&gt;;
&gt; D;
GrpGPC : D of infinite order on 2 PC-generators
PC-Relations:
    u^2 = Id(D), 
    v^u = v^-1
&gt; pi;
Mapping from: GrpFP: F to GrpGPC: D
</PRE>
<P>
<P>
<P>
<DL COMPACT class='compact'>
<DT>(3)</DT><DD>We create an element e of the group D defined above from a
 sequence of coefficients and extract both its leading generator and its
 leading exponent.
<P>
<P>
</DL>
<PRE>
&gt; e := D ! [1,42];
&gt; e;
u * v^42
&gt; gen := LeadingGenerator(e);
&gt; gen;
u
&gt; Parent(gen);     
GrpGPC : D of infinite order on 2 PC-generators
PC-Relations:
    u^2 = Id(D), 
    v^u = v^-1
&gt; exp := LeadingExponent(e);
&gt; exp;
1
</PRE>
We obtain an element of depth 2 from e, by replacing e with its quotient by
 the appropriate power of the leading generator.
<P>
<P>
<PRE>
&gt; e /:= gen^exp;
&gt; Depth(e);
2
&gt; e;
v^-42
&gt; ElementToSequence(e);
[ 0, -42 ]
</PRE>
<HR>
<H3><A NAME = "9602">Example <TT>GrpGPC_PolycyclicGroup (H77E2)</TT></A></H3>
Using the constructor <A  HREF = "text833.htm#GrpGPC:PolycyclicGroup">PolycyclicGroup</A> with different values of
the parameter <TT>Class</TT>, we construct the dihedral group of order 10 first as
a finite soluble group given by a power-conjugate presentation (<A  HREF = "text707.htm#GrpPC"> <TT>GrpPC</TT></A>)
and next as a general polycyclic group (<TT>GrpGPC</TT>).  Note that the
presentation &lt; a, b  | a<sup>2</sup>, b<sup>5</sup>, b<sup>a</sup>=b<sup>4</sup> &gt; is both a valid
power-conjugate presentation and a consistent polycyclic presentation, so we
have to set the parameter <TT>Class</TT> to <TT>"GrpGPC"</TT> if we want to construct
a group in the category <TT>GrpGPC</TT>.
<P>
<P>
<PRE>
&gt; G1&lt;a,b&gt; := PolycyclicGroup&lt; a,b | a^2, b^5, b^a=b^4 &gt;;
&gt; G1;
GrpPC : G1 of order 10 = 2 * 5
PC-Relations:
    a^2 = Id(G1), 
    b^5 = Id(G1), 
    b^a = b^4
&gt; G2&lt;a,b&gt; := PolycyclicGroup&lt; a,b | a^2, b^5, b^a=b^4 : Class := "GrpGPC"&gt;;
&gt; G2;
GrpGPC : G2 of order 10 = 2 * 5 on 2 PC-generators
PC-Relations:
    a^2 = Id(G2), 
    b^5 = Id(G2), 
    b^a = b^4
</PRE>
We construct the infinite dihedral group as a group in the category
<TT>GrpGPC</TT> from a consistent polycyclic presentation. We do not have to
use the parameter <TT>Class</TT> in this case.
<P>
<P>
<PRE>
&gt; G3&lt;a,b&gt; := PolycyclicGroup&lt; a,b | a^2, b^a=b^-1&gt;;
&gt; G3;
GrpGPC : G3 of infinite order on 2 PC-generators
PC-Relations:
    a^2 = Id(G3), 
    b^a = b^-1
</PRE>
The presentation &lt; a, b  | a<sup>2</sup>, b<sup>4</sup>, b<sup>a</sup>=b<sup>3</sup> &gt; is not a valid
power-conjugate presentation for the dihedral group of order 8, since the
exponent of b is not prime. However, it is a consistent polycyclic
presentation. Consequently, the constructor <TT>PolycyclicGroup</TT> without
specifying a value for the parameter <TT>Class</TT> returns a group in the
category <TT>GrpGPC</TT>.
<P>
<P>
<PRE>
&gt; G4&lt;a,b&gt; := PolycyclicGroup&lt; a,b | a^2, b^4, b^a=b^3 &gt;;
&gt; G4;
GrpGPC : G4 of order 2^3 on 2 PC-generators
PC-Relations:
    a^2 = Id(G3), 
    b^4 = Id(G3), 
    b^a = b^3
</PRE>
<HR>
<H4><A NAME = "9603">Properties of a Polycyclic Presentation</A></H4>



<H5><A NAME = "9604"></A><A NAME = "GrpGPC:IsConsistent">IsConsistent</A>(G) : GrpGPC -&gt; BoolElt</H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if the stored presentation for G is consistent,
<TT>false</TT> otherwise.
</BLOCKQUOTE>
<H5><A NAME = "9605">IsIdenticalPresentation(G, H) : GrpGPC, GrpGPC -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if the polycyclic presentations for G and H are
identical, <TT>false</TT> otherwise.
</BLOCKQUOTE>
<H5><A NAME = "9606"></A><A NAME = "GrpGPC:PresentationIsSmall">PresentationIsSmall</A>(G) : GrpGPC -&gt; BoolElt</H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if only small integers occur in the presentation of G,
<TT>false</TT> otherwise.
The category transfer functions <A  HREF = "text835.htm#GrpGPC:FPGroup">FPGroup</A> and
<A  HREF = "text835.htm#GrpGPC:PCGroup">PCGroup</A> currently support only groups with a small
presentation.
</BLOCKQUOTE>
<PRE></PRE> <A  HREF = "text834.htm">[Next]</A><A  HREF = "text832.htm">[Prev]</A> <A  HREF = "text834.htm">[Right]</A> <A  HREF = "text832.htm">[Left]</A> <A  HREF = "text831.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<br><small>Version: V2.22 of <I>
Thu Jun  9 16:37:49 EST 2016
</I></small>
</body></html>