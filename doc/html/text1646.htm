<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <link rel='stylesheet' href='help.css' type='text/css'>
  <TITLE>Elements of Modular Abelian Varieties</TITLE>
</head>
<body BGCOLOR="#FFFFFF">

 <A  HREF = "text1647.htm">[Next]</A><A  HREF = "text1645.htm">[Prev]</A> <A  HREF = "text1647.htm">[Right]</A> <A  HREF = "text1645.htm">[Left]</A> <A  HREF = "text1635.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<PRE></PRE><H3><A NAME = "18413">Elements of Modular Abelian Varieties</A></H3>

<P>
<P>
<P>
We represent torsion points on modular abelian varieties as follows.
Suppose A is an abelian variety defined over the complex numbers
C.  Then A(C) is canonically isomorphic to
H<sub>1</sub>(A, R)/H<sub>1</sub>(A, Z), and the torsion subgroup of A(C) is
isomorphic to H<sub>1</sub>(A, Q)/H<sub>1</sub>(A, Z).  We represent a torsion element
of A(C) by giving a representative element of H<sub>1</sub>(A, Q).  The
functions below provide basic arithmetic operations with such
elements, application of homomorphisms, and 
conversion functions.   
<P>
Sometimes it is useful to consider elements of H<sub>1</sub>(A, R), given
by floating point vectors (i.e., over <TT>RealField()</TT>). These
represent certain points of infinite order, but without further
information we do not know exactly what point they represent,
or even whether such a point is 0.    
<P>
Elements can only be created independently of other elements by 
coercion, see Section <A  HREF = "text1637.htm#18114">Coercion</A>.



<H5>Subsections</H5>
<UL>
<LI> <A  HREF = "text1646.htm#18414">Arithmetic</A>
<LI> <A  HREF = "text1646.htm#18420">Invariants</A>
<LI> <A  HREF = "text1646.htm#18426">Predicates</A>
<LI> <A  HREF = "text1646.htm#18432">Homomorphisms</A>
<LI> <A  HREF = "text1646.htm#18436">Representation of Torsion Points</A>
</UL>
<H4><A NAME = "18414">Arithmetic</A></H4>

<P>
<P>
<P>
The following commands describe the basic arithmetic operations available for
elements of modular abelian varieties.   Operations include
addition, subtraction, and multiplication by an integer, rational
number, or real number.


<H5><A NAME = "18415">a * x : FldReElt, ModAbVarElt -&gt;  ModAbVarElt</A></H5>
<H5>a * x : FldRatElt, ModAbVarElt -&gt;  ModAbVarElt</H5>
<H5>a * x : RngIntElt, ModAbVarElt -&gt;  ModAbVarElt</H5>
<BLOCKQUOTE>
Product of the integer, rational or real number a by the element x of
a modular abelian variety.  
</BLOCKQUOTE>
<H5><A NAME = "18416">x * a : ModAbVarElt, FldReElt -&gt;  ModAbVarElt</A></H5>
<H5>x * a : ModAbVarElt, FldRatElt -&gt;  ModAbVarElt</H5>
<H5>x * a : ModAbVarElt, RngIntElt -&gt;  ModAbVarElt</H5>
<BLOCKQUOTE>
Product of the element x of a modular abelian variety by 
the integer, rational or real number a.
</BLOCKQUOTE>
<H5><A NAME = "18417">x + y : ModAbVarElt, ModAbVarElt -&gt;  ModAbVarElt</A></H5>
<BLOCKQUOTE>
The sum of elements x and y of a modular abelian variety.  
</BLOCKQUOTE>
<H5><A NAME = "18418">x - y : ModAbVarElt, ModAbVarElt -&gt;  ModAbVarElt</A></H5>
<BLOCKQUOTE>
The difference of elements x minus y of a modular abelian variety.  
</BLOCKQUOTE>
<HR>
<H3><A NAME = "18419">Example <TT>ModAbVar_Elt-Arithmetic (H142E98)</TT></A></H3>
In this example, we construct J<sub>0</sub>(23), and consider the finite
subgroup ker(T<sub>3</sub> - 5), which has order 400.  We then do
various arithmetic operations with some of its elements.
<P>
<P>
<PRE>
&gt; A := JZero(23);
&gt; t3 := HeckeOperator(A,3);
&gt; Factorization(CharacteristicPolynomial(t3));
[
    &lt;x^2 - 5, 2&gt;
]
&gt; G := Kernel(t3-5);
&gt; #G;
400
&gt; Generators(G);
[
    Element of abelian variety defined by [1/10 0 1/10 1/5] modulo homology,
    Element of abelian variety defined by [0 0 0 -5/2] modulo homology,
    Element of abelian variety defined by [1/10 -1/10 0 -1/5] modulo homology,
    Element of abelian variety defined by [1 -3/2 2 1] modulo homology
]
&gt; x := G.1;
&gt; 1.5*x;
Element of abelian variety defined by [0.149999999999999999999999999998 0.E-28 
0.149999999999999999999999999998 
0.299999999999999999999999999996] modulo homology
&gt; (3/2)*x;
Element of abelian variety defined by [3/20 0 3/20 3/10] modulo homology
&gt; 10*x;
0
&gt; x*1.5;
Element of abelian variety defined by [0.149999999999999999999999999998 0.E-28 
0.149999999999999999999999999998 
0.299999999999999999999999999996] modulo homology
&gt; 1.5*x eq x*1.5;
true
&gt; x*(3/2);
Element of abelian variety defined by [3/20 0 3/20 3/10] modulo homology
&gt; x*5;
Element of abelian variety defined by [1/2 0 1/2 1] modulo homology
&gt; G.1 + G.2;
Element of abelian variety defined by [1/10 0 1/10 -23/10] modulo homology
&gt; G.1 - G.2;
Element of abelian variety defined by [1/10 0 1/10 27/10] modulo homology
</PRE>
<HR>
<H4><A NAME = "18420">Invariants</A></H4>

<P>
<P>
<P>
<P>
<P>
These commands compute information about the order of an element,
the degree of the homology of the parent variety, and a field
that the point is defined over. 


<H5><A NAME = "18421">Order(x) : ModAbVarElt -&gt;  RngIntElt</A></H5>
<BLOCKQUOTE>
Given an element of a modular abelian variety x, return the order of x, 
if x is known exactly. Otherwise an error occurs.  
</BLOCKQUOTE>
<H5><A NAME = "18422">ApproximateOrder(x) : ModAbVarElt -&gt;  RngIntElt</A></H5>
<BLOCKQUOTE>
Given a point x on a modular abelian variety return the exact order of x,
if x is known exactly as a torsion point, 
and if not the order of an approximation of x by a torsion point, 
obtained using continued fractions.  
</BLOCKQUOTE>
<H5><A NAME = "18423">Degree(x) : ModAbVarElt -&gt;  RngIntElt</A></H5>
<BLOCKQUOTE>
The dimension of the homology of the parent of x, where x is 
an element of a modular abelian variety.  
</BLOCKQUOTE>
<H5><A NAME = "18424">FieldOfDefinition(x) : ModAbVarElt -&gt;  ModTupFldElt</A></H5>
<BLOCKQUOTE>
A field that x is defined over, which need not be minimal, where 
x is an element of a modular abelian variety.  
</BLOCKQUOTE>
<HR>
<H3><A NAME = "18425">Example <TT>ModAbVar_Elt-Invariants (H142E99)</TT></A></H3>
We compute a 2-torsion point on the elliptic curve J<sub>0</sub>(11),
compute some approximate orders, and compute the degree.
<P>
<P>
<PRE>
&gt; A := JZero(11);
&gt; G := Kernel(nIsogeny(A,2));
&gt; G;
Finitely generated subgroup of abelian variety with invariants 
[ 2, 2 ]
&gt; x := G.1;
&gt; ApproximateOrder(Sqrt(2)*x);
1023286908188737
&gt; ApproximateOrder(1.000000000000001*x);
2
&gt; Degree(x);
2
</PRE>
<P>
Notice that <TT>FieldOfDefinition(x)</TT> is valid, but far from
optimal. It would be better to return the number field generated by
the 2-torsion point.
<P>
<P>
<PRE>
&gt; FieldOfDefinition(x);
Algebraically closed field with no variables
&gt; FieldOfDefinition(0*x);
Rational Field
&gt; Order(x);
2
</PRE>
<HR>
<H4><A NAME = "18426">Predicates</A></H4>

<P>
<P>
<P>
These are commands for testing equality, inclusion, whether an element
is 0, and whether an element is known exactly, (i.e., as an element
of H<sub>1</sub>(A, Q), or just as an element of H<sub>1</sub>(A, R)).


<H5><A NAME = "18427">x eq y : ModAbVarElt, ModAbVarElt -&gt;  BoolElt</A></H5>
<BLOCKQUOTE>
Return <TT>true</TT> if the elements x and y of a modular abelian variety are
equal.  
</BLOCKQUOTE>
<H5><A NAME = "18428">x in X : ModAbVarElt, List -&gt;  BoolElt</A></H5>
<BLOCKQUOTE>
Return <TT>true</TT> if the element x of a modular abelian variety 
is an element of the list X.  
</BLOCKQUOTE>
<H5><A NAME = "18429">IsExact(x) : ModAbVarElt -&gt;  BoolElt</A></H5>
<BLOCKQUOTE>
Return <TT>true</TT> if the element x of a modular abelian variety 
is known exactly, i.e., x is defined by an element of 
the rational homology.  
</BLOCKQUOTE>
<H5><A NAME = "18430">IsZero(x) : ModAbVarElt -&gt;  BoolElt</A></H5>
<BLOCKQUOTE>
Return <TT>true</TT> if the element x of a modular abelian variety
is known exactly and is equal to 0.  If x is
not known exactly, return <TT>true</TT> if a real homology vector that
represents x is "very close" to an element of the integral
homology, where very close means that the distance is
within 1/10<sup>n</sup>, where n is <TT>M`point_precision</TT> and M is the 
parent of x.
<P>
</BLOCKQUOTE>
<HR>
<H3><A NAME = "18431">Example <TT>ModAbVar_Elt-Predicates (H142E100)</TT></A></H3>
<P>
We demonstrate each of these commands using
elements of the 2-torsion subgroups of the two elliptic
curves of conductor 37.
<P>
<P>
<PRE>
&gt; J := JZero(37);
&gt; A, B := Explode(Decomposition(J));
&gt; A;
Modular abelian variety 37A of dimension 1, level 37 and 
conductor 37 over Q
&gt; B;
Modular abelian variety 37B of dimension 1, level 37 and 
conductor 37 over Q
&gt; A2 := Kernel(nIsogeny(A,2));
&gt; B2 := Kernel(nIsogeny(B,2));
&gt; x := A2.1;
&gt; y := B2.2;
&gt; x eq y;
false
&gt; x in [* x, y *];
true
&gt; IsZero(x);
false
&gt; IsZero(0*x);
true
&gt; IsExact(1.0000000000000000000001*x);
false
&gt; IsExact((2/3)*x);
true
</PRE>
For non-exact elements, <TT>IsZero</TT> means
"is quite close to 0".
<P>
<P>
<PRE>
&gt; IsZero(0.0001*x);
false
&gt; IsZero(0.00001*x);
true
&gt; IsZero(0.000000000001*x);
true
&gt; A`point_precision;
10
</PRE>
<HR>
<H4><A NAME = "18432">Homomorphisms</A></H4>

<P>
<P>
<P>
There are two notations for applying a homomorphism to an 
element.  One can find an inverse image of an 
element using the @@ command.


<H5><A NAME = "18433">x @ phi : ModAbVarElt, MapModAbVar -&gt;  ModAbVarElt</A></H5>
<H5>phi(x) : ModAbVarElt, MapModAbVar -&gt;  ModAbVarElt</H5>
<BLOCKQUOTE>
The image of the element x of a modular abelian variety 
under the homomorphism &phi; of abelian varieties.  
</BLOCKQUOTE>
<H5><A NAME = "18434">x @@ phi : ModAbVarElt, MapModAbVar -&gt;  ModAbVarElt</A></H5>
<BLOCKQUOTE>
An inverse image of the element x of a modular abelian variety
under the homomorphism &phi;  of abelian varieties.  
</BLOCKQUOTE>
<HR>
<H3><A NAME = "18435">Example <TT>ModAbVar_Elt-Homomorphisms (H142E101)</TT></A></H3>
Let &phi; = T<sub>3</sub> - 5 acting on the abelian surface J<sub>0</sub>(23).
We apply &phi; to an element of the kernel G of &phi;,
and get 0.  We also find an element y such that &phi;(y)
is a certain element of G.
<P>
<P>
<PRE>
&gt; A := JZero(23);
&gt; phi := HeckeOperator(A,3) - 5;
&gt; G := Kernel(phi);
&gt; x := G.1;
&gt; Order(x);
10
&gt; phi(x);
0
&gt; zero := A!0;
&gt; z := zero@@phi; z;
0
&gt; y := x@@phi; y;
Element of abelian variety defined by [-1/20 1/20 -1/20 -1/20] modulo homology
&gt; phi(y) in G;
true
&gt; y@phi eq phi(y);
true
</PRE>
<HR>
<H4><A NAME = "18436">Representation of Torsion Points</A></H4>

<P>
<P>
<P>
An exact torsion point representation of an element of a modular abelian
variety can be found using continued fractions to find good rational 
approximations for each coordinate of a representative real homology class.
A representative element of the homology can also be retrieved.
<P>
The <TT>Eltseq</TT> command gives the sequence of entries of the
vector returned by <TT>Element</TT>.


<H5><A NAME = "18437">ApproximateByTorsionPoint(x : parameters) : ModAbVarElt -&gt;  ModAbVarElt</A></H5>

<PRE>    Cutoff: RngIntElt                   Default: 10^3</PRE>
<BLOCKQUOTE>
If the modular abelian variety element 
x is defined by an element z in the real homology H<sub>1</sub>(A, R), 
find an element of H<sub>1</sub>(A, Q ) which 
approximates z, using continued fractions, 
and return the corresponding point.  
</BLOCKQUOTE>
<H5><A NAME = "18438">Element(x) : ModAbVarElt -&gt;  ModTupFldElt</A></H5>
<BLOCKQUOTE>
The vector in homology which represents the element x of a modular abelian 
variety.  
</BLOCKQUOTE>
<H5><A NAME = "18439">LatticeCoordinates(x) : ModAbVarElt -&gt;  ModTupFldElt</A></H5>
<BLOCKQUOTE>
A vector over the rational or real field which represents the element x with 
respect to the basis for integral homology of the parent abelian variety of x.
</BLOCKQUOTE>
<H5><A NAME = "18440">Eltseq(x) : ModAbVarElt -&gt;  SeqEnum</A></H5>
<BLOCKQUOTE>
The <TT>Eltseq</TT> of <TT>LatticeCoordinates(x)</TT> where x is an 
element of a modular abelian variety.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "18441">Example <TT>ModAbVar_Elt-Representation_of_Torsion_Points (H142E102)</TT></A></H3>
<P>
This code illustrates each of the commands for a 3-torsion
point in J<sub>0</sub>(33).
<P>
<P>
<PRE>
&gt; A := JZero(33);
&gt; x := A![1/3,0,0,0,0,0];
&gt; x;
Element of abelian variety defined by [1/3 0 0 0 0 0] modulo homology
&gt; Order(x);
3
&gt; ApproximateByTorsionPoint(1.001*x);
Element of abelian variety defined by [1001/3000 0 0 0 0 0] modulo homology
&gt; Element(x);
(1/3   0   0   0   0   0)
&gt; Eltseq(x);
[ 1/3, 0, 0, 0, 0, 0 ]
&gt; LatticeCoordinates(x);
(1/3   0   0   0   0   0)
</PRE>
<P>
The <TT>Element</TT> and <TT>LatticeCoordinates</TT> can differ when the
integral structure on the homology is complicated.  This is common
when the weight is bigger than 2.  
<P>
<P>
<PRE>
&gt; A := JZero(11,4); A;
Modular motive JZero(11,4) of dimension 2 and level 11 over Q
&gt; x := A![1/3,0,0,0];
&gt; Element(x);
(  1/8  1/24 -1/24 -1/24)
&gt; Eltseq(x);
[ 1/3, 0, 0, 0 ]
&gt; LatticeCoordinates(x);
(1/3   0   0   0)
&gt; x;
Element of abelian variety defined by [1/3 0 0 0] modulo homology
</PRE>
<HR>
<PRE></PRE> <A  HREF = "text1647.htm">[Next]</A><A  HREF = "text1645.htm">[Prev]</A> <A  HREF = "text1647.htm">[Right]</A> <A  HREF = "text1645.htm">[Left]</A> <A  HREF = "text1635.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<br><small>Version: V2.22 of <I>
Thu Jun  9 16:37:49 EST 2016
</I></small>
</body></html>