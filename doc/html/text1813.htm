<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <link rel='stylesheet' href='help.css' type='text/css'>
  <TITLE>Vertex and Edge Decorations</TITLE>
</head>
<body BGCOLOR="#FFFFFF">

 <A  HREF = "text1814.htm">[Next]</A><A  HREF = "text1812.htm">[Prev]</A> <A  HREF = "text1814.htm">[Right]</A> <A  HREF = "text1812.htm">[Left]</A> <A  HREF = "text1809.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<PRE></PRE><H3><A NAME = "20066">Vertex and Edge Decorations</A></H3>




<H5>Subsections</H5>
<UL>
<LI> <A  HREF = "text1813.htm#20067">Vertex Decorations: Labels</A>
<LI> <A  HREF = "text1813.htm#20081">Edge Decorations</A>
<LI> <A  HREF = "text1813.htm#20105">Unlabelled, or Uncapacitated, or Unweighted Graphs</A>
</UL>
<H4><A NAME = "20067">Vertex Decorations: Labels</A></H4>

<P>
<P>
<P>
<P>
<P>
<P>
In this implementation, it is only possible to assign labels 
as vertex decorations.
<P>
A vertex labelling of a graph G is a partial map from
  the vertex-set of G into a set L of labels.


<H5><A NAME = "20068">AssignLabel(~G, u, l) : GrphMult, GrphVert, . -&gt;</A></H5>
<BLOCKQUOTE>
Assigns the label l to the vertex u in the graph G.
</BLOCKQUOTE>
<H5><A NAME = "20069"></A><A NAME = "MultiGraph:AssignLabels">AssignLabels</A>(~G, S, L) : GrphMult, [GrphVert], SeqEnum -&gt;</H5>
<H5>AssignLabels(~G, S, L) : GrphMult, {@ GrphVert @}, SeqEnum -&gt;</H5>
<BLOCKQUOTE>
Assigns the labels in L to the corresponding vertices in G in the
   sequence or indexed set S.  
If for vertex u the corresponding entry 
  in L is not defined then any existing label of
  u is removed.
</BLOCKQUOTE>
<H5><A NAME = "20070">AssignVertexLabels(~G, L) : GrphMult, SeqEnum -&gt;</A></H5>
<BLOCKQUOTE>
Assigns the labels in L to the corresponding vertices in the
  graph G.
</BLOCKQUOTE>
<H5><A NAME = "20071">IsLabelled(u) : GrphVert -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if and only if the vertex u has a label.
</BLOCKQUOTE>
<H5><A NAME = "20072">IsLabelled(V) : GrphVertSet -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if and only if the vertex-set V is labelled.
</BLOCKQUOTE>
<H5><A NAME = "20073">IsVertexLabelled(G) : GrphMult -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if and only if vertices of the graph G are labelled.
</BLOCKQUOTE>
<H5><A NAME = "20074">Label(u) : GrphVert -&gt; .</A></H5>
<BLOCKQUOTE>
The label of the vertex u.  
An error is raised if u is not labelled.
</BLOCKQUOTE>
<H5><A NAME = "20075">Labels(S) : [GrphVert] -&gt; SeqEnum</A></H5>
<BLOCKQUOTE>
The sequence L of labels of the vertices in the sequence S.  
If an element of S has no label, 
  then the corresponding entry in L is undefined.
</BLOCKQUOTE>
<H5><A NAME = "20076">Labels(V) : GrphVertSet -&gt; SeqEnum</A></H5>
<BLOCKQUOTE>
The sequence L of labels of the vertices in the vertex-set V.  
If an element of V has no label, 
    then the corresponding entry in L is undefined.
</BLOCKQUOTE>
<H5><A NAME = "20077">VertexLabels(G) : GrphMult -&gt; SeqEnum</A></H5>
<BLOCKQUOTE>
The sequence L of labels of the vertices of G.  
If a vertex of G has no label, then the 
   corresponding entry in L is undefined.
</BLOCKQUOTE>
<H5><A NAME = "20078">DeleteLabel(~G, u) : GrphMult, GrphVert -&gt;</A></H5>
<BLOCKQUOTE>
Removes the label of the vertex u.
</BLOCKQUOTE>
<H5><A NAME = "20079">DeleteLabels(~G, S) : GrphMult, [GrphVert] -&gt;</A></H5>
<BLOCKQUOTE>
Remove the labels of the vertices in S.
</BLOCKQUOTE>
<H5><A NAME = "20080">DeleteVertexLabels(~G) : GrphMult -&gt;</A></H5>
<BLOCKQUOTE>
Remove the labels of the vertices in the graph G.
</BLOCKQUOTE>
<H4><A NAME = "20081">Edge Decorations</A></H4>

<P>
<P>
<P>
<P>
<P>
<P>
Simple graph or multigraph edges can be assigned three
  different types of decorations:
<DL COMPACT class='compact'>
<DT>-</DT><DD>a label,
<DT>-</DT><DD>a capacity,
<DT>-</DT><DD>a weight.
<P>
<P>
</DL>
Edge labels can be objects of any Magma type.
Edge capacities
  must be non-negative integers (and loops must be assigned
  a zero capacity).
Edge weights must be elements of a totally ordered ring.
Not all edges need to be assigned labels 
   when labelling edges, nor do all edges need to be
   assigned capacities or weights when assigning either 
   decoration.
In the latter case, if some edges have been assigned 
   a capacity or a weight, then 
   the capacity or weight of any remaining unassigned 
   edge is always taken to be zero.
<P>
One may want to assign capacities to edges in order 
  to apply a network-flow algorithm to 
  the graph (Section <A  HREF = "text1828.htm#20291">Maximum Flow and Minimum Cut</A>).
By assigning weights to edges one may also be able 
  to run a shortest-path algorithm (Section <A  HREF = "text1821.htm#20253">Distances, Shortest Paths and Minimum Weight Trees</A>).


<H5><A NAME = "20082">Assigning Edge Decorations</A></H5>



<H5><A NAME = "20083">AssignLabel(~G, e, l) : GrphMult, GrphEdge, . -&gt;</A></H5>
<H5>AssignCapacity(~G, e, c) : GrphMult, GrphEdge, RngIntElt  -&gt;</H5>
<H5>AssignWeight(~G, e, w) : GrphMult, GrphEdge, RngElt  -&gt;</H5>
<BLOCKQUOTE>
Assigns the label l or the capacity c or the weight w to the
edge e in the graph G.
The capacity of any edge must be a non-negative integer except in
the case of a loop when it must be zero.
The weight w must be an element from a totally ordered ring.
</BLOCKQUOTE>
<H5><A NAME = "20084">AssignLabels(~G, S, D) : GrphMult, [GrphEdge], SeqEnum -&gt;</A></H5>
<H5>AssignLabels(~G, S, D) : GrphMult, {@ GrphEdge @}, SeqEnum -&gt;</H5>
<H5>AssignCapacities(~G, S, D) : GrphMult, [GrphEdge], [RngIntElt] -&gt;</H5>
<H5>AssignCapacities(~G, S, D) : GrphMult, {@ GrphEdge @}, [RngIntElt] -&gt;</H5>
<H5>AssignWeights(~G, S, D) : GrphMult, [GrphEdge], [RngElt] -&gt;</H5>
<H5>AssignWeights(~G, S, D) : GrphMult, {@ GrphEdge @}, [RngElt] -&gt;</H5>
<BLOCKQUOTE>
Assigns the labels or capacities or  
   weights in the sequence D to the corresponding edges in the
   sequence or indexed set S.  
If for some edge e the corresponding entry in D 
   is not defined then any existing label or capacity or weight of
   e is removed.
The same constraints regarding capacity and weight 
  apply as in the single edge assignment case.
</BLOCKQUOTE>
<H5><A NAME = "20085">AssignEdgeLabels(~G, D) : GrphMult, SeqEnum -&gt;</A></H5>
<H5>AssignCapacities(~G, D) : GrphMult,  [RngIntElt] -&gt;</H5>
<H5>AssignWeights(~G, D) : GrphMult, [RngElt] -&gt;</H5>
<BLOCKQUOTE>
Assigns the labels or capacities or  
   weights in the sequence D to the corresponding edges in graph G.
Let E be the edge-set of G and let
  d be the decoration at position i in D, that is, d = D[i].
Then the corresponding edge e in E which will be 
  decorated is E.i (see <A  HREF = "text1812.htm#MultiGraph:E.i">E.i</A>).
<P>
If for some edge e the corresponding entry in D 
   is not defined then any existing label or capacity or weight of
   e is removed.
The same constraints regarding capacity and weight 
  apply as in the single edge assignment case.
</BLOCKQUOTE>
<H5><A NAME = "20086">Testing for Edge Decorations</A></H5>

<P>
<P>
<P>
<P>
<P>
<P>
While it is the case that an edge is considered 
  to be labelled if and only if it has been assigned 
  a label, an edge may have a default capacity (weight) of zero.
Let e be an edge of a graph G and assume that e has not 
  been assigned a capacity (weight).
<P>
If any other edge of G has been assigned a capacity (weight), 
  then the edge-set of G is considered to be capacitated
  (weighted).
In which case the capacity (weight) of e has a default value of zero.
<P>
If no other edge of G has been assigned a capacity (weight), 
  then the edge-set of G is considered to be uncapacitated
  (unweighted).
In which case asking for the capacity (weight) of e results 
  in an error.
<P>
This is in contrast to the labelling situation where there is
  no concept of a "default" label.
The edge-set of G is considered to be labelled if and only if 
  at least one edge of G has been labelled,
while any edge of G is considered to be labelled if and only if 
  e has been labelled.


<H5><A NAME = "20087">IsLabelled(e) : GrphEdge -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if and only if the edge e has a label.
</BLOCKQUOTE>
<H5><A NAME = "20088">IsLabelled(E) : GrphEdgeSet -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if and only if the edge-set is labelled;
  that is, if and only if at least one edge of 
  E has been assigned a label.
<P>
</BLOCKQUOTE>
<H5><A NAME = "20089">IsEdgeLabelled(G) : GrphMult -&gt; BoolElt</A></H5>
<H5>IsEdgeLabelled(G) : Grph -&gt; BoolElt</H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if and only if the edge-set of G is labelled.
</BLOCKQUOTE>
<H5><A NAME = "20090">IsCapacitated(E) : GrphEdgeSet -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if and only if the edge-set is capacitated;
  that is, if and only if at least one edge of 
  E has been assigned a capacity.
</BLOCKQUOTE>
<H5><A NAME = "20091">IsEdgeCapacitated(G) : GrphMult -&gt; BoolElt</A></H5>
<H5>IsEdgeCapacitated(G) : Grph -&gt; BoolElt</H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if and only if the edge-set of G is capacitated.
</BLOCKQUOTE>
<H5><A NAME = "20092">IsWeighted(E) : GrphEdgeSet -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if and only if the edge-set is weighted;
  that is, if and only if at least one edge of 
  E has been assigned a weight.
</BLOCKQUOTE>
<H5><A NAME = "20093">IsEdgeWeighted(G) : GrphMult -&gt; BoolElt</A></H5>
<H5>IsEdgeWeighted(G) : Grph -&gt; BoolElt</H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if and only if the edge-set of G is weighted.
</BLOCKQUOTE>
<H5><A NAME = "20094">Reading Edge Decorations</A></H5>

<P>
<P>
<P>
<P>
<P>
<P>
An edge may have a default capacity and weight of zero, see 
  Subsubsection <A  HREF = "text1813.htm#20086">Testing for Edge Decorations</A> for 
  more details.


<H5><A NAME = "20095">Label(e) : GrphEdge -&gt; .</A></H5>
<BLOCKQUOTE>
The label of the edge e. 
An error is raised if e has not been assigned a capacity.
</BLOCKQUOTE>
<H5><A NAME = "20096">Capacity(e) : GrphEdge -&gt; RngIntElt</A></H5>
<BLOCKQUOTE>
The capacity  of the edge e. 
Let G be the parent graph of e.
An error is raised if the edge-set of G is uncapacitated.
If the edge-set of G is capacitated but e has not been assigned 
  a capacity, then <TT>Capacity(e)</TT> returns zero as the default value.
</BLOCKQUOTE>
<H5><A NAME = "20097">Weight(e) : GrphEdge -&gt; RngElt</A></H5>
<BLOCKQUOTE>
The weight  of the edge e. 
Let G be the parent graph of e.
An error is raised if the edge-set of G is unweighted.
If the edge-set of G is weighted but e has not been assigned 
  a weight, then <TT>Weight(e)</TT> returns zero as the default value.
</BLOCKQUOTE>
<H5><A NAME = "20098">Labels(S) : [GrphEdge] -&gt; SeqEnum</A></H5>
<H5>Capacities(S) : [GrphEdge] -&gt; SeqEnum</H5>
<H5>Weights(S) : [GrphEdge] -&gt; SeqEnum</H5>
<BLOCKQUOTE>
The sequence D of labels or capacities or weights 
   of the edges in the sequence S.  
Let E be the edge-set of the parent graph of the edges.
If E is unlabelled or uncapacitated or unweighted
  then D is the null sequence.
If an element of S has no label 
   then the corresponding entry in D is undefined.
If an element of S has no capacity or weight  
   while E is capacitated or weighted
   then the corresponding entry in D has the default value of zero.
</BLOCKQUOTE>
<H5><A NAME = "20099">Labels(E) : GrphEdgeSet -&gt; SeqEnum</A></H5>
<H5>Capacities(E) : GrphEdgeSet -&gt; SeqEnum</H5>
<H5>Weights(E) : GrphEdgeSet -&gt; SeqEnum</H5>
<BLOCKQUOTE>
The sequence D of labels or capacities or weights 
   of the edges in the edge-set E.
If E is unlabelled or uncapacitated or unweighted
  then D is the null sequence.
If an element of E has no label 
   then the corresponding entry in D is undefined.
If an element of E has no capacity or weight  
   while E is capacitated or weighted
   then the corresponding entry in D has the default value of zero.
The corresponding entry i in D of any edge e is such that 
  e = E.i (see <A  HREF = "text1812.htm#MultiGraph:E.i">E.i</A>).
</BLOCKQUOTE>
<H5><A NAME = "20100">EdgeLabels(G) : GrphMult -&gt; SeqEnum</A></H5>
<H5>EdgeLabels(G) : Grph -&gt; SeqEnum</H5>
<H5>EdgeCapacities(G) : GrphMult -&gt; SeqEnum</H5>
<H5>EdgeCapacities(G) : Grph -&gt; SeqEnum</H5>
<H5>EdgeWeights(G) : GrphMult -&gt; SeqEnum</H5>
<H5>EdgeWeights(G) : Grph -&gt; SeqEnum</H5>
<BLOCKQUOTE>
The sequence D of labels or capacities or weights 
   of the edges in edge-set E of the graph G.
If E is unlabelled or uncapacitated or unweighted
  then D is the null sequence.
If an element of E has no label 
   then the corresponding entry in D is undefined.
If an element of E has no capacity or weight  
   while E is capacitated or weighted
   then the corresponding entry in D has the default value of zero.
The corresponding entry i in D of any edge e is such that 
  e = E.i (see <A  HREF = "text1812.htm#MultiGraph:E.i">E.i</A>).
</BLOCKQUOTE>
<H5><A NAME = "20101">Deleting Edge Decorations</A></H5>



<H5><A NAME = "20102">DeleteLabel(~G, e) : GrphMult, GrphEdge -&gt;</A></H5>
<H5>DeleteCapacity(~G, e) : GrphMult, GrphEdge -&gt;</H5>
<H5>DeleteWeight(~G, e) : GrphMult, GrphEdge -&gt;</H5>
<BLOCKQUOTE>
Removes the label or capacity or weight of the edge e in the graph G.
</BLOCKQUOTE>
<H5><A NAME = "20103">DeleteLabels(~G, S) : GrphMult, [GrphEdge] -&gt;</A></H5>
<H5>DeleteCapacities(~G, S) : GrphMult, [GrphEdge] -&gt;</H5>
<H5>DeleteWeights(~G, S) : GrphMult, [GrphEdge] -&gt;</H5>
<BLOCKQUOTE>
Remove the labels or capacities or weights of the edges (of the graph G) in S.
</BLOCKQUOTE>
<H5><A NAME = "20104">DeleteEdgeLabels(~G) : GrphMult -&gt;</A></H5>
<H5>DeleteCapacities(~G) : GrphMult -&gt;</H5>
<H5>DeleteWeights(~G) : GrphMult -&gt;</H5>
<BLOCKQUOTE>
Remove the labels  or capacities or weights of the edges in the edge
  set of the graph G.
</BLOCKQUOTE>
<H4><A NAME = "20105">Unlabelled, or Uncapacitated, or Unweighted Graphs</A></H4>

<P>
<P>
<P>
<P>
<P>
<P>
Starting with a graph G, the functions below return a graph that is
isomorphic as a simple graph to G, but without the vertex and edge 
labels of G, (or without the edge capacities or weights of G in the case of a 
network).  Should one require a copy of a graph without the support of G,
  see Subsection <A  HREF = "text1784.htm#19691">Operations on the Support</A>.
Should one require a copy of a graph without the support of G
  <I>and</I> without the vertex/edge decorations of G, see 
  Subsection <A  HREF = "text1815.htm#20158">Converting between Simple Graphs and Multigraphs</A>.


<H5><A NAME = "20106">UnlabelledGraph(G) : GrphMult -&gt; GrphMult</A></H5>
<BLOCKQUOTE>
Return the (vertex and edge) unlabelled graph structurally identical 
to G, whose edges have the same capacities and weights as those in G.
The support of G is also retained in the resulting graph.
</BLOCKQUOTE>
<H5><A NAME = "20107">UncapacitatedGraph(G) : GrphMult -&gt; GrphMult</A></H5>
<BLOCKQUOTE>
Return the uncapacitated graph structurally identical to G, 
whose vertices and edges have the same labels, and whose edges have 
the same weights as those in G.
The support of G is also retained in the resulting graph.
</BLOCKQUOTE>
<H5><A NAME = "20108">UnweightedGraph(G) : GrphMult -&gt; GrphMult</A></H5>
<BLOCKQUOTE>
Return the unweighted graph structurally identical to G, whose 
vertices and edges have the same labels, and whose edges have the 
same capacities as those in G.
The support of G is also retained in the resulting graph.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "20109">Example <TT>MultiGraph_GrphMult_Labels (H156E5)</TT></A></H3>
The labelling operations are illustrated by constructing a 2-colouring
of the complete bipartite graph K<sub>3, 4</sub>. 
Use is made of the function <TT>Distance</TT>(u, v) which returns the distance 
between vertices u and v.
<P>
<P>
<PRE>
&gt; K34, V, E := BipartiteGraph(3, 4);
&gt; L := [ IsEven(Distance(V!1, v)) select "red" else "blue" : v in Vertices(K34) ];
&gt; AssignLabels(Vertices(K34), L);
&gt; VertexLabels(K34);                                          
[ red, red, red, blue, blue, blue, blue ]
</PRE>
<HR>
<H3><A NAME = "20110">Example <TT>MultiGraph_CayleyGraph (H156E6)</TT></A></H3>
Another illustration is the creation of the Cayley graph of a group.  
In this example Sym(4) is used.
<P>
<P>
<PRE>
&gt; G&lt;a,b&gt; := FPGroup(Sym(4));
&gt; I, m := Transversal(G, sub&lt;G | 1&gt;);
&gt; S := Setseq(Generators(G));
&gt; N := [ {m(a*b) : b in S} : a in I ];      
&gt; graph := StandardGraph(Digraph&lt; I | N &gt;);
&gt; AssignLabels(VertexSet(graph), IndexedSetToSequence(I));
&gt; V := VertexSet(graph); 
&gt; E := EdgeSet(graph);
&gt; for i in [1..#I] do
&gt;     AssignLabels([ E![V | i, Index(I, m(I[i]*s))] : s in S], S);
&gt; end for;
</PRE>
In this graph, [1,2,5,4] is a cycle.  
So the corresponding edge labels should multiply to the identity.
<P>
<P>
<PRE>
&gt; &amp;*Labels([ EdgeSet(graph) | [1,2], [2,5], [5,4], [4,1] ]);        
a^4
&gt; G;
Finitely presented group G on 2 generators
Relations
    b^2 = Id(G)
    a^4 = Id(G)
    (a^-1 * b)^3 = Id(G)
</PRE>
<HR>
<H3><A NAME = "20111">Example <TT>MultiGraph_GrphMult_EdgesDecs (H156E7)</TT></A></H3>
We turn to multigraphs to illustrate a point 
<P>
  with respect to the listing of the edge decorations.
We assign random labels, capacities and weights 
  to a multigraph.
<P>
<P>
<PRE>
&gt; G := MultiGraph&lt; 3 | &lt; 1, {2, 3} &gt;, &lt; 1, {2} &gt;, &lt; 2, {2, 3} &gt; &gt;;
&gt; E := EdgeSet(G);
&gt; I := Indices(G);
&gt; 
&gt; for i in I do
&gt;     AssignLabel(~G, E.i, Random([ "a", "b", "c", "d" ]));
&gt;     if not InitialVertex(E.i) eq TerminalVertex(E.i) then
&gt;         AssignCapacity(~G, E.i, Random(1, 3));
&gt;     end if;
&gt;     AssignWeight(~G, E.i, Random(1, 3));
&gt; end for;
&gt; 
&gt; EdgeLabels(G);
[ c, undef, c, undef, d, undef, c, undef, c ]
&gt; EdgeCapacities(G);
[ 2, undef, 3, undef, 2, undef, 0, undef, 3 ]
&gt; EdgeWeights(G);
[ 3, undef, 2, undef, 1, undef, 2, undef, 1 ]
</PRE>
Since G is undirected, the edge {v, u} and the edge {v, u}
  are the same object, and thus they have the same index:
<P>
<P>
<PRE>
&gt; V := VertexSet(G);
&gt; u := V!1;
&gt; v := V!3;
&gt; Indices(u, v);
[ 3 ]
&gt; Indices(v, u);
[ 3 ]
</PRE>
However, since G is represented by means of an adjacency list,
  the undirected edge {u, v} is stored twice in the list,
  and so there are two positions in the list associated 
  with the edge.
By convention, these positions are contiguous,  
  but, more importantly from the user's perspective,
  the function <TT>Index</TT> that returns the index of the edge 
  {u, v} <I>always</I> returns the odd index associated with the
  edge.
This explains why, for an undirected multigraph, the sequence returned
  by a function like <TT>EdgeLabels</TT> will always have undefined
  elements.
<P>
Finally note that the loop {2, 2}, which was assigned no capacity,
  is shown to have capacity zero:
<P>
<P>
<PRE>
&gt; E := EdgeSet(G);
&gt; E.7;
&lt; {2, 2}, 7 &gt;
&gt; Capacity(E.7);
0
</PRE>
This is in accordance with the definition of the default value
  for edge  capacity  and weight 
  (see Subsubsection <A  HREF = "text1813.htm#20086">Testing for Edge Decorations</A>).
<HR>
<PRE></PRE> <A  HREF = "text1814.htm">[Next]</A><A  HREF = "text1812.htm">[Prev]</A> <A  HREF = "text1814.htm">[Right]</A> <A  HREF = "text1812.htm">[Left]</A> <A  HREF = "text1809.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<br><small>Version: V2.22 of <I>
Thu Jun  9 16:37:49 EST 2016
</I></small>
</body></html>