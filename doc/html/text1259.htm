<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <link rel='stylesheet' href='help.css' type='text/css'>
  <TITLE>The Homomorphism Type</TITLE>
</head>
<body BGCOLOR="#FFFFFF">

 <A  HREF = "text1260.htm">[Next]</A><A  HREF = "text1258.htm">[Prev]</A> <A  HREF = "text1260.htm">[Right]</A> <A  HREF = "text1258.htm">[Left]</A> <A  HREF = "text1254.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<PRE></PRE><H3><A NAME = "13844">The Homomorphism Type</A></H3>

<P>
<P>
Magma has a special type for a homomorphism between two R-modules.
The type of such a homomorphism is <TT>ModMPolHom</TT>.
In general, functions such as <A  HREF = "text1260.htm#PMod:Morphism">Morphism</A> return a homomorphism
of type <TT>ModMPolHom</TT>, while the boundary maps of complexes are also of
type <TT>ModMPolHom</TT> (see the function <A  HREF = "text1266.htm#PMod:FreeResolution">FreeResolution</A>).
<P>
A homomorphism f: M -&gt; N is represented by a matrix A.  There
are two ways in which A can be defined:
<DL COMPACT class='compact'>
<DT>(a)</DT><DD>A is an <B>ambient</B> matrix: in this case, A gives the
explicit map on the <I>ambient</I> modules of M and N.
Thus A is m x n, where m=<TT>Degree(M)</TT>, n=<TT>Degree(N)</TT>.
<DT>(b)</DT><DD>A is a <B>presentation</B> matrix: in this case, A gives
the explicit map on the <I>presentation</I> modules of M and N.
Thus A is m x n, where m=<TT>Degree(Presentation(M))</TT>, n=<TT>Degree(Presentation(N))</TT>.
<P>
<P>
<P>
</DL>
If M and N are reduced (a common case), then they equal their
respective presentation modules, so there is no difference between
the above two cases (the ambient matrix and the presentation matrix
are identical).  So the only difference between (a) and (b) occurs when
at least one of M and N is a non-ambient (proper) submodule of an
embedded module.
<P>
<P>
<P>
When M and N are graded - that is, generated by elements homogeneous with
respect to the ambient column weightings and with a relation module that is
also generated by homogeneous elements - all homomorphisms as non-graded
modules are still allowed. However there are functions to test if a given
homomorphism preserves the gradings on the domain and codomain up to a 
constant degree shift. See <TT>IsHomogeneous</TT> and <TT>Degree</TT> below.


<H5><A NAME = "13845">Homomorphism(M, N, A): ModMPol, ModMPol, Mtrx -&gt; ModMPolHom</A></H5>

<PRE>    Presentation: BoolElt               Default: <TT>true</TT></PRE>
<BLOCKQUOTE>
Given R-modules M and N and an m x n
matrix A over R, construct the homomorphism f:M -&gt; N
(with type <TT>ModMPolHom</TT>) defined by A.
<P>
By default, A is assumed to be a presentation matrix (see the comments
above), in which case m and n must equal the degrees of the
presentation modules of M and N, respectively.  Alternatively,
setting the parameter <TT>Presentation</TT> to {<TT>false</TT>} specifies that A
is an ambient matrix; in this case, m and n must equal the degrees
of M and N, respectively.
</BLOCKQUOTE>
<H5><A NAME = "13846">Domain(f) : ModMPolHom -&gt; ModMPol</A></H5>
<BLOCKQUOTE>
Given a module homomorphism f:M -&gt; N, return the domain M.
</BLOCKQUOTE>
<H5><A NAME = "13847">Codomain(f) : ModMPolHom -&gt; ModMPol</A></H5>
<BLOCKQUOTE>
Given a module homomorphism f:M -&gt; N, return the codomain N.
</BLOCKQUOTE>
<H5><A NAME = "13848">PresentationMatrix(f) : ModMPolHom -&gt; ModMatRngElt</A></H5>
<H5>Matrix(f) : ModMPolHom -&gt; ModMatRngElt</H5>
<BLOCKQUOTE>
Given a module homomorphism f:M -&gt; N, return the presentation
matrix A<sub>P</sub> of f as an m x n matrix corresponding to the
presentation modules of M and N, respectively.  This presentation matrix is always
well-defined and computed, even if f is constructed via an ambient matrix.
</BLOCKQUOTE>
<H5><A NAME = "13849">AmbientMatrix(f) : ModMPolHom -&gt; ModMatRngElt</A></H5>
<H5>Matrix(f) : ModMPolHom -&gt; ModMatRngElt</H5>
<BLOCKQUOTE>
Given a module homomorphism f:M -&gt; N, return the ambient
matrix A<sub>A</sub> of f as an m x n corresponding to the
ambient modules of M and N, respectively.  If M and N are reduced
(as commonly happens), this will be the same as the presentation matrix above.
But if M and N are not reduced and f is constructed via a
presentation matrix, then an error may result (since it may be impossible
to give a matrix over the base ring R which gives the mapping for the
ambient modules).
</BLOCKQUOTE>
<H5><A NAME = "13850">f(v) : ModMPolHom, RngMPolElt -&gt; RngMPolElt</A></H5>
<H5>v * f : ModMPolHom, RngMPolElt -&gt; RngMPolElt</H5>
<BLOCKQUOTE>
Given a module homomorphism f:M -&gt; N and an element v of M,
return the image of v under f, as an element of N.
</BLOCKQUOTE>
<H5><A NAME = "13851">f[i] : ModMPolHom, RngIntElt -&gt; RngMPolElt</A></H5>
<BLOCKQUOTE>
Given a module homomorphism f:M -&gt; N and an integer i,
return the element of N corresponding to the i-th row of the
ambient matrix of f.
</BLOCKQUOTE>
<H5><A NAME = "13852">Image(f) : ModMPolHom -&gt; ModMPol</A></H5>
<BLOCKQUOTE>
Given a module homomorphism f:M -&gt; N, return the image of f
as a submodule of N (which will be reduced iff N is).
</BLOCKQUOTE>
<H5><A NAME = "13853">Kernel(f) : ModMPolHom -&gt; ModMPol</A></H5>
<BLOCKQUOTE>
Given a module homomorphism f:M -&gt; N, return the kernel of f
as a submodule of M (which will be reduced iff M is).
</BLOCKQUOTE>
<H5><A NAME = "13854">Cokernel(f) : ModMPolHom -&gt; ModMPol</A></H5>
<BLOCKQUOTE>
Given a module homomorphism f:M -&gt; N, return the cokernel of f
as a quotient module of N (which will be reduced iff N is).
</BLOCKQUOTE>
<H5><A NAME = "13855">IsZero(f) : ModMPolHom -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Given a module homomorphism f:M -&gt; N, return whether f is
the zero map.  Note that f may be the zero map even if the presentation
or ambient matrices of f are non-zero.
</BLOCKQUOTE>
<H5><A NAME = "13856">IsInjective(f) : ModMPolHom -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Given a module homomorphism f:M -&gt; N, return whether f is
injective (whether the kernel of f is the zero module).
</BLOCKQUOTE>
<H5><A NAME = "13857">IsSurjective(f) : ModMPolHom -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Given a module homomorphism f:M -&gt; N, return whether f is
surjective (whether the image of f equals N).
</BLOCKQUOTE>
<H5><A NAME = "13858">IsBijective(f) : ModMPolHom -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Given a module homomorphism f:M -&gt; N, return whether f is
bijective (injective and surjective).
</BLOCKQUOTE>
<H5><A NAME = "13859">IsGraded(f) : ModMPolHom -&gt; BoolElt</A></H5>
<H5>IsHomogeneous(f) : ModMPolHom -&gt; BoolElt</H5>
<BLOCKQUOTE>
Given a module homomorphism f:M -&gt; N, where M and N are
graded modules, return whether f is homogeneous of some degree d;
that is, whether for every pure degree element v&isin;M, f(v)=0 or
<TT>Degree</TT>(f(v)) equals <TT>Degree</TT>(v) + d.
</BLOCKQUOTE>
<H5><A NAME = "13860">Degree(f) : ModMPolHom -&gt; RngIntElt</A></H5>
<BLOCKQUOTE>
Given a module homomorphism f:M -&gt; N, return the degree of
f, which is the maximum d such that an element of M of degree
e is mapped via f to zero or an element of degree e + d.  If f
is homogeneous, then the `maximum' concept is unnecessary, since the degree
will be consistent for all elements of M (see the previous function).
</BLOCKQUOTE>
<HR>
<H3><A NAME = "13861">Example <TT>PMod_HomomorphismEmbedded (H115E2)</TT></A></H3>
We illustrate some homomorphism functionality by looking at the explicit
inclusion homomorphism between two submodules of a rank 3 free module over
Q[x, y]. We define this in non-presentational form by the identity
matrix. Then we can retrieve the corresponding defining matrix for the
map between the internal presentations of the two submodules. The two
submodules being graded submodules, we check that the inclusion is indeed
homogeneous of degree 0 (as it must be, obviously preserving degrees of
elements). 
<P>
<P>
<PRE>
&gt; R&lt;x,y&gt; := PolynomialRing(RationalField(), 2, "grevlex");
&gt; F := EModule(R, 3);
&gt; // get a submodule M1 generated by a single non-zero element of F
&gt; M1 := sub&lt;F|[x^2,y^2,x*y]&gt;;
&gt; // and a second submodule M2 containing M1
&gt; M2 := sub&lt;F|[x,0,y],[0,y,0]&gt;;
&gt; incl_hm :=  Homomorphism(M1,M2,IdentityMatrix(R,3) : 
&gt;               Presentation := false);
&gt; incl_hm;
Module homomorphism (3 by 3)
Ambient matrix:
[1 0 0]
[0 1 0]
[0 0 1]
</PRE>
Now the corresponding presentation matrix of the inclusion map is the obvious
one coming from the expression of the natural generator of M1 in
terms of the two natural generators of M2
<P>
<P>
<PRE>
&gt;  PresentationMatrix(incl_hm);
[y x]
&gt; // check homogeneity of incl_hm
&gt; IsHomogeneous(incl_hm);
true
&gt; Degree(incl_hm);
0
</PRE>
<HR>
<PRE></PRE> <A  HREF = "text1260.htm">[Next]</A><A  HREF = "text1258.htm">[Prev]</A> <A  HREF = "text1260.htm">[Right]</A> <A  HREF = "text1258.htm">[Left]</A> <A  HREF = "text1254.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<br><small>Version: V2.22 of <I>
Thu Jun  9 16:37:49 EST 2016
</I></small>
</body></html>