<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <link rel='stylesheet' href='help.css' type='text/css'>
  <TITLE>Creating Sets</TITLE>
</head>
<body BGCOLOR="#FFFFFF">

 <A  HREF = "text88.htm">[Next]</A><A  HREF = "text86.htm">[Prev]</A> <A  HREF = "text88.htm">[Right]</A> <A  HREF = "text86.htm">[Left]</A> <A  HREF = "text85.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<PRE></PRE><H3><A NAME = "605">Creating Sets</A></H3>

<P>
<P>
The customary braces <TT>{ </TT> and <TT> }</TT> are used to define
enumerated sets. Formal sets are delimited by the composite braces
<TT>{!</TT> and <TT>!</TT>}.
For indexed sets <TT>{@</TT> and <TT>@</TT>} are used.
For multisets <TT>{* </TT> and <TT>*</TT>} are used.



<H5>Subsections</H5>
<UL>
<LI> <A  HREF = "text87.htm#606">The Formal Set Constructor</A>
<LI> <A  HREF = "text87.htm#608">The Enumerated Set Constructor</A>
<LI> <A  HREF = "text87.htm#619">The Indexed Set Constructor</A>
<LI> <A  HREF = "text87.htm#629">The Multiset Constructor</A>
<LI> <A  HREF = "text87.htm#639">The Arithmetic Progression Constructors</A>
</UL>
<H4><A NAME = "606">The Formal Set Constructor</A></H4>

<P>
<P>
The formal set constructor has the following fixed format (the
expressions appearing in the construct are defined above):


<H5><A NAME = "607">{! x in F | P(x) !}</A></H5>
<BLOCKQUOTE>
Form the formal set consisting of the subset of elements
x of F for which P(x) is true.
If P(x) is true for every element of F, the set
constructor may be abbreviated to
<TT>{! x in F !</TT>}.
Note that the universe of a formal set will always be equal
to the carrier set F.
</BLOCKQUOTE>
<H4><A NAME = "608">The Enumerated Set Constructor</A></H4>

<P>
<P>
Enumerated sets can be constructed by expressions enclosed in braces,
provided that the values of all expressions can be automatically
coerced into some common structure, as outlined in the Introduction, 
(Chapter <A  HREF = "text80.htm#588">INTRODUCTION TO AGGREGATES</A>).
All general constructors have an optional universe (U in the
list below) up front, that allows the user to specify into which structure
all terms of the sets should be coerced. 


<H5><A NAME = "609">{ } : Null -&gt; Set</A></H5>
<BLOCKQUOTE>
The null set: an empty set that does not have its universe defined.
</BLOCKQUOTE>
<H5><A NAME = "610">{ U | } : Str -&gt; Set</A></H5>
<BLOCKQUOTE>
The empty set with universe U.
</BLOCKQUOTE>
<H5><A NAME = "611">{ e<sub>1</sub>, e<sub>2</sub>, ..., e<sub>n</sub> } : Elt, ..., Elt -&gt; Set</A></H5>
<BLOCKQUOTE>
Given a list of expressions e<sub>1</sub>, ..., e<sub>n</sub>, defining elements
a<sub>1</sub>, a<sub>2</sub>, ..., a<sub>n</sub> all belonging to (or automatically
coercible into) a single algebraic structure U, create the set
{ a<sub>1</sub>, a<sub>2</sub>, ..., a<sub>n</sub> } of elements of U.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "612">Example <TT>Set_Universe (H9E1)</TT></A></H3>
We create a set by listing its elements explicitly.
<P>
<P>
<PRE>
&gt; S := { (7^2+1)/5, (8^2+1)/5, (9^2-1)/5 };
&gt; S;
{ 10, 13, 16 }
&gt; Parent(S);
Set of subsets of Rational Field
</PRE>
Thus S was created as a set of rationals,  because <TT>/</TT>
on integers has a rational result. If one wishes to obtain a
set of integers, one could specify the universe (or one could
use <TT>div</TT>, or one could use <TT>!</TT> on every element to coerce
it into the ring of integers):
<P>
<P>
<PRE>
&gt; T := { Integers() | (7^2+1)/5, (8^2+1)/5, (9^2-1)/5 };
&gt; T;
{ 10, 13, 16 }
&gt; Parent(T);
Set of subsets of Integer Ring
</PRE>
<HR>
<H5><A NAME = "613">{ U | e<sub>1</sub>, e<sub>2</sub>, ..., e<sub>n</sub> } : Str, Elt, ..., Elt -&gt; Set</A></H5>
<BLOCKQUOTE>
Given a list of expressions e<sub>1</sub>, ..., e<sub>n</sub>, which define elements
a<sub>1</sub>, a<sub>2</sub>, ..., a<sub>n</sub> that are all
coercible into U, create the set
{ a<sub>1</sub>, a<sub>2</sub>, ..., a<sub>n</sub> } of elements of U.
</BLOCKQUOTE>
<H5><A NAME = "614">{ e(x) : x in E | P(x) }</A></H5>
<BLOCKQUOTE>
Form the set of elements e(x), all belonging to some common
structure, for those x &isin;E
with the property that the predicate P(x) is true. The
expressions appearing in this construct have the interpretation
given in the Introduction (Chapter <A  HREF = "text80.htm#588">INTRODUCTION TO AGGREGATES</A>) (in particular, E must be
a finite structure that can be enumerated).
<P>
If P(x) is true for every value of x in E, then the set
constructor may be abbreviated to <TT>{ e(x) : x in E }</TT>.
</BLOCKQUOTE>
<H5><A NAME = "615">{ U | e(x) : x in E | P(x) }</A></H5>
<BLOCKQUOTE>
Form the set of elements of U consisting of the values e(x)
for those x&isin;E for which the predicate P(x) is true (an error
results if not all e(x) are coercible into U). The
expressions appearing in this construct have the same
interpretation as before.
<P>
If P is always true, it may be omitted (including
the |).
</BLOCKQUOTE>
<H5><A NAME = "616">{ e(x<sub>1</sub>,...,x<sub>k</sub>) : x<sub>1</sub> in E<sub>1</sub>, ..., x<sub>k</sub>in E<sub>k</sub> | P(x<sub>1</sub>, ..., x<sub>k</sub>) }</A></H5>
<BLOCKQUOTE>
The set consisting of those elements e(x<sub>1</sub>, ..., x<sub>k</sub>),
in some common structure, for which x<sub>1</sub>, ..., x<sub>k</sub>
in E<sub>1</sub>, ..., E<sub>k</sub> have the property that
P(x<sub>1</sub>, ..., x<sub>k</sub>) is true.
The expressions appearing in this construct have the interpretation
given in the Introduction (Chapter <A  HREF = "text80.htm#588">INTRODUCTION TO AGGREGATES</A>).
<P>
Note that if two successive allowable structures E<sub>i</sub> and E<sub>i + 1</sub> 
are identical, then the specification of the carrier sets for x<sub>i</sub> 
and x<sub>i + 1</sub> may be abbreviated to <TT>x<sub>i</sub>, x<sub>i + 1</sub> in E<sub>i</sub></TT>.
<P>
Also, if P(x<sub>1</sub>, ..., x<sub>k</sub>) is always true, it may be omitted (including
the |).
</BLOCKQUOTE>
<H5><A NAME = "617">{ U | e(x<sub>1</sub>,...,x<sub>k</sub>) : x<sub>1</sub> in E<sub>1</sub>, ...,x<sub>k</sub> in E<sub>k</sub> | P(x<sub>1</sub>, ..., x<sub>k</sub>) }</A></H5>
<BLOCKQUOTE>
As in the previous entry, the set consisting of those elements
e(x<sub>1</sub>, ..., x<sub>k</sub>) for which P(x<sub>1</sub>, ..., x<sub>k</sub>) is true, is formed,
as a set of elements of U (an error occurs if not all
e(x<sub>1</sub>, ..., x<sub>k</sub>) are elements of or coercible into U).
<P>
Again, identical successive structures may be
abbreviated, and a predicate that is always true may be omitted.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "618">Example <TT>Set_AlmostFermat (H9E2)</TT></A></H3>
Now that Fermat's last theorem may have been proven, it may be of
interest to find integers that almost satisfy x<sup>n</sup> + y<sup>n</sup>=z<sup>n</sup>.
In this example we find all 2 &lt; x, y, z &lt; 1000 such that x<sup>3</sup> + y<sup>3</sup>=z<sup>3</sup> + 1.
First we build a set of cubes, then two sets of pairs for
which the sum of cubes differs from a cube by 1. Note that 
we build a <I>set</I> rather than a sequence of cubes
because we only need fast membership testing.
Also note that the resulting sets of pairs do not have their
elements in the order in which they were found.
<P>
<P>
<PRE>
&gt; cubes := { Integers() | x^3 : x in [1..1000] };
&gt; plus := { &lt;a, b&gt; : a in [2..1000], b in [2..1000] | \
&gt;    b ge a and (a^3+b^3-1) in cubes };
&gt; plus;
{ 
       &lt; 9, 10 &gt;,
       &lt; 135, 235 &gt;
       &lt; 334, 438 &gt;,
       &lt; 73, 144 &gt;,
       &lt; 64, 94 &gt;,
       &lt; 244, 729 &gt;
 }
</PRE>
Note that we spend a lot of time cubing integers this way.
For a more efficient approach, see a subsequent example.
<HR>
<H4><A NAME = "619">The Indexed Set Constructor</A></H4>

<P>
<P>
The creation of indexed sets is similar to that of enumerated sets.


<H5><A NAME = "620">{@ @} : Null -&gt; SetIndx</A></H5>
<BLOCKQUOTE>
The null set: an empty indexed set that does not have its universe defined.
</BLOCKQUOTE>
<H5><A NAME = "621">{@ U | @} : Str -&gt; SetIndx</A></H5>
<BLOCKQUOTE>
The empty indexed set with universe U.
</BLOCKQUOTE>
<H5><A NAME = "622">{@ e<sub>1</sub>, e<sub>2</sub>, ..., e<sub>n</sub> @} : Elt, ..., Elt -&gt; SetIndx</A></H5>
<BLOCKQUOTE>
Given a list of expressions e<sub>1</sub>, ..., e<sub>n</sub>, defining elements
a<sub>1</sub>, a<sub>2</sub>, ..., a<sub>n</sub> all belonging to (or automatically
coercible into) a single algebraic structure U, create the indexed set
Q = { a<sub>1</sub>, a<sub>2</sub>, ..., a<sub>n</sub> } of elements of U.
</BLOCKQUOTE>
<H5><A NAME = "623">{@ U |  e<sub>1</sub>, e<sub>2</sub>, ..., e<sub>m</sub> @} : Str, Elt, ..., Elt -&gt; SetIndx</A></H5>
<BLOCKQUOTE>
Given a list of expressions e<sub>1</sub>, ..., e<sub>m</sub>, which define elements
a<sub>1</sub>, a<sub>2</sub>, ..., a<sub>n</sub> that are all
coercible into U, create the indexed set
Q = { a<sub>1</sub>, a<sub>2</sub>, ..., a<sub>n</sub> } of elements of U.
</BLOCKQUOTE>
<H5><A NAME = "624">{@ e(x) : x in E | P(x) @}</A></H5>
<BLOCKQUOTE>
Form the indexed set of elements e(x), all belonging to some common
structure, for those x &isin;E
with the property that the predicate P(x) is true. The
expressions appearing in this construct have the interpretation
given in the Introduction (Chapter <A  HREF = "text80.htm#588">INTRODUCTION TO AGGREGATES</A>) (in particular, E must be
a finite structure that can be enumerated).
<P>
If P is always true, it may be omitted (including
the |).
</BLOCKQUOTE>
<H5><A NAME = "625">{@ U |  e(x) : x in E | P(x) @}</A></H5>
<BLOCKQUOTE>
Form the indexed set of elements of U consisting of the values e(x)
for those x&isin;E for which the predicate P(x) is true (an error
results if not all e(x) are coercible into U). The
expressions appearing in this construct have the same
interpretation as before.
<P>
If P is always true, it may be omitted (including
the |).
</BLOCKQUOTE>
<H5><A NAME = "626">{@ e(x<sub>1</sub>,...,x<sub>k</sub>) : x<sub>1</sub> in E<sub>1</sub>, ..., x<sub>k</sub>in E<sub>k</sub> | P(x<sub>1</sub>, ..., x<sub>k</sub>) @}</A></H5>
<BLOCKQUOTE>
The indexed set consisting of those elements e(x<sub>1</sub>, ..., x<sub>k</sub>)
(in some common structure), for which x<sub>1</sub>, ..., x<sub>k</sub>
in E<sub>1</sub> x ... x E<sub>k</sub> have the property that
P(x<sub>1</sub>, ..., x<sub>k</sub>) is true.
The expressions appearing in this construct have the interpretation
given in the Introduction (Chapter <A  HREF = "text80.htm#588">INTRODUCTION TO AGGREGATES</A>).
<P>
Note that if two successive allowable structures E<sub>i</sub> and E<sub>i + 1</sub> 
are identical, then the specification of the carrier sets for x<sub>i</sub> 
and x<sub>i + 1</sub> may be abbreviated to <TT>x<sub>i</sub>, x<sub>i + 1</sub> in E<sub>i</sub></TT>.
<P>
Also, if P(x<sub>1</sub>, ..., x<sub>k</sub>) is always true, it may be omitted.
</BLOCKQUOTE>
<H5><A NAME = "627">{@ U | e(x<sub>1</sub>,...,x<sub>k</sub>) : x<sub>1</sub> in E<sub>1</sub>, ...,x<sub>k</sub> in E<sub>k</sub> | P(x<sub>1</sub>, ..., x<sub>k</sub>)@}</A></H5>
<BLOCKQUOTE>
As in the previous entry, the indexed set consisting of those elements
e(x<sub>1</sub>, ..., x<sub>k</sub>) for which P(x<sub>1</sub>, ..., x<sub>k</sub>) is true is formed,
as an indexed set of elements of U (an error occurs if not all
e(x<sub>1</sub>, ..., x<sub>k</sub>) are elements of or coercible into U).
<P>
Again, identical successive structures may be
abbreviated, and a predicate that is always true may be omitted.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "628">Example <TT>Set_AlmostFermatIndexed (H9E3)</TT></A></H3>
In the previous example we found pairs x, y such that x<sup>3</sup> + y<sup>3</sup> differs
by one from some cube z<sup>3</sup>. Using indexed sets it is somewhat easier to
retrieve the integer z as well. We give a small example.
Note also that it is beneficial to know here that evaluation of
expressions proceeds left to right.
<P>
<P>
<PRE>
&gt; cubes := {@ Integers() | z^3 : z in [1..25] @};
&gt; plus := { &lt;x, y, z&gt; : x in [-10..10], y in [-10..10], z in [1..25] |
&gt;    y ge x and Abs(x) gt 1 and Abs(y) gt 1 and (x^3+y^3-1) in cubes
&gt;    and (x^3+y^3-1) eq cubes[z] };
&gt; plus;
{ &lt;-6, 9, 8&gt;, &lt;9, 10, 12&gt;, &lt;-8, 9, 6&gt; }
</PRE>
<HR>
<H4><A NAME = "629">The Multiset Constructor</A></H4>

<P>
<P>
The creation of multisets is similar to that of enumerated sets.  An
important difference is that repetitions are significant and the
operator ^^ (mentioned above) may be used to specify the multiplicity
of an element.


<H5><A NAME = "630">{*  *} : Null -&gt; SetMulti</A></H5>
<BLOCKQUOTE>
The null set: an empty multiset that does not have its universe defined.
</BLOCKQUOTE>
<H5><A NAME = "631">{*  U | *} : Str -&gt; SetMulti</A></H5>
<BLOCKQUOTE>
The empty multiset with universe U.
</BLOCKQUOTE>
<H5><A NAME = "632">{*  e<sub>1</sub>, e<sub>2</sub>, ..., e<sub>n</sub> *} : Elt, ..., Elt -&gt; SetMulti</A></H5>
<BLOCKQUOTE>
Given a list of expressions e<sub>1</sub>, ..., e<sub>n</sub>, defining elements
a<sub>1</sub>, a<sub>2</sub>, ..., a<sub>n</sub> all belonging to (or automatically
coercible into) a single algebraic structure U, create the multiset
Q = {*  a<sub>1</sub>, a<sub>2</sub>, ..., a<sub>n</sub> *} of elements of U.
</BLOCKQUOTE>
<H5><A NAME = "633">{*  U |  e<sub>1</sub>, e<sub>2</sub>, ..., e<sub>m</sub> *} : Str, Elt, ..., Elt -&gt; SetMulti</A></H5>
<BLOCKQUOTE>
Given a list of expressions e<sub>1</sub>, ..., e<sub>m</sub>, which define elements
a<sub>1</sub>, a<sub>2</sub>, ..., a<sub>n</sub> that are all
coercible into U, create the multiset
Q = {*  a<sub>1</sub>, a<sub>2</sub>, ..., a<sub>n</sub> *} of elements of U.
</BLOCKQUOTE>
<H5><A NAME = "634">{*  e(x) : x in E | P(x) *}</A></H5>
<BLOCKQUOTE>
Form the multiset of elements e(x), all belonging to some common
structure, for those x &isin;E
with the property that the predicate P(x) is true. The
expressions appearing in this construct have the interpretation
given in the Introduction (Chapter <A  HREF = "text80.htm#588">INTRODUCTION TO AGGREGATES</A>) (in particular, E must be
a finite structure that can be enumerated).
<P>
If P is always true, it may be omitted (including
the |).
</BLOCKQUOTE>
<H5><A NAME = "635">{*  U |  e(x) : x in E | P(x) *}</A></H5>
<BLOCKQUOTE>
Form the multiset of elements of U consisting of the values e(x)
for those x&isin;E for which the predicate P(x) is true (an error
results if not all e(x) are coercible into U). The
expressions appearing in this construct have the same
interpretation as before.
<P>
If P is always true, it may be omitted (including
the |).
</BLOCKQUOTE>
<H5><A NAME = "636">{*  e(x<sub>1</sub>,...,x<sub>k</sub>) : x<sub>1</sub> in E<sub>1</sub>, ..., x<sub>k</sub>in E<sub>k</sub> | P(x<sub>1</sub>, ..., x<sub>k</sub>) *}</A></H5>
<BLOCKQUOTE>
The multiset consisting of those elements e(x<sub>1</sub>, ..., x<sub>k</sub>)
(in some common structure), for which x<sub>1</sub>, ..., x<sub>k</sub>
in E<sub>1</sub> x ... x E<sub>k</sub> have the property that
P(x<sub>1</sub>, ..., x<sub>k</sub>) is true.
The expressions appearing in this construct have the interpretation
given in the Introduction (Chapter <A  HREF = "text80.htm#588">INTRODUCTION TO AGGREGATES</A>).
<P>
Note that if two successive allowable structures E<sub>i</sub> and E<sub>i + 1</sub> 
are identical, then the specification of the carrier sets for x<sub>i</sub> 
and x<sub>i + 1</sub> may be abbreviated to <TT>x<sub>i</sub>, x<sub>i + 1</sub> in E<sub>i</sub></TT>.
<P>
Also, if P(x<sub>1</sub>, ..., x<sub>k</sub>) is always true, it may be omitted.
</BLOCKQUOTE>
<H5><A NAME = "637">{*  U | e(x<sub>1</sub>,...,x<sub>k</sub>) : x<sub>1</sub> in E<sub>1</sub>, ...,x<sub>k</sub> in E<sub>k</sub> | P(x<sub>1</sub>, ..., x<sub>k</sub>) *}</A></H5>
<BLOCKQUOTE>
As in the previous entry, the multiset consisting of those elements
e(x<sub>1</sub>, ..., x<sub>k</sub>) for which P(x<sub>1</sub>, ..., x<sub>k</sub>) is true is formed,
as a multiset of elements of U (an error occurs if not all
e(x<sub>1</sub>, ..., x<sub>k</sub>) are elements of or coercible into U).
<P>
Again, identical successive structures may be
abbreviated, and a predicate that is always true may be omitted.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "638">Example <TT>Set_Multiset (H9E4)</TT></A></H3>
Here we demonstrate the use of the multiset constructors.
<P>
<P>
<PRE>
&gt; M := {*  1, 1, 1, 3, 5 *};
&gt; M;
{* 1^^3, 3, 5 *}
&gt; M := {*  1^^4, 2^^5, 1/2^^3 *};
&gt; M;
&gt; // Count frequency of digits in first 1000 digits of pi:
&gt; pi := Pi(RealField(1001));
&gt; dec1000 := Round(10^1000*(pi-3));
&gt; I := IntegerToString(dec1000);
&gt; F := {* I[i]: i in [1 .. #I] *};
&gt; F;
{*  7^^95, 3^^102, 6^^94, 2^^103, 9^^106, 5^^97,
1^^116, 8^^101, 4^^93, 0^^93 *}
&gt; for i := 0 to 9 do i, Multiplicity(F, IntegerToString(i)); end for;
0 93
1 116
2 103
3 102
4 93
5 97
6 94
7 95
8 101
9 106
</PRE>
<HR>
<H4><A NAME = "639">The Arithmetic Progression Constructors</A></H4>

<P>
<P>
Some special constructors exist to create and store enumerated
sets of integers in arithmetic progression efficiently.
This only works for arithmetic progressions of elements of
the ring of integers.


<H5><A NAME = "640">{ i..j } : RngIntElt, RngIntElt -&gt; Set</A></H5>
<H5>{ U | i..j } : Str, RngIntElt, RngIntElt -&gt; SetIndx</H5>
<BLOCKQUOTE>
The enumerated set whose elements form the arithmetic progression
i, i + 1, i + 2, ..., j, where i and j are (expressions defining) integers. 
If j is less than i then the empty set will be created.
<P>
The only universe U that is legal here is the ring of integers.
</BLOCKQUOTE>
<H5><A NAME = "641">{ i .. j by k } : RngIntElt, RngIntElt, RngIntElt -&gt; Set</A></H5>
<H5>{ U | i .. j by k } : Str, RngIntElt, RngIntElt, RngIntElt -&gt; Set</H5>
<BLOCKQUOTE>
The enumerated set consisting of the integers forming the arithmetic 
progression i, i + k, i + 2 * k, ..., j, where i, j and 
k are (expressions defining) integers (but k&ne;0).
<P>
If k is positive then the last element in the progression 
will be the greatest integer of the form i + n * k that is 
less than or equal to j. If j is less than i, the empty 
set will be constructed.
<P>
If k is negative then the last element in the progression 
will be the least integer of the form i + n * k that is 
greater than or equal to j. If j is greater than i, the 
empty set will be constructed.
<P>
As for the previous constructor, only the ring of integers is allowed
as a legal universe U.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "642">Example <TT>Set_Progression (H9E5)</TT></A></H3>
It is possible to use the arithmetic progression constructors to save
typing in the creation of `arithmetic progressions' of elements of other
structures than the ring of integers, but it should be kept in mind
that the result will not be treated especially efficiently like the
integer case. Here is the `wrong' way, as well as two correct ways
to create a set of 10 finite field elements.
<P>
<P>
<PRE>
&gt; S := { FiniteField(13) | 1..10 };
Runtime error in { .. }: Invalid set universe
&gt; S := { FiniteField(13) | x : x in { 1..10 } };
&gt; S;
{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }
&gt; G := PowerSet(FiniteField(13));
&gt; S := G ! { 1..10 };
&gt; S;
{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }
</PRE>
<HR>
<PRE></PRE> <A  HREF = "text88.htm">[Next]</A><A  HREF = "text86.htm">[Prev]</A> <A  HREF = "text88.htm">[Right]</A> <A  HREF = "text86.htm">[Left]</A> <A  HREF = "text85.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<br><small>Version: V2.22 of <I>
Thu Jun  9 16:37:49 EST 2016
</I></small>
</body></html>