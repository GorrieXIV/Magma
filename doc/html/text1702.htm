<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <link rel='stylesheet' href='help.css' type='text/css'>
  <TITLE>Operations on Points and  Lines</TITLE>
</head>
<body BGCOLOR="#FFFFFF">

 <A  HREF = "text1703.htm">[Next]</A><A  HREF = "text1701.htm">[Prev]</A> <A  HREF = "text1703.htm">[Right]</A> <A  HREF = "text1701.htm">[Left]</A> <A  HREF = "text1690.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<PRE></PRE><H3><A NAME = "18790">Operations on Points and  Lines</A></H3>

<P>
<P>
<P>
All the usual equality, membership and subset functions are provided 
along with a collection of deconstruction functions and others.



<H5>Subsections</H5>
<UL>
<LI> <A  HREF = "text1702.htm#18791">Elementary Operations</A>
<LI> <A  HREF = "text1702.htm#18803">Deconstruction Functions</A>
<LI> <A  HREF = "text1702.htm#18814">Other Point and Line Functions</A>
</UL>
<H4><A NAME = "18791">Elementary Operations</A></H4>



<H5><A NAME = "18792">p eq q : PlanePt, PlanePt -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if the points p and q are equal, otherwise <TT>false</TT>.
</BLOCKQUOTE>
<H5><A NAME = "18793">p ne q : PlanePt, PlanePt -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Return <TT>true</TT> if the points p and q are not equal, otherwise <TT>false</TT>.
</BLOCKQUOTE>
<H5><A NAME = "18794">l eq m : PlaneLn, PlaneLn -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Return <TT>true</TT> if the lines l and m are equal, otherwise <TT>false</TT>.
</BLOCKQUOTE>
<H5><A NAME = "18795">l ne m : PlaneLn, PlaneLn -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Return <TT>true</TT> if the lines l and m are not equal, otherwise <TT>false</TT>.
</BLOCKQUOTE>
<H5><A NAME = "18796">p in l : PlanePt, PlaneLn -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Return <TT>true</TT> if point p lies on the line l, otherwise <TT>false</TT>.
</BLOCKQUOTE>
<H5><A NAME = "18797">p notin l : PlanePt, PlaneLn -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Return <TT>true</TT> if point p does not lie on the line l, otherwise <TT>false</TT>.
</BLOCKQUOTE>
<H5><A NAME = "18798">S subset l : { PlanePt }, PlaneLn -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Given a subset S of the point set of the plane P and a 
line l of P, return <TT>true</TT> if the subset S of points 
lies on the line l, otherwise <TT>false</TT>.
</BLOCKQUOTE>
<H5><A NAME = "18799">S notsubset l : { PlanePt }, PlaneLn -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Given a subset S of the point set of the plane P and a 
line l of P, return <TT>true</TT> if the subset S of points 
does not lie on the line l, otherwise <TT>false</TT>.
</BLOCKQUOTE>
<H5><A NAME = "18800">l meet m : PlaneLn, PlaneLn -&gt; PlanePt</A></H5>
<BLOCKQUOTE>
The unique point common to the lines l and m.
</BLOCKQUOTE>
<H5><A NAME = "18801">Representative(l) : PlaneLn -&gt; PlanePt</A></H5>
<H5>Rep(l) : PlaneLn -&gt; PlanePt</H5>
<BLOCKQUOTE>
Given a line l of the plane P, return a representative point 
of P which is incident with l.
</BLOCKQUOTE>
<H5><A NAME = "18802">Random(l) : PlaneLn -&gt; PlanePt</A></H5>
<BLOCKQUOTE>
Given a line l of the plane P, return a random point 
of P which is incident with l.
</BLOCKQUOTE>
<H4><A NAME = "18803">Deconstruction Functions</A></H4>



<H5><A NAME = "18804">Index(P, p) : Plane, PlanePt -&gt; RngIntElt</A></H5>
<BLOCKQUOTE>
Given a point p from the point--set V of a plane P, return the
index of p, i.e. the integer i such that p is <TT>V.i</TT>.
</BLOCKQUOTE>
<H5><A NAME = "18805">Index(P, l) : Plane, PlaneLn -&gt; RngIntElt</A></H5>
<BLOCKQUOTE>
Given a line l, return the index of l in the plane P, i.e. the integer i such that l is L.i (where L is the line--set of P).
</BLOCKQUOTE>
<H5><A NAME = "18806">p[i] : PlanePt, RngIntElt -&gt; FldFinElt</A></H5>
<BLOCKQUOTE>
The i-th coordinate of the point p, which must be from
a classical plane. If p is from a projective plane, then i
must satisfy 1 &le;i &le;3; if p is from an affine plane, then
i must satisfy 1 &le;i &le;2.
</BLOCKQUOTE>
<H5><A NAME = "18807">l[i] : PlaneLn, RngIntElt -&gt; FldFinElt</A></H5>
<BLOCKQUOTE>
The i-th coordinate of the line l, which must be from
a classical plane. The integer i must satisfy 1 &le;i &le;3.
Recall that in a classical plane &lt;a:b:c&gt; (where a, b, c &isin;K)
represents the line given by the equation ax + by + cz = 0 in a
projective plane or ax + by + c = 0 in an affine plane.
</BLOCKQUOTE>
<H5><A NAME = "18808">Coordinates(P, p) : Plane, PlanePt -&gt; [ FldFinElt ]</A></H5>
<BLOCKQUOTE>
Given a point p = (a:b:c) from a classical projective plane P (or
p = (a, b) from a classical affine plane P), return the sequence
[a, b, c] (or [a, b] in the affine case) of coordinates of p.
</BLOCKQUOTE>
<H5><A NAME = "18809">Coordinates(P, l) : Plane, PlaneLn -&gt; [ FldFinElt ]</A></H5>
<BLOCKQUOTE>
Given a line l = &lt;a:b:c&gt; from a classical plane P (projective or
affine), return the sequence [a, b, c] of coordinates of l.
</BLOCKQUOTE>
<H5><A NAME = "18810">ElementToSequence(p) : PlanePt -&gt; [ FldFinElt ]</A></H5>
<H5>Eltseq(p) : PlanePt -&gt; [ FldFinElt ]</H5>
<BLOCKQUOTE>
Given a point p = (a:b:c) from a classical projective plane P (or
p = (a, b) from a classical affine plane P), return the sequence
[a, b, c] (or [a, b] in the affine case) of coordinates of p.
</BLOCKQUOTE>
<H5><A NAME = "18811">ElementToSequence(l) : PlaneLn -&gt; [ FldFinElt ]</A></H5>
<H5>Eltseq(l) : PlaneLn -&gt; [ FldFinElt ]</H5>
<BLOCKQUOTE>
Given a line l = &lt;a:b:c&gt; from a classical plane P (projective or
affine), return the sequence [a, b, c] of coordinates of l.
</BLOCKQUOTE>
<H5><A NAME = "18812">Set(l) : PlaneLn -&gt; { PlanePt }</A></H5>
<BLOCKQUOTE>
The set of points contained in the line l.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "18813">Example <TT>Plane_decon (H147E8)</TT></A></H3>
The following example illustrates the use of some of the elementary and
deconstruction functions on lines and points discussed in the previous two
subsections.
<P>
<P>
<PRE>
&gt; K&lt;w&gt; := GF(4);
&gt; P, V, L := FiniteProjectivePlane(K);
</PRE>
Create the line x + z = 0:
<P>
<P>
<PRE>
&gt; l := L![1, 0, 1];
&gt; l;
&lt; 1 : 0 : 1 &gt;
</PRE>
Look at the points on the line l:
<P>
<P>
<PRE>
&gt; Set(l);
{  ( 0 : 1 : 0 ), ( 1 : w^2 : 1 ), ( 1 : 0 : 1 ),
   ( 1 : w : 1 ), ( 1 : 1 : 1) }
</PRE>
Get the coordinates of the line l:
<P>
<P>
<PRE>
&gt; Coordinates(P, l);
[ 1, 0, 1 ]
&gt; l[1];
1
</PRE>
Find the index of the line l in the line--set L of P, and check it:
<P>
<P>
<PRE>
&gt; Index(P, l);
8
&gt; l eq L.8;
true
</PRE>
Test if a point is on the line l:
<P>
<P>
<PRE>
&gt; V![1, 0, 1] in l;
true
</PRE>
Test a set of points for containment in l:
<P>
<P>
<PRE>
&gt; S := {V.1, V.2};
&gt; S;
{  ( 1 : 0 : 0 ), ( 0 : 1 : 0 ) }
&gt; S subset l;
false
</PRE>
Create the line containing the points in S:
<P>
<P>
<PRE>
&gt; l2 := L!S;
&gt; l2;
&lt; 0 : 0 : 1 &gt;
&gt; S subset l2;
true
</PRE>
And finally, find the point common to the lines l and l2:
<P>
<P>
<PRE>
&gt; p := l meet l2;
&gt; p;
( 0 : 1 : 0 )
&gt; p[3];
0
</PRE>
<HR>
<H4><A NAME = "18814">Other Point and Line Functions</A></H4>



<H5><A NAME = "18815">IsCollinear(P, S) : Plane, { PlanePt } -&gt; BoolElt, PlaneLn</A></H5>
<BLOCKQUOTE>
Return <TT>true</TT> if the set S of points of the plane P are collinear,
otherwise <TT>false</TT>. If the points are collinear, the line which they
define is also returned.
</BLOCKQUOTE>
<H5><A NAME = "18816">IsConcurrent(P, R) : Plane, { PlaneLn } -&gt; BoolElt, PlanePt</A></H5>
<BLOCKQUOTE>
Return <TT>true</TT> if the set R of lines of the plane P are concurrent,
otherwise <TT>false</TT>. If the lines are concurrent, their common point
is returned as a second value.
</BLOCKQUOTE>
<H5><A NAME = "18817">ContainsQuadrangle(P, S) : Plane, { PlanePt } -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Return <TT>true</TT> if the set S of points of a plane P contains a quadrangle.
</BLOCKQUOTE>
<H5><A NAME = "18818">Pencil(P, p) : Plane, PlanePt -&gt; { PlaneLn }</A></H5>
<BLOCKQUOTE>
The pencil of lines passing through the point p in the plane P.
</BLOCKQUOTE>
<H5><A NAME = "18819">Slope(l) : PlaneLn -&gt; FldFinElt</A></H5>
<BLOCKQUOTE>
The slope of the line l of a classical affine plane P.
</BLOCKQUOTE>
<H5><A NAME = "18820">IsParallel(P, l, m) : Plane, PlaneLn, PlaneLn -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Return <TT>true</TT> if the line l is parallel to the line m in the affine
plane P.
</BLOCKQUOTE>
<H5><A NAME = "18821">ParallelClass(P, l) : Plane, PlaneLn -&gt; { PlaneLn }</A></H5>
<BLOCKQUOTE>
The parallel class containing the line l of an affine plane P.
</BLOCKQUOTE>
<H5><A NAME = "18822">ParallelClasses(P) : PlaneAff -&gt; { { PlaneLn } }</A></H5>
<BLOCKQUOTE>
The partition into parallel classes of the lines of the affine plane P.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "18823">Example <TT>Plane_elt-other (H147E9)</TT></A></H3>
We use the affine plane AG<sub>2</sub>(3) to demonstrate some of
the above functions.
<P>
<P>
<PRE>
&gt; A, V, L := FiniteAffinePlane(3);
</PRE>
Create the line y = 2x + 1 in A, and check its slope:
<P>
<P>
<PRE>
&gt; l := L![2, 1];
&gt; l;
&lt; 1 : 1 : 2 &gt;
&gt; Slope(l);
2
</PRE>
Find the lines parallel to l:
<P>
<P>
<PRE>
&gt; ParallelClass(l);
{ 
    &lt; 1 : 1 : 0 &gt;,
    &lt; 1 : 1 : 1 &gt;,
    &lt; 1 : 1 : 2 &gt;
}
&gt; [Slope(m): m in ParallelClass(l)];
[ 2, 2, 2 ]
</PRE>
Get the pencil of lines through a point of l:
<P>
<P>
<PRE>
&gt; p := Rep(l);
&gt; p;
( 1, 0 )
&gt; Pencil(A, p);
{ 
    &lt; 1 : 0 : 2 &gt;,
    &lt; 1 : 1 : 2 &gt;,
    &lt; 1 : 2 : 2 &gt;,
    &lt; 0 : 1 : 0 &gt;
}
</PRE>
<HR>
<PRE></PRE> <A  HREF = "text1703.htm">[Next]</A><A  HREF = "text1701.htm">[Prev]</A> <A  HREF = "text1703.htm">[Right]</A> <A  HREF = "text1701.htm">[Left]</A> <A  HREF = "text1690.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<br><small>Version: V2.22 of <I>
Thu Jun  9 16:37:49 EST 2016
</I></small>
</body></html>