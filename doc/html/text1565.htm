<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <link rel='stylesheet' href='help.css' type='text/css'>
  <TITLE>Unit Disc</TITLE>
</head>
<body BGCOLOR="#FFFFFF">

 <A  HREF = "text1566.htm">[Next]</A><A  HREF = "text1564.htm">[Prev]</A> <A  HREF = "text1566.htm">[Right]</A> <A  HREF = "text1564.htm">[Left]</A> <A  HREF = "text1563.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<PRE></PRE><H3><A NAME = "17531">Unit Disc</A></H3>

<P>
<P>
Let D denote the Poincar&eacute; unit disc,
 D={z &isin;C:|z|&lt;1} 
equipped with the hyperbolic metric 
d(z, w) = log ((|1 - z bar(w)| + |z - w| /|1 - z bar(w)| - |z - w|)).
<P>
We mimic the existing functionality for working with the upper half-plane (see Chapter <A  HREF = "text1551.htm#17401">CONGRUENCE SUBGROUPS OF PSL<sub>2</sub>(R)</A>) to compute in a similar way with the geometry of the unit disc, including computation of angles, intersections, areas, and so on.



<H5>Subsections</H5>
<UL>
<LI> <A  HREF = "text1565.htm#17532">Creation</A>
<LI> <A  HREF = "text1565.htm#17534">Basic Operations</A>
<LI> <A  HREF = "text1565.htm#17541">Access Operations</A>
<LI> <A  HREF = "text1565.htm#17550">Distance and Angles</A>
<LI> <A  HREF = "text1565.htm#17557">Structural Operations</A>
</UL>
<H4><A NAME = "17532">Creation</A></H4>

<P>


<H5><A NAME = "17533">UnitDisc() : -&gt; SpcHyd</A></H5>

<PRE>    Center: RngElt                      Default: (9/10)i</PRE>

<PRE>    Precision: RngElt                   Default: 0</PRE>
<BLOCKQUOTE>
The hyperbolic unit disc, mapped conformally to the upper half-plane
by mapping 0 in D to <TT>Center</TT>, with given <TT>Precision</TT>.
</BLOCKQUOTE>
<H4><A NAME = "17534">Basic Operations</A></H4>



<H5><A NAME = "17535">D ! x : SpcHyd, . -&gt; SeqEnum</A></H5>
<BLOCKQUOTE>
Coerces x into D, if possible.
</BLOCKQUOTE>
<H5><A NAME = "17536">x eq y : SpcHydElt, SpcHydElt -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if and only if x=y.
</BLOCKQUOTE>
<H5><A NAME = "17537">a * x : RngElt, SpcHydElt -&gt; RngElt</A></H5>
<H5>x * a : SpcHydElt, RngElt -&gt; RngElt</H5>
<BLOCKQUOTE>
Returns a .x.
</BLOCKQUOTE>
<H5><A NAME = "17538">x + y : SpcHydElt, RngElt -&gt; RngElt</A></H5>
<H5>y + x : RngElt, SpcHydElt -&gt; RngElt</H5>
<H5>x + y : SpcHydElt, SpcHydElt -&gt; RngElt</H5>
<BLOCKQUOTE>
Returns x + y.
</BLOCKQUOTE>
<H5><A NAME = "17539">x - y : SpcHydElt, RngElt -&gt; RngElt</A></H5>
<H5>x - y : RngElt, SpcHydElt -&gt; RngElt</H5>
<H5>x - y : SpcHydElt, SpcHydElt -&gt; RngElt</H5>
<BLOCKQUOTE>
Returns x - y.
</BLOCKQUOTE>
<H5><A NAME = "17540">x / a : SpcHydElt, RngElt -&gt; RngElt</A></H5>
<BLOCKQUOTE>
Returns (1/a).x.
</BLOCKQUOTE>
<H4><A NAME = "17541">Access Operations</A></H4>



<H5><A NAME = "17542">IsExact(z) : SpcHydElt -&gt; BoolElt, .</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> (and the exact value of z) if and only if z is exact.
</BLOCKQUOTE>
<H5><A NAME = "17543">ExactValue(z) : SpcHydElt -&gt; .</A></H5>
<BLOCKQUOTE>
Returns the exact value of z; if it does not exist, returns an error.
</BLOCKQUOTE>
<H5><A NAME = "17544">ComplexValue(z) : SpcHydElt -&gt; FldComElt</A></H5>

<PRE>    Precision: RngIntElt                Default: 0</PRE>
<BLOCKQUOTE>
Returns the complex value z, with given precision.
</BLOCKQUOTE>
<H5><A NAME = "17545">Im(z) : SpcHydElt -&gt; FldReElt</A></H5>
<H5>Imaginary(z) : SpcHydElt -&gt; FldReElt</H5>

<PRE>    Precision: RngIntElt                Default: 0</PRE>
<BLOCKQUOTE>
Returns the imaginary part of z, with given precision.
</BLOCKQUOTE>
<H5><A NAME = "17546">Re(z) : SpcHydElt -&gt; FldReElt</A></H5>
<H5>Real(z) : SpcHydElt -&gt; FldReElt</H5>

<PRE>    Precision: RngIntElt                Default: 0</PRE>
<BLOCKQUOTE>
Returns the real part of z, with given precision.
</BLOCKQUOTE>
<H5><A NAME = "17547">Argument(z) : SpcHydElt -&gt; FldReElt</A></H5>

<PRE>    Precision: RngIntElt                Default: 0</PRE>
<BLOCKQUOTE>
Returns the argument of z, with given precision.
</BLOCKQUOTE>
<H5><A NAME = "17548">Abs(z) : SpcHydElt -&gt; FldReElt</A></H5>
<H5>AbsoluteValue(z) : SpcHydElt -&gt; FldReElt</H5>

<PRE>    Precision: RngIntElt                Default: 0</PRE>
<BLOCKQUOTE>
Returns the absolute value of z, with given precision.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "17549">Example <TT>GrpPSL2Shim_UnitDiscBasics (H137E4)</TT></A></H3>
In this example, we exhibit basic functions for the unit disc.
<P>
<P>
<P>
<PRE>
&gt; D := UnitDisc();
&gt; D;
Hyperbolic unit disc
&gt; CC&lt;I&gt; := ComplexField();
&gt; w := D ! ((1+I)/2);
&gt; w;
0.500000000000000000000000000000 + 0.500000000000000000000000000000*I
&gt; Re(w), Abs(w);
0.500000000000000000000000000000 0.707106781186547524400844362105
</PRE>
<P>
Note that since D does not form a ring, when binary operations are performed, we return elements according to the base ring in which they belong; if desired, they can be coerced back into D.
<P>
<P>
<P>
<PRE>
&gt; z := D ! 0;
&gt; z;
0
&gt; IsExact(z);
true 0
&gt; ComplexValue(z : Precision := 100);
0.00000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000
&gt; 2*z;
0
&gt; Type($1);
FldRatElt
&gt; D!(z+w) eq w;
true
</PRE>
<HR>
<H4><A NAME = "17550">Distance and Angles</A></H4>



<H5><A NAME = "17551">Distance(z,w) : SpcHydElt, SpcHydElt -&gt; FldReElt</A></H5>

<PRE>    Precision: RngIntElt                Default: 0</PRE>
<BLOCKQUOTE>
Returns the hyperbolic distance between z and w.
</BLOCKQUOTE>
<H5><A NAME = "17552">Geodesic(z,w) : SpcHydElt, SpcHydElt -&gt; RngElt, RngElt</A></H5>

<PRE>    Precision: RngIntElt                Default: 0</PRE>
<BLOCKQUOTE>
Returns the center and radius of the geodesic containing z and w, with given precision.
</BLOCKQUOTE>
<H5><A NAME = "17553">TangentAngle(x,y) : SpcHydElt, SpcHydElt -&gt; FldReElt</A></H5>

<PRE>    Precision: RngIntElt                Default: 0</PRE>
<BLOCKQUOTE>
Returns the angle of the tangent at x of the geodescic from x to y, with given precision.
</BLOCKQUOTE>
<H5><A NAME = "17554">Angle(e1,e2) : [SpcHydElt], [SpcHydElt] -&gt; FldReElt</A></H5>

<PRE>    Precision: RngIntElt                Default: 0</PRE>
<BLOCKQUOTE>
Given two sequences e<sub>1</sub> = [z<sub>1</sub>, z<sub>2</sub>] and e<sub>2</sub> = [z<sub>1</sub>, z<sub>3</sub>], returns 
the angle between the geodesics at z<sub>1</sub>.
</BLOCKQUOTE>
<H5><A NAME = "17555">ArithmeticVolume(P) : [SpcHydElt] -&gt; FldReElt</A></H5>

<PRE>    Precision: RngIntElt                Default: 0</PRE>
<BLOCKQUOTE>
The volume of the convex region specified the sequence of elements of
the unit disc.  The elements must be specified in counterclockwise order
by their arguments.  The volume is normalized "arithmetic" volume,
so the "usual" volume is divided by 2&pi;; this gives an ideal triangle
volume 1/2.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "17556">Example <TT>GrpPSL2Shim_UnitDiscAngle (H137E5)</TT></A></H3>
In this example, we compute geodesics in the unit disc.
<P>
<P>
<P>
<PRE>
&gt; D := UnitDisc();
&gt; CC&lt;I&gt; := ComplexField();
&gt; z0 := D!0;
&gt; z1 := D!(1/2*I);
&gt; z2 := D!(1/2);
&gt; Distance(z0,z1);
1.09861228866810969139524523692
&gt; Geodesic(z0,z1);
Infty 0.000000000000000000000000000000
&gt; Geodesic(z1,z2);
1.25000000000000000000000000000 + 1.25000000000000000000000000000*I
1.45773797371132511771853821939
&gt; TangentAngle(z0,z1);
1.57079632679489661923132169164
&gt; TangentAngle(z1,z2);
-1.03037682652431246378774332703
&gt; Angle([z1,z2],[z1,z0]);
2.60117315331920908301906501867
&gt; ArithmeticVolume([D | 1/2+1/2*I, -1/2+1/2*I, -1/2-1/2*I, 1/2-1/2*I]);
0.590334470601733096701604304899
</PRE>
<HR>
<H4><A NAME = "17557">Structural Operations</A></H4>



<H5><A NAME = "17558">T * x : GrpPSL2Elt, SpcHydElt -&gt; SpcHydElt</A></H5>
<BLOCKQUOTE>
Returns T(x), using the identification of the unit disc with the
upper half-plane.
</BLOCKQUOTE>
<H5><A NAME = "17559">Center(D) : SpcHyd -&gt; RngElt</A></H5>
<BLOCKQUOTE>
Returns the element in the upper half-plane which maps to 0 in D.
</BLOCKQUOTE>
<H5><A NAME = "17560">DiscToPlane(H,z) : SpcHyp, SpcHydElt -&gt; SpcHypElt</A></H5>
<BLOCKQUOTE>
Maps z in a unit disc to Hh.
</BLOCKQUOTE>
<H5><A NAME = "17561">PlaneToDisc(D,z) : SpcHyd, SpcHypElt -&gt; SpcHydElt</A></H5>
<BLOCKQUOTE>
Maps z in an upper half-plane to D.
</BLOCKQUOTE>
<H5><A NAME = "17562">Matrix(g,D) : GrpPSL2Elt, SpcHyd -&gt; AlgMatElt</A></H5>
<BLOCKQUOTE>
Returns the matrix representation of g acting on the unit disc D.
</BLOCKQUOTE>
<H5><A NAME = "17563">FixedPoints(g,D) : GrpPSL2Elt, SpcHyd -&gt; SeqEnum</A></H5>
<BLOCKQUOTE>
Returns the fixed points of g acting on D.
</BLOCKQUOTE>
<H5><A NAME = "17564">IsometricCircle(g) : GrpPSL2Elt -&gt; RngElt, RngElt</A></H5>
<H5>IsometricCircle(g,H) : GrpPSL2Elt, SpcHyp -&gt; RngElt, RngElt</H5>
<BLOCKQUOTE>
Returns the center and radius of the set of points in the upper half-plane H
where g acts as a Euclidean isometry.
</BLOCKQUOTE>
<H5><A NAME = "17565">IsometricCircle(g,D) : GrpPSL2Elt, SpcHyd -&gt; RngElt, RngElt</A></H5>
<BLOCKQUOTE>
Returns the center and radius of the set of points in the unit disc D where 
g acts as a Euclidean isometry.
</BLOCKQUOTE>
<H5><A NAME = "17566">GeodesicsIntersection(x1,x2) : [SpcHydElt], [SpcHydElt]) -&gt; .</A></H5>
<BLOCKQUOTE>
Returns the intersection in the unit disc of the two geodesics x<sub>1</sub>, x<sub>2</sub>,
where x and y are specified by their end points.  If more than
one intersection exists, returns a sequence.
</BLOCKQUOTE>
<H5><A NAME = "17567">BoundaryIntersection(x) : [SpcHydElt] -&gt; [FldComElt]</A></H5>
<BLOCKQUOTE>
Computes the intersection of the geodesic x with the boundary
of the unit disc.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "17568">Example <TT>GrpPSL2Shim_UnitDiscPractice2 (H137E6)</TT></A></H3>
<P>
In this example, we illustrate the use of the structural operations on 
the unit disc.  We begin by declaring a Fuchsian group over the totally real
subfield F=Q(&zeta;<sub>9</sub>)^ + of Q(&zeta;<sub>9</sub>).
<P>
<P>
<P>
<PRE>
&gt; K&lt;z&gt; := CyclotomicField(9);
&gt; F := sub&lt;K | z+1/z &gt;;
&gt; b := F! (z+1/z);
&gt; A&lt;alpha,beta&gt; := QuaternionAlgebra&lt;F | -3, -b&gt;;
&gt; G := FuchsianGroup(A);
&gt; O := BaseRing(G);
&gt; A&lt;alpha,beta&gt; := Algebra(O);
</PRE>
<P>
Next, we compute the fixed point of the element g=(1 + &alpha;)/2.
<P>
<P>
<P>
<PRE>
&gt; g := G!((1+alpha)/2);
&gt; H := UpperHalfPlane();
&gt; FixedPoints(g, H);
[
    root(-1)
]
&gt; Matrix(g);
[0.5000000000000000000000000000000000000000000000000000000000000000000000000000
    000000000000000000000000 0.866025403784438646763723170752936183471402626905
    1903140279034897259665084544000185405730933786242878]
[-0.866025403784438646763723170752936183471402626905190314027903489725966508454
    4000185405730933786242878 0.50000000000000000000000000000000000000000000000
    00000000000000000000000000000000000000000000000000000]
&gt; g*H.1;
root(-1);
</PRE>
<P>
The fixed point is at z=i.  Next, we compute the isometric circle C(g) of g,
 C(g)={z &isin;C: |g(z)|=|z| }. 
(See also the next section on fundamental domains.)
<P>
<P>
<P>
<PRE>
&gt; cH, rH := IsometricCircle(g);
&gt; cH;
0.57735026918962576450914878050195745564760175127012687601860232648397767230293
33456937153955857495252
&gt; rH;
1.15470053837925152901829756100391491129520350254025375203720465296795534460586
6691387430791171499050
</PRE>
<P>
The circle C(g) has radius r<sub>H</sub>=1.154 ... and center c<sub>H</sub>=0.577 ... .  We verify that g acts by a Euclidean isometry at the point c<sub>H</sub> + r<sub>H</sub> i &isin;C(g).
<P>
<P>
<P>
<PRE>
&gt; CC&lt;I&gt; := ComplexField();
&gt; Abs(Matrix(g)[2,1]*(cH+rH*I)+Matrix(g)[2,2]);
1.00000000000000000000000000000
</PRE>
<P>
We now repeat these same steps, with g acting on the unit disc D.
<P>
<P>
<P>
<PRE>
&gt; D := UnitDisc(: Center := 9/10*H.1);
&gt; Matrix(g, D);
[0.5000000000000000000000000000000000000000000000000000000000000000000000000000
    000000000000000000000000 + 0.8708366560276855281346327439238178790538869671
    932875211895468244836121536336192488985662869809493679*$.1
    -0.091413792621690746047281890246448583363214116792146568962386184205317861
    46329352761052320334348050449*$.1]
[0.0914137926216907460472818902464485833632141167921465689623861842053178614632
    9352761052320334348050449*$.1 0.5000000000000000000000000000000000000000000
    000000000000000000000000000000000000000000000000000000000 -
    0.8708366560276855281346327439238178790538869671932875211895468244836121536
    336192488985662869809493679*$.1]
&gt; cD, rD := IsometricCircle(g, D);
&gt; Abs(Matrix(g, D)[2,1]*PlaneToDisc(D, H!(cH+rH*I))+Matrix(g, D)[2,2]);
1.00000000000000000000000000000
</PRE>
<HR>
<PRE></PRE> <A  HREF = "text1566.htm">[Next]</A><A  HREF = "text1564.htm">[Prev]</A> <A  HREF = "text1566.htm">[Right]</A> <A  HREF = "text1564.htm">[Left]</A> <A  HREF = "text1563.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<br><small>Version: V2.22 of <I>
Thu Jun  9 16:37:49 EST 2016
</I></small>
</body></html>