<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <link rel='stylesheet' href='help.css' type='text/css'>
  <TITLE>Structure Operations</TITLE>
</head>
<body BGCOLOR="#FFFFFF">

 <A  HREF = "text390.htm">[Next]</A><A  HREF = "text388.htm">[Prev]</A> <A  HREF = "text390.htm">[Right]</A> <A  HREF = "text388.htm">[Left]</A> <A  HREF = "text383.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<PRE></PRE><H3><A NAME = "3712">Structure Operations</A></H3>

<P>
<P>
<P>
In the lists below F usually refers to an algebraic field, K to a number field and O to an order.



<H5>Subsections</H5>
<UL>
<LI> <A  HREF = "text389.htm#3713">General Functions</A>
<LI> <A  HREF = "text389.htm#3719">Related Structures</A>
<LI> <A  HREF = "text389.htm#3738">Representing Fields as Vector Spaces</A>
<LI> <A  HREF = "text389.htm#3742">Invariants</A>
<LI> <A  HREF = "text389.htm#3759">Basis Representation</A>
<LI> <A  HREF = "text389.htm#3771">Ring Predicates</A>
<LI> <A  HREF = "text389.htm#3782">Order Predicates</A>
<LI> <A  HREF = "text389.htm#3789">Field Predicates</A>
<LI> <A  HREF = "text389.htm#3801">Setting Properties of Orders</A>
</UL>
<H4><A NAME = "3713">General Functions</A></H4>

<P>
<P>
Number fields form the Magma category <TT>FldNum</TT>, orders
form <TT>RngOrd</TT> and their fields of fractions form <TT>FldOrd</TT>. 
The notional power structures exist as parents
of algebraic fields and their orders, no operations are allowed.


<H5>Category(F) : FldAlg -&gt; Cat</H5>

<H5>Parent(F) : FldAlg -&gt; Pow</H5>


<H5>Category(O) : RngOrd -&gt; Cat</H5>

<H5>Parent(O) : RngOrd -&gt; Pow</H5><P>


<H5><A NAME = "3714">AssignNames(~K, s) : FldNum, [ MonStgElt ] -&gt;</A></H5>
<BLOCKQUOTE>
Procedure to change the names of the generating elements in the
number field K to the contents of the sequence of strings s.
<P>
The i-th sequence element will be the name used for the generator of
the (i - 1)-st subfield down from K as determined by the creation of K, 
the first element being used 
as the name for the generator of K. 
In the case where K is defined by more than one polynomial as an absolute
extension, the ith sequence element will be the name used for the 
root of the ith polynomial used in the creation of K.
<P>
This procedure only changes the names used in printing the elements of K.
It does <I>not</I> assign to any identifiers 
the value of a generator in K; to do this, use an assignment statement,
or use angle brackets when creating the field.
<P>
Note that since this is a procedure that modifies K,
it is necessary to have a reference <TT>~K</TT> to K
in the call to this function.
</BLOCKQUOTE>
<H5><A NAME = "3715">Name(K, i) : FldNum, RngIntElt -&gt; FldNumElt</A></H5>
<H5>K . i : FldNum, RngIntElt -&gt; FldNumElt</H5>
<BLOCKQUOTE>
Given a number field K, return the
element which has the i-th name attached to it,
that is, the generator of the (i - 1)-st subfield down from K
as determined by the creation of K.
Here i must be
in the range 1&le;i&le;m, where m is the number of polynomials
used in creating K. If K was created using multiple polynomials 
as an absolute extension, <TT>K.i</TT> will be a root of the ith polynomial
used in creating K.
</BLOCKQUOTE>
<H5><A NAME = "3716">AssignNames(~F, s) : FldOrd, [ MonStgElt ] -&gt;</A></H5>
<BLOCKQUOTE>
Assign the strings in the sequence s to the names of the basis elements
of the field of fractions F.
</BLOCKQUOTE>
<H5><A NAME = "3717">F . i : FldOrd, RngIntElt -&gt; FldOrdElt</A></H5>
<H5>Name(F, i) : FldOrd, RngIntElt -&gt; FldOrdElt</H5>
<BLOCKQUOTE>
Return the ith basis element of the field of fractions F.
</BLOCKQUOTE>
<H5><A NAME = "3718">O . i : RngOrd, RngIntElt -&gt; RngOrdElt</A></H5>
<BLOCKQUOTE>
Return the ith basis element of the order O.
</BLOCKQUOTE>
<H4><A NAME = "3719">Related Structures</A></H4>

<P>
<P>
Each order and field has other orders and fields which are related to
it in various ways.


<H5>PrimeRing(F) : FldAlg -&gt; RngRat</H5>

<H5>PrimeField(F) : FldAlg -&gt; RngRat</H5>

<H5>PrimeRing(O) : RngOrd -&gt; RngInt</H5><P>

<H5>Centre(F) : FldAlg -&gt; FldAlg</H5>

<H5>Centre(O) : RngOrd -&gt; RngOrd</H5><P>




<H5><A NAME = "3720">GroundField(F) : FldAlg -&gt; Fld</A></H5>
<H5>BaseField(F) : FldAlg -&gt; Fld</H5>
<H5>CoefficientField(F) : FldAlg -&gt; Fld</H5>
<H5>CoefficientRing(F) : FldAlg -&gt; Fld</H5>
<BLOCKQUOTE>
Given an algebraic field F, return the algebraic field over 
which F was defined.
For an absolute number field F, the function returns the rational
field Q.
</BLOCKQUOTE>
<H5><A NAME = "3721"></A><A NAME = "RngOrd:BaseRing">BaseRing</A>(O) : RngOrd -&gt; Rng</H5>
<H5>CoefficientRing(O) : RngOrd -&gt; Rng</H5>
<BLOCKQUOTE>
Given an order O, this returns the order over which O was defined.
For an absolute order O this will be the integers
Z.
</BLOCKQUOTE>
<H5><A NAME = "3722">AbsoluteField(F) : FldAlg -&gt; FldAlg</A></H5>
<BLOCKQUOTE>
Given an algebraic field F, this returns an isomorphic number field
L defined as an absolute extension (i.e. over Q).
</BLOCKQUOTE>
<H5><A NAME = "3723">AbsoluteOrder(O) : RngOrd -&gt; RngOrd</A></H5>
<BLOCKQUOTE>
Given an order O, this returns an isomorphic order
O' defined as an order in an absolute extension (over Q).
</BLOCKQUOTE>
<H5><A NAME = "3724">SimpleExtension(F) : FldAlg -&gt; FldAlg</A></H5>
<H5>SimpleExtension(O) : RngOrd -&gt; RngOrd</H5>
<BLOCKQUOTE>
Given an algebraic field F or an order O,
this returns an isomorphic field
L defined as an absolute simple extension
or the Z-isomorphic order in it.
</BLOCKQUOTE>
<H5><A NAME = "3725">RelativeField(F, L) : FldAlg, FldAlg -&gt; FldAlg</A></H5>
<H5>RelativeField(Q, L) : FldRat, FldAlg -&gt; FldAlg</H5>
<BLOCKQUOTE>
Given algebraic fields L and F such that Magma knows
that F is a subfield of L, return an isomorphic algebraic 
field M defined as an extension over F.
</BLOCKQUOTE>
<H5><A NAME = "3726">Components(F) : FldAlg -&gt; [FldAlg]</A></H5>
<H5>Components(O) : RngOrd -&gt; [RngOrd]</H5>
<BLOCKQUOTE>
Given an equation order O or a field of fractions F of an equation 
order O return the sequence of orders or fields each defined by
a defining polynomial of O or F.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "3727">Example <TT>RngOrd_Compositum (H38E8)</TT></A></H3>
It is often desirable to build up a number field by adjoining several
algebraic numbers to Q. The following function returns a number field
that is the composite field of two given number fields K and L, provided that K&cap;L=Q; if K and L have a common subfield larger than Q the function returns a field with the property that it contains a subfield isomorphic to K as well as a subfield
isomorphic to L.
<P>
<P>
<PRE>
&gt; R&lt;x&gt; := PolynomialRing(Integers());
&gt; Composite := function( K, L )
&gt;     T&lt;y&gt; := PolynomialRing( K );
&gt;     f := T!DefiningPolynomial( L );	
&gt;     ff := Factorization(f);
&gt;     LKM := NumberField(ff[1][1]);
&gt;     return AbsoluteField(LKM);
&gt; end function;
</PRE>
To create, for example, the field Q(Sqrt(2), Sqrt(3), Sqrt(5)), the
above function should be applied twice:
<P>
<P>
<PRE>
&gt; K := NumberField(x^2-3);
&gt; L := NumberField(x^2-2);
&gt; M := NumberField(x^2-5);
&gt; KL := Composite(K, L);
&gt; S&lt;s&gt; := PolynomialRing(BaseField(KL));
&gt; KLM&lt;w&gt; := Composite(KL, M);
&gt; KLM;
Number Field with defining polynomial s^8 - 40*s^6 + 352*s^4 - 960*s^2 + 576 
over the Rational Field
</PRE>
Note, that the same field may be constructed with just one call
to <TT>NumberField</TT> followed by <TT>AbsoluteField</TT>:
<P>
<P>
<PRE>
&gt; KLM2 := AbsoluteField(NumberField([x^2-3, x^2-2, x^2-5]));
&gt; KLM2;
Number Field with defining polynomial s^8 - 40*s^6 + 352*s^4 - 960*s^2 + 576 
over the Rational Field
</PRE>
or by
<P>
<P>
<PRE>
&gt; AbsoluteField(ext&lt;Rationals() | [x^2-3, x^2-2, x^2-5]&gt;);
Number Field with defining polynomial s^8 - 40*s^6 + 352*s^4 - 960*s^2 + 576 
over the Rational Field
</PRE>
In general, however, the resulting polynomials of KLM and KLM2 will differ.
To see the difference between <TT>SimpleExtension</TT> and <TT>AbsoluteField</TT>,
we will create <TT>KLM2</TT> again:
<P>
<P>
<PRE>
&gt; KLM3 := NumberField([x^2-3, x^2-2, x^2-5]: Abs);
&gt; AbsoluteField(KLM3);
Number Field with defining polynomials [ x^2 - 3, x^2 - 2, 
    x^2 - 5] over the Rational Field
&gt; SimpleExtension(KLM3);
Number Field with defining polynomial s^8 - 40*s^6 + 352*s^4 - 960*s^2 + 576 
over the Rational Field
</PRE>
<HR>
<H5><A NAME = "3728">Simplify(O) : RngOrd -&gt; RngOrd</A></H5>
<BLOCKQUOTE>
Given an order O, obtained by a chain of transformations from 
an equation order E, return an order that is given directly by
a single transformation over E.
</BLOCKQUOTE>
<H5><A NAME = "3729">LLL(O) : RngOrd -&gt; RngOrd, AlgMatElt</A></H5>

<PRE>    Delta: RngElt                       Default: 0.99</PRE>
<BLOCKQUOTE>
Given an order O, return an order O' obtained from O
by a transformation matrix T, which is returned as a second value.
O' will have a LLL-reduced basis.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "3730">Example <TT>RngOrd_lll (H38E9)</TT></A></H3>
Using <TT>LLL</TT> to reduce the basis of an order is shown.
<P>
<P>
<PRE>
&gt; M := MaximalOrder(x^4-14*x^3+14*x^2-14*x+14);
&gt; L, T := LLL(M);
&gt; L;
Maximal Order, Transformation of M
Transformation Matrix:
[  1   0   0   0]
[ -3   1   0   0]
[  3 -13   1   0]
[ -7   1 -13   1]
&gt; T;
[  1   0   0   0]
[ -3   1   0   0]
[  3 -13   1   0]
[ -7   1 -13   1]
&gt; Basis(M);
[
    M.1,
    M.2,
    M.3,
    M.4
]
&gt; Basis(L, M);
[
    [1, 0, 0, 0],
    [-3, 1, 0, 0],
    [3, -13, 1, 0],
    [-7, 1, -13, 1]
]
&gt; L eq M;
true
</PRE>
Even though L and M are considered to be equal because they contain
the same elements L has a basis which is LLL reduced but M does not.
<P>
Following on from the orders and ideals example (<A  HREF = "text386.htm#3692">H38E5</A>)
we have 
<P>
<P>
<PRE>
&gt; R&lt;x&gt; := PolynomialRing(Integers());
&gt; K := NumberField(x^4-420*x^2+40000);
&gt; E := EquationOrder(K);
&gt; O := Round2(E, K);
[ &lt;2, 18&gt;, &lt;5, 8&gt;, &lt;41, 2&gt; ]
index is 2
index is 4
index is 8
index is 4
index is 2
index is 1
index is 5
index is 25
index is 1
index is 1
index of equation order in maximal order is: 64000
&gt; L := LLL(O);
&gt; O;
Transformation of E
Transformation Matrix:
[800   0   0   0]
[  0 400   0   0]
[  0 200  20   0]
[400 180   0   1]
Denominator: 800
&gt; O:Maximal;
   F[1]
    |
   F[2]
  /
 /
Q
F  [ 1]     Given by transformation matrix
F  [ 2]     x^4 - 420*x^2 + 40000
Index: 64000/1 
Signature: [4, 0]
&gt; L;
Transformation of O
Transformation Matrix:
[-1  0  0  0]
[-1 -1  0  1]
[10  1 -2  0]
[ 5  1 -1  0]
&gt; L:Maximal;
   F[1]
    |
   F[2]
    |
   F[3]
  /
 /
Q
F  [ 1]     Given by transformation matrix
F  [ 2]     Given by transformation matrix
F  [ 3]     x^4 - 420*x^2 + 40000
Index: 1/1 
Signature: [4, 0]
&gt; Simplify(L):Maximal;
   F[1]
    |
   F[2]
  /
 /
Q
F  [ 1]     Given by transformation matrix
F  [ 2]     x^4 - 420*x^2 + 40000
Index: 64000/1 
Signature: [4, 0]
&gt; Simplify(L);
Transformation of E
Transformation Matrix:
[-800    0    0    0]
[-400 -220    0    1]
[8000    0  -40    0]
[4000  200  -20    0]
Denominator: 800
</PRE>
<HR>
<H5><A NAME = "3731">Embed(F, L, a) : FldAlg, FldAlg, FldAlgElt -&gt;</A></H5>
<BLOCKQUOTE>
Install the embedding of a simple field F in L 
where the image of the primitive element
of F is the element a of L. This embedding will be used in 
coercing from F into L.
</BLOCKQUOTE>
<H5><A NAME = "3732">Embed(F, L, a) : FldAlg, FldAlg, [FldAlgElt] -&gt;</A></H5>
<BLOCKQUOTE>
Install the embedding of the non-simple field F in L
where the image of the generating elements
of F are in the sequence a of elements of L. This embedding will be 
used in coercing from F into L.
</BLOCKQUOTE>
<H5><A NAME = "3733">EmbeddingMap(F, L): FldAlg, FldAlg -&gt; Map</A></H5>
<BLOCKQUOTE>
Returns the embedding map of F in L if an embedding is known.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "3734">Example <TT>RngOrd_em (H38E10)</TT></A></H3>
Magma does not recognize two independently created number fields as equal
since more than one embedding of a field in a larger field may be possible.
To coerce between them then it is convenient to be able to embed them
in each other.
<P>
<P>
<PRE>
&gt; k := NumberField(x^2-2);
&gt; l := NumberField(x^2-2);
&gt; l!k.1; 
&gt;&gt; l!k.1; 
    ^
Runtime error in '!': Arguments are not compatible
LHS: FldNum
RHS: FldNumElt
&gt; l eq k;
false
&gt; Embed(k, l, l.1);
&gt; l!k.1;           
l.1
&gt; Embed(l, k, k.1);
&gt; k!l.1;
k.1
</PRE>
<TT>Embed</TT> is useful in specifying the embedding of a field in a larger 
field.
<P>
<P>
<PRE>
&gt; l&lt;a&gt; := NumberField(x^3-2);
&gt; L&lt;b&gt; := NumberField(x^6+108);
&gt; Root(L!2, 3);
1/18*b^4
&gt; Embed(l, L, $1);
&gt; L!l.1;
1/18*b^4
</PRE>
Another embedding would be
<P>
<P>
<PRE>
&gt; Roots(PolynomialRing(L)!DefiningPolynomial(l));
[
    &lt;1/36*(-b^4 - 18*b), 1&gt;,
    &lt;1/36*(-b^4 + 18*b), 1&gt;,
    &lt;1/18*b^4, 1&gt;
]
&gt; Embed(l, L, $1[1][1]);
&gt; L!l.1;
1/36*(-b^4 - 18*b)
</PRE>
<HR>
<H5><A NAME = "3735"></A><A NAME = "RngOrd:Completion1">Completion</A>(K, P) : FldAlg, RngOrdIdl -&gt; FldLoc, Map</H5>
<H5>Completion(O, P) : RngOrd, RngOrdIdl -&gt; RngLoc, Map</H5>
<H5>comp&lt;K|P&gt; : FldAlg, RngOrdIdl -&gt; FldLoc, Map</H5>
<H5>comp&lt;O|P&gt; : RngOrd, RngOrdIdl -&gt; RngLoc, Map</H5>

<PRE>    Precision: RngIntElt                Default: 50</PRE>
<BLOCKQUOTE>
For an absolute extension K of Q or O of Z, compute the
completion at a prime ideal P which must be either a prime ideal
of the maximal order or unramified.
The result will be a local field or ring with precision <TT>Precision</TT>
or e<TT>*Precision</TT> if the ideal is ramified with ramification degree e.
<P>
The returned map is the canonical injection into the
completion. It allows pointwise inverse operations.
</BLOCKQUOTE>
<H5><A NAME = "3736">Completion(K, P) : FldAlg, PlcNumElt -&gt; FldLoc, Map</A></H5>

<PRE>    Precision: RngIntElt                Default: 50</PRE>
<BLOCKQUOTE>
For an absolute extension K over Q and a (finite) place
P, compute the completion at P. The precision and the map
are as described for <A  HREF = "text389.htm#RngOrd:Completion1">Completion</A>.
</BLOCKQUOTE>
<H5><A NAME = "3737">LocalRing(P, prec) : RngOrdIdl, RngIntElt -&gt; RngLoc, Map</A></H5>
<BLOCKQUOTE>
The completion of <TT>Order(P)</TT> at the prime ideal P up to
precision <TT>prec</TT>.
</BLOCKQUOTE>
<H4><A NAME = "3738">Representing Fields as Vector Spaces</A></H4>

<P>
<P>
These functions are used to recreate a number field as an associative algebra
or as a vector space.  In both cases, the base field may be any subfield.


<H5><A NAME = "3739">Algebra(K, J) : FldAlg, Fld -&gt; AlgAss, Map</A></H5>
<H5>Algebra(K, J, S) : FldAlg, Fld, [FldAlgElt] -&gt; AlgAss, Map</H5>
<BLOCKQUOTE>
Returns the associative structure constant algebra which is isomorphic to
the algebraic field K as an algebra over J. Also returns the
isomorphism from K to the algebra mapping w<sup>i</sup> to the i + 1st unit
vector of the algebra where w is a primitive element of K.
<P>
If a sequence S is given it is taken to be a basis of K over J and
the isomorphism will map the ith element of S to the ith unit
vector of the algebra.
</BLOCKQUOTE>
<H5><A NAME = "3740">VectorSpace(K, J) : FldAlg, Fld -&gt; ModTupFld, Map</A></H5>
<H5>KSpace(K, J) : FldAlg, Fld -&gt; ModTupFld, Map</H5>
<H5>VectorSpace(K, J, S) : FldAlg, Fld, [FldAlgElt] -&gt; ModTupFld, Map</H5>
<H5>KSpace(K, J, S) : FldAlg, Fld, [FldAlgElt] -&gt; ModTupFld, Map</H5>
<BLOCKQUOTE>
The vector space isomorphic to the algebraic field K as a vector space
over J and the isomorphism from K to the vector space. The isomorphism
maps w<sup>i</sup> to the i + 1st unit vector of the vector space where w is
a primitive element of K.
<P>
If S is given, the isomorphism will map the ith element of S to
the ith unit vector of the vector space.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "3741">Example <TT>RngOrd_vector_space_eg (H38E11)</TT></A></H3>
We use the <TT>Algebra</TT> of a relative number field to obtain the minimal
polynomial of an element over a subfield which is not in its coefficient field 
tower.
<P>
<P>
<PRE>
&gt; K := NumberField([x^2 - 2, x^2 - 3, x^2 - 7]);
&gt; J := AbsoluteField(NumberField([x^2 - 2, x^2 - 7]));
&gt; A, m := Algebra(K, J);
&gt; A;
Associative Algebra of dimension 2 with base ring J
&gt; m;
Mapping from: RngOrd: K to AlgAss: A
&gt; m(K.1);
(1/10*(J.1^3 - 13*J.1)                      0)
&gt; m(K.1^2);
(2 0)
&gt; m(K.2);  
(1/470*(83*J.1^3 + 125*J.1^2 - 1419*J.1 - 1735) 1/940*(-24*J.1^3 - 5*J.1^2 + 
    382*J.1 + 295))
&gt; m(K.2^2);
(3 0)
&gt; m(K.3);  
(1/10*(-J.1^3 + 23*J.1)                       0)
&gt; m(K.3^2);
(7 0)
&gt; A.1 @@ m;
1
&gt; A.2 @@ m;
(($.1 - 1)*$.1 - $.1 - 1)*K.1 + ($.1 + 1)*$.1 + $.1 + 1
&gt; 
&gt; r := 5*K.1 - 8*K.2 + K.3;
&gt; m(r);
(1/235*(-238*J.1^3 - 500*J.1^2 + 4689*J.1 + 6940) 1/235*(48*J.1^3 + 10*J.1^2 - 
    764*J.1 - 590))
&gt; MinimalPolynomial($1);
$.1^2 + 1/5*(-4*J.1^3 + 42*J.1)*$.1 + 5*J.1^2 - 180
&gt; Evaluate($1, r);
0
&gt; K:Maximal;

  K
  |
  |
  $1
  |
  |
  $2
  |
  |
  Q

K : $.1^2 - 2
$1 : $.1^2 - 3
$2 : x^2 - 7
&gt; Parent($3);
Univariate Polynomial Ring over J
&gt; J;
Number Field with defining polynomial $.1^4 - 18*$.1^2 + 25 over the Rational 
Field
</PRE>
<HR>
<H4><A NAME = "3742">Invariants</A></H4>

<P>
<P>
Some information describing an order can be retrieved.


<H5>Characteristic(F) : FldAlg -&gt; RngIntElt</H5>

<H5>Characteristic(O) : RngOrd -&gt; RngIntElt</H5><P>


<H5><A NAME = "3743">Degree(O) : RngOrd -&gt; RngIntElt</A></H5>
<H5><A NAME = "RngOrd:Degree">Degree</A>(F) : FldAlg -&gt; RngIntElt</H5>
<BLOCKQUOTE>
Given an algebraic field F, return the degree [F:G] of F over
its ground field G.
For an order O it returns the relative degree of O over
its ground order.
</BLOCKQUOTE>
<H5><A NAME = "3744">AbsoluteDegree(O) : RngOrd -&gt; RngIntElt</A></H5>
<H5>AbsoluteDegree(F) : FldAlg -&gt; RngIntElt</H5>
<BLOCKQUOTE>
Given an order O or an algebraic field F, return the absolute
degree of O over Z or F over Q.
</BLOCKQUOTE>
<H5><A NAME = "3745">Discriminant(O) : RngOrd -&gt; RngIntElt</A></H5>
<H5>Discriminant(O) : RngInt -&gt; RngIntElt</H5>
<H5><A NAME = "RngOrd:Discriminant">Discriminant</A>(F) : FldAlg  -&gt; RngIntElt</H5>
<H5>Discriminant(O) : RngOrd -&gt; RngOrdIdl</H5>
<H5>Discriminant(F) : FldAlg -&gt; RngOrdIdl</H5>
<BLOCKQUOTE>
Given an extension F of Q, return the discriminant
of F. This discriminant is defined to be
the discriminant of the order of the field of fractions or the equation
order of a number field. 
<P>
<P>
The discriminant of any order O defined over Z
is by definition the discriminant
of its basis, where the discriminant
of any sequence of elements &omega;<sub>i</sub> from K
is defined to be the determinant of the trace matrix of the sequence.
<P>
<P>
The discriminant of absolute fields and orders is an integer.
<P>
The discriminant 
in a relative extension is the ideal generated by the discriminants
of all sequences of elements &omega;<sub>i</sub> from O, where the discriminant
of a sequence is defined to be the determinant of its trace matrix.
This can only be computed in when the coefficient ring of O is maximal
or when O has a power basis.
<P>
<P>
The discriminant of relative orders is an ideal of the base ring.
</BLOCKQUOTE>
<H5><A NAME = "3746">AbsoluteDiscriminant(O) : RngOrd -&gt; RngIntElt</A></H5>
<BLOCKQUOTE>
Given an order O, return the absolute value of the
discriminant of O regarded as an
order over Z.
</BLOCKQUOTE>
<H5><A NAME = "3747">AbsoluteDiscriminant(K) : FldAlg -&gt; FldRatElt</A></H5>
<BLOCKQUOTE>
Given an algebraic field K, return the absolute value of the
discriminant of K regarded as an
extension of Q.
</BLOCKQUOTE>
<H5><A NAME = "3748">ReducedDiscriminant(O) : RngOrd -&gt; RngIntElt</A></H5>
<H5>ReducedDiscriminant(F) : FldAlg  -&gt; RngIntElt</H5>
<H5>ReducedDiscriminant(O) : RngOrd -&gt; RngOrdIdl</H5>
<H5>ReducedDiscriminant(F) : FldAlg  -&gt; RngOrdIdl</H5>
<BLOCKQUOTE>
The reduced discriminant of an order O is defined as the maximal
elementary divisor (elementary ideal) of the torsion module
O^#/O where O^# is the dual module to O with respect to the
trace form. The reduced discriminant of an algebraic field is that of the order
of a field of fractions and that of the equation order of a number field.
<P>
For absolute extensions this is the largest entry of the Smith normal form
of the <TT>TraceMatrix</TT>. 
For relative extensions, in addition to the <TT>TraceMatrix</TT> one has to 
consider the coefficient ideals.
<P>
For orders with a power basis, this is (a generator of) the inverse of
the ideal generated by the cofactors X and Y of Xf + Yf'=1
where f is the defining polynomial of the order and f' its
first derivative.
<P>
</BLOCKQUOTE>
<H5><A NAME = "3749">Regulator(O: parameters) : RngOrd -&gt; FldReElt</A></H5>

<PRE>    Current: BoolElt                    Default: <TT>false</TT></PRE>
<H5>Regulator(K) : FldNum -&gt; FldReElt</H5>
<BLOCKQUOTE>
Given a number field K or an order O, return the regulator of K
or O, as a real number.
Note that this will trigger the computation of the maximal
order and its unit group if they are not known yet.
This only works in an absolute extension.
<P>
If <TT>Current</TT> is <TT>true</TT> and a maximal system of independent units
is known, then the regulator of that system is returned. In this case
no effort is spent to produce a system of fundamental units.
<P>
The precision of the answer may be controlled by using <TT>SetKantPrecision</TT>
for the relevant order.
</BLOCKQUOTE>
<H5><A NAME = "3750">RegulatorLowerBound(O) : RngOrd -&gt; FldReElt</A></H5>
<H5>RegulatorLowerBound(K) : FldNum -&gt; FldReElt</H5>
<BLOCKQUOTE>
Given an order O or number field K, return a lower bound on the 
regulator of O or K.
This only works in an absolute extension.
</BLOCKQUOTE>
<H5><A NAME = "3751">Signature(O) : RngOrd -&gt; RngIntElt, RngIntElt</A></H5>
<H5>Signature(F) : FldAlg -&gt; RngIntElt, RngIntElt</H5>
<BLOCKQUOTE>
Given an absolute algebraic field F, or an order O of F, returns 
two integers, one being the number of real embeddings, the other the number 
of pairs of complex embeddings of F.
</BLOCKQUOTE>
<H5><A NAME = "3752">UnitRank(O) : RngOrd -&gt; RngIntElt</A></H5>
<H5>UnitRank(K) : FldNum -&gt; RngIntElt</H5>
<BLOCKQUOTE>
The unit rank of the order O or the number field K
(one less than the number of real embeddings plus number 
of pairs of complex embeddings).
</BLOCKQUOTE>
<H5><A NAME = "3753">Index(O, S) : RngOrd, RngOrd -&gt; RngIntElt</A></H5>
<H5>Index(O, S) : RngOrd, RngOrd -&gt; RngOrdIdl</H5>
<BLOCKQUOTE>
The module index of order S in order O, for orders S&sub;O.
O and S must have the same equation order and S
must be a suborder of O.
</BLOCKQUOTE>
<H5><A NAME = "3754">DefiningPolynomial(F) : FldAlg -&gt; RngUPolElt</A></H5>
<H5>DefiningPolynomial(O) : RngOrd -&gt; RngUPolElt</H5>
<H5>DefiningPolynomial(F) : FldAlg -&gt; [RngUPolElt]</H5>
<H5>DefiningPolynomial(O) : RngOrd -&gt; [RngUPolElt]</H5>
<BLOCKQUOTE>
Given an algebraic field F,
the polynomial
defining F as an extension of its ground field G is returned.
For an order O, a integral polynomial is returned that defines O
over its coefficient ring.
<P>
For non simple extensions, this will return a list of polynomials.
</BLOCKQUOTE>
<H5><A NAME = "3755">Zeroes(O, n) : RngOrd, RngIntElt -&gt; [ FldReElt ]</A></H5>
<H5>Zeros(O, n) : RngOrd, RngIntElt -&gt; [ FldReElt ]</H5>
<H5>Zeroes(F, n) : FldAlg, RngIntElt -&gt; [ FldReElt ]</H5>
<H5>Zeros(F, n) : FldAlg, RngIntElt -&gt; [ FldReElt ]</H5>
<BLOCKQUOTE>
Given an absolute algebraic field F or an order O in F, and an 
integer n, return the zeroes of the defining polynomial of F 
with a precision of exactly n decimal digits.
The function returns a sequence of length the degree of F; all of the
real zeroes appear before the complex zeroes.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "3756">Example <TT>RngOrd_zero (H38E12)</TT></A></H3>
The information provided by <TT>Zeros</TT> and <TT>DefiningPolynomial</TT>
is illustrated below.
<P>
<P>
<PRE>
&gt; L := NumberField(x^6+108);
&gt; DefiningPolynomial(L);
x^6 + 108
&gt; Zeros(L, 30);
[ 1.889881574842309747150815910899999999994 + 
1.0911236359717214035600726141999999999977*i, 
1.889881574842309747150815910899999999994 - 
1.0911236359717214035600726141999999999977*i,  0.E-29 + 
2.1822472719434428071201452283999999999955*i,  0.E-29 - 
2.1822472719434428071201452283999999999955*i, 
-1.889881574842309747150815910899999999994 + 
1.0911236359717214035600726141999999999977*i, 
-1.889881574842309747150815910899999999994 - 
1.0911236359717214035600726141999999999977*i ]
&gt; l := NumberField(x^3 - 2);
&gt; DefiningPolynomial(l);
x^3 - 2
&gt; Zeros(l, 30);
[ 1.259921049894873164767210607299999999994, 
-0.629960524947436582383605303639109999999 + 
1.0911236359717214035600726141999999999977*i, 
-0.629960524947436582383605303639109999999 - 
1.0911236359717214035600726141999999999977*i ]
</PRE>
<HR>
<H5><A NAME = "3757">Different(O) : RngOrd -&gt; RngOrdIdl</A></H5>
<BLOCKQUOTE>
The different of a maximal order O&sub;K is defined as the inverse ideal 
of
{ x &isin;K | Tr(xO)&sub;O}.
</BLOCKQUOTE>
<H5><A NAME = "3758">Conductor(O) : RngOrd -&gt; RngOrdIdl</A></H5>
<BLOCKQUOTE>
The conductor of an order O is the largest ideal of its maximal order
that is still contained in O:
{ x &isin;M | xM &sube;O}.
</BLOCKQUOTE>
<H4><A NAME = "3759">Basis Representation</A></H4>

<P>
<P>
The basis of an order or algebraic field can be expressed using elements
from any compatible ring. Basis related matrices can be formed.


<H5><A NAME = "3760">Basis(O) : RngOrd -&gt; [ FldOrdElt ]</A></H5>
<H5>Basis(O, R) : RngOrd, Rng -&gt; [ RngElt ]</H5>
<H5>Basis(F) : FldAlg -&gt; [ FldAlgElt ]</H5>
<H5>Basis(F, R) : FldAlg, Rng -&gt; [ RngElt ]</H5>
<BLOCKQUOTE>
Return the current basis for the order O or algebraic field F 
over its ground ring
as a sequence of elements of its field of fractions or as a sequence 
of elements of R.
</BLOCKQUOTE>
<H5><A NAME = "3761">IntegralBasis(F) : FldAlg -&gt; [ FldAlgElt ]</A></H5>
<H5>IntegralBasis(F, R) : FldAlg, Rng -&gt; [ RngElt ]</H5>
<BLOCKQUOTE>
An integral basis for the algebraic field F is returned as a
sequence of elements of F or R if given. This is the same as the basis for
the maximal order. Note that the maximal order will be determined
(and stored) if necessary.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "3762">Example <TT>RngOrd_basis-ring (H38E13)</TT></A></H3>
The following illustrates how a basis can look different when expressed 
in a different ring.
<P>
<P>
<PRE>
&gt; f := x^5 + 5*x^4 - 75*x^3 + 250*x^2 + 65625;
&gt; M := MaximalOrder(f);
&gt; M;
Maximal Order of Equation Order with defining polynomial x^5 + 5*x^4 - 75*x^3 + 
    250*x^2 + 65625 over its ground order
&gt; Basis(M);
[
    M.1,
    M.2,
    M.3,
    M.4,
    M.5
]
&gt; Basis(NumberField(M));
[
    1,
    $.1,
    $.1^2,
    $.1^3,
    $.1^4
]
&gt; Basis(M, NumberField(M));
[
    1,
    1/5*$.1,
    1/25*$.1^2,
    1/125*$.1^3,
    1/625*$.1^4
]
</PRE>
<HR>
<H5><A NAME = "3763"></A><A NAME = "RngOrd:AbsoluteBasis">AbsoluteBasis</A>(K) : FldAlg -&gt; [FldAlgElt]</H5>
<BLOCKQUOTE>
Returns an absolute basis for the algebraic field K, i.e. a basis for K as
a Q vector space. The basis will consist of the products of
the basis elements of the intermediate fields.
The expansion is done depth-first.
</BLOCKQUOTE>
<H5><A NAME = "3764">BasisMatrix(O) : RngOrd -&gt; AlgMatElt</A></H5>
<BLOCKQUOTE>
Given an order O in a number field K of degree n,
this returns an n x n matrix whose
i-th row contains the (rational) coefficients for the i-th basis
element of O with respect to the power basis of K. Thus,
if b<sub>i</sub> is the i-th basis element of O,
b<sub>i</sub>=&sum;<sub>j=1</sub><sup>n</sup>M<sub>ij</sub>&alpha;<sup>j - 1</sup>
where M is the matrix and &alpha; is the generator of K.
<P>
The matrix is the same as <TT>TransformationMatrix(O, E)</TT>, where
E is the equation order for K, except that the entries of the 
basis matrix are from the subfield of K, instead of the coefficient
ring of the order.
</BLOCKQUOTE>
<H5><A NAME = "3765">TransformationMatrix(O, P) : RngOrd, RngOrd -&gt; AlgMatElt, RngIntElt</A></H5>
<BLOCKQUOTE>
Returns the transformation matrix for the transformation between
the orders O and P with common equation order of degree n.
The function returns an n x n matrix T with integral
entries as well as a common integer denominator. The rows of the matrix
express the n basis elements of O as a linear combination of the
basis elements of P. Hence the effect of multiplying T on the left by
a row vector v containing the basis coefficients of an element of O
is the row vector v.T expressing the same element of the common 
number field on the basis for P.
</BLOCKQUOTE>
<H5><A NAME = "3766">CoefficientIdeals(O) : RngOrd -&gt; [RngOrdFracIdl]</A></H5>
<BLOCKQUOTE>
The coefficient ideals of the order O of a relative extension. These are 
the ideals {A<sub>i</sub>} of the coefficient ring of O such that for every element 
e of O, e = &sum;<sub>i</sub> a<sub>i</sub> * b<sub>i</sub> where {b<sub>i</sub>}
is the basis returned for O and each a<sub>i</sub> &isin;A<sub>i</sub>.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "3767">Example <TT>RngOrd_Bases (H38E14)</TT></A></H3>
We continue our example of a field of degree 4.
<P>
The functions <TT>Basis</TT> and <TT>IntegralBasis</TT> both return
a sequence of elements, that can be accessed using the operators
for enumerated sequences. Note that if, as in our example, O is
the maximal order of K, both functions produce the same output:
<P>
<P>
<PRE>
&gt; R&lt;x&gt; := PolynomialRing(Integers());
&gt; f := x^4 - 420*x^2 + 40000;
&gt; K&lt;y&gt; := NumberField(f);
&gt; O := MaximalOrder(K);
&gt; I := IntegralBasis(K);
&gt; B := Basis(O);
&gt; I, B;
[
    1,
    1/2*y,
    1/40*(y^2 + 10*y),
    1/800*(y^3 + 180*y + 400)
]
[
    O.1,
    O.2,
    O.3,
    O.4
]
&gt; Basis(O, K);
[
    1,
    1/2*y,
    1/40*(y^2 + 10*y),
    1/800*(y^3 + 180*y + 400)
]
</PRE>
The <TT>BasisMatrix</TT> function makes it possible to move between orders, in
the following manner. We may regard orders as free Z-modules of rank
the degree of the number field. The basis matrix then provides the
transformation between the order and the equation order. The function
<TT>ElementToSequence</TT> can be used to create module elements.
<P>
<P>
<PRE>
&gt; BM := BasisMatrix(O);
&gt; Mod := RSpace(RationalField(), Degree(K));
&gt; z := O ! y;
&gt; e := z^2-3*z;
&gt; em := Mod ! ElementToSequence(e);
&gt; em;
(  0 -26  40   0)
&gt; f := em*BM;
&gt; f;
( 0 -3  1  0)
</PRE>
So, since f is represented with respect to the basis of the
equation order, which is the power basis, we indeed get the original element
back. Of course it is much more useful to go in the other direction, using
the inverse transformation. We check the result in the last line:
<P>
<P>
<PRE>
&gt; E := EquationOrder(K);
&gt; f := y^3+7;
&gt; fm := Mod ! ElementToSequence(f);
&gt; e := fm*BM^-1;
&gt; e;
(-393 -360    0  800)
&gt; &amp;+[e[i]*B[i] : i in [1 .. Degree(K)] ];
-393/1*O.1 - 360/1*O.2 + 800/1*O.4
&gt; K!$1;
y^3 + 7
</PRE>
<HR>
<H5><A NAME = "3768">MultiplicationTable(O) : RngOrd -&gt; [AlgMatElt]</A></H5>
<BLOCKQUOTE>
Given an order O of some number field K of degree n, return
the multiplication table with respect to the basis of O as a sequence
of n matrices of size n x n.
The i-th matrix will have as its
j-th row the basis representation of b<sub>i</sub>b<sub>j</sub>, where b<sub>i</sub>
is the i-th basis element for O.
</BLOCKQUOTE>
<H5><A NAME = "3769">TraceMatrix(O) : RngOrd -&gt; AlgMatElt</A></H5>
<H5>TraceMatrix(F) : FldAlg -&gt; AlgMatElt</H5>
<BLOCKQUOTE>
Return the trace matrix of an order O or algebraic field F, 
which has the trace
Tr(&omega;<sub>i</sub>&omega;<sub>j</sub>) as its i, j-th entry where
the &omega;<sub>i</sub> are the basis for O or F.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "3770">Example <TT>RngOrd_MultiplicationTable (H38E15)</TT></A></H3>
We continue our example of a field of degree 4.
<P>
The multiplication table of the order O consists of 4 matrices, such
that the i-th 4 x 4 matrix (1&le;i&le;4) determines the
multiplication by the i-th basis element of O as a linear transformation
with respect to that basis. Thus the third row of T[2] gives
the basis coefficients for the product of B[2] and B[3], and
we can use the sequence reduction operator to calculate B[2] * B[3] in
an alternative way:
<P>
<P>
<PRE>
&gt; R&lt;x&gt; := PolynomialRing(Integers());
&gt; f := x^4 - 420*x^2 + 40000;
&gt; K&lt;y&gt; := NumberField(f);
&gt; O := MaximalOrder(K);
&gt; B := Basis(O);
&gt; B[2];
O.2
&gt; T := MultiplicationTable(O);
&gt; T[2];
[  0   1   0   0]
[  0  -5  10   0]
[ -5  -7   5  10]
[-25  -7  15   0]
&gt;  &amp;+[ T[2][3][i]*B[i] : i in [1..4] ];
-5/1*O.1 - 7/1*O.2 + 5/1*O.3 + 10/1*O.4
&gt; B[2]*B[3];
-5/1*O.1 - 7/1*O.2 + 5/1*O.3 + 10/1*O.4
</PRE>
The trace matrix may be found either by using the built-in function
or by the one-line definition given below (for a field of degree 4):
<P>
<P>
<PRE>
&gt; TraceMatrix(O);
[  4   0  21   2]
[  0 210 105 215]
[ 21 105 173 118]
[  2 215 118 226]
&gt; MatrixRing(RationalField(), 4) ! [Trace(B[i]*B[j]): i, j in [1..4] ];
[  4   0  21   2]
[  0 210 105 215]
[ 21 105 173 118]
[  2 215 118 226]
</PRE>
<HR>
<H4><A NAME = "3771">Ring Predicates</A></H4>

<P>
<P>
Orders and algebraic fields can be tested for having several properties
that may hold for general rings.


<H5>IsCommutative(R) : Rng -&gt; BoolElt</H5>

<H5>IsUnitary(R) : Rng -&gt; BoolElt</H5>

<H5>IsFinite(R) : Rng -&gt; BoolElt</H5>
<P>

<H5>IsOrdered(R) : Rng -&gt; BoolElt</H5>

<H5>IsField(R) : Rng -&gt; BoolElt</H5>
<P>

leftskip=large
These predicates are clear.


<H5>IsPID(F) : FldAlg -&gt; BoolElt</H5>

<H5>IsUFD(F) : FldAlg -&gt; BoolElt</H5>
<P>

<H5>IsPID(O) : RngOrd -&gt; BoolElt</H5>

<H5>IsUFD(O) : RngOrd -&gt; BoolElt</H5>
<P>

<H5>IsDomain(R) : FldAlg -&gt; BoolElt</H5>
<P>

<H5>F ne L : FldAlg, FldAlg -&gt; BoolElt</H5>

<H5>O ne N : RngOrd, RngOrd -&gt; BoolElt</H5>

<H5>O subset P : RngOrd, RngOrd -&gt; BoolElt</H5>

<H5>K subset L : FldAlg, FldAlg -&gt; BoolElt</H5>

<H5>K subset L : FldRat, FldAlg -&gt; BoolElt</H5>
<P>


<H5><A NAME = "3772">N eq O : RngOrd, RngOrd -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Two orders are equal if the
transformation matrix taking one to the other is integral and has
determinant 1 or -1. For the transformation matrix to exist
the orders must have the same number field.
</BLOCKQUOTE>
<H5><A NAME = "3773">F eq L : FldAlg, FldAlg -&gt; BoolElt</A></H5>
<H5>F eq L : FldRat, FldAlg -&gt; BoolElt</H5>
<H5>F eq L : FldAlg, FldRat -&gt; BoolElt</H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if and only if the fields F
and L, are the same.
<P>
No two algebraic fields which have been created independently of each other
will be considered equal since it is possible that they can be embedded 
into a larger field in more than one way.
</BLOCKQUOTE>
<H5><A NAME = "3774">IsNumberField(R) : . -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> iff <TT>Type(R)</TT> matches <TT>FldNum</TT>.
</BLOCKQUOTE>
<H5><A NAME = "3775">IsAlgebraicField(R) : Any -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> iff <TT>Type(R)</TT> matches <TT>FldAlg</TT> (i.e. either <TT>FldNum</TT> or <TT>FldOrd</TT>).
</BLOCKQUOTE>
<H5><A NAME = "3776">IsEuclideanDomain(F) : FldAlg -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
This is not a check for euclidean number fields. This function will
always return an error.
</BLOCKQUOTE>
<H5><A NAME = "3777">IsSimple(F) : FldAlg -&gt; BoolElt</A></H5>
<H5>IsSimple(O) : RngOrd -&gt; BoolElt</H5>
<BLOCKQUOTE>
Checks if the field F or the order O 
is defined as a simple extension over the base ring.
</BLOCKQUOTE>
<H5><A NAME = "3778">IsPrincipalIdealRing(F) : FldAlg -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Always <TT>true</TT> for fields.
</BLOCKQUOTE>
<H5><A NAME = "3779">IsPrincipalIdealRing(O) : RngOrd -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Always <TT>false</TT> for orders. Even if the class number is 1, orders
are not considered to be PIDs.
</BLOCKQUOTE>
<H5><A NAME = "3780"></A><A NAME = "RngOrd:HasComplexConjugate">HasComplexConjugate</A>(K) : FldAlg -&gt; BoolElt, Map</H5>
<BLOCKQUOTE>
This function returns <TT>true</TT> if there is an automorphism in
the field K that acts like complex conjugation.
</BLOCKQUOTE>
<H5><A NAME = "3781">ComplexConjugate(x) : FldAlgElt -&gt; FldAlgElt</A></H5>
<BLOCKQUOTE>
For an element x of a field K where <A  HREF = "text389.htm#RngOrd:HasComplexConjugate">HasComplexConjugate</A>
returns <TT>true</TT> (in particular this includes totally real fields, cyclotomic and
quadratic fields and CM-extensions), the conjugate of x is returned.
</BLOCKQUOTE>
<H4><A NAME = "3782">Order Predicates</A></H4>

<P>
<P>
Since orders are rings with additional properties, special 
predicates are applicable.


<H5><A NAME = "3783">IsEquationOrder(O) : RngOrd -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
This returns <TT>true</TT> if the basis of the order O is an integral power basis,
<TT>false</TT> otherwise.
</BLOCKQUOTE>
<H5><A NAME = "3784">IsMaximal(O) : RngOrd -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
This returns <TT>true</TT> if the order O in the field F
is the maximal order of F, <TT>false</TT> otherwise. The user is
warned that this may trigger the computation of the maximal order.
</BLOCKQUOTE>
<H5><A NAME = "3785">IsAbsoluteOrder(O) : RngOrd -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> iff the order O is a constructed as an absolute extension 
of Z.
</BLOCKQUOTE>
<H5><A NAME = "3786">IsWildlyRamified(O) : RngOrd -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> iff the order O is wildly ramified, i.e. if there is a prime
ideal P of O such that the characteristic of its residue class field
divides its ramification index.
</BLOCKQUOTE>
<H5><A NAME = "3787">IsTamelyRamified(O) : RngOrd -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> iff the order O is not wildly ramified, i.e. if for all prime
ideals P of O the characteristic of its residue class field
does not divide the ramification index.
</BLOCKQUOTE>
<H5><A NAME = "3788">IsUnramified(O) : RngOrd -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> iff the order O is unramified at the <I>finite</I>
places.
</BLOCKQUOTE>
<H4><A NAME = "3789">Field Predicates</A></H4>

<P>
<P>
Here all the predicates that are specific to algebraic fields are listed.


<H5><A NAME = "3790">IsIsomorphic(F, L) : FldAlg, FldAlg -&gt; BoolElt, Map</A></H5>
<BLOCKQUOTE>
Given two algebraic
fields F and L, this returns <TT>true</TT> as well as an isomorphism
F -&gt; L, if F and L are isomorphic,
and it returns <TT>false</TT> otherwise.
</BLOCKQUOTE>
<H5><A NAME = "3791">IsSubfield(F, L) : FldAlg, FldAlg  -&gt; BoolElt, Map</A></H5>
<H5>IsSubfield(F, L) : FldRat, FldAlg  -&gt; BoolElt, Map</H5>
<BLOCKQUOTE>
Given two algebraic
fields F and L, this returns <TT>true</TT> as well as an embedding
F -&gt; L, if F is a subfield of L, and
it returns <TT>false</TT> otherwise.
</BLOCKQUOTE>
<H5><A NAME = "3792">IsNormal(F) : FldAlg -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if and only if the algebraic 
field F is a normal extension. At
present this may only be applied if F is an absolute extension
or simple relative extension. In the relative case the result
is obtained via Galois group computation.
</BLOCKQUOTE>
<H5><A NAME = "3793">IsAbelian(F) : FldAlg -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if and only if the algebraic 
field F is a normal extension with
abelian Galois group. At present this may only be applied if F is an 
absolute extension or simple relative extension. In the
relative case the result is obtained via Galois Group computation.
</BLOCKQUOTE>
<H5><A NAME = "3794">IsCyclic(F) : FldAlg -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if and only if the algebraic 
field F is a normal extension with
cyclic Galois group. At present this may only be applied if F is an 
absolute extension or simple relative extension. In the
relative case the result is obtained via Galois and automorphism
group.
</BLOCKQUOTE>
<H5><A NAME = "3795">IsAbsoluteField(K) : FldAlg -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> iff the algebraic 
field K is a constructed as an absolute extension 
of Q.
</BLOCKQUOTE>
<H5><A NAME = "3796">IsWildlyRamified(K) : FldAlg -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> iff the algebraic 
field K is wildly ramified, i.e. if there is a prime
ideal P of K (its maximal order)
such that the characteristic of its residue class field
divides the ramification index.
</BLOCKQUOTE>
<H5><A NAME = "3797">IsTamelyRamified(K) : FldAlg -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> iff the algebraic field 
K is not wildly ramified, i.e. if for all prime
ideals P of the maximal order of K,
the characteristic of its residue class field
does not divide the ramification index.
</BLOCKQUOTE>
<H5><A NAME = "3798">IsUnramified(K) : FldAlg -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> iff the algebraic field 
K is unramified at the <I>finite</I>
places.
</BLOCKQUOTE>
<H5><A NAME = "3799">IsQuadratic(K) : FldAlg -&gt; BoolElt, FldQuad</A></H5>
<BLOCKQUOTE>
If the number field K is quadratic, return <TT>true</TT> and an isomorphic
quadratic field.
</BLOCKQUOTE>
<H5><A NAME = "3800">IsTotallyReal(K) : FldAlg -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Tests if the number field F is totally real, ie. if all infinite places are
real. For absolute fields this is equivalent to the defining polynomial
having only real roots.
</BLOCKQUOTE>
<H4><A NAME = "3801">Setting Properties of Orders</A></H4>

<P>
<P>
Several properties of orders can be set to be known and/or to have
a given value.


<H5><A NAME = "3802">SetOrderMaximal(O, b) : RngOrd, BoolElt -&gt;</A></H5>
<BLOCKQUOTE>
Set the order O to be maximal if b is <TT>true</TT> or known
to be non maximal if b is <TT>false</TT>.
</BLOCKQUOTE>
<H5><A NAME = "3803">SetOrderTorsionUnit(O, e, r) : RngOrd, RngOrdElt, RngIntElt -&gt;</A></H5>
<BLOCKQUOTE>
Set the torsion unit of the order O to be the element e with order r.
</BLOCKQUOTE>
<H5><A NAME = "3804"></A><A NAME = "RngOrd:SetOrderUnitsAreFundamental">SetOrderUnitsAreFundamental</A>(O) : RngOrd -&gt;</H5>
<BLOCKQUOTE>
This tells Magma to assume that the currently known unit group for 
the order O is the full unit group, in all subsequent calculations 
involving <TT>NumberField(O)</TT>.
(This can only be invoked after a unit group has been computed.)
</BLOCKQUOTE>
<PRE></PRE> <A  HREF = "text390.htm">[Next]</A><A  HREF = "text388.htm">[Prev]</A> <A  HREF = "text390.htm">[Right]</A> <A  HREF = "text388.htm">[Left]</A> <A  HREF = "text383.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<br><small>Version: V2.22 of <I>
Thu Jun  9 16:37:49 EST 2016
</I></small>
</body></html>