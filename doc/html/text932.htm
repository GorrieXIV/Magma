<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <link rel='stylesheet' href='help.css' type='text/css'>
  <TITLE>Ideals and Gr&ouml;bner Bases</TITLE>
</head>
<body BGCOLOR="#FFFFFF">

 <A  HREF = "text933.htm">[Next]</A><A  HREF = "text931.htm">[Prev]</A> <A  HREF = "text933.htm">[Right]</A> <A  HREF = "text931.htm">[Left]</A> <A  HREF = "text925.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<PRE></PRE><H3><A NAME = "10520">Ideals and Gr&ouml;bner Bases</A></H3>

<P>
<P>
<P>
Magma supports left-sided, right-sided, and two-sided ideals of
free algebras.
In general, there are not many operations applicable to single-sided ideals:
quotients are supported only in the case of two-sided ideals.
<P>
Within the general context of fp-algebras, the term "basis" will refer
to an <I>ordered</I> sequence of polynomials which generate an ideal.
(Thus a basis may contain duplicates and zero elements so it is dissimilar
to a basis of a vector space.)



<H5>Subsections</H5>
<UL>
<LI> <A  HREF = "text932.htm#10521">Creation of Ideals</A>
<LI> <A  HREF = "text932.htm#10525">Gr&ouml;bner Bases</A>
<LI> <A  HREF = "text932.htm#10530">Verbosity</A>
<LI> <A  HREF = "text932.htm#10534">Related Functions</A>
</UL>
<H4><A NAME = "10521">Creation of Ideals</A></H4>



<H5><A NAME = "10522">ideal&lt;A | L&gt; : AlgFr, List -&gt; AlgFr</A></H5>
<H5>lideal&lt;A | L&gt; : AlgFr, List -&gt; AlgFr</H5>
<H5>rideal&lt;A | L&gt; : AlgFr, List -&gt; AlgFr</H5>
<BLOCKQUOTE>
Given a free algebra A over a field K,
return the two-sided (<TT>ideal</TT>), left-sided (<TT>lideal</TT>), or right-sided
(<TT>rideal</TT>) of A generated by the elements of A specified by
the list L.  Each term of the list L must be an expression defining
an object of one of the following types:
<DL COMPACT class='compact'>
<DT>(a)</DT><DD>An element of A;
<DT>(b)</DT><DD>A set or sequence of elements of A;
<DT>(c)</DT><DD>An ideal of A;
<DT>(d)</DT><DD>A set or sequence of ideals of A.</DL>
</BLOCKQUOTE>
<H5><A NAME = "10523">Basis(I) : AlgFr -&gt; [ AlgFrElt ]</A></H5>
<BLOCKQUOTE>
Given an ideal I, return the current basis of I.
If a Gr&ouml;bner basis of I has been computed, that is returned.
</BLOCKQUOTE>
<H5><A NAME = "10524">BasisElement(I, i) : AlgFr, RngIntElt -&gt; AlgFrElt</A></H5>
<BLOCKQUOTE>
Given an ideal I together with an integer i, return the i-th element
of the current basis of I.  This the same as <TT>Basis(I)[i]</TT>.
</BLOCKQUOTE>
<H4><A NAME = "10525">Gr&ouml;bner Bases</A></H4>

<P>
<P>
<P>
Gr&ouml;bner bases (GBs) may be computed for any kind of ideal (left-, right-, or two-sided), but for single-sided ideals, the GBs are generally weak
(i.e., they rarely differ much from the original generators of the ideals).
<P>
Unfortunately, the GB of a given ideal may not be finite.  Thus
the Buchberger or F<sub>4</sub> algorithms below will run forever in such
cases.  One can interrupt any GB computation by pressing <TT>Ctrl-C</TT>.
Alternatively, the function <A  HREF = "text932.htm#fpa_gb_deg">GroebnerBasis</A><TT>(S,d)</TT> below, which creates
a truncated degree-d Gr&ouml;bner basis, can be used to set a limit
on the degrees of the pairs considered, so the computation will
always terminate.
<P>
As in the commutative case, when Magma constructs a
GB G of an ideal I, then G is always the unique sorted minimal
reduced GB of I.
Before this happens, an ideal will usually possess a basis which is
not a Gr&ouml;bner basis, but that will be changed into the unique
Gr&ouml;bner basis when the GB is computed.  Thus the original basis will
be discarded.  See the procedure <A  HREF = "text932.htm#FPA:Groebner">Groebner</A> below for details on the algorithms available.
<P>
The unique Gr&ouml;bner basis 
will be computed automatically when necessary; the <A  HREF = "text932.htm#FPA:Groebner">Groebner</A>
procedure below simply allows
control of the algorithms used to compute the Gr&ouml;bner basis.


<H5><A NAME = "10526"></A><A NAME = "FPA:Groebner">Groebner</A>(I: parameters) : AlgFr -&gt;</H5>
<BLOCKQUOTE>
(Procedure.)
Explicitly force a Gr&ouml;bner basis (GB) for I to be constructed.
This procedure is normally not necessary, as Magma will automatically
compute the GB when needed, but it does allow
one to control how the GB is constructed.
<P>
<P>
<PRE>
     Faugere: BoolElt                    Default: <TT>true</TT>
</PRE>
<P>
Magma has two algorithms for computing noncommutative GBs:
<P>
<DL COMPACT class='compact'>
<DL COMPACT class='compact'>
<DT>(1)</DT><DD>A noncommutative generalization (due to Allan Steel)
    of the Faug&egrave;re F<sub>4</sub> algorithm
    <A  HREF = "text924.htm#bib_FaugereF4">[Fau99]</A>, which works by specialized sparse linear algebra
    and is applicable to two-sided ideals defined over a finite field or
    the rational field;
<DT>(2)</DT><DD>The noncommutative Buchberger algorithm <A  HREF = "text924.htm#bib_CLO">[CLO96, Chap. 2, Para 7]</A> for ideals
    defined over any field.
<P>
<P>
<P>
<P>
</DL>
</DL>
If the parameter <TT>Faugere</TT> is set to <TT>true</TT>, then the Faug&egrave;re
F<sub>4</sub> algorithm will be used (if the field is a finite field or the rational
field); otherwise the Buchberger algorithm is used.
<P>
The current implementation of the Faug&egrave;re algorithm is usually very
much faster than the Buchberger algorithm and usually does not take much
more memory, so that it is why it is selected by default.  However,
there may be examples for which it may be more desirable to use the
Buchberger algorithm (particularly to save some memory).
</BLOCKQUOTE>
<H5><A NAME = "10527"></A><A NAME = "FPA:GroebnerBasis">GroebnerBasis</A>(I: parameters) : AlgFr -&gt; AlgFrElt</H5>
<BLOCKQUOTE>
Given an ideal I, force the Gr&ouml;bner basis of I to be computed,
and then return that.
The parameters are the same as those for the procedure <A  HREF = "text932.htm#FPA:Groebner">Groebner</A>.
</BLOCKQUOTE>
<H5><A NAME = "10528">GroebnerBasis(S: parameters) : [ AlgFrElt ] -&gt; [ AlgFrElt ]</A></H5>
<H5>GroebnerBasis(S: parameters) : { AlgFrElt } -&gt; [ AlgFrElt ]</H5>
<BLOCKQUOTE>
Given a set or sequence S of polynomials, return the unique Gr&ouml;bner
basis of the two-sided ideal generated by S as a sorted sequence.
This function is useful for computing Gr&ouml;bner bases without the need
to construct ideals.  The parameters are the same as those for the
procedure <A  HREF = "text932.htm#FPA:Groebner">Groebner</A>.  See also the function
<A  HREF = "text932.htm#fpa_gb_deg">GroebnerBasis</A><TT>(S,d)</TT> below, which creates a truncated
degree-d Gr&ouml;bner basis.
</BLOCKQUOTE>
<H5><A NAME = "10529"></A><A NAME = "fpa_gb_deg">GroebnerBasis</A>(S, d: parameters) : [ AlgFr ], RngInt -&gt; AlgFrElt</H5>
<BLOCKQUOTE>
Given a set or sequence S of polynomials, return the degree-d Gr&ouml;bner 
basis of the ideal generated by S, which is the truncated Gr&ouml;bner basis
obtained by ignoring S-polynomial pairs whose total degree is greater than d.
<P>
If the ideal is homogeneous, then it is guaranteed that the result
is equal to the set of all polynomials in the full Gr&ouml;bner basis of
the ideal whose total degree is less than or equal to d, and
a polynomial whose total degree is less than or equal to d is in
the ideal if and only if its normal form with respect to this truncated basis
is zero.  But if the ideal is not homogeneous, these last properties
may not hold, but it may still be useful to construct the truncated
basis.
<P>
The parameters are the same as those for the procedure <A  HREF = "text932.htm#FPA:Groebner">Groebner</A>.
</BLOCKQUOTE>
<H4><A NAME = "10530">Verbosity</A></H4>

<P>
<P>
This subsection describes the verbose flags available for the
Gr&ouml;bner basis algorithms.
There are separate verbose flags for each algorithm (<TT>Buchberger</TT>, etc.),
but the all-encompassing verbose flag <TT>Groebner</TT> includes all these
flags implicitly.
<P>
For each procedure provided for setting one of these flags, the value
<TT>false</TT> is equivalent to level 0 (nothing), and <TT>true</TT> is equivalent to level
1 (minimal verbosity).  For each <TT>Set-</TT> procedure, there is also
a corresponding <TT>Get-</TT> function to return the value of the corresponding
flag.


<H5><A NAME = "10531">SetVerbose("Groebner", v) : MonStgElt, RngIntElt -&gt;</A></H5>
<BLOCKQUOTE>
(Procedure.)
Change the verbose printing level for all Gr&ouml;bner basis algorithms
to be v.
This includes all of the algorithms whose verbosity is controlled
by flags subsequently listed, as well as some other minor related algorithms.
Currently the legal levels are 0, 1, 2, 3, or 4.
One would normally set this flag to 1 for minimal verbosity for
Gr&ouml;bner basis-type computations, and possibly also set one or more
of the following flags to levels higher than 1 for more verbosity.
</BLOCKQUOTE>
<H5><A NAME = "10532">SetVerbose("Buchberger", v) : MonStgElt, RngIntElt -&gt;</A></H5>
<BLOCKQUOTE>
(Procedure.)
Change the verbose printing level for the Buchberger algorithm to be v.
Currently the legal levels are 0, 1, 2, 3, or 4.
If the value w of the <TT>Groebner</TT> verbose flag is greater than v,
then w is taken to be the current value of this flag.
</BLOCKQUOTE>
<H5><A NAME = "10533">SetVerbose("Faugere", v) : MonStgElt, RngIntElt -&gt;</A></H5>
<BLOCKQUOTE>
(Procedure.)
Change the verbose printing level for the Faug&egrave;re algorithm to be v.
Currently the legal levels are 0, 1, 2, or 3.
If the value w of the <TT>Groebner</TT> verbose flag is greater than v,
then w is taken to be the current value of this flag.
</BLOCKQUOTE>
<H4><A NAME = "10534">Related Functions</A></H4>

<P>
<P>
The following functions and procedures perform operations related to Gr&ouml;bner
bases.


<H5><A NAME = "10535">MarkGroebner(I) : AlgFr -&gt;</A></H5>
<BLOCKQUOTE>
(Procedure.)
Given an ideal I, mark the current basis of I to be <I>the</I>
Gr&ouml;bner basis of the ideal with respect to the monomial order of the ideal.
Note that the current basis must exactly equal the unique (reverse)
sorted minimal reduced Gr&ouml;bner basis for the ideal, as returned by
the function <A  HREF = "text932.htm#FPA:GroebnerBasis">GroebnerBasis</A>.  This procedure is useful when one
creates an ideal with a basis known to be the Gr&ouml;bner basis of the
ideal from a previous computation or for other reasons.  If the basis
is not the unique Gr&ouml;bner basis, the results are unpredictable.
</BLOCKQUOTE>
<H5><A NAME = "10536"></A><A NAME = "FPA:Reduce">Reduce</A>(S) : [ AlgFrElt ] -&gt; [ AlgFrElt ]</H5>
<H5>Reduce(S) : { AlgFrElt } -&gt; [ AlgFrElt ]</H5>
<BLOCKQUOTE>
Given a set or sequence S of polynomials, return
the sequence consisting of the reduction of S.
The reduction is obtained by reducing to normal form
each element of S with respect to the other elements and sorting
the resulting non-zero elements left.  Note that all Gr&ouml;bner bases
returned by Magma are automatically reduced so that this function
would usually only be used just to simplify a set or sequence of
polynomials which is not a Gr&ouml;bner basis.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "10537">Example <TT>AlgFP_GB (H87E4)</TT></A></H3>
For a certain sequence B of noncommutative polynomials, we create the
left-, right- and two-sided ideals generated by B.  We note that for
the first two cases, the GB is no different from B, but for the two-sided
case, the GB contains several more elements.
<P>
<P>
<PRE>
&gt; K := RationalField();
&gt; F&lt;x,y,z&gt; := FreeAlgebra(K, 3);
&gt; B := [x^2 - y*z, x*y - y*z, y*x - z^2, y^3 - x*z];
&gt; I := lideal&lt;F | B&gt;;  
&gt; I;
Left ideal of Finitely presented algebra of rank 3 over Rational Field
Non-commutative Graded Lexicographical Order
Variables: x, y, z
Basis:
[
    x^2 - y*z,
    x*y - y*z,
    y*x - z^2,
    y^3 - x*z
]
&gt; GroebnerBasis(I);
[
    y^3 - x*z,
    x^2 - y*z,
    x*y - y*z,
    y*x - z^2
]
&gt; I := rideal&lt;F | B&gt;;
&gt; GroebnerBasis(I);
[
    y^3 - x*z,
    x^2 - y*z,
    x*y - y*z,
    y*x - z^2
]
&gt; I := ideal&lt;F | B&gt;;
&gt; Groebner(I);
&gt; I;
Two-sided ideal of Finitely presented algebra of rank 3 over Rational Field
Non-commutative Graded Lexicographical Order
Variables: x, y, z
Groebner basis:
[
    y*z^2*y - y*z^2,
    y*z^3 - y*z^2,
    z*y*z^2 - y*z^2,
    z^2*y^2 - y*z^2,
    z^2*y*z - y*z^2,
    z^3*y - y*z^2,
    z^4 - y*z^2,
    x*z*x - y*z^2,
    x*z*y - z^3,
    x*z^2 - y*z^2,
    y^3 - x*z,
    y^2*z - z^2*y,
    y*z*x - y*z^2,
    y*z*y - y*z^2,
    z^2*x - z^2*y,
    x^2 - y*z,
    x*y - y*z,
    y*x - z^2
]
&gt; NormalForm(x*y, I);
y*z
&gt; NormalForm(y*x, I);
z^2
</PRE>
Finally, we compute some truncated bases of the two-sided ideal.
For degree 2, the truncated GB has no new polynomials while for degree 3,
some are added.  Only at degree 5 do we obtain the full GB.
<P>
<P>
<PRE>
&gt; GroebnerBasis(B, 2);
[
    y^3 - x*z,
    x^2 - y*z,
    x*y - y*z,
    y*x - z^2
]
&gt; GroebnerBasis(B, 3);    
[
    x*z^2 - y*z^2,
    y^3 - x*z,
    y^2*z - z^2*y,
    y*z*x - y*z^2,
    y*z*y - y*z^2,
    z^2*x - z^2*y,
    x^2 - y*z,
    x*y - y*z,
    y*x - z^2
]
&gt; #GroebnerBasis(I);
18
&gt; #GroebnerBasis(B, 4);
16
&gt; #GroebnerBasis(B, 5);
18
&gt; GroebnerBasis(B, 5) eq GroebnerBasis(I);
true
</PRE>
<HR>
<PRE></PRE> <A  HREF = "text933.htm">[Next]</A><A  HREF = "text931.htm">[Prev]</A> <A  HREF = "text933.htm">[Right]</A> <A  HREF = "text931.htm">[Left]</A> <A  HREF = "text925.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<br><small>Version: V2.22 of <I>
Thu Jun  9 16:37:49 EST 2016
</I></small>
</body></html>