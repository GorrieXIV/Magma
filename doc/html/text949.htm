<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <link rel='stylesheet' href='help.css' type='text/css'>
  <TITLE>Elementary Operations on Elements</TITLE>
</head>
<body BGCOLOR="#FFFFFF">

 <A  HREF = "text950.htm">[Next]</A><A  HREF = "text948.htm">[Prev]</A> <A  HREF = "text950.htm">[Right]</A> <A  HREF = "text948.htm">[Left]</A> <A  HREF = "text942.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<PRE></PRE><H3><A NAME = "10673">Elementary Operations on Elements</A></H3>




<H5>Subsections</H5>
<UL>
<LI> <A  HREF = "text949.htm#10674">Arithmetic</A>
<LI> <A  HREF = "text949.htm#10688">Predicates</A>
</UL>
<H4><A NAME = "10674">Arithmetic</A></H4>



<H5><A NAME = "10675">a + b : AlgMatElt, AlgMatElt -&gt; AlgMatElt</A></H5>
<BLOCKQUOTE>
Sum of the matrices a and b, where a and b belong
to a common matrix algebra R.
</BLOCKQUOTE>
<H5><A NAME = "10676">a + t : AlgMatElt, RngElt -&gt; AlgMatElt</A></H5>
<H5>t + a : AlgMatElt, RngElt -&gt; AlgMatElt</H5>
<BLOCKQUOTE>
Sum of the matrix a and the scalar matrix  t * I.
</BLOCKQUOTE>
<H5><A NAME = "10677">- a : AlgMatElt -&gt; AlgMatElt</A></H5>
<BLOCKQUOTE>
Negation of the matrix a.
</BLOCKQUOTE>
<H5><A NAME = "10678">a - b : AlgMatElt, AlgMatElt -&gt; AlgMatElt</A></H5>
<BLOCKQUOTE>
Difference of the matrices a and b, where a and b
belong to the same matrix algebra R.
</BLOCKQUOTE>
<H5><A NAME = "10679">a - t : AlgMatElt, RngElt -&gt; AlgMatElt</A></H5>
<H5>t - a : AlgMatElt, RngElt -&gt; AlgMatElt</H5>
<BLOCKQUOTE>
Difference of the matrix a and the scalar matrix  t * I.
</BLOCKQUOTE>
<H5><A NAME = "10680">a * b : AlgMatElt, AlgMatElt -&gt; AlgMatElt</A></H5>
<BLOCKQUOTE>
Product of the matrices a and b, where a and b
belong to the same matrix algebra R.
</BLOCKQUOTE>
<H5><A NAME = "10681">a * b : AlgMatElt, Mtrx -&gt; Mtrx</A></H5>
<BLOCKQUOTE>
Given a matrix a belonging to a subalgebra of M<sub>n</sub>(S) and
an element b of a submodule of Hom(R<sup>(n)</sup>, R<sup>(m)</sup>), construct
the product of a and b as an element of Hom(R<sup>(n)</sup>, R<sup>(m)</sup>).
</BLOCKQUOTE>
<H5><A NAME = "10682">a * b : Mtrx, AlgMatElt -&gt; Mtrx</A></H5>
<BLOCKQUOTE>
Given a matrix a belonging to a submodule of Hom(R<sup>(n)</sup>, R<sup>(m)</sup>)
and an element b of a subalgebra of M<sub>m</sub>(S), construct
the product of a and b as an element of Hom(R<sup>(n)</sup>, R<sup>(m)</sup>).
</BLOCKQUOTE>
<H5><A NAME = "10683">t * a : RngElt, AlgMatElt -&gt; AlgMatElt</A></H5>
<H5>a * t : AlgMatElt, RngElt -&gt; AlgMatElt</H5>
<BLOCKQUOTE>
Given an element a of the matrix algebra R, and an element t belonging 
to the coefficient ring S of R, form their scalar product.
</BLOCKQUOTE>
<H5><A NAME = "10684">u * a : ModTupRngElt, AlgMatElt -&gt; ModTupElt</A></H5>
<BLOCKQUOTE>
Given an element u belonging to the S-module S<sup>(n)</sup> and an element 
a belonging to a subalgebra of M<sub>n</sub>(S), form the element u * a of S<sup>n</sup>.
</BLOCKQUOTE>
<H5><A NAME = "10685">a ^ n : AlgMatElt, RngIntElt -&gt; AlgMatElt</A></H5>
<BLOCKQUOTE>
If n is positive, form the n-th power of a; if n is zero, form
the identity matrix; if n is negative, form the ( - n)-th power of the
inverse of a.
</BLOCKQUOTE>
<H5><A NAME = "10686">NumberOfColumns(a) : AlgMatElt -&gt; RngIntElt</A></H5>
<H5>Ncols(a) : AlgMatElt -&gt; RngIntElt</H5>
<BLOCKQUOTE>
The number of columns in the matrix a.
</BLOCKQUOTE>
<H5><A NAME = "10687">NumberOfRows(a) : AlgMatElt -&gt; RngIntElt</A></H5>
<H5>Nrows(a) : AlgMatElt -&gt; RngIntElt</H5>
<BLOCKQUOTE>
The number of rows in the matrix a.
</BLOCKQUOTE>
<H4><A NAME = "10688">Predicates</A></H4>



<H5><A NAME = "10689">Comparison</A></H5>



<H5><A NAME = "10690">a eq b : AlgMatElt, AlgMatElt -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if the matrix a is equal to the matrix b, where a and b 
are elements of a common matrix algebra R.
</BLOCKQUOTE>
<H5><A NAME = "10691">a ne b : AlgMatElt, AlgMatElt -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if the matrix a is not equal to the matrix b, where a and b 
are elements of a common matrix algebra R.
</BLOCKQUOTE>
<H5><A NAME = "10692">Properties of Elements</A></H5>

<P>
<P>
The functions given here test properties of matrices.
See also the section in the Lattices chapter for a description
of the function <TT>IsPositiveDefinite</TT> and related functions.


<H5><A NAME = "10693">IsDiagonal(a) : AlgMatElt -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> iff the element a belonging to the matrix algebra R is a 
diagonal matrix; i.e. the only non-zero entries are on the diagonal.
</BLOCKQUOTE>
<H5><A NAME = "10694">IsMinusOne(a) : AlgMatElt -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> iff the element a belonging to the matrix algebra R is the 
negation of the identity element for R.
</BLOCKQUOTE>
<H5><A NAME = "10695">IsOne(a) : AlgMatElt -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> iff the element a belonging to the matrix algebra R is the 
identity element for R.
</BLOCKQUOTE>
<H5><A NAME = "10696">IsScalar(a) : AlgMatElt -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> iff the element a belonging to the matrix algebra R is a 
scalar matrix.
</BLOCKQUOTE>
<H5><A NAME = "10697">IsSymmetric(a) : AlgMatElt -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> iff the element a belonging to the matrix algebra R is a 
symmetric matrix; i.e. the transpose of a equals a.
</BLOCKQUOTE>
<H5><A NAME = "10698">IsUnit(a) : AlgMatElt -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> iff the matrix a belonging to the matrix algebra R is a unit.
</BLOCKQUOTE>
<H5><A NAME = "10699">IsZero(a) : AlgMatElt -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> iff the element a belonging to the matrix algebra R is the 
zero element for R.
</BLOCKQUOTE>
<H5><A NAME = "10700">IsNilpotent(a) : AlgMatElt -&gt; BoolElt, RngIntElt</A></H5>
<BLOCKQUOTE>
Return <TT>true</TT> if some power of the matrix a belonging to a matrix algebra
is the zero of the matrix algebra. Also returns the minimum exponent n such 
that a<sup>n</sup> = 0.
</BLOCKQUOTE>
<H5><A NAME = "10701">IsUnipotent(a) : AlgMatElt -&gt; BoolElt, RngIntElt</A></H5>
<BLOCKQUOTE>
Return <TT>true</TT> if the matrix a belonging to a matrix algebra is the
identity of that algebra plus a nilpotent matrix. Also returns the index of
nilpotence of a - I.
</BLOCKQUOTE>
<H5><A NAME = "10702">Rank(a) : AlgMatElt -&gt; RngIntElt</A></H5>
<BLOCKQUOTE>
Return the rank of the element a belonging to the matrix algebra R.
</BLOCKQUOTE>
<H5><A NAME = "10703">Determinant(A) : AlgMatElt -&gt; RngElt</A></H5>

<PRE>    MonteCarloLevel: RngIntElt          Default: 0</PRE>

<PRE>    Proof: BoolElt                      Default: <TT>true</TT></PRE>

<PRE>    pAdic: BoolElt                      Default: <TT>true</TT></PRE>

<PRE>    Divisor: RngIntElt                  Default: 0</PRE>
<BLOCKQUOTE>
Given a square matrix A over the ring R, return the
determinant of A as an element of R.
R may be any commutative ring.
The determinant of the 0 x 0 matrix over R is defined to be <TT>R!1</TT>.
<P>
If the coefficient ring is the integer ring Z or the rational field
Q then a modular algorithm based on that of
Abbott et al. <A  HREF = "text941.htm#bib_ABM_Det">[ABM99]</A> is
used, which first computes a divisor d of the determinant D using a fast
p-adic nullspace computation, and then computes the quotient D/d
by computing the determinant D modulo enough small primes to cover
the Hadamard bound divided by d.  This always yields a correct answer.
<P>
If the parameter <TT>MonteCarloLevel</TT> is set to a small positive
integer s, then a probabilistic Monte-Carlo modular technique is
used.  Rather than using sufficient primes to cover the Hadamard bound divided
by the divisor d,
this version of the algorithm terminates when the constructed residue
remains constant for s steps.  The probability of this being wrong is
non-zero but extremely small, even if s is only 1 or 2.
If the level is set to 0, then the normal deterministic algorithm
is used.  Setting the parameter <TT>Proof</TT> to <TT>false</TT> is equivalent
to setting <TT>MonteCarloLevel</TT> to 2.
<P>
If the coefficient ring is Z and the parameter <TT>Divisor</TT>
is set to an integer d, then d must be a known exact divisor of the
determinant (the sign does not matter), and the algorithm may be
sped up because of this knowledge.
</BLOCKQUOTE>
<H5><A NAME = "10704">Trace(a) : AlgMatElt -&gt; RngElt</A></H5>
<BLOCKQUOTE>
Given an element a of a subalgebra of M<sub>n</sub>(S), return the 
trace of a as an element of S.	
</BLOCKQUOTE>
<H5><A NAME = "10705">Transpose(a) : AlgMatElt -&gt; AlgMatElt</A></H5>
<BLOCKQUOTE>
Given an element a of a subalgebra of M<sub>n</sub>(S), return the
transpose of a as an element of M<sub>n</sub>(S).
</BLOCKQUOTE>
<H5><A NAME = "10706">Order(a) : AlgMatElt -&gt; RngIntElt</A></H5>
<BLOCKQUOTE>
Given an invertible matrix a over any commutative ring, determine the 
order of a.  If a has infinite order, the function may become
stuck indefinitely since it cannot prove such.
</BLOCKQUOTE>
<H5><A NAME = "10707">FactoredOrder(a) : AlgMatElt -&gt; [ &lt;RngIntElt, RngIntElt&gt; ]</A></H5>
<BLOCKQUOTE>
Given an invertible matrix a over a finite field, return the 
order of a in factored form.
</BLOCKQUOTE>
<H5><A NAME = "10708">ProjectiveOrder(a) : AlgMatElt -&gt; RngIntElt</A></H5>
<BLOCKQUOTE>
Given an invertible matrix a over a finite field, return the 
projective order o of a and a scalar s such that a<sup>o</sup> = sI.
</BLOCKQUOTE>
<H5><A NAME = "10709">FactoredProjectiveOrder(a) : AlgMatElt -&gt; [ &lt;RngIntElt, RngIntElt&gt; ]</A></H5>
<BLOCKQUOTE>
Given an invertible matrix a over a finite field, return the 
projective order o of a in factored form and a scalar s
such that a<sup>o</sup> = sI.
</BLOCKQUOTE>
<H5><A NAME = "10710">CharacteristicPolynomial(a: parameters) : AlgMatElt -&gt; RngUPolElt</A></H5>

<PRE>    Al: MonStgElt                       Default: "Modular"</PRE>

<PRE>    Proof: BoolElt                      Default: <TT>true</TT></PRE>
<BLOCKQUOTE>
The characteristic polynomial of the element a belonging to the algebra 
M<sub>n</sub>(R), where R can be any commutative ring.
The parameter <TT>Al</TT> may be used to specify
the algorithm used.  The algorithm <TT>Modular</TT> (the default) can be used for
matrices over Z and Q---in such a case the parameter <TT>Proof</TT> can also be
used to suppress proof of correctness.  The algorithm <TT>Hessenberg</TT>,
allowed for matrices over fields, works by first reducing the matrix to
Hessenberg form.  The algorithm <TT>Interpolation</TT>, allowed for matrices
over Z and Q, works by evaluating the characteristic matrix of a
at various points and then interpolating.  The algorithm <TT>Trace</TT>, allowed
for matrices over fields, works by calculating the traces of powers of a.
</BLOCKQUOTE>
<H5><A NAME = "10711">MinimalPolynomial(a) : AlgMatElt -&gt; RngUPolElt</A></H5>
<BLOCKQUOTE>
The minimal polynomial of the element a belonging to the
module M<sub>n</sub>(R), where R is a field or Z.
</BLOCKQUOTE>
<H5><A NAME = "10712">HessenbergForm(a) : AlgMatElt -&gt; AlgMatElt</A></H5>
<BLOCKQUOTE>
The Hessenberg form for the matrix a belonging to the
algebra M<sub>n</sub>(K), where the coefficient ring K must be a field.
The form has zero entries above the super-diagonal.
(This form is used in one of the characteristic polynomial algorithms.)
</BLOCKQUOTE>
<H5><A NAME = "10713">Adjoint(a) : AlgMatElt -&gt; AlgMatElt</A></H5>
<BLOCKQUOTE>
The adjoint of the matrix a belonging to the
algebra M<sub>n</sub>(K), where the coefficient ring K must be a ring with
exact division whose
characteristic must be zero or greater than the degree of a.
</BLOCKQUOTE>
<H5><A NAME = "10714">Eigenvalues(a) : AlgMatElt -&gt; { &lt;FldElt, RngIntElt&gt; }</A></H5>
<BLOCKQUOTE>
The eigenvalues of the matrix a returned as a set of pairs, each of
which gives the value of a distinct eigenvalue and its multiplicity.
The coefficient ring must have a polynomial roots algorithm.
</BLOCKQUOTE>
<H5><A NAME = "10715">Eigenspace(a, e) : AlgMatElt, FldElt -&gt; ModTup</A></H5>
<BLOCKQUOTE>
The eigenspace of the matrix a, corresponding to the eigenvalue e,
returned as a submodule of the base module for the parent algebra of a
(i.e. the kernel of a - eI).  If the ring element e is not a eigenvalue
for the matrix a then
the trivial space is returned.
</BLOCKQUOTE>
<PRE></PRE> <A  HREF = "text950.htm">[Next]</A><A  HREF = "text948.htm">[Prev]</A> <A  HREF = "text950.htm">[Right]</A> <A  HREF = "text948.htm">[Left]</A> <A  HREF = "text942.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<br><small>Version: V2.22 of <I>
Thu Jun  9 16:37:49 EST 2016
</I></small>
</body></html>