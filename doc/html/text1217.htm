<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <link rel='stylesheet' href='help.css' type='text/css'>
  <TITLE>First Operations on Ideals</TITLE>
</head>
<body BGCOLOR="#FFFFFF">

 <A  HREF = "text1218.htm">[Next]</A><A  HREF = "text1216.htm">[Prev]</A> <A  HREF = "text1218.htm">[Right]</A> <A  HREF = "text1216.htm">[Left]</A> <A  HREF = "text1214.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<PRE></PRE><H3><A NAME = "13542">First Operations on Ideals</A></H3>

<P>
<P>
In the following, note that since ideals of a full polynomial ring P
are regarded as subrings of P, the ring P itself is a valid ideal
as well (the ideal containing 1).



<H5>Subsections</H5>
<UL>
<LI> <A  HREF = "text1217.htm#13543">Simple Ideal Constructions</A>
<LI> <A  HREF = "text1217.htm#13548">Basic Commutative Algebra Operations</A>
<LI> <A  HREF = "text1217.htm#13561">Ideal Predicates</A>
<LI> <A  HREF = "text1217.htm#13577">Element Operations with Ideals</A>
</UL>
<H4><A NAME = "13543">Simple Ideal Constructions</A></H4>

<P>
<P>
The following basic constructions involve no Gr&ouml;bner basis computation.


<H5><A NAME = "13544">I + J : RngMPol, RngMPol -&gt; RngMPol</A></H5>
<BLOCKQUOTE>
Given ideals I and J of the same polynomial ring P, return the sum
of I and J, which is the ideal generated by the generators of
I and those of J.
</BLOCKQUOTE>
<H5><A NAME = "13545">I * J : RngMPol, RngMPol -&gt; RngMPol</A></H5>
<BLOCKQUOTE>
Given ideals I and J of the same polynomial ring P,
return the product of I and J, which is the ideal generated
by the products of the generators of I and those of J. 
</BLOCKQUOTE>
<H5><A NAME = "13546">I ^ k : RngMPol, RngIntElt -&gt; RngMPol</A></H5>
<BLOCKQUOTE>
Given an ideal I of the polynomial ring P, and an integer k,
return the k-th power of I.
</BLOCKQUOTE>
<H5><A NAME = "13547">I / J : RngMPol, RngMPol -&gt; RngMPolRes</A></H5>
<BLOCKQUOTE>
Given an ideal I of a polynomial ring P over a field and an ideal J
of P, such that J &sub;I, return the affine algebra I/J.
</BLOCKQUOTE>
<H4><A NAME = "13548">Basic Commutative Algebra Operations</A></H4>

<P>
<P>
The following important basic operations on ideals involve Gr&ouml;bner basis 
computation and use the standard algorithms as described in Chapter 1.8 of
<A  HREF = "text1213.htm#bib_GrPf02">[GP02]</A>, for example, unless otherwise stated.


<H5><A NAME = "13549">QuotientDimension(I) : RngMPol -&gt; RngIntElt</A></H5>
<BLOCKQUOTE>
Given an ideal I of a polynomial ring P over a field K, return
the dimension of P/I as a K-vector space.  Note that this
is quite different from the function <A  HREF = "text1224.htm#dpoly_ideal:Dimension">Dimension</A> below (which
returns the Krull dimension of an ideal). If I is not of Krull dimension
0 then the vector space is infinite and <TT>Infinity</TT> is returned.
</BLOCKQUOTE>
<H5><A NAME = "13550">ColonIdeal(I, J) : RngMPol, RngMPol -&gt; RngMPol</A></H5>
<H5>IdealQuotient(I, J) : RngMPol, RngMPol -&gt; RngMPol</H5>
<BLOCKQUOTE>
Given ideals I and J of the same polynomial ring P,
return the colon ideal I:J (or ideal quotient of I by J),
consisting of the polynomials f of P such that f * g is in I
for all g in J.
</BLOCKQUOTE>
<H5><A NAME = "13551">ColonIdeal(I, f) : RngMPol, RngMPolElt -&gt; RngMPol, RngIntElt</A></H5>
<H5>IdealQuotient(I, f) : RngMPol, RngMPolElt -&gt; RngMPol, RngIntElt</H5>
<BLOCKQUOTE>
Given an ideal I and an element f of a polynomial ring P,
return the saturation (colon) ideal I:f^&infin;,
consisting of the polynomials g of P such that
there exists an i &ge;1 with f<sup>i</sup> * g &isin;I.
An integer s with s &ge;1 is also returned such that
I:f^&infin;= I:f<sup>s</sup>.  Note that if s is not needed, only one return
value of the function should be expected which increases the efficiency
enormously.  Note also that this function is <I>not</I> equivalent to
taking the ideal quotient of I by the ideal of P generated by f.
It is in some ways a more natural operation mathematically, corresponding
to taking the full inverse image of the localised ideal I<sub>f</sub> under the
localisation map P -&gt; P<sub>f</sub>, and can
be faster than the I:f computation, if s is not required. In this
case, the computation goes by the elimination of extra variable t
from the ideal &lt;I, 1 - f * t&gt;. 
</BLOCKQUOTE>
<H5><A NAME = "13552">ColonIdealEquivalent(I, f) : RngMPol, RngMPolElt -&gt; RngMPol, RngMPolElt</A></H5>
<H5>Saturation(I, f) : RngMPol, RngMPolElt -&gt; RngMPol, RngMPolElt</H5>
<BLOCKQUOTE>
Given an ideal I and an element f of a polynomial ring P,
return the saturation (colon) ideal C=I:f^&infin;, and a polynomial g&isin;P
such that C=I:&lt; g &gt; and g is of minimal degree.
The irreducible factors of g will be a subset of the irreducible
factors of f (and the corresponding multiplicities may be greater
or lesser, depending on how often an irreducible factor divides the
ideal I).
</BLOCKQUOTE>
<H5><A NAME = "13553">Saturation(I, J) : RngMPol, RngMPol -&gt; RngMPol</A></H5>
<BLOCKQUOTE>
Given ideals I and J of some polynomial ring P, return the saturation
(I:J^&infin;): that is, the ideal
{ f &isin;P: exists n &gt; 0, f<sup>n</sup> J &sube;I}.
</BLOCKQUOTE>
<H5><A NAME = "13554">Saturation(I): RngMPol -&gt; RngMPol</A></H5>
<BLOCKQUOTE>
Given an ideal I of a polynomial ring P, return the saturation of I with
respect to the irrelevant ideal of P -- that is, the ideal of all elements of
P having positive degree.
</BLOCKQUOTE>
<H5><A NAME = "13555">Generic(I) : RngMPol -&gt; RngMPol</A></H5>
<BLOCKQUOTE>
Given an ideal I of a generic polynomial ring P, return P.
</BLOCKQUOTE>
<H5><A NAME = "13556">LeadingMonomialIdeal(I) : RngMPol -&gt; RngMPol</A></H5>
<BLOCKQUOTE>
Given an ideal I, return the leading monomial ideal of I; that is, the
ideal generated by all the leading monomials of I.
</BLOCKQUOTE>
<H5><A NAME = "13557">I meet J : RngMPol, RngMPol -&gt; RngMPol</A></H5>
<BLOCKQUOTE>
Given ideals I and J of the same polynomial ring P,
return the intersection of I and J.
</BLOCKQUOTE>
<H5><A NAME = "13558">&amp;meet S : [ RngMPol ] -&gt; RngMPol</A></H5>
<BLOCKQUOTE>
Given a set or sequence S of ideals of the same polynomial ring P,
return the intersection of all the ideals of S.
</BLOCKQUOTE>
<H5><A NAME = "13559">RegularSequence(I): RngMPol -&gt; SeqEnum</A></H5>

<PRE>    Homogeneous: BoolElt                Default: <TT>true</TT></PRE>
<BLOCKQUOTE>
Given an ideal I of a polynomial ring P over a field, computes and returns
a maximal regular sequence in I. The algorithm used is that of Eisenbud and
Sturmfels (<A  HREF = "text1213.htm#bib_eis-sturm-reg-94">[ES94]</A>) that tries to construct a regular sequence of
fairly sparse polynomials. If parameter <TT>Homogeneous</TT> is <TT>true</TT> (the default),
and I is a homogeneous ideal with respect to the variable weights, then the
regular sequence constructed will also consist of homogeneous polynomials.
</BLOCKQUOTE>
<H5><A NAME = "13560"></A><A NAME = "comm:rees-ideal">ReesIdeal</A>(P, I): RngMPol, RngMPol -&gt; RngMPol, Map</H5>
<H5>ReesIdeal(P, J, I): RngMPol, RngMPol, RngMPol -&gt; RngMPol, Map</H5>

<PRE>    a: RngMPolElt                       Default: 1</PRE>
<H5>ReesIdeal(R, I): RngMPolRes, RngMPol -&gt; RngMPol, Map</H5>

<PRE>    a: RngMPolElt                       Default: 1</PRE>
<BLOCKQUOTE>
In each case P is a multivariate polynomial ring and I is an ideal of P.
In the third case R is an affine quotient algebra of the form P/J. In the
second case J is another ideal of P and we write R for the affine
algebra P/J. In the first case, let R = P.
<P>
The Rees algebra R(I) is the finitely-generated, graded polynomial algebra
isomorphic to the algebra
<P>
 R direct-sum I direct-sum I<sup>2</sup> direct-sum I<sup>3</sup> direct-sum ... where I gives the first graded part, I<sup>2</sup> the second etc. and the multiplication
is the obvious one. Here I is thought of as an ideal of R, rather than P for
the second and third signatures. Proj of this algebra represents the blow-up of
the affine scheme Spec(R) along the closed subscheme defined by I (see 
Chapter 2, Section 7 of <A  HREF = "text1213.htm#bib_hartshorne">[Har77]</A>).
<P>
The function returns the <I>Rees ideal</I>, K, such that, if R<sub>1</sub> is the
generic polynomial ring of K, then R<sub>1</sub>/K is an affine algebra isomorphic to
R(I)/&lt;a - torsion&gt;, where a is an element of P (or R in the third case)
that gives a non-zero divisor in R and is 1 by default. In the first case,
any such a remains a non-zero divisor in R(I), so is redundant. However,
in the second and third cases, a can be specified to be not equal to 1
by use of the <TT>a</TT> parameter. Geometrically, dividing out by a-torsion
gives the coordinate ring of the maximal closed subscheme of the blow-up that
is flat over the generic point and the codimension one points defined by the
vanishing of a, if these points are regular.   
</BLOCKQUOTE>
<H4><A NAME = "13561">Ideal Predicates</A></H4>



<H5><A NAME = "13562">I eq J : RngMPol, RngMPol -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Given two ideals I and J of the same polynomial ring P,
return whether I and J are equal. Involves the use
of a Gr&ouml;bner basis for each ideal.
</BLOCKQUOTE>
<H5><A NAME = "13563">I ne J : RngMPol, RngMPol -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Given two ideals I and J of the same polynomial ring P,
return whether I and J are not equal. Involves the use
of a Gr&ouml;bner basis for each ideal.
</BLOCKQUOTE>
<H5><A NAME = "13564">I notsubset J : RngMPol, RngMPol -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Given two ideals I and J in the same polynomial ring P
return whether I is not contained in J. Involves the use
of a Gr&ouml;bner basis for J.
</BLOCKQUOTE>
<H5><A NAME = "13565">I subset J : RngMPol, RngMPol -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Given two ideals I and J in the same polynomial ring P
return whether I is contained in J.  Involves the use
of a Gr&ouml;bner basis for J.
</BLOCKQUOTE>
<H5><A NAME = "13566">IsZero(I) : RngMPol -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Given an ideal I of the polynomial ring P, return whether I is the
zero ideal (contains zero alone).
</BLOCKQUOTE>
<H5><A NAME = "13567">IsProper(I) : RngMPol -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Given an ideal I of the polynomial ring P, return whether I is proper;
that is, whether I is strictly contained in P, or whether the Gr&ouml;bner
basis of I does not contain 1 alone.
</BLOCKQUOTE>
<H5><A NAME = "13568">IsHomogeneous(I) : RngMPol -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Given an ideal I of the polynomial ring P, this
function returns whether I is homogeneous with respect to the
weights on the variables of P (i.e., whether I possesses a
basis consisting of homogeneous polynomials alone). Checks whether
the current basis of I consists of homogeneous polynomials and,
if not and the current basis isn't Gr&ouml;bner, then whether an
easy Gr&ouml;bner basis consists of homogeneous elements.
</BLOCKQUOTE>
<H5><A NAME = "13569">IsPrincipal(I) : RngMPol -&gt; BoolElt, RngMPolElt</A></H5>
<BLOCKQUOTE>
Given an ideal I of the polynomial ring P, return whether I is principal,
and if so, return also a generator of I. This will be true if and only if
an arbitrary Gr&ouml;bner basis consists of a single (generating) element.
</BLOCKQUOTE>
<H5><A NAME = "13570"></A><A NAME = "dpoly_ideal:IsPrimary">IsPrimary</A>(I) : RngMPol -&gt; BoolElt</H5>
<BLOCKQUOTE>
Given an ideal I of the polynomial ring P, return whether I is primary.
An ideal I is primary if and only if for all ab &isin;I, either
a &isin;I or b<sup>n</sup> &isin;I for some n &ge;1.
The restrictions on I are the same as for the function
<A  HREF = "text1225.htm#dpoly_ideal:PrimaryDecomposition">PrimaryDecomposition</A>---see the description of that function.
In general, this function computes or retrieves the primary decomposition and
checks whether it has a unique element.
</BLOCKQUOTE>
<H5><A NAME = "13571">IsPrime(I) : RngMPol -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Given an ideal I of the polynomial ring P, return whether I is prime.
An ideal I is prime if and only if for all ab &isin;I, either
a &isin;I or b &isin;I.
The restrictions on I are the same as for the function
<A  HREF = "text1225.htm#dpoly_ideal:PrimaryDecomposition">PrimaryDecomposition</A>---see the description of that function.
Again, this function computes the primary decomposition or uses the already
stored one.
</BLOCKQUOTE>
<H5><A NAME = "13572">IsMaximal(I) : RngMPol -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Given an ideal I of the polynomial ring P, return whether I is maximal.
The restrictions on I are the same as for the function
<A  HREF = "text1225.htm#dpoly_ideal:PrimaryDecomposition">PrimaryDecomposition</A>---see the description of that function.
Checks first whether I is zero-dimensional (see below) and, if so, then checks 
whether it is prime. NB: given that I is of dimension 0, the
prime/primary decomposition computation is relatively fast.
</BLOCKQUOTE>
<H5><A NAME = "13573">IsRadical(I) : RngMPol -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Given an ideal I of the polynomial ring P, return whether I is radical;
that is, whether the radical of I is I itself.  The restrictions on I
are the same as for the function <A  HREF = "text1225.htm#dpoly_ideal:Radical">Radical</A>---see the description of
that function. The function computes the radical or uses the already stored one.
</BLOCKQUOTE>
<H5><A NAME = "13574">IsZeroDimensional(I) : RngMPol -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Given an ideal I of the polynomial ring P, defined over a field,
return whether I is
zero-dimensional (so the quotient of P by I has non-zero finite
dimension as a vector space over the coefficient field -- see the section
on dimension for further details).  Note that the full polynomial ring P
as an ideal of itself has dimension -1, so it is not zero-dimensional.
</BLOCKQUOTE>
<H5><A NAME = "13575">HasGrevlexOrder(I) : RngMPol -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Given an ideal I of the polynomial ring P, return whether the
monomial order of I is the <TT>grevlex</TT> order.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "13576">Example <TT>Ideal_IdealArithmetic (H112E1)</TT></A></H3>
We construct some ideals in Q[x, y, z] and perform basic arithmetic on them.
<P>
<P>
<PRE>
&gt; P&lt;x,y,z&gt; := PolynomialRing(RationalField(), 3);
&gt; I := ideal&lt;P | x*y - 1, x^3*z^2 - y^2, x*z^3 - x - 1&gt;;
&gt; J := ideal&lt;P | x*y - 1, x^2*z - y, x*z^3 - x - 1&gt;;
&gt; A := I * J;
&gt; A;
Ideal of Polynomial ring of rank 3 over Rational Field
Order: Lexicographical
Variables: x, y, z
Basis:
[
    x^2*y^2 - 2*x*y + 1,
    x^3*y*z - x^2*z - x*y^2 + y,
    x^2*y*z^3 - x^2*y - x*y - x*z^3 + x + 1,
    x^4*y*z^2 - x^3*z^2 - x*y^3 + y^2,
    x^5*z^3 - x^3*y*z^2 - x^2*y^2*z + y^3,
    x^4*z^5 - x^4*z^2 - x^3*z^2 - x*y^2*z^3 + x*y^2 + y^2,
    x^2*y*z^3 - x^2*y - x*y - x*z^3 + x + 1,
    x^3*z^4 - x^3*z - x^2*z - x*y*z^3 + x*y + y,
    x^2*z^6 - 2*x^2*z^3 + x^2 - 2*x*z^3 + 2*x + 1
]
&gt; M := I meet J;
&gt; M;
Ideal of Polynomial ring of rank 3 over Rational Field
Order: Lexicographical
Variables: x, y, z
Basis:
[
    x^4 + x^3 - x*z^2 + z^12 - 4*z^9 + 6*z^6 - z^4 - 4*z^3 + z + 1,
    x^5 + x^4 - x^2*z^2 + z^9 - 3*z^6 + 3*z^3 - z - 1,
    x*z^3 - x - 1,
    y - z^3 + 1
]
&gt; A eq M;
true
&gt; QuotientDimension(A);
24
&gt; ColonIdeal(I, J);
Ideal of Polynomial ring of rank 3 over Rational Field
Order: Lexicographical
Variables: x, y, z
Inhomogeneous, Dimension 0
Basis:
[
    x*y - 1,
    x^3*z^2 - y^2,
    x*z^3 - x - 1
]
</PRE>
<HR>
<H4><A NAME = "13577">Element Operations with Ideals</A></H4>



<H5><A NAME = "13578">f in I : RngMPolElt, RngMPol -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Given a polynomial f from a polynomial ring P, together with an ideal
I of P, return whether f is in I. The function computes the normal
form of f relative to some Gr&ouml;bner basis of I and checks if this is
zero.
</BLOCKQUOTE>
<H5><A NAME = "13579">f notin I : RngMPolElt, RngMPol -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Given a polynomial f from a polynomial ring P, together with an ideal
I of P, return whether f is not in I. As with <TT>in</TT>, this 
performs a normal form computation.
</BLOCKQUOTE>
<H5><A NAME = "13580">IsInRadical(f, I) : RngMPolElt, RngMPol -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Given a polynomial f from a polynomial ring P, together with an ideal
I of P, return whether f is in the radical of I.  Note that using
this function is much quicker in general than actually computing the
radical of I. It uses the algorithm described in section 1.8.6 of
<A  HREF = "text1213.htm#bib_GrPf02">[GP02]</A>.
</BLOCKQUOTE>
<H5><A NAME = "13581">JacobianIdeal(f) : RngMPolElt -&gt; RngMPol</A></H5>
<BLOCKQUOTE>
Return the ideal generated by all first partial derivatives 
of the polynomial f.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "13582">Example <TT>Ideal_ElementOperations (H112E2)</TT></A></H3>
We demonstrate the element operations with respect to an ideal
of Q[x, y, z].
<P>
<P>
<PRE>
&gt; P&lt;x, y, z&gt; := PolynomialRing(RationalField(), 3);
&gt; I := ideal&lt;P | (x + y)^3, (y - z)^2, y^2*z + z&gt;;
&gt; NormalForm(y^2*z + z, I);
0
&gt; NormalForm(x^3, I);
-3*x^2*y - 3*x*z^4 - 6*x*z^2 + 1/2*z^3 + 3/2*z
&gt; NormalForm(z^4 + y^2, I);
2*z^4 + 2*z^2
&gt; x + y in I;
false
&gt; IsInRadical(x + y, I);
true
&gt; IsInRadical((x + y)^2, I);
true
&gt; IsInRadical(z, I);
false
&gt; SPolynomial(x^4 + y - z, x^2 + y - z);
-x^2*y + x^2*z + y - z
</PRE>
<HR>
<PRE></PRE> <A  HREF = "text1218.htm">[Next]</A><A  HREF = "text1216.htm">[Prev]</A> <A  HREF = "text1218.htm">[Right]</A> <A  HREF = "text1216.htm">[Left]</A> <A  HREF = "text1214.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<br><small>Version: V2.22 of <I>
Thu Jun  9 16:37:49 EST 2016
</I></small>
</body></html>