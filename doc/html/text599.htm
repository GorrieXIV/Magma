<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <link rel='stylesheet' href='help.css' type='text/css'>
  <TITLE>Complexes of Modules</TITLE>
</head>
<body BGCOLOR="#FFFFFF">

 <A  HREF = "text600.htm">[Next]</A><A  HREF = "text598.htm">[Prev]</A> <A  HREF = "text600.htm">[Right]</A> [____] <A  HREF = "text598.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<PRE></PRE><H3><A NAME = "6309">Complexes of Modules</A></H3>

<P>
<P>
<P>
<P>
Complexes of modules are a fundamental object in homological algebra.
Magma supports the type <TT>ModCpx</TT> representing a complex of modules.
Conceptually, a complex is an infinite sequence of modules,
indexed by integers, with maps between successive modules
such that the composition of any two maps is zero.  Complexes are
often written ... mapright(f<sub>n + 1</sub>) M<sub>n</sub> mapright(f<sub>n</sub>) M<sub>n - 1</sub> 
mapright(f<sub>n - 1</sub>) M<sub>n - 2</sub> mapright(f<sub>n - 2</sub>) ... where the map f<sub>n</sub> has domain M<sub>n</sub> and codomain M<sub>n - 1</sub>.
The indices on the modules and maps decrease to the right.
In practice, Magma requires all but a finite number of the modules
and maps to be zero.  
<P>
The homomorphism from M<sub>n</sub> to M<sub>n - 1</sub> in the complex is the
n<sup>th</sup> boundary map of the complex. The homology of the complex
in degree n is the quotient of the kernel of the n<sup>th</sup> 
boundary map by the cokernel
of the boundary map of degree n - 1. Magma computes the homology 
only if both boundary maps are defined. 
A complex is said to be <I>exact</I> if the image of each map is
equal to the kernel of the next.
<P>
Currently, there are two types of modules over which complexes are supported:
<DL COMPACT class='compact'>
<DT>(a)</DT><DD>Modules over a basic algebra A (see Chapter <A  HREF = "text966.htm#10877">BASIC ALGEBRAS</A>);
<DT>(b)</DT><DD>Modules over a multivariate polynomial ring over a field
	   (see Chapter <A  HREF = "text1254.htm#13781">MODULES OVER MULTIVARIATE RINGS</A> and in particular the function
	   <A  HREF = "text1266.htm#PMod:FreeResolution">FreeResolution</A>).
<P>
</DL>
Most of the functions in this chapter work for either type of module
but exceptions are noted.



<H5>Subsections</H5>
<UL>
<LI> <A  HREF = "text599.htm#6310">Creation</A>
<LI> <A  HREF = "text599.htm#6315">Subcomplexes and Quotient  Complexes</A>
<LI> <A  HREF = "text599.htm#6319">Access Functions</A>
<LI> <A  HREF = "text599.htm#6329">Elementary Operations</A>
<LI> <A  HREF = "text599.htm#6341">Extensions</A>
<LI> <A  HREF = "text599.htm#6350">Predicates</A>
</UL>
<H4><A NAME = "6310">Creation</A></H4>



<H5><A NAME = "6311">Complex(L, d) : List, RngIntElt -&gt; ModCpx</A></H5>
<BLOCKQUOTE>
Given a list L of maps between successive A-modules create 
the corresponding complex. The last term of the complex has 
degree d.  This function returns an error if the maps don't actually 
form a complex. 
</BLOCKQUOTE>
<H5><A NAME = "6312">Complex(f, d) : Map, RngIntElt -&gt; ModCpx</A></H5>
<BLOCKQUOTE>
Given a map f between A-modules M and N, form the complex
consisting of the two term complex whose only map is f. The term
N is in degree d.
</BLOCKQUOTE>
<H5><A NAME = "6313">ZeroComplex(A, m, n) : AlgBas, RngIntElt, RngIntElt -&gt; ModCpx</A></H5>
<BLOCKQUOTE>
Given a basic algebra A and integers m and n such that m &gt; n,
create a complex of modules over the basic algebra A, starting with
a term of degree m and ending with a term of degree n, where
all the modules and maps are zero.
</BLOCKQUOTE>
<H5><A NAME = "6314">Dual(C) : ModCpx -&gt;   ModCpx</A></H5>
<H5>Dual(C, n) : ModCpx, RngIntElt -&gt;   ModCpx</H5>
<BLOCKQUOTE>
The dual of the complex C over a basic algebra A as a complex over the
opposite algebra of A. If an integer n is supplied
then the last term of the dual complex is in degree n. Otherwise, the
last term of the dual complex is in degree 0.
</BLOCKQUOTE>
<H4><A NAME = "6315">Subcomplexes and Quotient  Complexes</A></H4>

<P>
<P>
<P>
Let C be a complex of A-modules, M<sub>m</sub>, ..., M<sub>n</sub>. A subcomplex
S of C is a complex whose terms are submodules of the terms of C
and whose maps are the restrictions of the maps of C to the terms
of S.


<H5><A NAME = "6316">sub&lt; C | Q &gt; : ModCpx, SeqEnum[ModAlg] -&gt; ModCpx, MapChn</A></H5>
<H5>sub&lt; C | L &gt; : ModCpx, List -&gt; ModCpx, MapChn</H5>
<BLOCKQUOTE>
Given a complex C and a sequence Q 
of submodules of the terms of C, returns
the smallest subcomplex whose terms contain the modules in Q. The 
input can also be a list L of sequences of elements of the 
successive terms of C. In this case the submodules generated by
the elements is computed. The function also returns the chain map
giving the inclusion of the subcomplex in C.
<P>
</BLOCKQUOTE>
<H5><A NAME = "6317">RandomSubcomplex(C, Q) : ModCpx, SeqEnum -&gt;  ModCpx, MapChn</A></H5>
<BLOCKQUOTE>
Given a chain complex C over a basic algebra in degrees a to
a - t + 1 and a sequence Q = [q<sub>1</sub>, ..., q<sub>t</sub>] of natural numbers, the
function creates the minimal chain complex whose term in degree a - i + 1
is a submodule generated by q<sub>i</sub> random elements of the term in degree
a - i + 1 of C. The function also returns the chain map that is the
inclusion of the subcomplex into C.
</BLOCKQUOTE>
<H5><A NAME = "6318">quo&lt; C | D &gt; : ModCpx, ModCpx -&gt; ModCpx</A></H5>
<H5>quo&lt; C | S &gt; : ModCpx, SeqEnum[ModAlg] -&gt; ModCpx</H5>
<H5>quo&lt; C | L &gt; : ModCpx, List -&gt; ModCpx</H5>
<BLOCKQUOTE>
Given a complex C and a subcomplex D of C,
returns the quotient complex C/D together with the natural quotient
map. If given as a sequence S of submodules of the terms of C
or a list L of sequences of elements of the terms of C, then the 
submodule generated by S or L is created and the quotient computed. 
The function also returns the chain map of C on the quotient. 
<P>
</BLOCKQUOTE>
<H4><A NAME = "6319">Access Functions</A></H4>



<H5><A NAME = "6320">Degrees(C) : ModCpx -&gt; RngIntElt</A></H5>
<BLOCKQUOTE>
Returns the first and last degrees of the defined terms of the 
complex C.
</BLOCKQUOTE>
<H5><A NAME = "6321">Algebra(C) : ModCpx -&gt; AlgBas</A></H5>
<BLOCKQUOTE>
Given a complex C over a basic algebra A, this function
returns the algebra A.
</BLOCKQUOTE>
<H5><A NAME = "6322">BoundaryMap(C, n) : ModCpx, RngIntElt -&gt; ModMatRngElt</A></H5>
<BLOCKQUOTE>
Returns the boundary map of the complex C from the term of degree n 
to the term of degree n - 1.
<P>
</BLOCKQUOTE>
<H5><A NAME = "6323">BoundaryMaps(C) : ModCpx  -&gt; List</A></H5>
<BLOCKQUOTE>
The list of boundary maps of the complex C.
<P>
</BLOCKQUOTE>
<H5><A NAME = "6324">DimensionsOfHomology(C) : ModCpx -&gt; SeqEnum</A></H5>
<BLOCKQUOTE>
Returns the list of the dimensions of the homology groups of the complex C.
</BLOCKQUOTE>
<H5><A NAME = "6325">DimensionOfHomology(C, n) : ModCpx, RngIntElt -&gt; RngIntElt</A></H5>
<BLOCKQUOTE>
Returns the dimension of the homology group of the complex C in degree n.
</BLOCKQUOTE>
<H5><A NAME = "6326">DimensionsOfTerms(C) : ModCpx -&gt; SeqEnum</A></H5>
<BLOCKQUOTE>
Returns the list of the dimensions of the terms of the complex C.
</BLOCKQUOTE>
<H5><A NAME = "6327">Term(C, n) : ModCpx, RngIntElt -&gt; ModAlg</A></H5>
<BLOCKQUOTE>
The module in the complex C in degree  n.
</BLOCKQUOTE>
<H5><A NAME = "6328">Terms(C) : ModCpx -&gt; SeqEnum</A></H5>
<BLOCKQUOTE>
The sequence of terms of the complex C.
</BLOCKQUOTE>
<H4><A NAME = "6329">Elementary Operations</A></H4>



<H5><A NAME = "6330">DirectSum(C, D) : ModCpx, ModCpx -&gt; ModCpx</A></H5>
<BLOCKQUOTE>
Returns the direct sum of the complex C and the complex D.
</BLOCKQUOTE>
<H5><A NAME = "6331">Homology(C) : ModCpx -&gt; SeqEnum</A></H5>
<H5>HomologyOfChainComplex(C) : ModCpx -&gt; SeqEnum</H5>
<BLOCKQUOTE>
The sequence of homology groups of the complex C as a 
sequence of modules.
</BLOCKQUOTE>
<H5><A NAME = "6332">Homology(C, n) : ModCpx, RngIntElt -&gt; SeqEnum</A></H5>
<BLOCKQUOTE>
Returns the homology group in degree n of the complex C,
as an A-module.
</BLOCKQUOTE>
<H5><A NAME = "6333">Prune(C) : ModCpx -&gt; ModCpx</A></H5>
<BLOCKQUOTE>
Returns the complex that consists of the terms of C with the right end
term (term of lowest degree) removed.
</BLOCKQUOTE>
<H5><A NAME = "6334">Prune(C,n) : ModCpx, RngIntElt -&gt; ModCpx</A></H5>
<BLOCKQUOTE>
Returns the complex that consists of the terms of C with n terms removed
from the right end.
</BLOCKQUOTE>
<H5><A NAME = "6335">Preprune(C) : ModCpx -&gt; ModCpx</A></H5>
<BLOCKQUOTE>
Returns the complex that consists of the terms of C with the left end
term (term of highest degree) removed.
</BLOCKQUOTE>
<H5><A NAME = "6336">Preprune(C,n) : ModCpx, RngIntElt -&gt; ModCpx</A></H5>
<BLOCKQUOTE>
Returns the complex that consists of the terms of C with n terms removed
from the left end.
</BLOCKQUOTE>
<H5><A NAME = "6337">Shift(C, n) : ModCpx, RngIntElt -&gt; ModCpx</A></H5>
<BLOCKQUOTE>
Given the complex C in degrees r to s, returns the complex in shifted
degrees r + n to s + n. The integer n may be either positive or
negative. The maps in the complex are all multiplied by the scalar ( - 1)<sup>n</sup>.
</BLOCKQUOTE>
<H5><A NAME = "6338">ShiftToDegreeZero(C) : ModCpx -&gt; ModCpx</A></H5>
<BLOCKQUOTE>
Given the complex C, returns the shift of C so that the last term, the 
term of lowest degree, is in degree 0.
</BLOCKQUOTE>
<H5><A NAME = "6339">Splice(C, D) : ModCpx, ModCpx -&gt;  ModCpx</A></H5>
<BLOCKQUOTE>
Given two complexes C and D over the same basic algebra, such
that the end term of C coincides with the initial term of D,
form the complex that corresponds to the concatenation of C and
D (as sequences of maps) This function checks that the resulting
sequence of maps forms a complex. The degrees of complex D remain
unchanged while the degrees of the terms in complex C are changed
to fit.
</BLOCKQUOTE>
<H5><A NAME = "6340">Splice(C, D, f) : ModCpx, ModCpx, ModMatRngElt -&gt;  ModCpx</A></H5>
<BLOCKQUOTE>
The splice of the complex C with the complex D along the map f from the 
last term of C to the first term of D. The degree of the last term of 
the splice is the same as the degree of the last term of the complex D.
</BLOCKQUOTE>
<H4><A NAME = "6341">Extensions</A></H4>

<P>
<P>
<P>
The following are elementary operations related to extending complexes


<H5><A NAME = "6342">LeftExactExtension(C) : ModCpx -&gt;   ModCpx</A></H5>
<BLOCKQUOTE>
Given a complex C of modules over a basic algebra, returns the complex of
length one greater that is obtained by adjoining the inclusion map from the 
kernel of the boundary map in highest degree to the term of highest degree 
in C.
</BLOCKQUOTE>
<H5><A NAME = "6343">RightExactExtension(C) : ModCpx -&gt;   ModCpx</A></H5>
<BLOCKQUOTE>
Given a complex C of modules over a basic algebra, returns the complex of
length one greater that is obtained by adjoining the quotient map to the 
cokernel of the boundary map of lowest degree from the term of lowest 
degree in C.
</BLOCKQUOTE>
<H5><A NAME = "6344">ExactExtension(C) : ModCpx -&gt;   ModCpx</A></H5>
<BLOCKQUOTE>
Returns the left and right exact extensions of the complex C.
</BLOCKQUOTE>
<H5><A NAME = "6345">LeftZeroExtension(C) : ModCpx -&gt;  ModCpx</A></H5>
<H5>LeftZeroExtension(C, n) : ModCpx, RngIntElt -&gt;  ModCpx</H5>
<BLOCKQUOTE>
Given a complex C of modules over a basic algebra, returns the complex of
length one greater that is obtained by adjoining the zero map from the zero 
module to the term of highest degree in the complex.  If a natural number
n is included in the input then the operation is performed n times. 
</BLOCKQUOTE>
<H5><A NAME = "6346">RightZeroExtension(C) : ModCpx -&gt;  ModCpx</A></H5>
<H5>RightZeroExtension(C, n) : ModCpx, RngIntElt -&gt;  ModCpx</H5>
<BLOCKQUOTE>
Given a complex C of modules over a basic algebra, returns the complex of
length one greater that is obtained by adjoining the zero map to the zero 
module from the term of lowest degree in the complex.  If a natural number
n is included in the input then the operation is performed n times. 
</BLOCKQUOTE>
<H5><A NAME = "6347">ZeroExtension(C) : ModCpx -&gt;   ModCpx</A></H5>
<BLOCKQUOTE>
Returns the left and right zero extensions of the complex C.
</BLOCKQUOTE>
<H5><A NAME = "6348">EqualizeDegrees(C, D) : ModCpx, ModCpx -&gt;   ModCpx, ModCpx</A></H5>
<H5>EqualizeDegrees(Q) : SeqEnum -&gt;  SeqEnum</H5>
<BLOCKQUOTE>
Given complexes C and D over the same algebra, the function returns the 
complexes obtained by taking zero extensions of C and D, if necessary, so
that both complexes have the same degrees. The input can also be given
as a sequence Q of complexes, in which case the function returns the 
sequence of complexes obtained by taking zero extensions of the elements 
of Q, if necessary, until all of the elements of the sequence have the 
same degrees.
</BLOCKQUOTE>
<H5><A NAME = "6349">EqualizeDegrees(C, D, n) : ModCpx, ModCpx, RngIntElt  -&gt;   ModCpx, ModCpx</A></H5>
<BLOCKQUOTE>
The two complexes, C and D, with zero extension sufficient that the first 
and the shift by degree n of the second have the same degrees.
</BLOCKQUOTE>
<H4><A NAME = "6350">Predicates</A></H4>

<P>
<P>
<P>
The following functions return a Boolean value.


<H5><A NAME = "6351">IsExact(C) : ModComplex -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if and only if the complex C is an exact sequence, i.e. the image
of each map in C is equal to the kernel of the succeeding map
(with the obvious exceptions of the first and last maps of 
the complex).
If the complex has only two terms then this is true trivially.
</BLOCKQUOTE>
<H5><A NAME = "6352">IsShortExactSequence(C) : ModCpx -&gt; BoolElt, RngIntElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if the complex C consists of a short exact sequence together with 
other terms that are zero. The function returns also the degrees
of the complex of nonzero terms.
</BLOCKQUOTE>
<H5><A NAME = "6353">IsExact(C, n) : ModCpx, RngIntElt -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if and only if the complex C is an exact sequence in degree n, i.e.
the image of the map in C into the term of degree n is equal 
to the kernel of the succeeding map.
</BLOCKQUOTE>
<H5><A NAME = "6354">IsZeroComplex(C) : ModCpx -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if and only if the complex C is composed entirely of zero modules and maps.
</BLOCKQUOTE>
<H5><A NAME = "6355">IsZeroMap(C, n) : ModCpx, RngIntElt -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if and only if the boundary map in degree n of the complex C 
is the zero map.
</BLOCKQUOTE>
<H5><A NAME = "6356">IsZeroTerm(C, n) : ModCpx, RngIntElt -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if and only if the term in degree n 
of the complex C is the zero object.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "6357">Example <TT>ModCpx_Complexes (H60E1)</TT></A></H3>
We construct the quiver algebra of a quiver with three nodes and three 
arrows going from node 1 to node 2, from 2 to 1 and 2 to 3. The relation
is that (ab)<sup>3</sup>a =0 where a is the first arrow and b is the second. 
Then we construct projective and injective resolutions of the first 
simple module.
<P>
<P>
<PRE>
&gt; ff := GF(8);
&gt; FA&lt;e1,e2,e3,a,b,c&gt; := FreeAlgebra(ff,6);
&gt; rrr := [a*b*a*b*a*b*a];
&gt; D := BasicAlgebra(FA,rrr,3,[&lt;1,2&gt;,&lt;2,1&gt;,&lt;2,3&gt;]);
&gt; D;
Basic algebra of dimension 23 over GF(2^3)
Number of projective modules: 3
Number of generators: 6
&gt; DimensionsOfProjectiveModules(D);
[ 10, 12, 1 ]
&gt; DimensionsOfInjectiveModules(D);
[ 8, 7, 8 ]
</PRE>
Here is the opposite algebra:
<P>
<P>
<PRE>
&gt; OD := OppositeAlgebra(D);
reverse trees
&gt; OD;
Basic algebra of dimension 23 over GF(2^3)
Number of projective modules: 3
Number of generators: 6
&gt; s1 := SimpleModule(D,1);
&gt; P,mu := ProjectiveResolution(s1,7);
&gt; P;
Basic algebra complex with terms of degree 7 down to 0
Dimensions of terms: 12 12 12 12 12 12 12 10
&gt; Q,nu := InjectiveResolution(s1,7);
&gt; Q;
Basic algebra complex with terms of degree 0 down to -7
Dimensions of terms: 8 7 0 0 0 0 0 0
</PRE>
Note that the projective and injective resolutions are complexes with
the appropriate augmentation and coaugmentation maps. First we form the 
two term complex whose boundary map is the composition of the augmentation
and coaugmentation maps. 
<P>
<P>
<PRE>
&gt; theta := MapToMatrix(hom&lt;Term(P,0)-&gt; Term(Q,0)|mu*nu&gt;);
&gt; E := Complex(theta,0);
</PRE>
Then we splice all of this together.
<P>
<P>
<PRE>
&gt; R := Splice(P,E);
&gt; S := Splice(R,Q);
&gt; S;
Basic algebra complex with terms of degree 8 down to -7
Dimensions of terms: 12 12 12 12 12 12 12 10 8 7 0 0 0 0 0 0
</PRE>
<HR>
<PRE></PRE> <A  HREF = "text600.htm">[Next]</A><A  HREF = "text598.htm">[Prev]</A> <A  HREF = "text600.htm">[Right]</A> [____] <A  HREF = "text598.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<br><small>Version: V2.22 of <I>
Thu Jun  9 16:37:49 EST 2016
</I></small>
</body></html>