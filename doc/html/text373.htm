<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <link rel='stylesheet' href='help.css' type='text/css'>
  <TITLE>Special Element Operations</TITLE>
</head>
<body BGCOLOR="#FFFFFF">

 <A  HREF = "text374.htm">[Next]</A><A  HREF = "text372.htm">[Prev]</A> <A  HREF = "text374.htm">[Right]</A> <A  HREF = "text372.htm">[Left]</A> <A  HREF = "text369.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<PRE></PRE><H3><A NAME = "3583">Special Element Operations</A></H3>

<P>
<P>
Several functions are available only for elements of certain maximal orders.
<P>
The maximal orders of <TT>QuadraticField(d)</TT> for 
d = - 1, - 2, - 3, - 7, - 11, 2, 3, 5 and 13 
are Euclidean with respect to the <TT>Norm</TT>.  The division algorithm, 
Euclidean algorithm, GCD and LCM are available for these orders only. 
Below, we will refer to these orders as the "special Euclidean orders".



<H5>Subsections</H5>
<UL>
<LI> <A  HREF = "text373.htm#3584">Division Algorithm</A>
<LI> <A  HREF = "text373.htm#3590">Factorization</A>
<LI> <A  HREF = "text373.htm#3593">Conjugates</A>
<LI> <A  HREF = "text373.htm#3596">Other Element Functions</A>
</UL>
<H4><A NAME = "3584">Division Algorithm</A></H4>



<H5><A NAME = "3585">a div b : RngQuadElt, RngQuadElt -&gt; RngQuadElt</A></H5>
<BLOCKQUOTE>
This operation is available for all orders, but its behaviour depends on whether
the order R containing a and b is one of the special Euclidean orders listed above.
<P>
When R is not a special Euclidean order, this returns the exact quotient of a and b.
An error results if a is not exactly divisible by b in R.
<P>
When R is a special Euclidean order, this performs the division algorithm in R.
It finds uniquely determined elements q and r in R such that a = q b + r 
and Norm(r) &lt;  Norm(b), and returns q.
</BLOCKQUOTE>
<H5><A NAME = "3586">a mod b : RngQuadElt, RngQuadElt -&gt; RngQuadElt</A></H5>
<BLOCKQUOTE>
This operation requires a and b to belong to one of the special Euclidean orders
listed above.  
It performs the same calculation as <TT>div</TT>, and returns the remainder r.
</BLOCKQUOTE>
<H5><A NAME = "3587">GreatestCommonDivisor(a, b) : RngQuadElt, RngQuadElt -&gt; RngQuadElt</A></H5>
<H5>Gcd(a, b) : RngQuadElt, RngQuadElt -&gt; RngQuadElt</H5>
<H5>GCD(a, b) : RngQuadElt, RngQuadElt -&gt; RngQuadElt</H5>
<BLOCKQUOTE>
The greatest common divisor of a and b, which must be elements of 
one of the special Euclidean orders listed above.
</BLOCKQUOTE>
<H5><A NAME = "3588">LeastCommonMultiple(a, b) : RngQuadElt, RngQuadElt -&gt; RngQuadElt</A></H5>
<H5>Lcm(a, b) : RngQuadElt, RngQuadElt -&gt; RngQuadElt</H5>
<H5>LCM(a, b) : RngQuadElt, RngQuadElt -&gt; RngQuadElt</H5>
<BLOCKQUOTE>
The least common multiple of a and b, which must be elements of
one of the special Euclidean orders listed above.
</BLOCKQUOTE>
<H5><A NAME = "3589">Modexp(a, e, n) : RngQuadElt, RngInt, RngQuadElt -&gt; RngQuadElt</A></H5>
<BLOCKQUOTE>
This returns a<sup>e</sup> mod n, where a and n must be elements of
one of the special Euclidean orders listed above.
</BLOCKQUOTE>
<H4><A NAME = "3590">Factorization</A></H4>

<P>
<P>
Magma's factorization in maximal orders of quadratic number fields
is based upon factoring the norm in the integers.
Thus, the comments that are made about the <TT>Factorization</TT> command
in the integers also apply here.
Moreover, since the factorization may be off by a unit power,
that power is also returned
(the unit being -1, Sqrt( - 1), or (1 + Sqrt( - 3))/2).


<H5><A NAME = "3591">Factorization(n) : RngQuadElt -&gt; SeqEnum, Tup</A></H5>
<H5>Factorisation(n) : RngQuadElt -&gt; SeqEnum, Tup</H5>
<BLOCKQUOTE>
The factorization of n in the maximal order of the quadratic number field 
Q(Sqrt(d)), where d is one of: -1, -2, -3, -7, or -11.
Returns the 
factorization along with the appropriate power of a unit
(the unit being -1, Sqrt( - 1), or (1 + Sqrt( - 3))/2).
</BLOCKQUOTE>
<H5><A NAME = "3592">TrialDivision(n, B) : RngQuadElt, RngIntElt -&gt; SeqEnum, SeqEnum, Tup</A></H5>
<BLOCKQUOTE>
Trial division of n by primes of relative norm &le; B in the
maximal order of Q(Sqrt(d)), where d is one of: -1, -2, -3, -7, or -11.
Returns the factored part, the unfactored part, and the power of the 
unit that the factorization is off by 
(the unit being -1, Sqrt( - 1), or (1 + Sqrt( - 3))/2).
</BLOCKQUOTE>
<H4><A NAME = "3593">Conjugates</A></H4>



<H5><A NAME = "3594">ComplexConjugate(a) : FldQuadElt -&gt; FldQuadElt</A></H5>
<H5>ComplexConjugate(a) : RngQuadElt -&gt; RngQuadElt</H5>
<BLOCKQUOTE>
The complex conjugate of quadratic field element a; returns a in
a real quadratic field and bar a=x - ySqrt(d) if a=x + ySqrt(d)
in an imaginary quadratic field Q(Sqrt(d)).
</BLOCKQUOTE>
<H5><A NAME = "3595">Conjugate(a) : FldQuadElt -&gt; FldQuadElt</A></H5>
<H5>Conjugate(a) : RngQuadElt -&gt; RngQuadElt</H5>
<BLOCKQUOTE>
The conjugate x - ySqrt(d) of a=x + ySqrt(d) in the quadratic field
Q(Sqrt(d)).
</BLOCKQUOTE>
<H4><A NAME = "3596">Other Element Functions</A></H4>

<P>
<P>
For the ring of integers of Q(i) the biquadratic residue symbol
(generalizing the Legendre symbol) is available.


<H5><A NAME = "3597">BiquadraticResidueSymbol(a, b) : RngQuadElt, RngQuadElt -&gt; RngQuadElt</A></H5>
<BLOCKQUOTE>
Given a Gaussian integer a and a primary, non-unit Gaussian integer b, where
a and b are coprime, return the value of the biquadratic
character ( (a/b))<sub>4</sub>. The value of this character
is equal to i<sup>k</sup>, for some k&isin;{0, 1, 2, 3}.
If a and b have a factor in common, the function returns 0,
if b is not primary or b is a unit an error results.
</BLOCKQUOTE>
<H5><A NAME = "3598">Primary(a) : RngQuadElt -&gt; RngQuadElt</A></H5>
<BLOCKQUOTE>
Return the unique associate bar a of the Gaussian integer a that 
satisfies 
bar a &equiv; 1 mod (1 + i)<sup>3</sup>, 
<P>
or 0 in case a is divisible 
by 1 + i.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "3599">Example <TT>FldQuad_Represent (H36E6)</TT></A></H3>
The following example checks for primes p with 65&le;p&le;1000 and
p &equiv; 1mod 4 a result that was conjectured by Euler and proved by
Gauss, namely that
z<sup>4</sup> &equiv; 2 mod p has a solution iff p=x<sup>2</sup> + 64y<sup>2</sup> for some x, y.
<P>
We use the function <TT>NormEquation</TT> to find the prime above p
in the Gaussian integers, and we build the set of such primes for
which 2 is a biquadratic residue (which means that z<sup>4</sup> &equiv; 2 mod p for some z). 
<P>
<P>
<PRE>
&gt; s := { };
&gt; Q := QuadraticField(-1);
&gt; M := RingOfIntegers(Q);
&gt; for p := 65 to 1000 by 4 do
&gt;    if IsPrime(p) then
&gt;       _, x := NormEquation(Q, p);
&gt;       if BiquadraticResidueSymbol(2, Primary(M!x[1])) eq 1 then
&gt;          Include(~s, p);
&gt;       end if;
&gt;    end if;
&gt; end for;
&gt; s;
{ 73, 89, 113, 233, 257, 281, 337, 353, 577, 593, 601, 617, 881, 937 }
</PRE>
Next we create the set of all primes as above that are of the form x<sup>2</sup> + 64y<sup>2</sup>.
Note that we have to use <TT>NormEquation</TT> on a suborder of Q
now, because we want to solve x<sup>2</sup> + 64y<sup>2</sup>=p, while <TT>QuadraticField(-64)</TT>
returns just Q(i) in which we can only solve x<sup>2</sup> + y<sup>2</sup>=p.
<P>
<P>
<PRE>
&gt; S := sub&lt;MaximalOrder(Q) | 8&gt;;
&gt; t := { };
&gt; for p := 65 to 1000 by 4 do
&gt;    if IsPrime(p) then
&gt;       if NormEquation(S, p) then
&gt;           Include(~t, p);
&gt;       end if;
&gt;    end if;
&gt; end for;
&gt; t;
{ 73, 89, 113, 233, 257, 281, 337, 353, 577, 593, 601, 617, 881, 937 }
</PRE>
<HR>
<PRE></PRE> <A  HREF = "text374.htm">[Next]</A><A  HREF = "text372.htm">[Prev]</A> <A  HREF = "text374.htm">[Right]</A> <A  HREF = "text372.htm">[Left]</A> <A  HREF = "text369.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<br><small>Version: V2.22 of <I>
Thu Jun  9 16:37:49 EST 2016
</I></small>
</body></html>