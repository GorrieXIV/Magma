<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <link rel='stylesheet' href='help.css' type='text/css'>
  <TITLE>Element Operations</TITLE>
</head>
<body BGCOLOR="#FFFFFF">

 <A  HREF = "text214.htm">[Next]</A><A  HREF = "text212.htm">[Prev]</A> <A  HREF = "text214.htm">[Right]</A> <A  HREF = "text212.htm">[Left]</A> <A  HREF = "text209.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<PRE></PRE><H3><A NAME = "1782">Element Operations</A></H3>

<P>
<P>
The categories for elements in univariate polynomial rings
and their quotients are
are <TT>RngUPolElt</TT> and <TT>RngUPolResElt</TT>



<H5>Subsections</H5>
<UL>
<LI> <A  HREF = "text213.htm#1783">Parent and Category</A>
<LI> <A  HREF = "text213.htm#1784">Arithmetic Operators</A>
<LI> <A  HREF = "text213.htm#1785">Equality and Membership</A>
<LI> <A  HREF = "text213.htm#1786">Predicates on Ring Elements</A>
<LI> <A  HREF = "text213.htm#1787">Coefficients and Terms</A>
<LI> <A  HREF = "text213.htm#1801">Degree</A>
<LI> <A  HREF = "text213.htm#1803">Roots</A>
<LI> <A  HREF = "text213.htm#1811">Derivative, Integral</A>
<LI> <A  HREF = "text213.htm#1815">Evaluation, Interpolation</A>
<LI> <A  HREF = "text213.htm#1818">Quotient and Remainder</A>
<LI> <A  HREF = "text213.htm#1828">Modular Arithmetic</A>
<LI> <A  HREF = "text213.htm#1831">Other Operations</A>
</UL>
<H4><A NAME = "1783">Parent and Category</A></H4>



<H5>Parent(p) : RngUPolElt -&gt; RngUPol</H5>

<H5>Category(p) : RngUPolElt -&gt; Cat</H5><P>

<H4><A NAME = "1784">Arithmetic Operators</A></H4>

<P>
<P>
The usual unary and binary ring operations are available
for univariate polynomials, with the following notable restrictions.
<P>
Since inverses cannot generally be obtained in polynomial rings,
division (using <TT>/</TT>) of polynomials is not allowed, and
neither are negative powers. For polynomial
rings over fields division by elements of the coefficient
field are allowed.
<P>
The operators <TT>div</TT> and <TT>mod</TT> give results corresponding
to the quotient  and the remainder of division of the
arguments. See the section on quotient and remainder for details.


<H5>+ a : RngUPolElt -&gt; RngUPolElt</H5>

<H5>- a : RngUPolElt -&gt; RngUPolElt</H5>



<H5>a + b : RngUPolElt, RngUPolElt -&gt; RngUPolElt</H5>

<H5>a - b : RngUPolElt, RngUPolElt -&gt; RngUPolElt</H5>

<H5>a * b : RngUPolElt, RngUPolElt -&gt; RngUPolElt</H5>

<H5>a ^ k : RngUPolElt, RngIntElt -&gt; RngUPolElt</H5>

<H5>a / b : RngUPolElt, RngElt -&gt; FldFunUElt</H5>


<H5>a div b : RngUPolElt, RngUPolElt -&gt; RngUPolElt</H5>

<H5>a mod b : RngUPolElt, RngUPolElt -&gt; RngUPolElt</H5><P>

<H5>a +:= b : RngUPolElt, RngUPolElt -&gt; RngUPolElt</H5>

<H5>a -:= b : RngUPolElt, RngUPolElt -&gt; RngUPolElt</H5>

<H5>a *:= b : RngUPolElt, RngUPolElt -&gt; RngUPolElt</H5><P>

<H4><A NAME = "1785">Equality and Membership</A></H4>



<H5>a eq b : RngUPolElt, RngUPolElt -&gt; BoolElt</H5>

<H5>a ne b : RngUPolElt, RngUPolElt -&gt; BoolElt</H5>



<H5>a in R : RngUPolElt, Rng -&gt; BoolElt</H5>

<H5>a notin R : RngUPolElt, Rng -&gt; BoolElt</H5><P>

<H4><A NAME = "1786">Predicates on Ring Elements</A></H4>

<P>
<P>
The list belows contains the general ring element predicates.
Note that not all functions are available for every coefficient ring.


<H5>IsZero(a) : RngUPolElt -&gt; BoolElt</H5>

<H5>IsOne(a) : RngUPolElt -&gt; BoolElt</H5>

<H5>IsMinusOne(a) : RngUPolElt -&gt; BoolElt</H5><P>

<H5>IsNilpotent(a) : RngUPolElt -&gt; BoolElt</H5>

<H5>IsIdempotent(a) : RngUPolElt -&gt; BoolElt</H5><P>

<H5>IsUnit(a) : RngUPolElt -&gt; BoolElt</H5>

<H5>IsZeroDivisor(a) : RngUPolElt -&gt; BoolElt</H5>

<H5>IsRegular(a) : RngUPolElt -&gt; BoolElt</H5><P>

<H5>IsIrreducible(a) : RngUPolElt -&gt; BoolElt</H5>

<H5>IsPrime(a) : RngUPolElt -&gt; BoolElt</H5>

<H5>IsMonic(a) : RngUPolElt -&gt; BoolElt</H5><P>

<H4><A NAME = "1787">Coefficients and Terms</A></H4>



<H5><A NAME = "1788">Coefficients(p) : RngUPolElt -&gt; [ RngElt ]</A></H5>
<H5>ElementToSequence(p) : RngUPolElt -&gt; [ RngElt ]</H5>
<H5>Eltseq(p) : RngUPolElt -&gt; [ RngElt ]</H5>
<BLOCKQUOTE>
The coefficients of the polynomial
p&isin;R[x] in ascending order, as a sequence of elements of 
R.
</BLOCKQUOTE>
<H5><A NAME = "1789">Coefficient(p, i) : RngUPolElt, RngIntElt -&gt; RngElt</A></H5>
<BLOCKQUOTE>
Given a polynomial p&isin;R[x]
and an integer i&ge;0, return the coefficient of the
i-th power of x in f. (If i exceeds
the degree of f then zero is returned.) The return value
is an element of R.
</BLOCKQUOTE>
<H5><A NAME = "1790">MonomialCoefficient(p, m) : RngUPolElt, RngUPolElt -&gt; RngElt</A></H5>
<BLOCKQUOTE>
Given elements p and m of a polynomial ring P=R[x], where m is
a monomial (that is, has exactly one non-zero base coefficient, which must be
1), return the coefficient of m in p, as an element of the
coefficient ring R.
</BLOCKQUOTE>
<H5><A NAME = "1791">LeadingCoefficient(p) : RngUPolElt -&gt; RngElt</A></H5>
<BLOCKQUOTE>
Return the coefficient of the highest occurring power of x in p&isin;R[x],
as an element of the coefficient ring R.
</BLOCKQUOTE>
<H5><A NAME = "1792">TrailingCoefficient(p) : RngUPolElt -&gt; RngElt</A></H5>
<BLOCKQUOTE>
Return the coefficient of the lowest occurring power of x in p&isin;R[x],
as an element of the coefficient ring R.
</BLOCKQUOTE>
<H5><A NAME = "1793">ConstantCoefficient(p) : RngUPolElt -&gt; RngElt</A></H5>
<BLOCKQUOTE>
Return the constant term, ie. the coefficient of x<sup>0</sup> as an element
of the coefficient ring R.
</BLOCKQUOTE>
<H5><A NAME = "1794">Terms(p) : RngUPolElt -&gt; [ RngUPolElt ]</A></H5>
<BLOCKQUOTE>
Return the non-zero terms of the polynomial p&isin;P=R[x] in
ascending order with respect to the degree,
as a sequence of elements of P with ascending degrees.
</BLOCKQUOTE>
<H5><A NAME = "1795">LeadingTerm(p) : RngUPolElt -&gt; RngUPolElt</A></H5>
<BLOCKQUOTE>
Return the term of p&isin;P= R[x]
with the highest occurring power of x,
as an element of P. The coefficient of the result
will be the leading coefficient of p.
</BLOCKQUOTE>
<H5><A NAME = "1796">TrailingTerm(p) : RngUPolElt -&gt; RngUPolElt</A></H5>
<BLOCKQUOTE>
Return the term of p&isin;P= R[x]
with the lowest occurring power of x,
as an element of P. The coefficient of the result
will be the trailing coefficient of p.
</BLOCKQUOTE>
<H5><A NAME = "1797">Monomials(p) : RngUPolElt -&gt; SeqEnum</A></H5>
<BLOCKQUOTE>
The monomials of the univariate p, matching up with <TT>Coefficients(p)</TT>,
that is a sequence of powers of the indeterminate up to the degree of p.
</BLOCKQUOTE>
<H5><A NAME = "1798">Support(p) : RngUPolElt -&gt; [RngIntElt], [RngElt]</A></H5>
<BLOCKQUOTE>
Given a polynomial p&isin;R[x], return the positions in p for
which there are non-zero coefficients, and the corresponding coefficients.
</BLOCKQUOTE>
<H5><A NAME = "1799">Round(p) : RngUPolElt -&gt; RngUPolElt</A></H5>
<BLOCKQUOTE>
Given a polynomial p&isin;P= R[x] where R is a subring of the real
field (the ring of integers Z, the rational field Q, or a real
field), return the polynomial in Z[x] obtained from p by rounding
all the coefficients of p.
</BLOCKQUOTE>
<H5><A NAME = "1800">Valuation(p) : RngUPolElt -&gt; RngIntElt</A></H5>
<BLOCKQUOTE>
The valuation of a polynomial p &isin;R[x],
that is, the exponent of the largest power of x which divides
p.  Note that the zero polynomial has valuation &infin;.
</BLOCKQUOTE>
<H4><A NAME = "1801">Degree</A></H4>



<H5><A NAME = "1802">Degree(p) : RngUPolElt -&gt; RngIntElt</A></H5>
<BLOCKQUOTE>
The degree of a polynomial p &isin;R[x],
that is, the exponent of the largest power of x that occurs with
non-zero coefficient.  Note that the zero polynomial has degree -1.
</BLOCKQUOTE>
<H4><A NAME = "1803">Roots</A></H4>



<H5><A NAME = "1804">Roots(p) : RngUPolElt -&gt; [ &lt; RngElt, RngIntElt&gt; ]</A></H5>

<PRE>    Max: RngIntElt                      Default: </PRE>
<BLOCKQUOTE>
Given a polynomial p over one of a certain collection
of coefficient rings, this function
returns a sorted sequence of pairs of coefficient ring element and integer,
where the ring element is a root of p in the coefficient ring, and
the integer its multiplicity.
Currently the coefficient rings that are allowed comprise
complex and real fields, integers and rationals, finite fields and
residue class rings with prime modulus.
If the parameter <TT>Max</TT> is set to a non-negative number m, at
most m roots are returned.
</BLOCKQUOTE>
<H5><A NAME = "1805">Roots(p, S) : RngUPolElt -&gt; [ &lt; RngElt, RngIntElt&gt; ]</A></H5>
<BLOCKQUOTE>
Given a polynomial p over one of a certain collection
of coefficient rings as well as a ring S into which the
coefficients of p can be coerced automatically, this function
returns a sorted sequence of pairs of ring element and integer,
where the ring element is a root of p in the ring S, and
the integer its multiplicity.
Currently the coefficient rings that are allowed comprise
complex and real fields, integers and rationals, finite fields and
residue class rings with prime modulus.
</BLOCKQUOTE>
<H5><A NAME = "1806">HasRoot(p) : RngUPolElt -&gt; BoolElt, RngElt</A></H5>
<BLOCKQUOTE>
Given a polynomial p over the coefficient ring R
this function returns <TT>true</TT> iff p has a root in R.  If the result
is <TT>true</TT>, the function also returns a root of p as a second return value.
Currently the coefficient rings that are allowed comprise
complex and real fields, integers and rationals, finite fields and
residue class rings with prime modulus.
Note that particularly for finite fields, this method may be much faster
than the computation of all roots of the polynomial.
</BLOCKQUOTE>
<H5><A NAME = "1807">HasRoot(p, S) : RngUPolElt, Rng -&gt; BoolElt, RngElt</A></H5>
<BLOCKQUOTE>
Given a polynomial p over the coefficient ring R and a ring S which
contains R,
this function returns <TT>true</TT> iff p has a root in S.  If the result
is <TT>true</TT>, the function also returns a root of p in S as a second return
value.
Currently the coefficient rings that are allowed comprise
complex and real fields, integers and rationals, finite fields and
residue class rings with prime modulus.
Note that particularly for finite fields, this method may be much faster
than the computation of all roots of the polynomial.
</BLOCKQUOTE>
<H5><A NAME = "1808">SmallRoots(p, N, X) : RngUPolElt, RngElt, RngElt -&gt; [RngElt]</A></H5>

<PRE>    Bits: BoolElt                       Default: <TT>false</TT></PRE>

<PRE>    Beta: FldReElt                      Default: 1.0</PRE>

<PRE>    Exponent: RngIntElt                 Default: </PRE>

<PRE>    Finalshifts: RngIntElt              Default: </PRE>

<PRE>    Direct: BoolElt                     Default: <TT>false</TT></PRE>
<BLOCKQUOTE>
Given a monic non-zero univariate integer polynomial p and two positive 
integers N and X, this function returns all x<sub>0</sub>'s such that
|x<sub>0</sub>| &le;X and P(x<sub>0</sub>)=0   [N], as long 
as X &le;0.5 .N<sup>1/d</sup>, where d is the degree of p.
<P>
This function implements Coppersmith's algorithm to compute the small
roots of a univariate polynomial modulo an integer <A  HREF = "text208.htm#bib_Coppersmith96">[Cop96]</A>, 
as described in Alexander May's PhD thesis <A  HREF = "text208.htm#bib_May03">[May03]</A>. It relies upon 
the LLL algorithm for reducing euclidean lattices <A  HREF = "text208.htm#bib_LLL">[LLL82]</A>. It is
frequently used for cryptanalysing public-key cryptosystems (see the example
below).
<P>
<P>
<P>
When <TT>Bits</TT> is set to {<TT>true</TT>}, the input X is read as 2<sup>X</sup>.
<P>
The parameter <TT>Beta</TT> can be set to any value in (0.0, 1.0]. 
The routine will then find all x<sub>0</sub>'s such that
|x<sub>0</sub>| &le;X and P(x<sub>0</sub>)=0 isomorphic to N', as long 
as X &le;0.5 .N<sup>&beta;<sup>2</sup>/d</sup>, where d is the degree of p
and N'&ge;N<sup>&beta;</sup> is any divisor of N.
<P>
The <TT>Exponent</TT> and <TT>Finalshifts</TT> specify the shape of the lattice
basis to be reduced. If <TT>Exponent</TT> is m, then p<sup>m</sup> will be 
the highest power of p used to build the lattice basis, and 
if <TT>Finalshifts</TT> is t, t shifts of p<sup>m</sup> will be used.
Unless requested by the user, these parameters are chosen automatically.
<P>
Finally, the <TT>Direct</TT> option allows the user to require the lattice basis
to be reduced at once, and not progressively while constructed. This is can 
be slower.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "1809">Example <TT>RngPol_SmallRootsUsage (H23E5)</TT></A></H3>
We show how to use the <TT>SmallRoots</TT> routine to factor an RSA
modulus when some most significant bits of one of the factors is known. 
We first generate an RSA modulus.
<P>
<P>
<PRE>
&gt; SetSeed(1);
&gt; F&lt;x&gt; := PolynomialRing (Integers());
&gt; length := 1024; 
&gt; p:=NextPrime (2^(Round(length/2)): Proof:=false);
&gt; pi:=Pi(RealField());
&gt; q:=NextPrime (Round (pi*p): Proof:=false);
&gt; N := p*q;
</PRE>
Suppose that N is known, as well as an approximation of the factor q:
<P>
<P>
<PRE>
&gt; hidden:=220; 
&gt; approxq := q+Random(2^hidden-1);
</PRE>
Our goal is to recover <TT>q</TT> from our knowledge of <TT>approxq</TT>.
We are therefore interested in the small roots of the polynomial
x - approxq modulo q, whose multiple N is known.
<P>
<P>
<PRE>
&gt; A:=x-approxq;
&gt; time perturb:=SmallRoots (A, N, hidden : Bits, Beta:=0.5)[1];
Time 0.050
&gt; q eq approxq-perturb;
true
</PRE>
<HR>
<H5><A NAME = "1810">SetVerbose("SmallRoots", v) : MonStgElt, RngIntElt -&gt;</A></H5>
<BLOCKQUOTE>
(Procedure.)
Set the verbose printing level for the <TT>SmallRoots</TT> routine to
be v.  Currently the legal values for v are <TT>true</TT>, <TT>false</TT>, 0, 1 or 2
(<TT>false</TT> is the same as 0, and <TT>true</TT> is the same as 1).
</BLOCKQUOTE>
<H4><A NAME = "1811">Derivative, Integral</A></H4>



<H5><A NAME = "1812">Derivative(p) : RngUPolElt -&gt; RngUPolElt</A></H5>
<BLOCKQUOTE>
Given a polynomial p&isin;P, return the derivative
of p as an element of P.
</BLOCKQUOTE>
<H5><A NAME = "1813">Derivative(p, n) : RngUPolElt, RngIntElt -&gt; RngUPolElt</A></H5>
<BLOCKQUOTE>
Given a polynomial p&isin;P and an integer n &ge;0, return the n-th
derivative of p as an element of P.
</BLOCKQUOTE>
<H5><A NAME = "1814">Integral(p) : RngUPolElt -&gt; RngUPolElt</A></H5>
<BLOCKQUOTE>
Given a polynomial p&isin;P over a field of characteristic zero,
return the formal integral of p as an element of P.
</BLOCKQUOTE>
<H4><A NAME = "1815">Evaluation, Interpolation</A></H4>



<H5><A NAME = "1816">Evaluate(p, r) : RngUPolElt, RngElt -&gt; RngElt</A></H5>
<BLOCKQUOTE>
Given an element p of a polynomial ring P and an element r of a ring S, 
return the value of p evaluated at r.
If r can be coerced into the coefficient ring R of P,
the result will be an element of R.
If r cannot be coerced to the coefficient ring, then an attempt is made
to do a generic evaluation of p at r.  In this case, the result will
be an element of S.
</BLOCKQUOTE>
<H5><A NAME = "1817">Interpolation(I, V) : [ RngElt ], [ RngElt ] -&gt; RngUPolElt</A></H5>
<BLOCKQUOTE>
This function finds a univariate polynomial that evaluates to the
values V in the interpolation points I.
Let K be a field and n&gt;0 an integer; given sequences I and V, both
consisting of n elements of K, return the
unique univariate polynomial p over K of degree less than n such that
p(I[i]) = V[i] for each 1&le;i&le;n.
</BLOCKQUOTE>
<H4><A NAME = "1818">Quotient and Remainder</A></H4>



<H5><A NAME = "1819">Quotrem(f, g) : RngUPolElt, RngUPolElt -&gt; RngUPolElt, RngUPolElt</A></H5>
<BLOCKQUOTE>
Given elements f and g of the polynomial ring P=R[x],
this function returns polynomials
q (quotient) and r (remainder) in P such that f = q.g + r, and
the degree of r is minimal. The leading coefficient of g
has to be a non-zero divisor in R.
If the leading coefficient of g is
a unit, then the degree of r will be strictly less than that of g
(taking the degree of 0 to be -1). Over the integers (R=Z)
this will be true in general when the leading coefficient of g
divides that of f.
</BLOCKQUOTE>
<H5><A NAME = "1820">f div g : RngUPolElt, RngUPolElt -&gt; RngUPolElt</A></H5>
<BLOCKQUOTE>
The quotient q of f by g, where f and g are in
the polynomial ring P=R[x]. Magma calculates the polynomials
q (quotient) and r (remainder) in P such that f = q * g + r, and
the degree of r is minimal. The leading coefficient of g
has to be a unit.
If the leading coefficient of g is
a unit in R, then the degree of r will be strictly less than that of g
(taking the degree of 0 to be -1). Over the integers (R=Z)
this will be true in general when the leading coefficient of g
divides that of f.
<P>
To find r, use <TT>mod</TT>, and to find both q and r, 
use <TT>Quotrem</TT>.
</BLOCKQUOTE>
<H5><A NAME = "1821">IsDivisibleBy(a, b) : RngUPolElt, RngUPolElt -&gt; BoolElt, RngUPolElt</A></H5>
<BLOCKQUOTE>
Return whether the polynomial f is exactly divisible by the polynomial g;
that is, whether there exists q with f=qg.  If so, return also the
exact divisor q.
</BLOCKQUOTE>
<H5><A NAME = "1822">ExactQuotient(f, g) : RngUPolElt, RngUPolElt -&gt; RngUPolElt</A></H5>
<BLOCKQUOTE>
Assuming that the polynomial f is exactly divisible by the polynomial g,
return the exact quotient of f by g (as a polynomial in the same
polynomial ring).  An error results if g does not divide f exactly.
</BLOCKQUOTE>
<H5><A NAME = "1823">f mod g : RngUPolElt, RngUPolElt -&gt; RngUPolElt</A></H5>
<BLOCKQUOTE>
The remainder r upon division of f by g, where f and g are in
the polynomial ring P=R[x]. Magma calculates the polynomials
q (quotient) and r (remainder) in P such that f = q * g + r, and
the degree of r is minimal. The leading coefficient of g
has to be a non-zero divisor.
If the leading coefficient of g is
a unit in R, then the degree of r will be strictly less than that of g
(taking the degree of 0 to be -1). Over the integers (R=Z)
this will be true in general when the leading coefficient of g
divides that of f.
<P>
To find q, use <TT>div</TT>, and to find both q and r, 
use <TT>Quotrem</TT>.
</BLOCKQUOTE>
<H5><A NAME = "1824">Valuation(f, g) : RngUPolElt, RngUPolElt -&gt; RngIntElt</A></H5>
<BLOCKQUOTE>
The exponent of the highest power of the polynomial g which divides
the polynomial f.
</BLOCKQUOTE>
<H5><A NAME = "1825">Reductum(f) : RngUPolElt -&gt; RngUPolElt</A></H5>
<BLOCKQUOTE>
The reductum of a polynomial f, which is the polynomial obtained
by removing the leading term of f.
</BLOCKQUOTE>
<H5><A NAME = "1826">PseudoRemainder(f, g) : RngUPolElt, RngUPolElt -&gt; RngUPolElt</A></H5>
<BLOCKQUOTE>
Given polynomials f, g in P=R[x], where R is an integral domain,
this function returns the pseudo-remainder r of f and g defined as
follows. Let d be the maximum of 0 and deg(f) - deg(g) + 1, and
let c be the leading coefficient of g; then r
will be the unique polynomial in P such that c<sup>d</sup>.f=q.g + r
and the degree of r is less than that of g (possibly -1 for r=0).
</BLOCKQUOTE>
<H5><A NAME = "1827">EuclideanNorm(p) : RngUPol -&gt; RngIntElt</A></H5>
<BLOCKQUOTE>
Return the Euclidean norm of the univariate polynomial p&isin;P,
where the Euclidean norm is the function that makes
P into a Euclidean ring, which is the degree function.
</BLOCKQUOTE>
<H4><A NAME = "1828">Modular Arithmetic</A></H4>

<P>
<P>
The following functions allow modular arithmetic for univariate polynomials
over a field without the need to move into the quotient ring.
See also the description of <TT>mod</TT> in the section on quotient and
remainder.


<H5><A NAME = "1829">Modexp(f, n, g) : RngUPolElt, RngIntElt, RngUPolElt -&gt; RngUPolElt</A></H5>
<BLOCKQUOTE>
Given univariate polynomials f and g in K[x]
over a field K, return f<sup>n</sup> mod g as an element of K[x].
Here n must be a non-negative integer, and g is allowed to be
a constant polynomial.
</BLOCKQUOTE>
<H5><A NAME = "1830">ChineseRemainderTheorem(X, M) : [RngUPolElt], [RngUPolElt] -&gt; RngUPolElt</A></H5>
<H5>CRT(X, M) : [RngUPolElt], [RngUPolElt] -&gt; RngUPolElt</H5>
<BLOCKQUOTE>
Given two sequences X and M of polynomials where the elements in M
are assumed to be pairwise coprime, find a single polynomial t
that solve the modular equation X<sub>i</sub> = t modulo M<sub>i</sub>.
</BLOCKQUOTE>
<H4><A NAME = "1831">Other Operations</A></H4>



<H5><A NAME = "1832">ReciprocalPolynomial(f) : RngUPolElt -&gt; RngUPolElt</A></H5>
<BLOCKQUOTE>
The reciprocal of the given univariate polynomial.
</BLOCKQUOTE>
<H5><A NAME = "1833">PowerPolynomial(f,n) : RngUPolElt, RngIntElt -&gt; RngUPolElt</A></H5>
<BLOCKQUOTE>
The polynomial whose roots are the nth powers of the roots
of the given polynomial (which should have coefficients in some field).
</BLOCKQUOTE>
<H5><A NAME = "1834">f ^ M : RngUPolElt, Mtrx -&gt; RngUPolElt</A></H5>
<BLOCKQUOTE>
The transformation of the univariate polynomial f under the 
linear fractional transformation given by the 2 by 2 matrix M
(obtained by homogenizing f and making a linear substitution).
</BLOCKQUOTE>
<PRE></PRE> <A  HREF = "text214.htm">[Next]</A><A  HREF = "text212.htm">[Prev]</A> <A  HREF = "text214.htm">[Right]</A> <A  HREF = "text212.htm">[Left]</A> <A  HREF = "text209.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<br><small>Version: V2.22 of <I>
Thu Jun  9 16:37:49 EST 2016
</I></small>
</body></html>