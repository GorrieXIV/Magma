<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <link rel='stylesheet' href='help.css' type='text/css'>
  <TITLE>Roots, Coroots and Reflections</TITLE>
</head>
<body BGCOLOR="#FFFFFF">

 <A  HREF = "text1127.htm">[Next]</A><A  HREF = "text1125.htm">[Prev]</A> <A  HREF = "text1127.htm">[Right]</A> <A  HREF = "text1125.htm">[Left]</A> <A  HREF = "text1118.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<PRE></PRE><H3><A NAME = "12621">Roots, Coroots and Reflections</A></H3>

<P>
<P>
<P>
<P>
Many of these functions have an optional argument
<TT>Basis</TT> which may take one of the following values
<P>
<DL COMPACT class='compact'>
<DT>1. </DT><DD><TT>"Standard"</TT>: the standard basis for the (co)root space.  
  This is the default.
<DT>2. </DT><DD><TT>"Root"</TT>: the basis of simple (co)roots.
<DT>3. </DT><DD><TT>"Weight"</TT>: the basis of fundamental (co)weights (see
Subsection <A  HREF = "text1126.htm#12644">Weights</A> below).</DL>



<H5>Subsections</H5>
<UL>
<LI> <A  HREF = "text1126.htm#12622">Accessing Roots and Coroots</A>
<LI> <A  HREF = "text1126.htm#12633">Reflections</A>
<LI> <A  HREF = "text1126.htm#12644">Weights</A>
</UL>
<H4><A NAME = "12622">Accessing Roots and Coroots</A></H4>



<H5><A NAME = "12623">RootSpace(W) : GrpMat -&gt; Lat</A></H5>
<H5>CorootSpace(W) : GrpMat -&gt; Lat</H5>
<BLOCKQUOTE>
The base space of the reflection group W.
If W is not a reflection group, an error occurs.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "12624">Example <TT>GrpRfl_RootSpace (H105E23)</TT></A></H3>
<P>
<P>
<PRE>
&gt; W := ComplexReflectionGroup("M", 3);
&gt; RootSpace(W);
Full Vector space of degree 3 over Cyclotomic Field of order 24 and degree 8
</PRE>
<HR>
<H5><A NAME = "12625">SimpleOrders(W) : GrpMat -&gt; [RngIntElt]</A></H5>
<BLOCKQUOTE>
The sequence of simple orders of the reflection group W.
If W is not a reflection group, an error is flagged.
</BLOCKQUOTE>
<H5><A NAME = "12626">SimpleRoots(W) : GrpMat -&gt; Mtrx</A></H5>
<H5>SimpleCoroots(W) : GrpMat -&gt; Mtrx</H5>
<BLOCKQUOTE>
The simple (co)rootsof the reflection group W
as the rows of a matrix, i.e. A (resp. B).  
</BLOCKQUOTE>
<H5><A NAME = "12627">NumberOfPositiveRoots(W) : GrpMat -&gt; RngIntElt</A></H5>
<H5>NumPosRoots(W) : GrpMat -&gt; RngIntElt</H5>
<BLOCKQUOTE>
The number of positive roots of the real reflection group W. 
This is also the number of positive coroots.  
The total number of (co)roots is twice the number of positive (co)roots.
This number is finite if and only if W is finite.
</BLOCKQUOTE>
<H5><A NAME = "12628">Roots(W) : GrpMat -&gt; (@@)</A></H5>
<H5>Coroots(W) : GrpMat -&gt; (@@)</H5>

<PRE>    Basis: MonStgElt                    Default: "Standard"</PRE>
<BLOCKQUOTE>
The indexed set of (co)roots of the real reflection group W, i.e. 
{@ &alpha;<sub>1</sub>, ... &alpha;<sub>2N</sub> @} 
(resp. {@ &alpha;<sub>1</sub><sup>star</sup>, ... &alpha;<sub>2N</sub><sup>star</sup> @}).
If W is infinite, an error is flagged.
</BLOCKQUOTE>
<H5><A NAME = "12629">PositiveRoots(W) : GrpMat -&gt; (@@)</A></H5>
<H5>PositiveCoroots(W) : GrpMat -&gt; (@@)</H5>

<PRE>    Basis: MonStgElt                    Default: "Standard"</PRE>
<BLOCKQUOTE>
The indexed set of positive
(co)rootsof the real reflection group W, 
that is, {@ &alpha;<sub>1</sub>, ... &alpha;<sub>N</sub> @} 
(resp. {@ &alpha;<sub>1</sub><sup>star</sup>, ... &alpha;<sub>N</sub><sup>star</sup> @}).
If W is infinite, an error is flagged.
</BLOCKQUOTE>
<H5><A NAME = "12630">Root(W, r) : GrpMat, RngIntElt -&gt; (@@)</A></H5>
<H5>Coroot(W, r) : GrpMat, RngIntElt -&gt; (@@)</H5>

<PRE>    Basis: MonStgElt                    Default: "Standard"</PRE>
<BLOCKQUOTE>
The rth (co)root &alpha;<sub>r</sub> (resp. &alpha;<sub>r</sub><sup>star</sup>) of the real reflection group W.
If W is infinite, an error is flagged.
</BLOCKQUOTE>
<H5><A NAME = "12631">RootPosition(W, v) : GrpMat, . -&gt; (@@)</A></H5>
<H5>CorootPosition(W, v) : GrpMat, . -&gt; (@@)</H5>

<PRE>    Basis: MonStgElt                    Default: "Standard"</PRE>
<BLOCKQUOTE>
If v is a (co)root in the finite real reflection group W, return its index;
otherwise return 0.  These functions will try to coerce v
into the appropriate lattice;  v should be written with
respect to the basis specified by the parameter <TT>Basis</TT>.
If W is infinite, an error is flagged.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "12632">Example <TT>GrpRfl_RootsCoroots (H105E24)</TT></A></H3>
<P>
<P>
<PRE>
&gt; W := ReflectionGroup("A3");
&gt; Roots(W);
{@
    (1 0 0),
    (0 1 0),
    (0 0 1),
    (1 1 0),
    (0 1 1),
    (1 1 1),
    (-1  0  0),
    (0 -1  0),
    (0  0 -1),
    (-1 -1  0),
    (0 -1 -1),
    (-1 -1 -1)
@}
&gt; PositiveCoroots(W);
{@
    (2 -1  0),
    (-1  2 -1),
    (0 -1  2),
    (1  1 -1),
    (-1  1  1),
    (1 0 1)
@}
&gt; #Roots(W) eq 2*NumPosRoots(W);
true
&gt; Root(W, 4);
(1 1 0)
&gt; Root(W, 4 : Basis := "Root");
(1 1 0)
&gt; RootPosition(W, [1,1,0]);
4
&gt; A := Matrix(3,3,[1,0,0, -1,-1,-3, 1,2,4]);
&gt; B := Matrix(3,3,[2,-1,0, -1,2,-1, 0,1,0]);
&gt; W := ReflectionGroup(A,B);
&gt; Roots(W);
{@
    (1 0 0),
    (-1 -1 -3),
    (1 2 4),
    (0 -1 -3),
    (0 1 1),
    (1 1 1),
    (-1  0  0),
    (1 1 3),
    (-1 -2 -4),
    (0 1 3),
    (0 -1 -1),
    (-1 -1 -1)
@}
&gt; PositiveCoroots(W);
{@
    (2 -1  0),
    (-1  2 -1),
    (0 1 0),
    (1  1 -1),
    (-1  3 -1),
    (1  2 -1)
@}
&gt; #Roots(W) eq 2*NumPosRoots(W);
true
&gt; Root(W, 4);
(0 -1 -3)
&gt; Root(W, 4 : Basis := "Root");
(1 1 0)
&gt; RootPosition(W, [0,-1,-3]);
4
</PRE>
<HR>
<H4><A NAME = "12633">Reflections</A></H4>

<P>
<P>
<P>
<P>
The root &alpha; acts on the root space via the reflection s<sub>&alpha;</sub>; the
coroot &alpha;<sup>star</sup> acts on the coroot space via the coreflection
s<sub>&alpha;</sub><sup>star</sup>.


<H5><A NAME = "12634">ReflectionMatrices(W) : GrpMat -&gt; [AlgMatElt]</A></H5>
<H5>CoreflectionMatrices(W) : GrpMat -&gt; [AlgMatElt]</H5>

<PRE>    Basis: MonStgElt                    Default: "Standard"</PRE>
<BLOCKQUOTE>
The sequence of reflections in the finite real reflection group W.   
The rth reflection in the sequence corresponds to the rth (co)root.
</BLOCKQUOTE>
<H5><A NAME = "12635">SimpleReflectionMatrices(W) : GrpMat -&gt; [AlgMatElt]</A></H5>
<H5>SimpleCoreflectionMatrices(W) : GrpMat -&gt; [AlgMatElt]</H5>

<PRE>    Basis: MonStgElt                    Default: "Standard"</PRE>
<BLOCKQUOTE>
The matrices giving the action of the simple (co)roots on the (co)root
space of the finite real reflection group W.
</BLOCKQUOTE>
<H5><A NAME = "12636">ReflectionMatrix(W, r) : GrpMat, RngIntElt -&gt; AlgMatElt</A></H5>
<H5>CoreflectionMatrix(W, r) : GrpMat, RngIntElt -&gt; []</H5>

<PRE>    Basis: MonStgElt                    Default: "Standard"</PRE>
<BLOCKQUOTE>
The reflection in finite real reflection group W corresponding to the rth (co)root.
If r=1, ..., n, this is a generator of W.
</BLOCKQUOTE>
<H5><A NAME = "12637">SimpleReflectionPermutations(W) : GrpMat -&gt; []</A></H5>
<BLOCKQUOTE>
The sequence of permutations giving the action of the simple (co)roots
of the finite reflection group W on the (co)roots.  
This action is the same for roots and coroots.
</BLOCKQUOTE>
<H5><A NAME = "12638">ReflectionPermutations(W) : GrpMat -&gt; []</A></H5>
<BLOCKQUOTE>
The sequence of permutations giving the action of the (co)roots of the 
finite reflection group W on the (co)roots.   
This action is the same for roots and coroots.
</BLOCKQUOTE>
<H5><A NAME = "12639">ReflectionPermutation(W, r) : GrpMat, RngIntElt -&gt; []</A></H5>
<BLOCKQUOTE>
The permutation giving the action of the rth (co)root of the finite reflection
group W on the (co)roots.    
This action is the same for roots and coroots.
</BLOCKQUOTE>
<H5><A NAME = "12640">ReflectionWords(W) : GrpMat -&gt; []</A></H5>
<BLOCKQUOTE>
The sequence of words  in the simple reflections for all
the reflections of the real reflection group W.
These words are given as sequences of integers.
In other words, if a = [a<sub>1</sub>, ..., a<sub>l</sub>] = ReflectionWords(W)[r],
then s<sub>&alpha;<sub>r</sub></sub> = s_(&alpha;<sub>a<sub>1</sub></sub>) ... s_(&alpha;<sub>a<sub>l</sub></sub>).
</BLOCKQUOTE>
<H5><A NAME = "12641">ReflectionWord(W, r) : GrpMat, RngIntElt -&gt; []</A></H5>
<BLOCKQUOTE>
The word in the simple reflections for the rth
reflection of the real reflection group W.
The word is given as a sequence of integers.
In other words, if a = [a<sub>1</sub>, ..., a<sub>l</sub>] = ReflectionWord(W, r),
then s<sub>&alpha;<sub>r</sub></sub> = s_(&alpha;<sub>a<sub>1</sub></sub>) ... s_(&alpha;<sub>a<sub>l</sub></sub>).
</BLOCKQUOTE>
<HR>
<H3><A NAME = "12642">Example <TT>GrpRfl_Action (H105E25)</TT></A></H3>
<P>
<P>
<PRE>
&gt; Q := RationalField();
&gt; W := ReflectionGroup("A3");
&gt; mx := ReflectionMatrix(W, 4);
&gt; perm := ReflectionPermutation(W, 4);
&gt; RootPosition(W, Vector(Q, Eltseq(Root(W,2))) * mx) eq 2^perm;
true
&gt; mx := CoreflectionMatrix(W, 4);
&gt; CorootPosition(W, Coroot(W,2) * mx) eq 2^perm;
true
</PRE>
<HR>
<H5><A NAME = "12643">Length(w) : GrpMatElt -&gt; RngIntElt</A></H5>
<H5>CoxeterLength(w) : GrpMatElt -&gt; RngIntElt</H5>
<BLOCKQUOTE>
The lengthof w as an element of
the Coxeter group W, ie. the number of positive roots of W which
become negative under the action of w.
</BLOCKQUOTE>
<H4><A NAME = "12644">Weights</A></H4>



<H5><A NAME = "12645">WeightLattice(W) : GrpMat -&gt; Lat</A></H5>
<H5>CoweightLattice(W) : GrpMat -&gt; Lat</H5>
<BLOCKQUOTE>
The (co)weight lattice of the real reflection group W.   
The roots and coroots of W must have integral components.
</BLOCKQUOTE>
<H5><A NAME = "12646">FundamentalWeights(W) : GrpMat -&gt; Mtrx</A></H5>
<H5>FundamentalCoweights(W) : GrpMat -&gt; Mtrx</H5>

<PRE>    Basis: MonStgElt                    Default: "Standard"</PRE>
<BLOCKQUOTE>
The fundamental weightsof the real reflection group W given as the rows of a matrix.  
The roots and coroots of W must have integral components.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "12647">Example <TT>GrpRfl_Weights (H105E26)</TT></A></H3>
<P>
<P>
<PRE>
&gt; W := ReflectionGroup("E6");
&gt; WeightLattice(W);
Lattice of rank 6 and degree 6
Basis:
(4  3  5  6  4  2)
(3  6  6  9  6  3)
(5  6 10 12  8  4)
(6  9 12 18 12  6)
(4  6  8 12 10  5)
(2  3  4  6  5  4)
Basis Denominator: 3
&gt; FundamentalWeights(W);    
[ 4/3    1  5/3    2  4/3  2/3]
[   1    2    2    3    2    1]
[ 5/3    2 10/3    4  8/3  4/3]
[   2    3    4    6    4    2]
[ 4/3    2  8/3    4 10/3  5/3]
[ 2/3    1  4/3    2  5/3  4/3]
</PRE>
<HR>
<H5><A NAME = "12648">IsDominant(R, v) : RootDtm, . -&gt; ModTupFldElt, GrpFPCoxElt</A></H5>

<PRE>    Basis: MonStgElt                    Default: "Standard"</PRE>
<BLOCKQUOTE>
Returns <TT>true</TT> if and only if v is a dominant weight for the root datum
R, ie, a nonnegative integral linear combination of the fundamental weights.
</BLOCKQUOTE>
<H5><A NAME = "12649">DominantWeight(W, v) : GrpMat, . -&gt; ModTupFldElt, GrpFPCoxElt</A></H5>

<PRE>    Basis: MonStgElt                    Default: "Standard"</PRE>
<BLOCKQUOTE>
The unique dominant weight in the same W-orbit as v, where W is 
a real reflection group and v is a weight given as a vector or 
a sequence representing a vector.
The second value returned is a Coxeter group element taking v to the dominant weight.
</BLOCKQUOTE>
<H5><A NAME = "12650">WeightOrbit(W, v) : GrpMat, . -&gt; @ ModTupFldElt @, [GrpFPCoxElt]</A></H5>

<PRE>    Basis: MonStgElt                    Default: "Standard"</PRE>
<BLOCKQUOTE>
The W-orbit of v as an indexed set, where W is 
a real reflection group and v is a weight given as a vector or 
a sequence representing a vector.
The first element in the orbit is always dominant.
The second value returned is a sequence of Coxeter group elements taking the dominant weight
to the corresponding element of the orbit.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "12651">Example <TT>GrpRfl_DominantWeights (H105E27)</TT></A></H3>
<P>
<P>
<PRE>
&gt; W := CoxeterGroup("B3");
&gt; DominantWeight(W, [1,-1,0] : Basis:="Weight");  
(1 0 0)
$.2 * $.3 * $.2 * $.1
&gt; #WeightOrbit(W, [1,-1,0] : Basis:="Weight");   
6
</PRE>
<HR>
<PRE></PRE> <A  HREF = "text1127.htm">[Next]</A><A  HREF = "text1125.htm">[Prev]</A> <A  HREF = "text1127.htm">[Right]</A> <A  HREF = "text1125.htm">[Left]</A> <A  HREF = "text1118.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<br><small>Version: V2.22 of <I>
Thu Jun  9 16:37:49 EST 2016
</I></small>
</body></html>