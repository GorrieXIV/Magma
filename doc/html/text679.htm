<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <link rel='stylesheet' href='help.css' type='text/css'>
  <TITLE>Composition Trees for Matrix  Groups</TITLE>
</head>
<body BGCOLOR="#FFFFFF">

 <A  HREF = "text680.htm">[Next]</A><A  HREF = "text678.htm">[Prev]</A> <A  HREF = "text680.htm">[Right]</A> <A  HREF = "text678.htm">[Left]</A> <A  HREF = "text673.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<PRE></PRE><H3><A NAME = "7815">Composition Trees for Matrix  Groups</A></H3>

<P>
<P>
<P>
<P>
A <I>composition tree</I> for a group G can be viewed as a data structure 
which presents a group in terms of its composition factors. The tree is
constructed recursively and the data structure facilitates the rewriting 
of elements of G in terms of different generating sets.
<P>
<P>
<P>
The basic strategy for computing a <I>composition tree</I> of a matrix group
employs a combination of a constructive version of Aschbacher's theorem 
<A  HREF = "text672.htm#bib_asch-maximal-subgps">[Asc84]</A> and constructive recognition algorithms for 
finite simple groups. The basic algorithms are described
in <A  HREF = "text672.htm#bib_crlg01">[LG01]</A>, <A  HREF = "text672.htm#bib_OBrien-survey">[O'B06]</A>, <A  HREF = "text672.htm#bib_OBrien10">[O'B11]</A> while some new ideas introduced 
in <A  HREF = "text672.htm#bib_neunhoeffer-seress">[NS06]</A> are incorporated. A detailed account of the 
entire <I>CompositionTree</I> procedure appears in <A  HREF = "text672.htm#bib_Baarnhielmetal11">[BHLGO15]</A>.
<P>
<P>
<P>
The algorithm for constructing a composition tree for a group G proceeds 
as follows.
<P>
<DL COMPACT class='compact'>
<DT>(i)</DT><DD>Attempt to construct an effective homomorphism &phi; : G to G<sub>1</sub>, for 
some group G<sub>1</sub>.  The homomorphism &phi; is called a <I>reduction</I> 
of G since G<sub>1</sub> is "smaller" than G in some sense -- for example,
with respect to its degree or field of definition.  
<P>
<DT>(ii)</DT><DD>Otherwise deduce that G is cyclic, elementary abelian, or "close"
to being non-abelian simple.  In this case G becomes a <I>leaf</I>
in the tree.
<P>
<P>
<P>
</DL>
If Case (i) applies the algorithm proceeds as follows:- 
<DL COMPACT class='compact'>
<DT>1.</DT><DD>Construct a composition tree for G<sub>1</sub>.
<DT>2.</DT><DD>Determine generators for G<sub>0</sub> := (Ker)(&phi;).
This requires a rewriting algorithm for G<sub>1</sub>.
<DT>3.</DT><DD>Construct a composition tree for G<sub>0</sub>.
<DT>4.</DT><DD>Combine the composition trees for G<sub>1</sub> and G<sub>0</sub> to
produce a composition tree for G.
<P>
<P>
<P>
</DL>
If G &le;GL(d, q), then Aschbacher's theorem <A  HREF = "text672.htm#bib_asch-maximal-subgps">[Asc84]</A> 
is applied in Step (1).  This requires algorithms that can decide whether 
G lies in a certain Aschbacher class, and to construct the corresponding 
&phi;.  Other homomorphisms, such as the determinant map, may also be used.
<P>
<P>
<P>
The group associated with a leaf need not be simple.  It may be cyclic
or elementary abelian, a soluble or non-abelian simple primitive
permutation group, or an absolutely irreducible matrix group that is
simple modulo its centre.  The  decision on just which groups are
treated as leaves is partly dictated by complexity considerations,
and partly based on the quality of available algorithms for processing
a leaf.  For example, refining a cyclic group into its composition 
factors appears to offer no practical advantage.
<P>
<P>
<P>
Once a composition tree for G = &lt; X &gt; has been constructed, 
then a second list Y of <I>nice generators</I> are stored with G. 
The group &lt; Y &gt; is called the <I>nice group</I>. The intrinsic
<TT>CompositionTree</TT> constructs the nice generators Y as straight-line 
programs (SLPs) with respect to X.  The rewriting algorithm solves 
rewriting problems with respect to Y and the resulting SLPs can then 
be rewritten to provide SLPs on X.
<P>
<P>
<P>
The verbose flag <TT>SetVerbose("CompositionTree", n)</TT> with 
n=1, ..., 10 may be used to print increasing levels of 
information on the progress of the functions.


<H5><A NAME = "7816">CompositionTree(G) : GrpMat[FldFin] -&gt; []</A></H5>
<BLOCKQUOTE>
Let G be a finite group generated by matrices over a finite field.
The intrinsic constructs a composition tree for G  using the 
algorithm outlined at the beginning of this section. The tree is
returned as the value of this intrinsic and is also stored with G 
and it is usually accessed by reference to G.
<P>
The intrinsic has a number of parameters that are described below.
Even in the case of a small group, the tree is a very voluminous object 
so that information about it should be extracted using the intrinsics
described below. The tree is constructed using Monte Carlo algorithms
and so there is a small probability that it is incorrect. Algorithms
are available to verify the correctness of the tree and may be invoked
either by setting a parameter for the <TT>CompositionTree</TT> intrinsic 
or by a separate intrinsic <TT>CompositionTreeVerify</TT> that may be 
applied to the tree produced by a call to <TT>CompositionTree</TT> and 
which is described below.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "7817">Example <TT>GrpMatFF_CompositionTree (H65E12)</TT></A></H3>
<P>
The minimum degree of a permutation representation of the sporadic 
simple group J<sub>4</sub> is 173, 067, 389 while there is a matrix 
representation of degree 112 over the finite field F<sub>2</sub>. We 
extract this matrix representation of J<sub>4</sub> from the Atlas database 
and apply <TT>CompositionTree</TT> to it. 
<P>
<P>
<P>
<PRE>
&gt; G := MatrixGroup(AtlasGroup("J4"));
&gt; G:Minimal;
MatrixGroup(112, GF(2)) 
&gt; time G_Tree := CompositionTree(G);
Time: 3.030
</PRE>
<P>
We now extract the order and list the isomorphism types of the non-abelian
composition trees.
<P>
<P>
<P>
<PRE>
&gt; CompositionTreeOrder(G);
86775571046077562880
&gt; nafact := CompositionTreeNonAbelianFactors(G);
&gt; nafact[1][3];
"J4"
</PRE>
<HR>
<H5><A NAME = "7818">CompositionTree(G : parameters) : GrpMat[FldFin] -&gt; []</A></H5>

<PRE>    Verify: BoolElt                     Default: <TT>false</TT></PRE>

<PRE>    Scalar: FldFinElt                   Default: 1</PRE>

<PRE>    KernelBatchSize: RngIntElt          Default: 5</PRE>

<PRE>    MandarinBatchSize: RngIntElt        Default: 100</PRE>

<PRE>    MaxHomFinderFails: RngIntElt        Default: 1</PRE>

<PRE>    MaxQuotientOrder: RngIntElt         Default: 10^6</PRE>

<PRE>    FastTensorTest: BoolElt             Default: <TT>true</TT></PRE>

<PRE>    MaxBSGSVerifyOrder: RngIntElt       Default: 2000</PRE>

<PRE>    AnalysePermGroups: BoolElt          Default: <TT>false</TT></PRE>

<PRE>    KnownLeaf: BoolElt                  Default: <TT>false</TT></PRE>

<PRE>    NamingElements: RngIntElt           Default: 200</PRE>

<PRE>    UnipotentBatchSize: RngIntElt       Default: 100</PRE>

<PRE>    PresentationKernel: BoolElt         Default: <TT>true</TT></PRE>
<BLOCKQUOTE>
Let G be a finite group generated by matrices over a finite field.
The intrinsic constructs a composition tree for G and returns the
tree using the algorithm outlined at the beginning of this section.
The intrinsic has a number of parameters which are now described.
<P>
<TT>Verify</TT>: If <TT>true</TT>, then verify correctness of the tree during 
construction.
<P>
<TT>KernelBatchSize</TT>: The number of normal generators
used to construct the kernel of homomorphism.
<P>
<TT>MandarinBatchSize</TT>: The number of random elements used 
to check correctness of the outcome of Monte-Carlo algorithms.
<P>
<TT>MaxHomFinderFails</TT>: 
 Assume a negative answer after this many failures
of certain Monte Carlo algorithms.
<P>
<TT>MaxQuotientOrder</TT>:  A leaf with larger order will not 
be fully refined to its composition factors.
<P>
<TT>FastTensorTest</TT>: Use only the fast tensor product test.
<P>
<TT>MaxBSGSVerifyOrder</TT>: If <TT>RandomSchreier</TT> is used on
a leaf and it has order less than <TT>MaxBSGSVerifyOrder</TT>, then 
<TT>Verify</TT> the calculation.
<P>
<TT>AnalysePermGroups</TT>: 
If <TT>false</TT>, then always treat the permutation group as a 
leaf, and do not analyse its structure.
<P>
<TT>NamingElements:</TT>
The number of random elements used in 
calls to <TT>LieType</TT> and <TT>RecogniseClassical</TT>.
<P>
<TT>PresentationKernel</TT>: Use presentations to obtain kernels, 
where possible.
<P>
<TT>UnipotentBatchSize</TT>: Batch size for the unipotent kernels.
<P>
<P>
</BLOCKQUOTE>
<H5><A NAME = "7819">CompositionTreeFastVerification(G) : Grp -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
The argument G must be a matrix group over a finite field for
which a composition tree datastructure has previously been
constructed. The intrinsic determines if correctness of
the composition tree can be verified at modest cost using 
presentations. In effect, the intrinsic determines whether
presentations on nice generators are known for all the leaves. 
</BLOCKQUOTE>
<H5><A NAME = "7820">CompositionTreeVerify(G) : Grp -&gt; BoolElt, []</A></H5>
<BLOCKQUOTE>
The argument G must be a matrix group over a finite field for
which a composition tree datastructure has previously been
constructed. The intrinsic verifies the correctness of the 
composition tree by using it to construct a presentation for G.
If G satisfies the presentation, then return <TT>true</TT>, and the
relators of the presentation as SLPs; otherwise return <TT>false</TT>.
The presentation is on the group returned by
<TT>CompositionTreeNiceGroup</TT>(G).
</BLOCKQUOTE>
<HR>
<H3><A NAME = "7821">Example <TT>GrpMatFF_CompositionTreeVerify (H65E13)</TT></A></H3>
<P>
We use the two methods of establishing correctness to verify the result 
of applying hfil <BR> <TT>CompositionTree</TT> to a wreath product.
<P>
<P>
<P>
<PRE>
&gt; U33 := MatrixGroup(AtlasGroup("U33"), 1);
&gt; G := TensorWreathProduct( U33, Sym(3) );
&gt; time G_Tree := CompositionTree(G);
Time: 26.620
</PRE>
<P>
<P>
<P>
<PRE>
&gt; G := TensorWreathProduct( U33, Sym(3) );
&gt; time G_Tree := CompositionTree(G : Verify := true);
Time: 28.450
</PRE>
<P>
Thus, verification adds a little under 2 seconds to the runtime. 
<P>
<P>
<P>
<PRE>
&gt; G := TensorWreathProduct( U33, Sym(3) );
&gt; time G_Tree := CompositionTree(G );
Time: 26.620
&gt; time CompositionTreeFastVerification(G);
Time: 0.000
true
&gt; time CompositionTreeVerify(G);
Time: 1.850
true
</PRE>
<P>
In this case we use <TT>CompositionTreeFastVerification</TT> to
check that verification wont be expensive and then apply the
intrinsic <TT>CompositionTreeVerify</TT> to actually do the 
verification.  Again, it takes less than 2 seconds.
<HR>
<H3><A NAME = "7822">Example <TT>GrpMatFF_CompTreeJ4 (H65E14)</TT></A></H3>
<P>
The composition tree (CT) machinery allows us to create a subgroup
H of a group G with a CT, to determine the order of H and to 
test membership in H. In general, additional machinery is needed
in order to be able to determine information about the subgroup
structure of G. However, there are two Monte Carlo algorithms for 
computing subgroups, specifically, an algorithm for computing the
centralizer of an involution and an algorithm for computing the 
normal closure of a subgroup. We illustrate how the centralizer
algorithm can be used by applying it to compute a large subgroup
in the sporadic group J<sub>4</sub>. The group J<sub>4</sub> has a maximal subgroup
of index 3,980,549,947 which is the centralizer of an involution.
We will try to find this maximal subgroup by working with J<sub>4</sub> in
its matrix representation of degree 112 over GF(2).
<P>
<P>
<P>
<PRE>
&gt; G := MatrixGroup(AtlasGroup("J4"));
&gt; G:Minimal;
MatrixGroup(112, GF(2))
&gt; CT := CompositionTree(G);
&gt; CompositionTreeOrder(G);
86775571046077562880

&gt; found := false;
&gt; for i := 1 to 30 do
&gt;    bool, x := RandomElementOfOrder(G, 2);
&gt;    C := CentraliserOfInvolution(G, x);
&gt;    CTree := CompositionTree(C);
&gt;    n := CompositionTreeOrder(C);
&gt;    if n eq 21799895040 then 
&gt;       found := true;
&gt;       break; 
&gt;    end if;
&gt; end for;

&gt; found;
true
&gt; cf := LMGChiefFactors(C); cf;

    G
    |  Cyclic(2)
    *
    |  M22
    *
    |  Cyclic(3)
    *
    |  Cyclic(2) (12 copies)
    *
    |  Cyclic(2)
    1

</PRE>
<P>
The intrinsic <TT>LMGChiefFactors</TT> computes the isomorphism
type of the chief factors of a group having the composition tree
datastructure. It will be described in the next section.
<HR>
<H5><A NAME = "7823">CompositionTreeNiceGroup(G) : Grp -&gt; GrpMat[FldFin]</A></H5>
<BLOCKQUOTE>
The argument G must be a matrix group over a finite field for
which a composition tree datastructure has previously been
constructed. The intrinsic returns the nice group for G.
</BLOCKQUOTE>
<H5><A NAME = "7824">CompositionTreeSLPGroup(G) : Grp -&gt; GrpSLP, Map</A></H5>
<BLOCKQUOTE>
The argument G must be a matrix group over a finite field for
which a composition tree datastructure and the associated nice 
group H has previously been constructed. The intrinsic returns 
the word group W for H, and the map from W to H.
</BLOCKQUOTE>
<H5><A NAME = "7825">DisplayCompTreeNodes(G : parameters) : Grp  -&gt;</A></H5>

<PRE>    NonTrivial: BoolElt                 Default: <TT>true</TT></PRE>

<PRE>    Leaves: BoolElt                     Default: <TT>false</TT></PRE>
<BLOCKQUOTE>
The argument G must be a matrix group over a finite field for
which a composition tree datastructure has previously been
constructed. This intrinsic displays information about the nodes 
in the composition tree for G.  The tree is traversed in-order. 
If parameter <TT>NonTrivial</TT> is <TT>true</TT>, then only non-trivial 
nodes will be displayed. If parameter <TT>Leaves</TT> is <TT>true</TT> 
then only leaves will be displayed.
</BLOCKQUOTE>
<H5><A NAME = "7826">CompositionTreeNiceToUser(G) : Grp -&gt; Map, []</A></H5>
<BLOCKQUOTE>
The argument G must be a matrix group over a finite field for
which a composition tree datastructure has previously been
constructed. This intrinsic returns the coercion map from SLPs in
nice generators of G to SLPs in input user generators of G, 
as well as the SLPs of the nice generators given in terms the 
user generators.
</BLOCKQUOTE>
<H5><A NAME = "7827">CompositionTreeOrder(G) : Grp -&gt; RngIntElt</A></H5>
<H5>CompositionTreeFactoredOrder(G) : Grp -&gt; RngIntEltFact</H5>
<BLOCKQUOTE>
The argument G must be a matrix group over a finite field for
which a composition tree datastructure has previously been
constructed. The intrinsics return the (factored) order of G. 
</BLOCKQUOTE>
<H5><A NAME = "7828">CompositionTreeElementToWord(G, g) : Grp, GrpElt -&gt; BoolElt, GrpSLPElt</A></H5>
<BLOCKQUOTE>
The argument G must be a matrix group over a finite field for
which a composition tree datastructure has previously been
constructed.  Given an element g&isin;G, return <TT>true</TT> and 
an SLP for g in the nice generators of G, otherwise return 
<TT>false</TT>.
</BLOCKQUOTE>
<H5><A NAME = "7829">CompositionTreeNonAbelianFactors(G) : GrpMat[FldFin] -&gt; List</A></H5>
<BLOCKQUOTE>
The argument G must be a matrix group over a finite field for
which a composition tree datastructure has previously been
constructed. This intrinsic returns a list naming the non-abelian
composition factors of G. 
</BLOCKQUOTE>
<H5><A NAME = "7830">CompositionTreeCBM(G) : GrpMat[FldFin -&gt; GrpMatElt</A></H5>
<BLOCKQUOTE>
The argument G must be a matrix group over a finite field for
which a composition tree datastructure has previously been
constructed. This intrinsic returns a change-of-basis matrix 
that exhibits the Aschbacher reductions of G given by the 
composition tree. 
</BLOCKQUOTE>
<H5><A NAME = "7831">CompositionTreeReductionInfo(G, t) : Grp, RngIntElt -&gt; MonStgElt,Grp, Grp</A></H5>
<BLOCKQUOTE>
The argument G must be a matrix group over a finite field for
which a composition tree datastructure has previously been
constructed. This intrinsic returns a string description of the 
reduction at the internal node t in the composition tree for G,
as well as the image and kernel of this reduction. 
</BLOCKQUOTE>
<H5><A NAME = "7832">CompositionTreeSeries(G) : Grp -&gt; SeqEnum, List, List, List, BoolElt, []</A></H5>
<BLOCKQUOTE>
The argument G must be a matrix group over a finite field for
which a composition tree datastructure has previously been
constructed. This intrinsic returns: 
<DL COMPACT class='compact'>
<DT>1.</DT><DD>A normal series of subgroups 1 = G<sub>0</sub> &lt; G<sub>1</sub> &lt; ... &lt; G<sub>k</sub> = G.
<DT>2.</DT><DD>Maps G<sub>i</sub> |-&gt; S<sub>i</sub>, where S<sub>i</sub> is the standard copy of G<sub>i</sub> / G<sub>i - 1</sub>, 
where i &ge;1. The kernel of this map is G<sub>i - 1</sub>. 
Observe that S<sub>i</sub> may be the standard copy plus scalars Z,
and the map is then a homomorphism modulo scalars, so that the kernel is 
(G<sub>i - 1</sub>.Z)/Z.
<DT>3.</DT><DD>Maps S<sub>i</sub> |-&gt; G<sub>i</sub>. 
<DT>4.</DT><DD>Maps S<sub>i</sub> |-&gt; <TT>WordGroup</TT>(S<sub>i</sub>).
<DT>5.</DT><DD>Boolean flag <TT>true</TT> or <TT>false</TT>
 to indicate if the series is a true composition series. 
<DT>6.</DT><DD>A sequence of the leaf nodes in the composition tree corresponding to each 
composition factor. All maps are defined by rules, so <TT>Function</TT>
can be applied on them to avoid built-in membership testing. </DL>
</BLOCKQUOTE>
<H5><A NAME = "7833">CompositionTreeFactorNumber(G, g) : Grp, GrpElt -&gt; RngIntElt</A></H5>
<BLOCKQUOTE>
The argument G must be a matrix group over a finite field for
which a composition tree datastructure has previously been
constructed. This intrinsic returns the minimal integer i such 
that g lies in the ith-term of the normal series returned by 
<TT>CompositionTreeSeries</TT> for G. 
</BLOCKQUOTE>
<H5><A NAME = "7834">HasCompositionTree(G) : Grp -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Given a matrix group G defined over a finite field, this 
intrinsic returns <TT>true</TT> if G has a composition tree 
and <TT>false</TT> otherwise.
</BLOCKQUOTE>
<H5><A NAME = "7835">CleanCompositionTree(G) : Grp  -&gt;</A></H5>
<BLOCKQUOTE>
The argument G must be a matrix group over a finite field for
which a composition tree datastructure has previously been
constructed. This intrinsic removes all data related to the 
composition tree datastructure for G.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "7836">Example <TT>GrpMatFF_CompTree1 (H65E15)</TT></A></H3>
We construct a composition tree for the conformal orthogonal group 
G of plus type of degree 4 over GF(5<sup>2</sup>).
<P>
<P>
<P>
<PRE>
&gt; G := CGOPlus(4, 5^2);
&gt; 
&gt; T := CompositionTree(G);
&gt; 
&gt; DisplayCompTreeNodes (G: Leaves:=true);
node = 2
parent = 1
depth = 1
scalar = 1
info = leaf, GrpAb, cyclic group, order 12
fast verify = true
----------
node = 4
parent = 3
depth = 2
scalar = 1
info = leaf, GrpAb, cyclic group, order 4
fast verify = true
----------
node = 7
parent = 6
depth = 4
scalar = 12
info = leaf, GrpAb, cyclic group, order 24
fast verify = true
----------
node = 8
parent = 6
depth = 4
scalar = 2
info = leaf, GrpMat, almost simple, &lt;"A", 1, 25&gt;
fast verify = true
----------
node = 9
parent = 5
depth = 3
scalar = 1
info = leaf, GrpMat, almost simple, &lt;"A", 1, 25&gt;
fast verify = true
----------
</PRE>
<P>
We now verify correctness of the composition tree.  In order to show
what is going on we illustrate various pieces of the verification
process.  We begin by setting up the nice group H for G and its 
associated SLP group; observe that H = G. After checking that 
verification can be done quickly, we perform the verification.
<P>
<P>
<P>
<PRE>
&gt; H := CompositionTreeNiceGroup(G);
&gt; W := CompositionTreeSLPGroup(G);
&gt;
&gt; CompositionTreeFastVerification(G);
true
&gt; 
&gt; f, R := CompositionTreeVerify(G);
&gt; #R;
73
</PRE>
<P>
<P>
At this point we have verified correctness. However, we now explicitly 
evaluate the relations R on the generators of H. This step has
already been performed by <TT>CompositionTreeVerify</TT> so it is shown
here just for demonstration purposes.
<P>
<P>
<P>
<PRE>
&gt; Set(Evaluate(R, [H.i:i in [1..Ngens(H)]]));
{
    [     1      0      0      0]
    [     0      1      0      0]
    [     0      0      1      0]
    [     0      0      0      1]
}
</PRE>
<P>
Now that we know that the composition tree is correct, we ask 
for the order of G.
<P>
<P>
<P>
<PRE>
&gt; CompositionTreeOrder(G);                                
11681280000
</PRE>
<P>
Express the element g of G as a SLP on the generators of the nice group H.
<P>
<P>
<P>
<PRE>
&gt; g := Random(G);
&gt; f, w := CompositionTreeElementToWord(G, g);
&gt; Evaluate(w, [H.i:i in [1..Ngens(H)]]) eq g;
true
</PRE>
Rewrite the SLP in terms of the user-supplied generators for G. 
<P>
<P>
<P>
<PRE>
&gt; tau := CompositionTreeNiceToUser(G);
&gt; tau;
Mapping from: GrpSLP: W to SLPGroup(5)
</PRE>
Images of elements of W under tau lie in <TT>WordGroup</TT>(G). 
<P>
<P>
<P>
<PRE>
&gt; v := tau(w);
&gt; Evaluate (v, [G.i : i in [1..Ngens(G)]]) eq g;
true
</PRE>
Test a random element of the generic group for G for membership.
(The generic group will be the general linear group GL(4, 5<sup>2</sup>).)
<P>
<P>
<P>
<PRE>
&gt; x := Random(Generic(G));
&gt; f, w := CompositionTreeElementToWord(G, x);
&gt; f; 
false
</PRE>
<P>
Finally, we construct a normal series for G and locate a random
element within this series.
<P>
<P>
<P>
<PRE>
&gt; CS, _, _, _, flag := CompositionTreeSeries(G);
&gt; "Series is composition series? ", flag;
Series is composition series?  true
&gt; "Length is ", #CS;
Length is  10
&gt; 
&gt; g := Random(G);
&gt; CompositionTreeFactorNumber(G, g);
10
</PRE>
<HR>
<H3><A NAME = "7837">Example <TT>GrpMatFF_CompTree2 (H65E16)</TT></A></H3>
<P>
In this example, we choose a maximal subgroup of the linear group
SL(10, 2<sup>8</sup>) and compute its composition tree.
<P>
<P>
<P>
<PRE>
&gt; X := ClassicalMaximals ("L", 10, 2^8);
&gt; G := X[1];
&gt; 
&gt; T := CompositionTree (G);
&gt; 
&gt; DisplayCompTreeNodes (G: Leaves:=true, NonTrivial:=true);
node = 6
parent = 5
depth = 5
scalar = 1
info = leaf, GrpAb, cyclic group, order 255
fast verify = true
----------
node = 9
parent = 8
depth = 5
scalar = 1
info = leaf, GrpMat, almost simple, &lt;"A", 8, 256&gt;
fast verify = true
----------
node = 13
parent = 12
depth = 3
scalar = 1
info = leaf, GrpPC, abelian group, order 256
fast verify = true
----------
node = 15
parent = 14
depth = 4
scalar = 1
info = leaf, GrpPC, abelian group, order 256
fast verify = true
----------
node = 17
parent = 16
depth = 5
scalar = 1
info = leaf, GrpPC, abelian group, order 256
fast verify = true
----------
node = 19
parent = 18
depth = 6
scalar = 1
info = leaf, GrpPC, abelian group, order 256
fast verify = true
----------
node = 21
parent = 20
depth = 7
scalar = 1
info = leaf, GrpPC, abelian group, order 256
fast verify = true
----------
----------
node = 23
parent = 22
depth = 8
scalar = 1
info = leaf, GrpPC, abelian group, order 256
fast verify = true
----------
node = 25
parent = 24
depth = 9
scalar = 1
info = leaf, GrpPC, abelian group, order 256
fast verify = true
----------
node = 27
parent = 26
depth = 10
scalar = 1
info = leaf, GrpPC, abelian group, order 256
fast verify = true
----------
node = 29
parent = 28
depth = 11
scalar = 1
info = leaf, GrpPC, abelian group, order 256
fast verify = true
----------
</PRE>
<P>
We now set up the nice group H for G and its associated SLP group;
observe that H = G.
<P>
<P>
<P>
<PRE>
&gt; H := CompositionTreeNiceGroup(G);
&gt; "# of generators of H is ", Ngens(H);
# of generators of H is  77
&gt; W := CompositionTreeSLPGroup(G);
</PRE>
<P>
After checking that correctness of the composition tree can be verified
quickly, we perform verification.
<P>
<P>
<P>
<PRE>
&gt; CompositionTreeFastVerification(G);
true
&gt; f, R := CompositionTreeVerify(G);
&gt; #R;
3028
</PRE>
<P>
Evaluate the relations on the generators of H. 
<P>
<P>
<P>
<PRE>
&gt; Set (Evaluate (R, [H.i:i in [1..Ngens (H)]]));
{
    [1 0 0 0 0 0 0 0 0 0]
    [0 1 0 0 0 0 0 0 0 0]
    [0 0 1 0 0 0 0 0 0 0]
    [0 0 0 1 0 0 0 0 0 0]
    [0 0 0 0 1 0 0 0 0 0]
    [0 0 0 0 0 1 0 0 0 0]
    [0 0 0 0 0 0 1 0 0 0]
    [0 0 0 0 0 0 0 1 0 0]
    [0 0 0 0 0 0 0 0 1 0]
    [0 0 0 0 0 0 0 0 0 1]
}
</PRE>
<P>
Express the element g of G as a SLP on the generators of the nice group H.
Then rewrite the SLP in terms of user generators for G.
<P>
<P>
<P>
<PRE>
&gt; g := Random (G);
&gt; f, w := CompositionTreeElementToWord (G, g);
&gt; Evaluate (w, [H.i:i in [1..Ngens (H)]]) eq g;
true
&gt;
&gt; tau := CompositionTreeNiceToUser (G);
&gt; tau;
Mapping from: GrpSLP: W to SLPGroup(4)
&gt; 
&gt; v := tau (w);
&gt; Evaluate (v, [G.i : i in [1..Ngens (G)]]) eq g;
true
</PRE>
<P>
Next test a random element of the generic group of G for membership 
of G.
<P>
<P>
<P>
<PRE>
&gt; x := Random (Generic (G));
&gt; f, w := CompositionTreeElementToWord (G, x);
&gt; f; 
false
</PRE>
<P>
Finally, we construct a normal series for G. 
<P>
<P>
<P>
<PRE>
&gt; CS, _, _, _, flag := CompositionTreeSeries (G);
&gt; "Series is composition series? ", flag;
Series is composition series?  true
&gt; "Length is ", #CS;
Length is  78
</PRE>
<HR>
<PRE></PRE> <A  HREF = "text680.htm">[Next]</A><A  HREF = "text678.htm">[Prev]</A> <A  HREF = "text680.htm">[Right]</A> <A  HREF = "text678.htm">[Left]</A> <A  HREF = "text673.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<br><small>Version: V2.22 of <I>
Thu Jun  9 16:37:49 EST 2016
</I></small>
</body></html>