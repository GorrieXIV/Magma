<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <link rel='stylesheet' href='help.css' type='text/css'>
  <TITLE>Galois Cohomology</TITLE>
</head>
<body BGCOLOR="#FFFFFF">

 <A  HREF = "text397.htm">[Next]</A><A  HREF = "text401.htm">[Prev]</A> <A  HREF = "text397.htm">[Right]</A> <A  HREF = "text401.htm">[Left]</A> <A  HREF = "text398.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<PRE></PRE><H3><A NAME = "4188">Galois Cohomology</A></H3>

<P>
<P>
Magma has some rudimentary functions to aid computations in Galois 
cohomology of number fields.


<H5><A NAME = "4189">Hilbert90(a, M) : FldNumElt, Map[FldNum, FldNum] -&gt; FldNumElt</A></H5>

<PRE>    S: [RngOrdIdl]                      Default: <TT>false</TT></PRE>
<BLOCKQUOTE>
Let K be a number field and M:K to K be an automorphism
of K furthermore, denote by k the fixed field of M, thus
M generates the automorphism group of the relative cyclic extension
K/k. For some element a in K, such that N<sub>K/k</sub>(a) = 1, this
function will find some element b such that a=b/M(b).
If <TT>S</TT> is given it should contain a sequence of prime ideals such that
there exists some b in the S-unit group over S.
</BLOCKQUOTE>
<H5><A NAME = "4190"></A><A NAME = "RngOrd:SUnitCohomologyProcess">SUnitCohomologyProcess</A>(S, U) : {RngOrdIdl}, GrpPerm -&gt; {1}</H5>

<PRE>    ClassGroup: BoolElt                 Default: <TT>false</TT></PRE>

<PRE>    Ramification: BoolElt               Default: <TT>false</TT></PRE>
<BLOCKQUOTE>
Let k be a normal number field with (abstract) automorphism group G.
For a set of prime ideals S of k, which is closed under the action
of the subgroup U of G, a process is created that allows working
with the cohomology of the multiplicative group of k - partially represented
by a group of S-units.
If <TT>ClassGroup</TT> is given, the set S is enlarged to support the current
generators of the class group. If <TT>Ramification</TT> is present, then all
ramified primes are also included in S.
<P>
During the computations with this object the set S can be increased to
allow the representation of a larger number of elements.
</BLOCKQUOTE>
<H5><A NAME = "4191">IsGloballySplit(C, l) : , UserProgram -&gt; BoolElt, UserProgram</A></H5>

<PRE>    Sub: GrpPerm                        Default: <TT>false</TT></PRE>

<PRE>    SetVerbose("Cohomology", n):        Maximum: 2</PRE>
<BLOCKQUOTE>
For a cohomology process C as created by 
<A  HREF = "text402.htm#RngOrd:SUnitCohomologyProcess">SUnitCohomologyProcess</A> and a 2-cocyle l:U x U to k
given as a Magma-function, decide if l is split, ie. if there
exists a 1-cochain m:U to k such that &delta; m = l
for the cohomological coboundary map &delta;.
If <TT>Sub</TT> is given it has to be a subgroup of the automorphism group
of the number field underlying the cohomology process, otherwise the 
full automorphism group is used. This allows to restrict a cocyle easily.
<P>
As a fixed cocyle l assumes only finitely many values, we can 
consider it as a cocyle with values in some suitable S-unit group.
Similarly, it is exists, m also has values in some S'-unit group
for a potentially larger set S'. This function first tries
to "remove" ideals from the support of l, to make the set S as small
as possible. Then the set is enlarged to make sure that m, if exists,
can be found with values in the S'=S-unit group. Since the final
problem now involves only finitely generated abelian groups, it can 
be solved by Magma's general cohomology machinery.
</BLOCKQUOTE>
<H5><A NAME = "4192">IsSplitAsIdealAt(I, l) : RngOrdFracIdl, UserProgram -&gt; BoolElt, UserProgram, [RngOrdIdl]</A></H5>

<PRE>    Sub: GrpPerm                        Default: <TT>false</TT></PRE>
<BLOCKQUOTE>
Let U be a subgroup of the automorphism group G of some number
field k, l:U x U to k<sup> * </sup> a 2-cocyle and I some ideal in k.
If <TT>Sub</TT> is given, U is taken to be <TT>Sub</TT>, otherwise U := G.
Assuming that each element l(u, v) has a valuation at all ideals in 
the U-orbit of I, ie.
we have a unique decomposition of ideals l(u, v) = J<sup>x(u, v)</sup> A(u, v)
for integers x(u, v) and ideals A(u, v) coprime to J for all J in 
I<sup>U</sup>.
Then we can use l to define a cocyle with values in I<sup>U</sup> which is 
a finitely generated group. This function determines if this cocycle
splits, and if so, computes a 1-cochain with values in I<sup>U</sup> for some
fixed ordering of I<sup>U</sup>. The cochain and I<sup>U</sup> are returned on success.
</BLOCKQUOTE>
<PRE></PRE> <A  HREF = "text397.htm">[Next]</A><A  HREF = "text401.htm">[Prev]</A> <A  HREF = "text397.htm">[Right]</A> <A  HREF = "text401.htm">[Left]</A> <A  HREF = "text398.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<br><small>Version: V2.22 of <I>
Thu Jun  9 16:37:49 EST 2016
</I></small>
</body></html>