<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <link rel='stylesheet' href='help.css' type='text/css'>
  <TITLE>Creating Sequences</TITLE>
</head>
<body BGCOLOR="#FFFFFF">

 <A  HREF = "text99.htm">[Next]</A><A  HREF = "text97.htm">[Prev]</A> <A  HREF = "text99.htm">[Right]</A> <A  HREF = "text97.htm">[Left]</A> <A  HREF = "text96.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<PRE></PRE><H3><A NAME = "741">Creating Sequences</A></H3>

<P>
<P>
Square brackets are used for the definition of enumerated sequences;
formal sequences are delimited by the composite brackets <TT>[!</TT>
and <TT>!]</TT>.
<P>
Certain expressions appearing below
(possibly with subscripts) have the standard interpretation:
<DL COMPACT class='compact'>
<DT>U</DT><DD>the universe: any Magma  structure;
<DT>E</DT><DD>the range set for enumerated sequences:
any enumerated structure (it must be possible to loop over
its elements -- see the Introduction to this Part);
<DT>F</DT><DD>the range set for formal sequences:
any structure for which membership testing using <TT>in</TT>
is defined -- see the Introduction to this Part);
<DT>x</DT><DD>a free variable which successively takes the
elements of E (or F in the formal case) as its values;
<DT>P</DT><DD>a Boolean expression that usually involves the
variable(s) x, x<sub>1</sub>, ..., x<sub>k</sub>;
<DT>e</DT><DD>an expression that also usually involves the
variable(s) x, x<sub>1</sub>, ..., x<sub>k</sub>.</DL>



<H5>Subsections</H5>
<UL>
<LI> <A  HREF = "text98.htm#742">The Formal Sequence Constructor</A>
<LI> <A  HREF = "text98.htm#744">The Enumerated Sequence Constructor</A>
<LI> <A  HREF = "text98.htm#753">The Arithmetic Progression Constructors</A>
<LI> <A  HREF = "text98.htm#757">Literal Sequences</A>
</UL>
<H4><A NAME = "742">The Formal Sequence Constructor</A></H4>

<P>
<P>
The formal sequence constructor has the following fixed format (the
expressions appearing in the construct are defined above):


<H5><A NAME = "743">[! x in F | P(x) !]</A></H5>
<BLOCKQUOTE>
Create the formal sequence consisting of the subsequence of elements
x of F for which P(x) is true.
If P(x) is true for every element of F, the sequence
constructor may be abbreviated to
<TT>[! x in F !] </TT>
</BLOCKQUOTE>
<H4><A NAME = "744">The Enumerated Sequence Constructor</A></H4>

<P>
<P>
Sequences can be constructed by expressions enclosed in square brackets,
provided that the values of all expressions can be automatically
coerced into some common structure, as outlined in the Introduction.
All general constructors have the universe U optionally up front, 
which allows the user to specify into which structure
all terms of the sequences should be coerced.


<H5><A NAME = "745">[ ] : Null -&gt; ESeqEnum</A></H5>
<BLOCKQUOTE>
The null sequence (empty, and no universe specified).
</BLOCKQUOTE>
<H5><A NAME = "746">[ U | ] : Str -&gt; SeqEnum</A></H5>
<BLOCKQUOTE>
The empty sequence with universe U.
</BLOCKQUOTE>
<H5><A NAME = "747">[ e<sub>1</sub>, e<sub>2</sub>, ..., e<sub>n</sub> ] : Elt, ..., Elt -&gt; SeqEnum</A></H5>
<BLOCKQUOTE>
Given a list of expressions e<sub>1</sub>, ..., e<sub>n</sub>, defining elements 
a<sub>1</sub>, a<sub>2</sub>, ..., a<sub>n</sub> all belonging to (or automatically
coercible into) a single algebraic structure U, create the sequence
Q = [ a<sub>1</sub>, a<sub>2</sub>, ..., a<sub>n</sub> ] of elements of U.
<P>
As for multisets, one may use the expression <TT>x^^ n</TT> to
specify the object x with multiplicity n: this is simply interpreted
to mean x repeated n times (i.e., no internal compaction of the
repetition is done). 
</BLOCKQUOTE>
<H5><A NAME = "748">[ U |  e<sub>1</sub>, e<sub>2</sub>, ..., e<sub>m</sub> ] : Str, Elt, ..., Elt -&gt; SeqEnum</A></H5>
<BLOCKQUOTE>
Given a list of expressions e<sub>1</sub>, ..., e<sub>m</sub>, which define elements 
a<sub>1</sub>, a<sub>2</sub>, ..., a<sub>n</sub> that are all 
coercible into U, create the sequence
Q = [ a<sub>1</sub>, a<sub>2</sub>, ..., a<sub>n</sub> ] of elements of U.
<P>
</BLOCKQUOTE>
<H5><A NAME = "749">[ e(x) : x in E | P(x) ]</A></H5>
<BLOCKQUOTE>
Form the sequence of elements e(x), all belonging to some common
structure, for those x &isin;E
with the property that the predicate P(x) is true. The
expressions appearing in this construct have the interpretation
given at the beginning of this section.
<P>
If P(x) is true for every element of E, the sequence constructor 
may be abbreviated to <TT>[ e(x) : x in E ] </TT>.
</BLOCKQUOTE>
<H5><A NAME = "750">[ U |  e(x) : x in E | P(x) ]</A></H5>
<BLOCKQUOTE>
Form the sequence of elements of U consisting of the values e(x)
for those x&isin;E for which the predicate P(x) is true (an error
results if not all e(x) are coercible into U). The
expressions appearing in this construct have the same
interpretation as above.
</BLOCKQUOTE>
<H5><A NAME = "751">[ e(x<sub>1</sub>,...,x<sub>k</sub>) : x<sub>1</sub> in E<sub>1</sub>, ..., x<sub>k</sub>in E<sub>k</sub> | P(x<sub>1</sub>, ..., x<sub>k</sub>) ]</A></H5>
<BLOCKQUOTE>
The sequence consisting of those elements e(x<sub>1</sub>, ..., x<sub>k</sub>),
in some common structure, for which x<sub>1</sub>, ..., x<sub>k</sub>
in E<sub>1</sub>, ..., E<sub>k</sub> have the property that
P(x<sub>1</sub>, ..., x<sub>k</sub>) is true.
<P>
The expressions appearing in this construct have the
interpretation given at the beginning of this section.
<P>
Note that if two successive ranges E<sub>i</sub> and E<sub>i + 1</sub> are identical, 
then the specification of the ranges for x<sub>i</sub> and x<sub>i + 1</sub> may be 
abbreviated to <TT>x<sub>i</sub>, x<sub>i + 1</sub> in E<sub>i</sub></TT>.
<P>
Also, if P(x<sub>1</sub>, ..., x<sub>k</sub>) is always true, it may be omitted.
</BLOCKQUOTE>
<H5><A NAME = "752">[ U | e(x<sub>1</sub>,...,x<sub>k</sub>) : x<sub>1</sub> in E<sub>1</sub>, ...,x<sub>k</sub> in E<sub>k</sub> | P(x<sub>1</sub>, ..., x<sub>k</sub>) ]</A></H5>
<BLOCKQUOTE>
As in the previous entry, the sequence consisting of those elements
e(x<sub>1</sub>, ..., x<sub>k</sub>) for which P(x<sub>1</sub>, ..., x<sub>k</sub>) is true is formed,
as a sequence of elements of U (an error occurs if not all 
e(x<sub>1</sub>, ..., x<sub>k</sub>) are coercible into U).
<P>
</BLOCKQUOTE>
<H4><A NAME = "753">The Arithmetic Progression Constructors</A></H4>

<P>
<P>
Since enumerated sequences of integers arise so often, there are a few special
constructors to create and handle them efficiently
in case the entries are in arithmetic progression.
The universe must be the ring of integers.
Some effort is made to preserve the special way of storing arithmetic
progressions under sequence operations.


<H5><A NAME = "754">[ i..j ] : RngIntElt, RngIntElt -&gt; SeqEnum</A></H5>
<H5>[ U | i..j ] : Str, RngIntElt, RngIntElt -&gt; SeqEnum</H5>
<BLOCKQUOTE>
The enumerated sequence of integers whose elements form the arithmetic progression
i, i + 1, i + 2, ..., j, where i and j are (expressions defining)
arbitrary integers. If j 
is less than i then the empty sequence of integers will be created.
<P>
The universe U, if it is specified, has to be the ring of integers;
any other universe will lead to an error.
<P>
</BLOCKQUOTE>
<H5><A NAME = "755">[ i .. j by k ] : RngIntElt, RngIntElt, RngIntElt -&gt; SeqEnum</A></H5>
<H5>[ U | i .. j by k ] : Str, RngIntElt, RngIntElt, RngIntElt -&gt; SeqEnum</H5>
<BLOCKQUOTE>
The enumerated sequence consisting of the integers forming the arithmetic
progression i, i + k, i + 2 * k, ..., j, where i, j and k 
are (expressions defining) arbitrary integers (but k&ne;0).
<P>
If k is positive then the last element in the progression will be 
the greatest integer of the form i + n * k that is less than or equal 
to j; if j is less than i, the empty sequence of integers
will be constructed.
<P>
If k is negative then the last element in the progression will be 
the least integer of the form i + n * k that is greater than or equal 
to j; if j is greater than i, the empty sequence of integers
will be constructed.
<P>
The universe U, if it is specified, has to be the ring of integers;
any other universe will lead to an error.
<P>
</BLOCKQUOTE>
<HR>
<H3><A NAME = "756">Example <TT>Seq_Progression (H10E1)</TT></A></H3>
As in the case of sets, it is possible to use the arithmetic progression
constructors to save some typing in the creation of sequences
of elements of rings other than the ring of integers, but the result will
not be treated especially efficiently.
<P>
<P>
<PRE>
&gt; s := [ IntegerRing(200) | x : x in [ 25..125 ] ];
</PRE>
<HR>
<H4><A NAME = "757">Literal Sequences</A></H4>

<P>
<P>
A literal sequence is an enumerated sequence all of whose terms are
from the same structure and all of these are `typed in' literally.
The sole purpose of literal sequences is to load certain enumerated
sequences very fast and very space-efficiently;
this is only useful when reading in very large
sequences (all of whose elements must have been specified literally, that
is, not as some expression other than a literal), but then it may save
a lot of time. The result will be an enumerated sequence, that is,
not distinguished in any way from other such sequences.
<P>
At present, only literal sequences of integers are supported.


<H5><A NAME = "758">\[ m<sub>1</sub>, ..., m<sub>n</sub> ] : RngIntElt, ..., RngIntElt -&gt; [ RngIntElt ]</A></H5>
<BLOCKQUOTE>
Given a succession of literal integers m<sub>1</sub>, ..., m<sub>n</sub>, build the
enumerated sequence [m<sub>1</sub>, ..., m<sub>n</sub>], in a time and space
efficient way.
</BLOCKQUOTE>
<PRE></PRE> <A  HREF = "text99.htm">[Next]</A><A  HREF = "text97.htm">[Prev]</A> <A  HREF = "text99.htm">[Right]</A> <A  HREF = "text97.htm">[Left]</A> <A  HREF = "text96.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<br><small>Version: V2.22 of <I>
Thu Jun  9 16:37:49 EST 2016
</I></small>
</body></html>