<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <link rel='stylesheet' href='help.css' type='text/css'>
  <TITLE>Predicates on Sequences</TITLE>
</head>
<body BGCOLOR="#FFFFFF">

 <A  HREF = "text102.htm">[Next]</A><A  HREF = "text100.htm">[Prev]</A> <A  HREF = "text102.htm">[Right]</A> <A  HREF = "text100.htm">[Left]</A> <A  HREF = "text96.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<PRE></PRE><H3><A NAME = "809">Predicates on Sequences</A></H3>

<P>
<P>
Boolean valued operators and functions on enumerated sequences exist to
test whether entries are defined (see previous section), to test
for membership and containment, and to compare sequences with
respect to an ordering on its entries.
On formal sequences, only element membership can be tested.



<H5>Subsections</H5>
<UL>
<LI> <A  HREF = "text101.htm#814">Membership Testing</A>
<LI> <A  HREF = "text101.htm#820">Testing Order Relations</A>
</UL>
<H5><A NAME = "810">IsComplete(S) : SeqEnum -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Boolean valued function, returning
<TT>true</TT> if and only if each of the terms S[i] for 1&le;i&le;#S
is defined, for an enumerated sequence S.
</BLOCKQUOTE>
<H5><A NAME = "811">IsDefined(S, i) : SeqEnum, RngIntElt -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Given an enumerated sequence S and an index i, this returns <TT>true</TT> if
and only if S[i] is defined. (Hence the result is <TT>false</TT>
if i&gt;#S, but an error results if i&lt;1.) Note that the
index i is allowed to be a multi-index; if i=[i<sub>1</sub>, ..., i<sub>r</sub>]
is a multi-index and i<sub>j</sub>&gt;#S[i<sub>1</sub>, ..., i<sub>j - 1</sub>] the function
returns false, but if S is s levels deep and r&gt;s while
i<sub>j</sub>&le;#S[i<sub>1</sub>, ..., i<sub>j - 1</sub>] for 1&le;j&le;s, then an error
occurs.
</BLOCKQUOTE>
<H5><A NAME = "812">IsEmpty(S) : SeqEnum -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Boolean valued function, returning
<TT>true</TT> if and only if the enumerated sequence S is empty.
</BLOCKQUOTE>
<H5><A NAME = "813">IsNull(S) : SeqEnum -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Boolean valued function, returning
<TT>true</TT> if and only if the enumerated sequence S is empty and
its universe is undefined, <TT>false</TT> otherwise.
</BLOCKQUOTE>
<H4><A NAME = "814">Membership Testing</A></H4>

<P>
<P>
Here, S and T denote sequences.
The element x is always assumed to be compatible with S.


<H5><A NAME = "815">x in S : Elt, SeqEnum -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if the object x occurs as a term of the enumerated or
formal sequence S, <TT>false</TT> otherwise.
If x is not in the universe of S, coercion is attempted. If that
fails, an error results.
</BLOCKQUOTE>
<H5><A NAME = "816">x notin S : Elt, SeqEnum -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if the object x does not occur as a term of the enumerated or
formal sequence S, <TT>false</TT> otherwise.
If x is not in the universe of S, coercion is attempted. If that
fails, an error results.
</BLOCKQUOTE>
<H5><A NAME = "817">IsSubsequence(S, T) : SeqEnum, SeqEnum -&gt; BoolElt</A></H5>
<H5>IsSubsequence(S, T: Kind := option) : SeqEnum, SeqEnum, MonStgElt -&gt; BoolElt</H5>

<PRE>    Kind: MonStgElt                     Default: "Consecutive"</PRE>
<BLOCKQUOTE>
Returns <TT>true</TT> if the enumerated sequence S appears as a
subsequence of consecutive elements of
the enumerated sequence T, <TT>false</TT> otherwise.
<P>
By changing the default value <TT>"Consecutive"</TT> of the parameter <TT>Kind</TT>
to <TT>"Sequential"</TT> or to <TT>"Setwise"</TT>, this returns <TT>true</TT> if and
only if the elements of S appear in order (but not necessarily
consecutively) in T, or if and only if all elements of S appear
as elements of T; so in the latter case the test is merely whether
the set of elements of S is contained in the set of elements of T.
<P>
If the universes of S and T are not the same, coercion is
attempted.
</BLOCKQUOTE>
<H5><A NAME = "818">S eq T : SeqEnum, SeqEnum -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if the enumerated sequences S and T are equal, <TT>false</TT> otherwise.
If the universes of S and T are not the same, coercion is
attempted.
</BLOCKQUOTE>
<H5><A NAME = "819">S ne T : SeqEnum, SeqEnum -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if the enumerated sequences S and T are not equal, <TT>false</TT> otherwise.
If the universes of S and T are not the same, coercion is
attempted.
</BLOCKQUOTE>
<H4><A NAME = "820">Testing Order Relations</A></H4>

<P>
<P>
Here, S and T denote complete enumerated sequences
with universe U and V respectively, such that a common overstructure W
for U and V can be found (as outlined in the Introduction), and such that
on W an ordering on the elements is defined allowing
the Magma operators <TT>eq</TT> (=), <TT>le</TT> (&le;), <TT>lt</TT> (&lt;), <TT>gt</TT>
(&gt;), and <TT>ge</TT> (&ge;) to be invoked on its elements.
<P>
<P>
With these comparison operators the <I>lexicographical</I> ordering
is used to order complete enumerated sequences. Sequences S and T
are equal (<TT>S eq T</TT>) if and only if they have the same length and all terms
are the same.  A sequence S precedes T (<TT>S lt T</TT>) in the ordering
imposed by that of the terms
if at the first index i where S and T differ then
S[i] &lt; T[i]. If the length of T exceeds that of S and S and
T agree in all places where S until after the length of S,
then <TT>S lt T</TT> is true also. In all
other cases where S&ne;T one has <TT>S gt T</TT>.


<H5><A NAME = "821">S lt T : SeqEnum, SeqEnum -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if the sequence S precedes the sequence T under the ordering 
induced from S, <TT>false</TT> otherwise.
Thus, <TT>true</TT> is returned if and only if either
S[k] &lt; T[k] and S[i] = T[i] (for 1&le;i&lt; k) for some k,
or S[i] = T[i] for 1&le;i&le;#S and #S &lt; #T.
</BLOCKQUOTE>
<H5><A NAME = "822">S le T : SeqEnum, SeqEnum -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if the sequence S either precedes the sequence T, under the 
ordering induced from S, or is equal to T, <TT>false</TT> otherwise.
Thus, <TT>true</TT> is returned if and only if either
S[k] &lt; T[k] and S[i] = T[i] (for 1&le;i&lt; k) for some k,
or S[i] = T[i] for 1&le;i&le;#S and #S&le;#T.
</BLOCKQUOTE>
<H5><A NAME = "823">S ge T : SeqEnum, SeqEnum -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if the sequence S either comes after the sequence T, under the 
ordering induced from S, or is equal to T, <TT>false</TT> otherwise.
Thus, <TT>true</TT> is returned if and only if either
S[k] &gt; T[k] and S[i] = T[i] (for 1&le;i&lt; k) for some k,
or S[i] = T[i] for 1&le;i&le;#T and #S&ge;#T.
</BLOCKQUOTE>
<H5><A NAME = "824">S gt T : SeqEnum, SeqEnum -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if the sequence S comes after the sequence T under the 
ordering induced from S, <TT>false</TT> otherwise.
Thus, <TT>true</TT> is returned if and only if either
S[k] &gt; T[k] and S[i] = T[i] (for 1&le;i&lt; k) for some k,
or S[i] = T[i] for 1&le;i&le;#T and #S &gt; #T.
</BLOCKQUOTE>
<PRE></PRE> <A  HREF = "text102.htm">[Next]</A><A  HREF = "text100.htm">[Prev]</A> <A  HREF = "text102.htm">[Right]</A> <A  HREF = "text100.htm">[Left]</A> <A  HREF = "text96.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<br><small>Version: V2.22 of <I>
Thu Jun  9 16:37:49 EST 2016
</I></small>
</body></html>