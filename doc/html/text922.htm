<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <link rel='stylesheet' href='help.css' type='text/css'>
  <TITLE>Ideals of Orders</TITLE>
</head>
<body BGCOLOR="#FFFFFF">

 <A  HREF = "text915.htm">[Next]</A><A  HREF = "text921.htm">[Prev]</A> <A  HREF = "text915.htm">[Right]</A> <A  HREF = "text921.htm">[Left]</A> <A  HREF = "text916.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<PRE></PRE><H3><A NAME = "10442">Ideals of Orders</A></H3>




<H5>Subsections</H5>
<UL>
<LI> <A  HREF = "text922.htm#10443">Construction of Ideals</A>
<LI> <A  HREF = "text922.htm#10447">Attributes of Ideals</A>
<LI> <A  HREF = "text922.htm#10451">Bases of Ideals</A>
<LI> <A  HREF = "text922.htm#10460">Arithmetic for Ideals</A>
<LI> <A  HREF = "text922.htm#10466">Predicates on Ideals</A>
<LI> <A  HREF = "text922.htm#10471">Other Operations on Ideals</A>
</UL>
<H4><A NAME = "10443">Construction of Ideals</A></H4>



<H5><A NAME = "10444">lideal&lt;O | E&gt; : AlgAssVOrd, [AlgAssVOrdElt] -&gt; AlgAssVOrdIdl</A></H5>
<H5>rideal&lt;O | E&gt; : AlgAssVOrd, [AlgAssVOrdElt] -&gt; AlgAssVOrdIdl</H5>
<H5>ideal&lt;O | E&gt; : AlgAssVOrd, [AlgAssVOrdElt] -&gt; AlgAssVOrdIdl</H5>
<BLOCKQUOTE>
For an associative order O, this constructs the left, right 
or two sided O-ideal generated by the elements in the given
sequence E (these elements should be coercible into O).
</BLOCKQUOTE>
<H5><A NAME = "10445">lideal&lt;O | M&gt; : AlgAssVOrd, PMat -&gt; AlgAssVOrdIdl</A></H5>
<H5>lideal&lt;O | M&gt; : AlgAssVOrd, Mtrx -&gt; AlgAssVOrdIdl</H5>
<H5>rideal&lt;O | M&gt; : AlgAssVOrd, PMat -&gt; AlgAssVOrdIdl</H5>
<H5>rideal&lt;O | M&gt; : AlgAssVOrd, Mtrx -&gt; AlgAssVOrdIdl</H5>
<H5>ideal&lt;O | M&gt; : AlgAssVOrd, PMat -&gt; AlgAssVOrdIdl</H5>
<H5>ideal&lt;O | M&gt; : AlgAssVOrd, Mtrx -&gt; AlgAssVOrdIdl</H5>
<BLOCKQUOTE>
Constructs a left, right or two sided ideal of the associative order O whose 
basis is given by M, which may be either a matrix or a pseudo matrix.
</BLOCKQUOTE>
<H5><A NAME = "10446">O * e : AlgAssVOrd, RngElt -&gt; AlgAssVOrdIdl</A></H5>
<H5>e * O : RngElt, AlgAssVOrd -&gt; AlgAssVOrdIdl</H5>
<BLOCKQUOTE>
The principal left (right) ideal of the associative order O generated by the 
element e.
</BLOCKQUOTE>
<H4><A NAME = "10447">Attributes of Ideals</A></H4>

<P>
<P>
In this section, I is an ideal of some order in an associative algebra.


<H5><A NAME = "10448">Order(I) : AlgAssVOrdIdl -&gt; AlgAssVOrd</A></H5>
<BLOCKQUOTE>
For an ideal I created as an ideal of an order O, this returns O.
</BLOCKQUOTE>
<H5><A NAME = "10449">Algebra(I) : AlgAssVOrdIdl -&gt; AlgAssV</A></H5>
<BLOCKQUOTE>
This returns <TT>Algebra(Order(I))</TT>.
</BLOCKQUOTE>
<H5><A NAME = "10450">LeftOrder(I) : AlgAssVOrdIdl -&gt; AlgAssVOrd</A></H5>
<H5>RightOrder(I) : AlgAssVOrdIdl -&gt; AlgAssVOrd</H5>
<BLOCKQUOTE>
For an ideal I, this returns the (full) order in <TT>Algebra(I)</TT>
which stabilizes I under multiplication on the left or right respectively.
Explicitly, the left order of I is defined as { x : x I &sube;I }.
</BLOCKQUOTE>
<H4><A NAME = "10451">Bases of Ideals</A></H4>

<P>
<P>
In this section, I is an ideal of an order O in an associative algebra.


<H5><A NAME = "10452">Denominator(I) : AlgAssVOrdIdl -&gt; RngElt</A></H5>
<BLOCKQUOTE>
This returns an element d of <TT>BaseRing(O)</TT> such that d I &sube;O,
where O is <TT>Order(I)</TT>.
</BLOCKQUOTE>
<H5><A NAME = "10453">PseudoBasis(I) : AlgAssVOrdIdl[RngOrd] -&gt; SeqEnum</A></H5>
<BLOCKQUOTE>
Given an ideal I of an order over R, where R is an order in a number field,
this returns data describing I as an R-module.  It returns a sequence of tuples
&lt; I<sub>i</sub>, b<sub>i</sub> &gt; where I<sub>i</sub> is an ideal of R and b<sub>i</sub> is an element of
<TT>Algebra(I)</TT>, such that I is the direct sum of the R-modules I<sub>i</sub> b<sub>i</sub>.
In particular, the b<sub>i</sub> form a basis of <TT>Algebra(I)</TT> as a vector space over
the field of fractions of R.  Note that the b<sub>i</sub> may not lie in I.
</BLOCKQUOTE>
<H5><A NAME = "10454">PseudoMatrix(I) : AlgAssVOrdIdl[RngOrd] -&gt; PMat</A></H5>
<H5>PseudoMatrix(I) : AlgAssVOrdIdl[RngFunOrd] -&gt; PMat</H5>
<BLOCKQUOTE>
Returns the pseudomatrix corresponding to <TT>PseudoBasis(I)</TT>.
</BLOCKQUOTE>
<H5><A NAME = "10455">Basis(I) : AlgAssVOrdIdl -&gt; SeqEnum</A></H5>
<BLOCKQUOTE>
When I is an ideal of an order over Z, this returns a Z-module basis of I.
<P>
When the base ring of <TT>Order(I)</TT> is an extension of Z, this returns part of
the data returned by <TT>PseudoBasis(I)</TT>: it returns a basis of <TT>Algebra(I)</TT>.
Note that this determines nothing about I, while the full data returned by
<TT>PseudoBasis(I)</TT> determines I.
</BLOCKQUOTE>
<H5><A NAME = "10456">BasisMatrix(I) : AlgAssVOrdIdl -&gt; AlgMatElt</A></H5>
<BLOCKQUOTE>
This returns <TT>Basis(I)</TT> as a row matrix.
</BLOCKQUOTE>
<H5><A NAME = "10457">ZBasis(I) : AlgAssVOrdIdl[RngOrd] -&gt; [AlgAssVOrdElt]</A></H5>
<BLOCKQUOTE>
Returns a Z-module basis for the ideal I.
</BLOCKQUOTE>
<H5><A NAME = "10458">Generators(I) : AlgAssVOrdIdl[RngOrd] -&gt; [AlgAssVOrdElt]</A></H5>
<BLOCKQUOTE>
Returns a sequence of generators for the ideal I as a module over its base ring.
</BLOCKQUOTE>
<H5><A NAME = "10459">PseudoBasis(I, R) : AlgAssVOrdIdl[RngOrd], Str -&gt; SeqEnum</A></H5>
<H5>PseudoMatrix(I, R) : AlgAssVOrdIdl[RngOrd], Str -&gt; PMat</H5>
<H5>Basis(I, R) : AlgAssVOrdIdl, Str -&gt; SeqEnum</H5>
<H5>BasisMatrix(I, R) : AlgAssVOrdIdl, Str -&gt; AlgMatElt</H5>
<BLOCKQUOTE>
In these variants of the functions described above, the elements of the basis are expressed 
with respect to the basis of R, where R is some ring contained in A =  <TT>Algebra(I)</TT>
such that R tensor F eq A where F is the base field of A.
</BLOCKQUOTE>
<H4><A NAME = "10460">Arithmetic for Ideals</A></H4>



<H5><A NAME = "10461">I + J : AlgAssVOrdIdl, AlgAssVOrdIdl -&gt; AlgAssVOrdIdl</A></H5>
<BLOCKQUOTE>
The sum of the ideals I and J, which are ideals which share a side
in equal orders.
</BLOCKQUOTE>
<H5><A NAME = "10462">I * J: AlgAssVOrdIdl, AlgAssVOrdIdl -&gt; AlgAssVOrdIdl, AlgAssVOrdIdl</A></H5>
<H5>I * J: AlgAssVOrdIdl[RngOrd], AlgAssVOrdIdl[RngOrd] -&gt; AlgAssVOrdIdl, AlgAssVOrdIdl</H5>
<BLOCKQUOTE>
The product of the ideals I and J, where I is a right ideal
and J is a left ideal of the same order O.  Returns the product
given the structure of left and right ideal.
</BLOCKQUOTE>
<H5><A NAME = "10463">a * I: RngElt, AlgAssVOrdIdl -&gt; AlgAssVOrdIdl</A></H5>
<H5>I * a: AlgAssVOrdIdl, RngElt -&gt; AlgAssVOrdIdl</H5>
<BLOCKQUOTE>
Returns the product of a and I as an ideal.
</BLOCKQUOTE>
<H5><A NAME = "10464">Colon(J, I): AlgAssVOrdIdl[RngOrd], AlgAssVOrdIdl[RngOrd] -&gt; PMat</A></H5>
<BLOCKQUOTE>
If I, J are left ideals, returns the colon 
(J:I)={x &isin;A: xI &sub;J}, similarly defined if I, J
are right ideals.
</BLOCKQUOTE>
<H5><A NAME = "10465">MultiplicatorRing(I): AlgAssVOrdIdl -&gt; AlgAssVOrd</A></H5>
<BLOCKQUOTE>
Returns the colon (I:I) of the ideal I, the set of all elements
which multiply I into I.
</BLOCKQUOTE>
<H4><A NAME = "10466">Predicates on Ideals</A></H4>



<H5><A NAME = "10467">IsLeftIdeal(I) : AlgAssVOrdIdl -&gt; BoolElt</A></H5>
<H5>IsRightIdeal(I) : AlgAssVOrdIdl -&gt; BoolElt</H5>
<H5>IsTwoSidedIdeal(I) : AlgAssVOrdIdl -&gt; BoolElt</H5>
<BLOCKQUOTE>
Return <TT>true</TT> if the associative ideal I is a left, right or two sided ideal
(respectively).
</BLOCKQUOTE>
<H5><A NAME = "10468">I eq J : AlgAssVOrdIdl, AlgAssVOrdIdl -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Return <TT>true</TT> if the associative ideals I and J are equal.
</BLOCKQUOTE>
<H5><A NAME = "10469">I subset J : AlgAssVOrdIdl, AlgAssVOrdIdl -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if and only if the ideal I is contained in the 
ideal J.
</BLOCKQUOTE>
<H5><A NAME = "10470">a in I : AlgAssVElt, AlgAssVOrdIdl -&gt; BoolElt</A></H5>
<H5>a notin I : AlgAssVElt, AlgAssVOrdIdl -&gt; BoolElt</H5>
<BLOCKQUOTE>
Return <TT>true</TT> (<TT>false</TT>) if the element a of an associative algebra is 
contained in the associative ideal I.
</BLOCKQUOTE>
<H4><A NAME = "10471">Other Operations on Ideals</A></H4>



<H5><A NAME = "10472">Norm(I) : AlgAssVOrdIdl[RngOrd] -&gt; RngOrdIdl</A></H5>
<BLOCKQUOTE>
Returns the norm of the ideal I, the ideal of the base number ring of
I generated by the norms of the elements in I.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "10473">Example <TT>AlgAss_sumandadjoin (H86E12)</TT></A></H3>
<P>
<P>
<PRE>

&gt; F&lt;w&gt; := CyclotomicField(3);
&gt; R := MaximalOrder(F);
&gt; A := Algebra(FPAlgebra&lt;F, x, y | x^3-3, y^3+5, y*x-w*x*y&gt;);
&gt; O := Order([A.i : i in [1..9]]);
&gt; MinimalPolynomial(O.2);
$.1^3 + 5/1*R.1
&gt; I := rideal&lt;O | O.2&gt;;
&gt; IsLeftIdeal(I), IsRightIdeal(I), IsTwoSidedIdeal(I);
false true false
&gt; MultiplicatorRing(I) eq O;
true
&gt; PseudoBasis(I);
[
    &lt;Principal Ideal of R
    Generator:
        R.1, (0 R.1 0 0 0 0 0 0 0)&gt;,
    &lt;Principal Ideal of R
    Generator:
        R.1, (0 0 0 R.1 0 0 0 0 0)&gt;,
    &lt;Principal Ideal of R
    Generator:
        R.1, (0 0 0 0 -R.1 - R.2 0 0 0 0)&gt;,
    &lt;Principal Ideal of R
    Generator:
        R.1, (-5/1*R.1 0 0 0 0 0 0 0 0)&gt;,
    &lt;Principal Ideal of R
    Generator:
        R.1, (0 0 0 0 0 0 -R.1 - R.2 0 0)&gt;,
    &lt;Principal Ideal of R
    Generator:
        R.1, (0 0 0 0 0 0 0 R.2 0)&gt;,
    &lt;Principal Ideal of R
    Generator:
        R.1, (0 0 5/1*R.1 + 5/1*R.2 0 0 0 0 0 0)&gt;,
    &lt;Principal Ideal of R
    Generator:
        R.1, (0 0 0 0 0 0 0 0 R.2)&gt;,
    &lt;Principal Ideal of R
    Generator:
        R.1, (0 0 0 0 0 -5/1*R.2 0 0 0)&gt;
]
&gt; ZBasis(I);
[ [0 R.1 0 0 0 0 0 0 0], [0 R.2 0 0 0 0 0 0 0], [0 0 0 R.1 0 0 0 0 0], [0 0 0
    R.2 0 0 0 0 0], [0 0 0 0 -R.1 - R.2 0 0 0 0], [0 0 0 0 R.1 0 0 0 0],
    [-5/1*R.1 0 0 0 0 0 0 0 0], [-5/1*R.2 0 0 0 0 0 0 0 0] ]
&gt; Norm(I);
Principal Ideal of R
Generator:
    15625/1*R.1
&gt; J := rideal&lt;O | O.3&gt;;
&gt; Norm(J);
Principal Ideal of R
Generator:
    729/1*R.1
&gt; A!1 in I+J;
false
&gt; Denominator(1/6*I);
[1, 0]
&gt; Colon(J,I);
Pseudo-matrix over Maximal Equation Order with defining polynomial x^2 + x + 1
over its ground order
Principal Ideal of R
Generator:
    3/1*R.1 * ( R.1 0 0 0 0 0 0 0 0 )
Principal Ideal of R
Generator:
    3/1*R.1 * ( 0 R.1 0 0 0 0 0 0 0 )
Principal Ideal of R
Generator:
    R.1 * ( 0 0 R.1 0 0 0 0 0 0 )
Fractional Principal Ideal of R
Generator:
    3/5*R.1 * ( 0 0 0 R.1 0 0 0 0 0 )
Principal Ideal of R
Generator:
    R.1 * ( 0 0 0 0 R.1 0 0 0 0 )
Principal Ideal of R
Generator:
    R.1 * ( 0 0 0 0 0 R.1 0 0 0 )
Fractional Principal Ideal of R
Generator:
    -1/5*R.1 * ( 0 0 0 0 0 0 R.1 0 0 )
Principal Ideal of R
Generator:
    R.1 * ( 0 0 0 0 0 0 0 R.1 0 )
Fractional Principal Ideal of R
Generator:
    1/5*R.1 * ( 0 0 0 0 0 0 0 0 R.1 )
</PRE>
<PRE></PRE> <A  HREF = "text915.htm">[Next]</A><A  HREF = "text921.htm">[Prev]</A> <A  HREF = "text915.htm">[Right]</A> <A  HREF = "text921.htm">[Left]</A> <A  HREF = "text916.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<br><small>Version: V2.22 of <I>
Thu Jun  9 16:37:49 EST 2016
</I></small>
</body></html>