<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <link rel='stylesheet' href='help.css' type='text/css'>
  <TITLE>Operations on Codewords</TITLE>
</head>
<body BGCOLOR="#FFFFFF">

 <A  HREF = "text1836.htm">[Next]</A><A  HREF = "text1834.htm">[Prev]</A> <A  HREF = "text1836.htm">[Right]</A> <A  HREF = "text1834.htm">[Left]</A> <A  HREF = "text1831.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<PRE></PRE><H3><A NAME = "20364">Operations on Codewords</A></H3>




<H5>Subsections</H5>
<UL>
<LI> <A  HREF = "text1835.htm#20365">Construction of a Codeword</A>
<LI> <A  HREF = "text1835.htm#20370">Arithmetic Operations on Codewords</A>
<LI> <A  HREF = "text1835.htm#20377">Distance and Weight</A>
<LI> <A  HREF = "text1835.htm#20382">Vector Space and Related Operations</A>
<LI> <A  HREF = "text1835.htm#20391">Predicates for Codewords</A>
<LI> <A  HREF = "text1835.htm#20395">Accessing Components of a Codeword</A>
</UL>
<H4><A NAME = "20365">Construction of a Codeword</A></H4>



<H5><A NAME = "20366">C ! [a<sub>1</sub>, ..., a<sub>n</sub>] : Code, [ RngElt ] -&gt; ModTupRngElt</A></H5>
<H5>elt&lt; C | a<sub>1</sub>, ..., a<sub>n</sub>&gt; : Code, List -&gt; ModTupRngElt</H5>
<BLOCKQUOTE>
Given a code C which is defined as a subset of the
R-space R<sup>(n)</sup>, and elements a<sub>1</sub>, ..., a<sub>n</sub> belonging 
to R, construct the codeword (a<sub>1</sub>, ..., a<sub>n</sub>) of C.  
It is checked that the vector (a<sub>1</sub>, ..., a<sub>n</sub>) is an element of C.
</BLOCKQUOTE>
<H5><A NAME = "20367">C ! u : Code, ModTupRngElt -&gt; ModTupRngElt</A></H5>
<BLOCKQUOTE>
Given a code C which is defined as a subset of the R-space
V = R<sup>(n)</sup>, and an element u belonging to V,
create the codeword of C corresponding to u. The function
will fail if u does not belong to C.
</BLOCKQUOTE>
<H5><A NAME = "20368">C ! 0 : Code, RngIntElt -&gt; ModTupRngElt</A></H5>
<BLOCKQUOTE>
The zero word of the code C.
</BLOCKQUOTE>
<H5><A NAME = "20369">Random(C): Code -&gt; ModTupRngElt</A></H5>
<BLOCKQUOTE>
A random codeword of C.
</BLOCKQUOTE>
<H4><A NAME = "20370">Arithmetic Operations on Codewords</A></H4>



<H5><A NAME = "20371">u + v : ModTupRngElt, ModTupRngElt -&gt; ModTupRngElt</A></H5>
<BLOCKQUOTE>
Sum of the codewords u and v, where u and 
v belong to the same linear code C.
</BLOCKQUOTE>
<H5><A NAME = "20372">- u : ModTupRngElt -&gt; ModTupRngElt</A></H5>
<BLOCKQUOTE>
Additive inverse of the codeword u belonging
to the linear code C.
</BLOCKQUOTE>
<H5><A NAME = "20373">u - v : ModTupRngElt, ModTupRngElt -&gt; ModTupRngElt</A></H5>
<BLOCKQUOTE>
Difference of the codewords u and v, where 
u and v belong to the same linear code C.
</BLOCKQUOTE>
<H5><A NAME = "20374">a * u : RngElt, ModTupRngElt -&gt; ModTupRngElt</A></H5>
<BLOCKQUOTE>
Given an element a belonging to the field K, 
and a codeword u belonging to the linear code
C, return the codeword a * u.
</BLOCKQUOTE>
<H5><A NAME = "20375">Normalize(u) : ModTupRngElt -&gt; ModTupRngElt</A></H5>
<BLOCKQUOTE>
Given an element u over a field, not the zero element, belonging to 
the linear code C, return (1/a) * u, where a is 
the first non-zero component of u. If u is the zero vector, 
it is returned as the value of this function. The net effect 
is that <TT>Normalize(u)</TT> always returns a vector v in the 
subspace generated by u, such that the first non-zero 
component of v is the unit of K.
</BLOCKQUOTE>
<H5><A NAME = "20376">Syndrome(w, C) : ModTupFldElt, Code -&gt; ModTupFldElt</A></H5>
<BLOCKQUOTE>
Given an [n, k] linear code C over a finite field
with parent vector space V,
and a vector w belonging to V, construct the syndrome of w
relative to the code C. This will be an element of the
<I>syndrome space</I> of C.
</BLOCKQUOTE>
<H4><A NAME = "20377">Distance and Weight</A></H4>



<H5><A NAME = "20378">Distance(u, v) : ModTupRngElt, ModTupRngElt -&gt; RngIntElt</A></H5>
<BLOCKQUOTE>
The Hamming distance between the codewords u and v,
where u and v belong to the same code C.
</BLOCKQUOTE>
<H5><A NAME = "20379">Weight(u) : ModTupRngElt -&gt; RngIntElt</A></H5>
<BLOCKQUOTE>
The Hamming weight of the codeword u, i.e., the number of non-zero
components of u.
</BLOCKQUOTE>
<H5><A NAME = "20380">LeeWeight(u) : ModTupRngElt -&gt; RngIntElt</A></H5>
<BLOCKQUOTE>
The Lee weight of the codeword u.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "20381">Example <TT>CodeFld_Distance (H158E11)</TT></A></H3>
We calculate all possible distances between code words of the 
non-extended Golay code over GF(3), and show the correspondence with
all possible code word weights.
<P>
<P>
<PRE>
&gt; C := GolayCode(GF(3),false);
&gt; {Distance(v,w):v,w in C};
{ 0, 5, 6, 8, 9, 11 }
&gt; {Weight(v):v in C};  
{ 0, 5, 6, 8, 9, 11 }
</PRE>
<HR>
<H4><A NAME = "20382">Vector Space and Related Operations</A></H4>



<H5><A NAME = "20383">(u, v) : ModTupRngElt, ModTupRngElt -&gt; RngElt</A></H5>
<H5>InnerProduct(u, v) : ModTupRngElt, ModTupRngElt -&gt; RngElt</H5>
<BLOCKQUOTE>
Inner product of the vectors u and v with respect to 
the Euclidean norm, where u and v belong to the parent 
vector space of the code C.
</BLOCKQUOTE>
<H5><A NAME = "20384">Support(w) : ModTupRngElt -&gt; { RngIntElt }</A></H5>
<BLOCKQUOTE>
Given a word w belonging to the [n, k] code C, return its
support as a subset of the integer set { 1 .. n }.  The support of w
consists of the coordinates at which w has non-zero entries.
</BLOCKQUOTE>
<H5><A NAME = "20385">Coordinates(C, u) : Code, ModTupRngElt -&gt; [ RngFinElt ]</A></H5>
<BLOCKQUOTE>
Given an [n, k] linear code C and a codeword u of C return the
coordinates of u with respect to C.  The coordinates of u are returned
as a sequence Q = [a<sub>1</sub>, ..., a<sub>k</sub>] of elements from the alphabet of C
so that u = a<sub>1</sub> * C.1 + ... + a<sub>k</sub> * C.k.
</BLOCKQUOTE>
<H5><A NAME = "20386">Parent(w): ModTupRngElt -&gt; ModTupRng</A></H5>
<BLOCKQUOTE>
Given a word w belonging to the code C, return the
ambient space V of C.
</BLOCKQUOTE>
<H5><A NAME = "20387">Rotate(u, k) : ModTupRngElt, RngIntElt -&gt; ModTupRngElt</A></H5>
<BLOCKQUOTE>
Given a vector u, return the vector obtained from u by
cyclically shifting its components to the right by k coordinate 
positions.
</BLOCKQUOTE>
<H5><A NAME = "20388">Rotate(~u, k) : ModTupRngElt, RngIntElt -&gt;</A></H5>
<BLOCKQUOTE>
Given a vector u, destructively rotate u by k coordinate positions.
</BLOCKQUOTE>
<H5><A NAME = "20389">Trace(u, S) : ModTupFldElt, FldFin -&gt; ModTupFldElt</A></H5>
<H5>Trace(u) : ModTupFldElt -&gt; ModTupFldElt</H5>
<BLOCKQUOTE>
Given a vector u with components in K, and a subfield S of K,
construct the vector with components in S obtained from u by taking
the trace of each component with respect to S.  If S is omitted,
it is taken to be the prime field of K.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "20390">Example <TT>CodeFld_Coordinates (H158E12)</TT></A></H3>
We create a specific code word in the length 5 even weight code, 
after a failed attempt to create a code word of odd weight. We then
display its support, find its coordinates with respect to the basis 
and then confirm it by way of re-construction.
<P>
<P>
<P>
<PRE>
&gt; C := EvenWeightCode(5);
&gt; C![1,1,0,1,0];

&gt;&gt; C![1,1,0,1,0];
    ^
Runtime error in '!': Result is not in the given structure
&gt; c := C![1,1,0,1,1];
&gt; c;
(1 1 0 1 1)
&gt; Support(c);
{ 1, 2, 4, 5 }
&gt; Coordinates(C,c);
[ 1, 1, 0, 1 ]
&gt; C.1 + C.2 + C.4;
(1 1 0 1 1)
</PRE>
<HR>
<H4><A NAME = "20391">Predicates for Codewords</A></H4>



<H5><A NAME = "20392">u eq v : ModTupRngElt, ModTupRngElt -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
The function returns <TT>true</TT> if and only if the codewords u and v 
are equal.
</BLOCKQUOTE>
<H5><A NAME = "20393">u ne v : ModTupRngElt, ModTupRngElt -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
The function returns <TT>true</TT> if and only if the codewords u and v 
are not equal.
</BLOCKQUOTE>
<H5><A NAME = "20394">IsZero(u) : ModTupRngElt -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
The function returns <TT>true</TT> if and only if the codeword u is the 
zero vector.
</BLOCKQUOTE>
<H4><A NAME = "20395">Accessing Components of a Codeword</A></H4>



<H5><A NAME = "20396">u[i] : ModTupRngElt, RngIntElt -&gt; RngElt</A></H5>
<BLOCKQUOTE>
Given a codeword u belonging to the code C defined 
over the ring R, return the i-th component of u 
(as an element of R).
</BLOCKQUOTE>
<H5><A NAME = "20397">u[i] := x;</A></H5>
<BLOCKQUOTE>
Given an element u belonging to a subcode C of the full R-space
V = R<sup>n</sup>, a positive integer i, 1 &le;i&le;n, and an 
element x of R, this function returns a vector in V
which is u with its i-th component redefined to be x.
</BLOCKQUOTE>
<PRE></PRE> <A  HREF = "text1836.htm">[Next]</A><A  HREF = "text1834.htm">[Prev]</A> <A  HREF = "text1836.htm">[Right]</A> <A  HREF = "text1834.htm">[Left]</A> <A  HREF = "text1831.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<br><small>Version: V2.22 of <I>
Thu Jun  9 16:37:49 EST 2016
</I></small>
</body></html>