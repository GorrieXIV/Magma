<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <link rel='stylesheet' href='help.css' type='text/css'>
  <TITLE>Divisor Maps and Riemann-Roch Spaces</TITLE>
</head>
<body BGCOLOR="#FFFFFF">

 <A  HREF = "text1351.htm">[Next]</A><A  HREF = "text1349.htm">[Prev]</A> <A  HREF = "text1351.htm">[Right]</A> <A  HREF = "text1349.htm">[Left]</A> <A  HREF = "text1344.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<PRE></PRE><H3><A NAME = "14885">Divisor Maps and Riemann-Roch Spaces</A></H3>

<P>
<P>
<P>
As stated at the beginning of the chapter, one of our main initial aims in 
introducing sheaf machinery has been to provide a way of computing the 
(rational) maps associated to invertible sheaves in reasonable generality 
(see Section 7, Chapter 2 of <A  HREF = "text1343.htm#bib_hartshorne">[Har77]</A>) and similarly for effective 
Cartier divisors (as closed subschemes) in the form of the map or their 
Riemann-Roch spaces.  This section describes the main intrinsics.
We hope to add further functionality to capture the correspondence between
divisors and invertible sheaves in future releases.


<H5><A NAME = "14886">DivisorMap(S) : ShfCoh -&gt; Map,Sch</A></H5>

<PRE>    graphmap: BoolElt                   Default: <TT>false</TT></PRE>
<BLOCKQUOTE>
Given an invertible sheaf S on the scheme X this function returns
the rational map from X into the projective space associated to S. 
For efficiency, the invertibility of S is not checked, so that if the user 
is unsure whether a potential S actually is invertible (ie, locally free 
of rank one) he should apply the <A  HREF = "text1351.htm#shf:loc-free">IsLocallyFree</A> intrinsic.
<P>
The rational map that is returned can be thought of as 
X -&gt; (Proj)(R) -&gt; Prj<sup>r</sup> where R is the graded
k-subalgebra of the graded ring direct-sum <sub>n &ge;0</sub> H<sup>0</sup>(X, S<sup> tensor n</sup>) generated
by the weight 1 subspace H<sup>0</sup>(X, S) -- the space of global sections of S -- and
the map to Prj<sup>r</sup>, where r + 1 is the dimension of the space of global sections,
is that induced by choosing a basis for the global sections. The divisor
map, as usual, is only unique up to a linear change of coordinates of the codomain.
The map is defined on the open subscheme of X where S is generated by global
sections. Also returned is the image of the map on X.
<P>
In most cases, the map returned is a graph map of type <TT>MapSchGrph</TT> (see
Section <A  HREF = "text1336.htm#14703">Scheme Graph Maps</A>). This computation naturally computes the graph of the map and,
in complicated situations, it is not particularly efficient to convert this
to the more usual <TT>MapSch</TT> which will be defined by very nasty, high degree polynomials
(often with a large base scheme) without some further specialised reduction routine.
The user can however convert to a <TT>MapSch</TT> using <A  HREF = "text1336.htm#sch:gr_mp_to_sch_mp">SchemeGraphMapToSchemeMap</A>.
In cases when the sheaf has been constructed from a divisor using the
<TT>DivisorToSheaf</TT> intrinsic below with the <TT>GetMax</TT> parameter <TT>true</TT>, so
that a Riemann-Roch space has been stored, a traditional <TT>MapSch</TT> is returned.
If in doubt, the user can distinguish using the <TT>Type</TT> intrinsic. Sometimes
the user may still want a <TT>MapSchGrph</TT> in the latter case (e.g. because
it is maximally defined, it is good for getting the genuine inverse image
of a point/subscheme without components of the base scheme which appear for
a non-maximally defined <TT>MapSch</TT>). This can be forced by setting the
parameter <TT>graphmap</TT> to <TT>true</TT>.
<P>
The major stage of the computation is the determination of the graph of the
map. An ideal defining the graph can be written down directly from the relation
matrix of a minimal presentation of the global section submodule M<sub>0</sub> of S, and
this ideal then only needs to be saturated with respect to an appropriate domain 
variable.  The submodule M<sub>0</sub> is computed (and stored) as described earlier 
in the chapter.
</BLOCKQUOTE>
<H5><A NAME = "14887"></A><A NAME = "shf:div-to-shf">DivisorToSheaf</A>(X, I) : Sch, RngMPol -&gt; ShfCoh</H5>

<PRE>    GetMax: BoolElt                     Default: <TT>true</TT></PRE>
<H5>RiemannRochBasis(X, I) : Sch, RngMPol -&gt; SeqEnum, RngMPolElt, ShfCoh</H5>
<BLOCKQUOTE>
Given an ordinary, projective scheme X and an ideal I of the coordinate ring
of the ambient of X that defines a subscheme D of X that is an effective 
Cartier (locally principal) divisor of X, this function returns the invertible 
sheaf corresponding to the divisor class of D, commonly denoted (L)(D) 
(see Section 6, Chapter 2 of <A  HREF = "text1343.htm#bib_hartshorne">[Har77]</A>). The conditions require D
to be purely of codimension 1 in X and that it is everywhere locally defined 
by a single equation. Again for efficiency, Magma does not perform the 
computationally expensive checks to verify that D is locally principal within 
X. If X is a non-singular variety, then a closed subscheme of codimension 
1 is automatically Cartier.
<P>
If <TT>GetMax</TT> is <TT>true</TT>, then the maximal module of (L)(D)
is computed and an explicit basis for the Riemann-Roch space L(D) is computed and
stored along the way. This basis is of the form [G<sub>1</sub>/G, ..., G<sub>n</sub>/G], where G and
the G<sub>i</sub> are homogeneous polynomials of some degree d on the ambient of X and the
G<sub>i</sub>/G are the usual rational functions restricted to X.
<P>
If instead of <TT>DivisorToSheaf</TT>, the intrinsic <TT>RiemannRochBasis</TT> is called, 
then the above procedure is carried out and a basis of the Riemann Roch space is 
returned as the sequence of numerators [G<sub>1</sub>, ..., G<sub>n</sub>] and the denominator G, 
along with the sheaf (L)(D). If (L)(D) has been computed from 
<TT>DivisorToSheaf</TT> and returned as S, then the RiemannRoch basis can be 
recovered at a later stage from the <I>attribute</I> of S, <TT>rr_space</TT>. 
This attribute, if assigned, contains a pair consisting of the above sequence 
of numerators and the denominator.
<P>
The algorithm used is based on the following observation. If we choose r &gt; 0 such
that I contains a homogeneous polynomial G of degree r that doesn't lie in the
ideal of X, I<sub>X</sub> (which is a proper subideal of I), then there is a "complementary" 
divisor E of X such that rH ~D + E, where H is a hyperplane divisor of
X. Then (L)(D) simeq (L)( - E)(r) and (L)( - E) is represented
by the module I<sub>E</sub>/I<sub>X</sub>, where I<sub>E</sub> is the ideal of E, a subscheme of X (see
Prop 6.18 of the above reference). Once a suitable G is found, I<sub>E</sub> is computed
by invoking intrinsics <TT>ColonIdeal</TT> and <TT>Saturation</TT> a few times. 
If the <TT>GetMax</TT> option is on, r is chosen large enough so that H<sup>1</sup>(I<sub>X</sub>(m)), 
m &ge;r vanishes, which 
guarantees that we end up with a maximal representing module and can get a full 
basis of Riemann-Roch numerators with G as the denominator.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "14888">Example <TT>Sheaf_shf:rr-scroll (H119E4)</TT></A></H3>
As a simple example, we consider a degree 3 rational scroll in Prj<sup>4</sup>. This
is a ruled surface that contains a family of disjoint lines. If l is a line
in the family, then the divisor map for (L)(l) is a map to the projective
line, the fibres of which are the lines of the family. We take such a scroll X
and line l and get the Riemann-Roch space L(l) and the divisor map down to
P<sup>1</sup>.
<P>
<P>
<P>
<PRE>
&gt; P4&lt;a,b,c,d,e&gt; := ProjectiveSpace(Rationals(),4);
&gt; X := Scheme(P4,[a*b - c^2, a*d - c*e, c*d - b*e]);
&gt; Il := ideal&lt;CoordinateRing(P4)|[a,c,e]&gt;; // ideal of l
&gt; rr_seq,G, Sl := RiemannRochBasis(X,Il);
&gt; rr_seq; G;
[
    d,
    e
]
e
</PRE>
Thus,  1 and d/e are a basis for the rational functions in L(l).
<P>
<P>
<PRE>
&gt; fib_mp := DivisorMap(Sl);
&gt; fib_mp;
Mapping from: Sch: X to Projective Space of dimension 1
Variables: $.1, $.2
with equations : 
d
e
</PRE>
Here the divisor map is not a graph map and is not maximally defined.
So we extend it to make it so. Note that the fibres are lines.
<P>
<P>
<PRE>
&gt; fib_mp := Extend(fib_mp);
&gt; (Codomain(fib_mp)![1,0])@@fib_mp;
Scheme over Rational Field defined by
a,
c,
e,
a*b - c^2,
a*d - c*e,
c*d - b*e
&gt; (Codomain(fib_mp)![0,1])@@fib_mp;
c,
b,
d,
a*b - c^2,
a*d - c*e,
c*d - b*e
</PRE>
Alternatively, we could ask for <TT>fib_mp</TT> as a <TT>MapSchGrph</TT> and not
have to extend it.
<P>
<P>
<PRE>
&gt; fib_mp := DivisorMap(Sl : graphmap := true);
&gt; Type(fib_mp);
MapSchGrph
&gt; (Codomain(fib_mp)![1,0])@@fib_mp;
Scheme over Rational Field defined by
a,
c,
e,
a*b - c^2,
a*d - c*e,
c*d - b*e
</PRE>
<HR>
<H3><A NAME = "14889">Example <TT>Sheaf_shf:dp3to6 (H119E5)</TT></A></H3>
As a second example, we consider the degree 3 Del Pezzo surface example from the 
Del Pezzo chapter. There we mapped it to a degree 6 Del Pezzo surface by blowing 
down 3 disjoint lines in an explicit fashion. We do the same thing here using the
sheaf machinery.
<P>
<P>
<P>
First we get the surface X<sub>3</sub> and the union of the 3 lines L<sub>123</sub>:-
<P>
<P>
<PRE>
&gt; R3&lt;x,y,z,t&gt; := PolynomialRing(Rationals(),4,"grevlex");
&gt; P3 := Proj(R3);
</PRE>
We set up the equation defining the degree 3 surface:
<P>
<P>
<PRE>
&gt; F := -x^2*z + x*z^2 - y*z^2 + x^2*t - y^2*t - y*z*t + x*t^2 + y*t^2;
&gt; X3 := Scheme(P3,F);
</PRE>
Get the ideal defining the union of the 3 lines:
<P>
<P>
<PRE>
&gt; I1 := ideal&lt;R3|[x,y]&gt;; // line 1 L1
&gt; I2 := ideal&lt;R3|[z,t]&gt;; // line 2 L2
&gt; I3 := ideal&lt;R3|[x-z,y-t]&gt;; //line 3 L3
&gt; I := I1*I2*I3; // (non-saturated) ideal of L1+L2+L3 = L123
</PRE>
Now we blow down to get the degree 6 Del Pezzo in Prj<sup>6</sup>. The divisor we
need for the map is H + L<sub>123</sub> where H is a hyperplane section. We get this
simply by twisting the sheaf corresponding to L<sub>123</sub> once.
<P>
<P>
<PRE>
&gt; S123 := DivisorToSheaf(X3,I);
&gt; H6 := Twist(S123,1); // sheaf of H+L123
&gt; mp, X := DivisorMap(H6);
&gt; X;
Scheme over Rational Field defined by
y[1]*y[2] - y[2]*y[3] - y[4]*y[5] + y[1]*y[6] + 3*y[2]*y[6] - y[4]*y[6] + y[6]^2
    + y[1]*y[7] + 2*y[2]*y[7] - y[4]*y[7] - y[5]*y[7] + 3*y[6]*y[7],
y[2]^2 - y[2]*y[3] + 2*y[2]*y[6] + y[6]^2 + 2*y[2]*y[7] + 3*y[6]*y[7],
y[1]*y[3] - y[2]*y[3] + 2*y[2]*y[6] - y[5]*y[6] + y[6]^2 + y[2]*y[7] - y[4]*y[7]
    + 3*y[6]*y[7],
y[2]*y[4] - y[2]*y[6] + y[4]*y[6] + y[4]*y[7] + y[5]*y[7],
y[3]*y[4] - y[2]*y[6] - y[6]^2 - y[6]*y[7] + y[7]^2,
y[4]^2 - y[4]*y[6] + y[5]*y[6] + y[1]*y[7] - y[2]*y[7] + y[4]*y[7] + y[5]*y[7],
y[2]*y[5] - y[4]*y[6] + y[5]*y[6] - y[2]*y[7] + y[4]*y[7] + y[5]*y[7],
y[3]*y[5] - y[6]^2 - y[2]*y[7] - y[7]^2,
y[5]^2 - y[1]*y[6] + y[2]*y[6] - 2*y[4]*y[6] + y[5]*y[6] + y[1]*y[7] - y[2]*y[7]
&gt; Dimension(X); Degree(X);
2
6
</PRE>
<HR>
<PRE></PRE> <A  HREF = "text1351.htm">[Next]</A><A  HREF = "text1349.htm">[Prev]</A> <A  HREF = "text1351.htm">[Right]</A> <A  HREF = "text1349.htm">[Left]</A> <A  HREF = "text1344.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<br><small>Version: V2.22 of <I>
Thu Jun  9 16:37:49 EST 2016
</I></small>
</body></html>