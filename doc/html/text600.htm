<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <link rel='stylesheet' href='help.css' type='text/css'>
  <TITLE>Chain Maps</TITLE>
</head>
<body BGCOLOR="#FFFFFF">

 <A  HREF = "text603.htm">[Next]</A><A  HREF = "text599.htm">[Prev]</A> [_____] <A  HREF = "text599.htm">[Left]</A> <A  HREF = "text598.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<PRE></PRE><H3><A NAME = "6358">Chain Maps</A></H3>

<P>
<P>
<P>
A chain map from complex C to complex D is a sequence of homomorphisms
between the terms of C and the terms of D such that the maps commute
with the boundary homomorphisms on the two complexes. The chain map has 
degree zero if the map on C<sub>n</sub> has it's image in D<sub>n</sub>. Otherwise 
the degree of 
the chain map expresses the extent to which the degrees of the terms
are raised or lowered by the chain map. 
<P>
Chain maps do not have to be defined in every degree for which either its 
domain or codomain is defined. On the other hand it must be defined 
wherever possible, i.e. for any degree i for which the term of the 
domain is defined and for which the term of the codomain is defined in 
degree i + n where n is the degree of the chain map. 
<P>
The freedom of definition can cause problems with constructions such as the
kernel or cokernel. That is, the kernel of a chain complex may not be a 
complex. For this reason we allow the Kernel and Cokernel functions to 
work only for proper chain maps where "proper" is defined as follows. 
Suppose C is a chain complex in degrees a to b and D is a complex
in degrees u to v. A chain map in degree n from C to D is proper
provided u &ge;a + n and v &ge;b + n.



<H5>Subsections</H5>
<UL>
<LI> <A  HREF = "text600.htm#6359">Creation</A>
<LI> <A  HREF = "text600.htm#6362">Access Functions</A>
<LI> <A  HREF = "text600.htm#6368">Elementary Operations</A>
<LI> <A  HREF = "text600.htm#6372">Predicates</A>
<LI> <A  HREF = "text600.htm#6383">Maps on Homology</A>
</UL>
<H4><A NAME = "6359">Creation</A></H4>



<H5><A NAME = "6360">ChainMap(Q, C, D, n) : SeqEnum, ModCpx, ModCpx, RngIntElt  -&gt; MapChn</A></H5>
<BLOCKQUOTE>
Returns the chain map given by the sequence of maps in Q. Each 
element in Q is a map from a term of the complex C to a 
corresponding term of the complex D.  The integer n is the
degree of the chain map. This means that for any i the term in
degree i of C is mapped to the term of degree n + i of D.
There should be a map defined for any degree i in the range of 
degrees of C such that there is a corresponding term in degree
n + i for the complex D. 
</BLOCKQUOTE>
<H5><A NAME = "6361">ZeroChainMap(C, D) : ModCpx, ModCpx -&gt; MapChn</A></H5>
<BLOCKQUOTE>
Given chain complexes C and D, construct the chain map from C
to D all of whose terms are zero.
</BLOCKQUOTE>
<H4><A NAME = "6362">Access Functions</A></H4>



<H5><A NAME = "6363">Degree(f) : MapChn -&gt; RngIntElt</A></H5>
<BLOCKQUOTE>
Given a chain map f, returns the degree of f. Note that 
f: C -&gt; D has degree n if it takes the term in 
degree i of the complex C to the term in degree i + n 
of the complex D.
<P>
</BLOCKQUOTE>
<H5><A NAME = "6364">ModuleMap(f, n) : MapChn, RngIntElt -&gt; ModMatRngElt</A></H5>
<BLOCKQUOTE>
Given a chain map f:C -&gt; D and an integer n, this
function returns the map from the term in degree n of the complex 
C to the term in degree n + (hbox (Degree))(f) of the complex D.
<P>
</BLOCKQUOTE>
<H5><A NAME = "6365">Kernel(f) : MapChn -&gt; ModCpx, MapChn</A></H5>
<BLOCKQUOTE>
Returns the kernel complex of f and the inclusion of the kernel 
in the domain of f. The function is only defined for proper 
chain maps. If the chain map is not defined for a certain term
of the domain then that term is equal to the term of the kernel
complex. That is, if f is not defined on a term then the functions
acts as if f were the zero map on that term. 
<P>
</BLOCKQUOTE>
<H5><A NAME = "6366">Cokernel(f) : MapChn -&gt; ModCpx, MapChn</A></H5>
<BLOCKQUOTE>
Returns the cokernel complex of f and the projection of the 
cokernel onto the codomain of f.  The function is only defined for proper 
chain maps. If the chain map is not defined for a certain term
of the codomain then that term is equal to the term of the cokernel
complex. That is, if f is not defined on a term then the function
acts as if f were the zero map on that term. 
</BLOCKQUOTE>
<H5><A NAME = "6367">Image(f) : MapChn -&gt; ModCpx, MapChn, MapChn</A></H5>
<BLOCKQUOTE>
Returns the image complex of f and the inclusion of the image 
in the codomain of f and the projection of the domain of f on 
to the image.  The function is only defined for proper chain maps. 
</BLOCKQUOTE>
<H4><A NAME = "6368">Elementary Operations</A></H4>



<H5><A NAME = "6369">f + g : MapChn , MapChn  -&gt; MapChn</A></H5>
<BLOCKQUOTE>
The sum of two chain maps with the same domain and codomain.
</BLOCKQUOTE>
<H5><A NAME = "6370">a * g : RngElt , MapChn  -&gt; MapChn</A></H5>
<BLOCKQUOTE>
The product of the chain map g by the scalar a in the base ring
of the algebra. 
</BLOCKQUOTE>
<H5><A NAME = "6371">f * g : MapChn , MapChn  -&gt; MapChn</A></H5>
<BLOCKQUOTE>
The composition of the two chain maps f and g.
</BLOCKQUOTE>
<H4><A NAME = "6372">Predicates</A></H4>

<P>
<P>
<P>
The following functions return a Boolean value.


<H5><A NAME = "6373">IsSurjective(f) : MapChn -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if the chain map f is a surjection in every degree, 
<TT>false</TT> otherwise.
</BLOCKQUOTE>
<H5><A NAME = "6374">IsInjective(f) : MapChn -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if the chain map f is an injection in every degree, 
<TT>false</TT> otherwise.
</BLOCKQUOTE>
<H5><A NAME = "6375">IsZero(f) : MapChn -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if the chain map f is zero in every degree, <TT>false</TT> 
otherwise.
</BLOCKQUOTE>
<H5><A NAME = "6376">IsIsomorphism(f) : MapChn -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if the chain map f is an isomorphism of chain
complexes, <TT>false</TT> otherwise.
</BLOCKQUOTE>
<H5><A NAME = "6377">IsShortExactSequence(f, g) : MapChn, MapChn -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if the sequence of chain complexes, 
0 -&gt; Domain(f) -&gt; Domain(g) -&gt; Codomain(g) -&gt; 0, where the internal maps are f  
and g, is exact.
</BLOCKQUOTE>
<H5><A NAME = "6378">IsChainMap(L, C, D, n) : List, ModCpx, ModCpx, RngIntElt -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if the list of maps L from the terms 
of complex C to the terms 
of the complex D is a chain map of degree n, i. e. it has the right 
length and the diagram commutes.
</BLOCKQUOTE>
<H5><A NAME = "6379">IsChainMap(f) : MapChn -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if the supposed chain map f really is a chain map, i. e. the 
diagrams commute. 
</BLOCKQUOTE>
<H5><A NAME = "6380">IsProperChainMap(f) : MapChn -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if the chain map f is a proper chain map, a necessary condition
for taking kernel and cokernel.
</BLOCKQUOTE>
<H5><A NAME = "6381">HasDefinedModuleMap(C,n) : ModCpx, RngIntElt -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if the  module map in degree n of the complex C is defined.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "6382">Example <TT>ModCpx_Chainmaps (H60E2)</TT></A></H3>
We from the basic algebra of the direct product of a cyclic group of
order 3 with symmetric group on three letters over the field with three
elements. 
<P>
<P>
<PRE>
&gt; FA&lt;e1,e2,a,b&gt; := FreeAlgebra(GF(3),4);
&gt; MM:= [e1 +e2 - FA!1, a*b*a, b*a*b];
&gt; BS3 := BasicAlgebra(FA, MM, 2, [&lt;1,2&gt;,&lt;2,1&gt;]);
&gt; gg := CyclicGroup(3);
&gt; BC3 := BasicAlgebra(gg,GF(3));
&gt; A := TensorProduct(BS3,BC3);
&gt; A;
Basic algebra of dimension 18 over GF(3)
Number of projective modules: 2
Number of generators: 6
</PRE>
Now we want the projective resolution of the second simple module as a 
complex. This we will manipulate and take a somewhat random complex. 
<P>
<P>
<PRE>
&gt; PR := ProjectiveResolution(SimpleModule(A,2),12);
&gt; PR;
Basic algebra complex with terms of degree 12 down to 0
Dimensions of terms: 117 108 99 90 81 72 63 54 45 36 27 18 9
&gt; PR := Prune(PR);
&gt; PR := Prune(PR);
&gt; PR := Prune(PR);
&gt; PR;
Basic algebra complex with terms of degree 12 down to 3
Dimensions of terms: 117 108 99 90 81 72 63 54 45 36
&gt; PR := Prune(PR);
&gt; PR := Prune(PR);
&gt; PR;
Basic algebra complex with terms of degree 12 down to 5
Dimensions of terms: 117 108 99 90 81 72 63 54
&gt; PR := ZeroExtension(PR);
&gt; PR;
Basic algebra complex with terms of degree 13 down to 4
Dimensions of terms: 0 117 108 99 90 81 72 63 54 0
&gt; PR := Shift(PR,-4);
&gt; PR;
Basic algebra complex with terms of degree 9 down to 0
Dimensions of terms: 0 117 108 99 90 81 72 63 54 0
&gt; S := [* *];
&gt; for i := 1 to 10 do
&gt;    S[i] := [Random(Term(PR,10-i)),Random(Term(PR,10-i))];
&gt; end for;
&gt; C,mu := Subcomplex(PR,S);
&gt; C;
Basic algebra complex with terms of degree 9 down to 0
Dimensions of terms: 0 36 67 64 62 63 58 54 51 0
&gt; Homology(C);
[
    AModule of dimension 4 over GF(3),
    AModule of dimension 6 over GF(3),
    AModule of dimension 5 over GF(3),
    AModule of dimension 3 over GF(3),
    AModule of dimension 2 over GF(3),
    AModule of dimension 1 over GF(3),
    AModule of dimension 4 over GF(3),
    AModule of dimension 26 over GF(3)
]
[
    Mapping from: AModule of dimension 4 over GF(3) to AModule of dimension 4 
    over GF(3),
    Mapping from: AModule of dimension 38 over GF(3) to AModule of dimension 6 
    over GF(3),
    Mapping from: AModule of dimension 34 over GF(3) to AModule of dimension 5 
    over GF(3),
    Mapping from: AModule of dimension 33 over GF(3) to AModule of dimension 3 
    over GF(3),
    Mapping from: AModule of dimension 31 over GF(3) to AModule of dimension 2 
    over GF(3),
    Mapping from: AModule of dimension 33 over GF(3) to AModule of dimension 1 
    over GF(3),
    Mapping from: AModule of dimension 29 over GF(3) to AModule of dimension 4 
    over GF(3),
    Mapping from: AModule of dimension 51 over GF(3) to AModule of dimension 26
    over GF(3)
]
&gt; D := Cokernel(mu);
&gt; D;
Basic algebra complex with terms of degree 9 down to 0
Dimensions of terms: 0 81 41 35 28 18 14 9 3 0
&gt; Homology(D);
[
    AModule of dimension 64 over GF(3)
    AModule of dimension 5 over GF(3),
    AModule of dimension 3 over GF(3),
    AModule of dimension 2 over GF(3),
    AModule of dimension 1 over GF(3),
    AModule of dimension 4 over GF(3),
    AModule of dimension 3 over GF(3),
    AModule of dimension 3 over GF(3)
]
[
    Mapping from: AModule of dimension 64 over GF(3) to AModule of dimension 64
    over GF(3),
    Mapping from: AModule of dimension 22 over GF(3) to AModule of dimension 5 
    over GF(3),
    Mapping from: AModule of dimension 22 over GF(3) to AModule of dimension 3 
    over GF(3),
    Mapping from: AModule of dimension 15 over GF(3) to AModule of dimension 2 
    over GF(3),
    Mapping from: AModule of dimension 14 over GF(3) to AModule of dimension 1 
    over GF(3),
    Mapping from: AModule of dimension 8 over GF(3) to AModule of dimension 4 
    over GF(3),
    Mapping from: AModule of dimension 9 over GF(3) to AModule of dimension 3 
    over GF(3),
    Mapping from: AModule of dimension 3 over GF(3) to AModule of dimension 3 
    over GF(3)
]
</PRE>
<HR>
<H4><A NAME = "6383">Maps on Homology</A></H4>



<H5><A NAME = "6384">InducedMapOnHomology(f, n) : MapChn, RngIntElt -&gt; ModTupFldElt</A></H5>
<BLOCKQUOTE>
The homomorphism induced on homology by the chain map f in degree n.
</BLOCKQUOTE>
<H5><A NAME = "6385">ConnectingHomomorphism(f, g, n) : MapChn, MapChn, RngIntElt -&gt; ModMatRngElt</A></H5>
<BLOCKQUOTE>
The connecting homomorphism in degree n of the short exact sequence of 
chain complexes given by the chain maps f and g.
</BLOCKQUOTE>
<H5><A NAME = "6386">LongExactSequenceOnHomology(f, g) : MapChn, MapChn -&gt; ModCpx</A></H5>
<BLOCKQUOTE>
The long exact sequence on homology for the exact sequence of complexes 
given by the chain maps f and g as a chain complex with the homology 
group in degree i for the Cokernel of the complex C appearing in degree 
3i.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "6387">Example <TT>ModCpx_LongExactSequence (H60E3)</TT></A></H3>
We create a basic algebra with two simple modules and four nonidempotent 
generators.  The relations are given in the sequence <TT>rrr</TT>.
<P>
<P>
<PRE>
&gt; ff := GF(3);
&gt; p := Characteristic(ff);
&gt; FA&lt;e1, e2, y, x, a, b&gt; := FreeAlgebra(ff,6);
&gt; rrr := [y^p,x^p,x*y+y*x,x*a*b-a*b*x,y*a*b-a*b*y,(b*a)^2,(b*a)^2];
&gt; A := BasicAlgebra(FA,rrr,2,[&lt;1,1&gt;,&lt;1,1&gt;,&lt;1,2&gt;,&lt;2,1&gt;]);
&gt; A;
Basic algebra of dimension 81 over GF(3)
Number of projective modules: 2
Number of generators: 6
&gt; DimensionsOfProjectiveModules(A);
[ 45, 36 ]
</PRE>
Now we generate the simple modules and their projective covers. We want a 
module PP that is the direct sum of two copies of each of the projective
indecomposable module. 
<P>
<P>
<PRE>
&gt; S1 := SimpleModule(A,1);
&gt; PP := ProjectiveModule(A,[2,2]);
</PRE>
Now we are going to create a complex all of whose terms are isomorphic to PP.
To make it interesting we will insist that the first homomorphism have its
image in the second radical layer of PP.
<P>
<P>
<PRE>
&gt; J1 := JacobsonRadical(PP);
&gt; theta1 := Morphism(J1,PP);
&gt; J2 := JacobsonRadical(J1);
&gt; theta2 := Morphism(J2,J1);
&gt; theta := theta2*theta1;
&gt; HomPJ := AHom(PP, J2);
&gt; HomPJ;
KMatrixSpace of 162 by 150 matrices and dimension 300 over GF(3)
&gt; gamma := Random(HomPJ)*theta;
&gt; LL := [* gamma *];
</PRE>
So we now have the first boundary map of the complex. The other boundary 
maps are generated randomly. 
<P>
<P>
<PRE>
&gt; for i := 1 to 15 do
&gt;     K, phi := Kernel(gamma);
&gt;     HomPK := AHom(PP,K);
&gt;     gamma := Random(HomPK)*MapToMatrix(phi);
&gt;     LL := [* gamma *] cat LL;
&gt; end for;
</PRE>
Now we make the list into a chain complex.
<P>
<P>
<PRE>
&gt; C := Complex(LL,0);
&gt; C;
Basic algebra complex with terms of degree 16 down to 0
Dimensions of terms: 162 162 162 162 162 162 162 162 162 162 162 162 162 162 
162 162 162
&gt; DimensionsOfHomology(C);
[ 30, 23, 34, 32, 35, 32, 35, 42, 30, 34, 32, 33, 29, 42, 21 ]

Now we will get a random subcomplex.

&gt; a,b := Degrees(C);
&gt; S, mu := RandomSubcomplex(C,[2: i in [1 .. a-b+1]]);
&gt; S;
Basic algebra complex with terms of degree 16 down to 0
Dimensions of terms: 162 155 162 162 162 154 142 162 162 148 154 162 162 152 
155 152 162
&gt; DimensionsOfHomology(S);
[ 27, 27, 34, 32, 35, 33, 48, 42, 28, 44, 38, 33, 29, 48, 24 ]
</PRE>
Now take the quotient.
<P>
<P>
<PRE>
&gt; Q,nu := quo&lt;C|S&gt;;
&gt; Q;
Basic algebra complex with terms of degree 16 down to 0
Dimensions of terms: 0 7 0 0 0 8 20 0 0 14 8 0 0 10 7 10 0
&gt; DimensionsOfHomology(Q);
[ 7, 0, 0, 0, 6, 18, 0, 0, 12, 6, 0, 0, 8, 5, 10 ]
</PRE>
Now we check to see if this is a short exact sequence of chain maps.
<P>
<P>
<PRE>
&gt; IsShortExactSequence(mu,nu);
true
&gt; lll := LongExactSequenceOnHomology(mu,nu);
Basic algebra complex with terms of degree 47 down to 3
Dimensions of terms: 27 30 7 27 23 0 34 34 0 32 32 0 35 35 6 33 32 18 48 35 0 
42 42 0 28 30 12 44 34 6 38 32 0 33 33 0 29 29 8 48 42 5 24 21 10
&gt; IsExact(lll);
true
</PRE>
<PRE></PRE> <A  HREF = "text603.htm">[Next]</A><A  HREF = "text599.htm">[Prev]</A> [_____] <A  HREF = "text599.htm">[Left]</A> <A  HREF = "text598.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<br><small>Version: V2.22 of <I>
Thu Jun  9 16:37:49 EST 2016
</I></small>
</body></html>