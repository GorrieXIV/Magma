<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <link rel='stylesheet' href='help.css' type='text/css'>
  <TITLE>Operations on Codewords</TITLE>
</head>
<body BGCOLOR="#FFFFFF">

 <A  HREF = "text1888.htm">[Next]</A><A  HREF = "text1886.htm">[Prev]</A> <A  HREF = "text1888.htm">[Right]</A> <A  HREF = "text1886.htm">[Left]</A> <A  HREF = "text1883.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<PRE></PRE><H3><A NAME = "21009">Operations on Codewords</A></H3>




<H5>Subsections</H5>
<UL>
<LI> <A  HREF = "text1887.htm#21010">Construction of a Codeword</A>
<LI> <A  HREF = "text1887.htm#21015">Arithmetic Operations on Codewords</A>
<LI> <A  HREF = "text1887.htm#21021">Distance and Weight</A>
<LI> <A  HREF = "text1887.htm#21024">Vector Space and Related Operations</A>
<LI> <A  HREF = "text1887.htm#21033">Predicates for Codewords</A>
<LI> <A  HREF = "text1887.htm#21037">Accessing Components of a Codeword</A>
</UL>
<H4><A NAME = "21010">Construction of a Codeword</A></H4>



<H5><A NAME = "21011">C ! [a<sub>1</sub>, ..., a<sub>n</sub>] : Code, [ RngElt ] -&gt; ModTupRngElt</A></H5>
<H5>elt&lt; C | a<sub>1</sub>, ..., a<sub>n</sub>&gt; : Code, List -&gt; ModTupRngElt</H5>
<BLOCKQUOTE>
Given a length n additive code C with alphabet F, then the codewords
of C lie in F<sup>(n)</sup>. Given
elements a<sub>1</sub>, ..., a<sub>n</sub> belonging 
to F, construct the codeword (a<sub>1</sub>, ..., a<sub>n</sub>) of C.  
A check is made that the vector (a<sub>1</sub>, ..., a<sub>n</sub>) is an element of C.
</BLOCKQUOTE>
<H5><A NAME = "21012">C ! u : Code, ModTupRngElt -&gt; ModTupRngElt</A></H5>
<BLOCKQUOTE>
Given an additive code C which is defined as a subset of the F-space
V = F<sup>(n)</sup>, and an element u belonging to V,
create the codeword of C corresponding to u. The function
will fail if u does not belong to C.
</BLOCKQUOTE>
<H5><A NAME = "21013">C ! 0 : Code, RngIntElt -&gt; ModTupRngElt</A></H5>
<BLOCKQUOTE>
The zero word of the additive code C.
</BLOCKQUOTE>
<H5><A NAME = "21014">Random(C): Code -&gt; ModTupRngElt</A></H5>
<BLOCKQUOTE>
A random codeword of the additive code C.
</BLOCKQUOTE>
<H4><A NAME = "21015">Arithmetic Operations on Codewords</A></H4>



<H5><A NAME = "21016">u + v : ModTupRngElt, ModTupRngElt -&gt; ModTupRngElt</A></H5>
<BLOCKQUOTE>
Sum of the codewords u and v, where u and 
v belong to the same linear code C.
</BLOCKQUOTE>
<H5><A NAME = "21017">- u : ModTupRngElt -&gt; ModTupRngElt</A></H5>
<BLOCKQUOTE>
Additive inverse of the codeword u belonging
to the linear code C.
</BLOCKQUOTE>
<H5><A NAME = "21018">u - v : ModTupRngElt, ModTupRngElt -&gt; ModTupRngElt</A></H5>
<BLOCKQUOTE>
Difference of the codewords u and v, where 
u and v belong to the same linear code C.
</BLOCKQUOTE>
<H5><A NAME = "21019">a * u : RngElt, ModTupRngElt -&gt; ModTupRngElt</A></H5>
<BLOCKQUOTE>
Given an element a belonging to the alphabet F, 
and a codeword u belonging to the additive code
C, return the codeword a * u.
</BLOCKQUOTE>
<H5><A NAME = "21020">Normalize(u) : ModTupRngElt -&gt; ModTupRngElt</A></H5>
<BLOCKQUOTE>
Normalize a codeword u of an additive code C, returning a scalar multiple
of u such that its first non-zero entry is 1.
</BLOCKQUOTE>
<H4><A NAME = "21021">Distance and Weight</A></H4>



<H5><A NAME = "21022">Distance(u, v) : ModTupRngElt, ModTupRngElt -&gt; RngIntElt</A></H5>
<BLOCKQUOTE>
The Hamming distance between the codewords u and v,
where u and v belong to the same additive code C.
</BLOCKQUOTE>
<H5><A NAME = "21023">Weight(u) : ModTupRngElt -&gt; RngIntElt</A></H5>
<BLOCKQUOTE>
The Hamming weight of the codeword u, i.e., the number of non-zero
components of u.
</BLOCKQUOTE>
<H4><A NAME = "21024">Vector Space and Related Operations</A></H4>



<H5><A NAME = "21025">(u, v) : ModTupRngElt, ModTupRngElt -&gt; RngElt</A></H5>
<H5>InnerProduct(u, v) : ModTupRngElt, ModTupRngElt -&gt; RngElt</H5>
<BLOCKQUOTE>
Inner product of the vectors u and v with respect to 
the Euclidean norm, where u and v belong to the parent 
vector space of the code C.
</BLOCKQUOTE>
<H5><A NAME = "21026">TraceInnerProduct(K, u, v) : FldFin, ModTupFldElt, ModTupFldElt -&gt; FldFinElt</A></H5>
<BLOCKQUOTE>
Given vectors u and v defined over a finite field L and a subfield K
of L, this function returns the trace of the inner product of the vectors 
u and v with respect to K.
</BLOCKQUOTE>
<H5><A NAME = "21027">Support(w) : ModTupRngElt -&gt; { RngIntElt }</A></H5>
<BLOCKQUOTE>
Given a word w belonging to the [n, k] code C, return its
support as a subset of the integer set { 1 .. n }.  The support of w
consists of the coordinates at which w has non-zero entries.
</BLOCKQUOTE>
<H5><A NAME = "21028">Coordinates(C, u) : Code, ModTupRngElt -&gt; [ RngFinElt ]</A></H5>
<BLOCKQUOTE>
Given an [n, k : k<sub>g</sub>] K-additive code C and 
a codeword u of C return the
coordinates of u with respect to the current basis of C.  
The coordinates of u are returned
as a sequence Q = [a<sub>1</sub>, ..., a<sub>k<sub>g</sub></sub>] of elements from K
such that u = a<sub>1</sub> * C.1 + ... + a<sub>k<sub>g</sub></sub> * C.(k<sub>g</sub>).
</BLOCKQUOTE>
<H5><A NAME = "21029">Parent(w): ModTupRngElt -&gt; ModTupRng</A></H5>
<BLOCKQUOTE>
Given a word w belonging to the code C, return the
ambient space V of C.
</BLOCKQUOTE>
<H5><A NAME = "21030">Rotate(u, k) : ModTupRngElt, RngIntElt -&gt; ModTupRngElt</A></H5>
<BLOCKQUOTE>
Given a vector u, return the vector obtained from u by
cyclically shifting its components to the right by k coordinate 
positions.
</BLOCKQUOTE>
<H5><A NAME = "21031">Rotate(~u, k) : ModTupRngElt, RngIntElt -&gt;</A></H5>
<BLOCKQUOTE>
Given a vector u, destructively rotate u by k coordinate positions.
</BLOCKQUOTE>
<H5><A NAME = "21032">Trace(u, S) : ModTupFldElt, FldFin -&gt; ModTupFldElt</A></H5>
<H5>Trace(u) : ModTupFldElt -&gt; ModTupFldElt</H5>
<BLOCKQUOTE>
Given a vector u with components in K, and a subfield S of K,
construct the vector with components in S obtained from u by taking
the trace of each component with respect to S.  If S is omitted,
it is taken to be the prime field of K.
</BLOCKQUOTE>
<H4><A NAME = "21033">Predicates for Codewords</A></H4>



<H5><A NAME = "21034">u eq v : ModTupRngElt, ModTupRngElt -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
The function returns <TT>true</TT> if and only if the codewords u and v 
belonging to the same additive code are equal.
</BLOCKQUOTE>
<H5><A NAME = "21035">u ne v : ModTupRngElt, ModTupRngElt -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
The function returns <TT>true</TT> if and only if the codewords u and v 
belonging to the same additive code are not equal.
</BLOCKQUOTE>
<H5><A NAME = "21036">IsZero(u) : ModTupRngElt -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
The function returns <TT>true</TT> if and only if the codeword u is the 
zero vector.
</BLOCKQUOTE>
<H4><A NAME = "21037">Accessing Components of a Codeword</A></H4>



<H5><A NAME = "21038">u[i] : ModTupRngElt, RngIntElt -&gt; RngElt</A></H5>
<BLOCKQUOTE>
Given a codeword u belonging to the code C defined 
over the ring R, return the i-th component of u 
(as an element of R).
</BLOCKQUOTE>
<H5><A NAME = "21039">u[i] := x;</A></H5>
<BLOCKQUOTE>
Given an element u belonging to a subcode C of the full R-space
V = R<sup>n</sup>, a positive integer i, 1 &le;i&le;n, and an 
element x of R, this function returns a vector in V
which is u with its i-th component redefined to be x.
</BLOCKQUOTE>
<PRE></PRE> <A  HREF = "text1888.htm">[Next]</A><A  HREF = "text1886.htm">[Prev]</A> <A  HREF = "text1888.htm">[Right]</A> <A  HREF = "text1886.htm">[Left]</A> <A  HREF = "text1883.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<br><small>Version: V2.22 of <I>
Thu Jun  9 16:37:49 EST 2016
</I></small>
</body></html>