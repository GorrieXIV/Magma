<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <link rel='stylesheet' href='help.css' type='text/css'>
  <TITLE>Roots and Coroots</TITLE>
</head>
<body BGCOLOR="#FFFFFF">

 <A  HREF = "text1085.htm">[Next]</A><A  HREF = "text1083.htm">[Prev]</A> <A  HREF = "text1085.htm">[Right]</A> <A  HREF = "text1083.htm">[Left]</A> <A  HREF = "text1079.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<PRE></PRE><H3><A NAME = "12048">Roots and Coroots</A></H3>

<P>
<P>
<P>
<P>
The roots are stored as an indexed set
<P>
  {@ &alpha;<sub>1</sub>, ..., &alpha;<sub>N</sub>, &alpha;<sub>N + 1</sub>, ..., &alpha;<sub>2N</sub>  @},
<P>
where &alpha;<sub>1</sub>, ..., &alpha;<sub>N</sub> are the positive roots (in an order compatible
with height), and &alpha;<sub>N + 1</sub>, ..., &alpha;<sub>2N</sub> are the corresponding
negative roots (i.e. &alpha;<sub>i + N</sub>= - &alpha;<sub>i</sub>).
The simple roots are &alpha;<sub>1</sub>, ..., &alpha;<sub>n</sub> where n is the rank.
<P>
Many of these functions have an optional argument
<TT>Basis</TT> which may take one of the following values
<P>
<DL COMPACT class='compact'>
<DT>1. </DT><DD><TT>"Standard"</TT>: the standard basis for the (co)root space  
  (this is the default); or
<DT>2. </DT><DD><TT>"Root"</TT>: the basis of simple (co)roots.</DL>



<H5>Subsections</H5>
<UL>
<LI> <A  HREF = "text1084.htm#12049">Accessing Roots and Coroots</A>
<LI> <A  HREF = "text1084.htm#12064">Reflections</A>
<LI> <A  HREF = "text1084.htm#12074">Operations and Properties for  Roots and Coroot Indices</A>
</UL>
<H4><A NAME = "12049">Accessing Roots and Coroots</A></H4>



<H5><A NAME = "12050">RootSpace(R) : RootSys -&gt; ModTupFld</A></H5>
<H5>CorootSpace(R) : RootSys -&gt; ModTupFld</H5>
<BLOCKQUOTE>
The vector spacecontaining the (co)roots
of the root system R, i.e. X (respectively, Y).
</BLOCKQUOTE>
<H5><A NAME = "12051">SimpleRoots(R) : RootSys -&gt; Mtrx</A></H5>
<H5>SimpleCoroots(R) : RootSys -&gt; Mtrx</H5>
<BLOCKQUOTE>
The simple (co)rootsof the root system R
as the rows of a matrix, i.e. A (respectively, B).  
</BLOCKQUOTE>
<HR>
<H3><A NAME = "12052">Example <TT>RootSys_RootSpace (H102E9)</TT></A></H3>
<P>
<P>
<PRE>
&gt; R := RootSystem("G2");
&gt; RootSpace(R);
Full Vector space of degree 2 over Rational Field                    
&gt; CorootSpace(R);
Full Vector space of degree 2 over Rational Field                    
&gt; SimpleRoots(R);
[1 0]
[0 1]
&gt; SimpleCoroots(R);
[ 2 -3]
[-1  2]
&gt; CartanMatrix(R);
[ 2 -1]
[-3  2]
</PRE>
<HR>
<H5><A NAME = "12053">NumberOfPositiveRoots(R) : RootSys -&gt; RngIntElt</A></H5>
<H5>NumPosRoots(R) : RootSys -&gt; RngIntElt</H5>
<BLOCKQUOTE>
The number of positive roots of the root system R. 
This is also the number of positive coroots.  
The total number of (co)roots is twice the number of positive (co)roots.
</BLOCKQUOTE>
<H5><A NAME = "12054">Roots(R) : RootSys -&gt; (@@)</A></H5>
<H5>Coroots(R) : RootSys -&gt; (@@)</H5>

<PRE>    Basis: MonStgElt                    Default: "Standard"</PRE>
<BLOCKQUOTE>
The indexed set of (co)roots of the root system R, i.e. 
{@ &alpha;<sub>1</sub>, ... &alpha;<sub>2N</sub> @} 
(respectively, {@ &alpha;<sub>1</sub><sup>star</sup>, ... &alpha;<sub>2N</sub><sup>star</sup> @}).
</BLOCKQUOTE>
<H5><A NAME = "12055">PositiveRoots(R) : RootSys -&gt; (@@)</A></H5>
<H5>PositiveCoroots(R) : RootSys -&gt; (@@)</H5>

<PRE>    Basis: MonStgElt                    Default: "Standard"</PRE>
<BLOCKQUOTE>
The indexed set of positive
(co)rootsof the root system R, 
i.e. {@ &alpha;<sub>1</sub>, ... &alpha;<sub>N</sub> @} 
(respectively, {@ &alpha;<sub>1</sub><sup>star</sup>, ... &alpha;<sub>N</sub><sup>star</sup> @}).
</BLOCKQUOTE>
<H5><A NAME = "12056">Root(R, r) : RootSys, RngIntElt -&gt; (@@)</A></H5>
<H5>Coroot(R, r) : RootSys, RngIntElt -&gt; (@@)</H5>

<PRE>    Basis: MonStgElt                    Default: "Standard"</PRE>
<BLOCKQUOTE>
The rth (co)root &alpha;<sub>r</sub> (respectively, &alpha;<sub>r</sub><sup>star</sup>) of 
the root system R.
</BLOCKQUOTE>
<H5><A NAME = "12057">RootPosition(R, v) : RootSys, . -&gt; (@@)</A></H5>
<H5>CorootPosition(R, v) : RootSys, . -&gt; (@@)</H5>

<PRE>    Basis: MonStgElt                    Default: "Standard"</PRE>
<BLOCKQUOTE>
If v is a (co)root in the root system R, return its index;
otherwise return 0. These functions will try to coerce v, which can be a vector or a sequence
representing a vector, into the appropriate vector space;  v should be written with
respect to the basis specified by the parameter <TT>Basis</TT>.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "12058">Example <TT>RootSys_RootsCoroots (H102E10)</TT></A></H3>
<P>
<P>
<PRE>
&gt; A := Matrix(2,3, [1,-1,0, -1,1,-1]);
&gt; B := Matrix(2,3, [1,-1,1, 0,1,-1]);
&gt; R := RootSystem(A, B);
&gt; Roots(R);
{@
    (1 -1  0),
    (-1  1 -1),
    (0  0 -1),
    (1 -1 -1),
    (2 -2 -1),
    (1 -1 -2),
    (-1  1  0),
    (1 -1  1),
    (0 0 1),
    (-1  1  1),
    (-2  2  1),
    (-1  1  2)
@}
&gt; PositiveCoroots(R);
{@
    (1 -1  1),
    (0  1 -1),
    (1  2 -2),
    (2  1 -1),
    (1 0 0),
    (1  1 -1)
@}
&gt; #Roots(R) eq 2*NumPosRoots(R);
true
&gt; Root(R, 4);
(1 -1 -1)
&gt; Root(R, 4 : Basis := "Root");
(2 1)
&gt; RootPosition(R, [1,-1,-1]);
4
&gt; RootPosition(R, [2,1] : Basis := "Root");
4
</PRE>
<HR>
<H5><A NAME = "12059">HighestRoot(R) : RootSys -&gt; .</A></H5>
<H5>HighestCoroot(R) : RootSys  -&gt; .</H5>

<PRE>    Basis: MonStgElt                    Default: "Standard"</PRE>
<BLOCKQUOTE>
The unique (co)root of greatest
heightin the irreducible
root system R. 
</BLOCKQUOTE>
<H5><A NAME = "12060">HighestLongRoot(R) : RootSys  -&gt; .</A></H5>
<H5>HighestLongCoroot(R) : RootSys  -&gt; .</H5>

<PRE>    Basis: MonStgElt                    Default: "Standard"</PRE>
<BLOCKQUOTE>
The unique long (co)root of greatest
heightin the irreducible
root system R. 
</BLOCKQUOTE>
<H5><A NAME = "12061">HighestShortRoot(R) : RootSys  -&gt; .</A></H5>
<H5>HighestShortCoroot(R) : RootSys  -&gt; .</H5>

<PRE>    Basis: MonStgElt                    Default: "Standard"</PRE>
<BLOCKQUOTE>
The unique short (co)root of greatest heightin the
irreducible root system R.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "12062">Example <TT>RootSys_HeighestRoots (H102E11)</TT></A></H3>
<P>
<P>
<PRE>
&gt; R := RootSystem("G2");
&gt; HighestRoot(R);
(3 2)
&gt; HighestLongRoot(R);
(3 2)
&gt; HighestShortRoot(R);
(2 1)
</PRE>
<HR>
<H5><A NAME = "12063">CoxeterForm(R) : RootSys -&gt; AlgMatElt</A></H5>
<H5>DualCoxeterForm(R) : RootSys -&gt; AlgMatElt</H5>

<PRE>    Basis: MonStgElt                    Default: "Standard"</PRE>
<BLOCKQUOTE>
The matrix of an inner producton 
the (co)root space of the root system R which is invariant under the action of the (co)roots.  
This inner product is uniquely determined up to a constant on each irreducible 
component of R.  The inner product is normalised so that the short roots in each
crystallographic component have length one.
</BLOCKQUOTE>
<H4><A NAME = "12064">Reflections</A></H4>

<P>
<P>
<P>
<P>
The root &alpha; acts on the root space via the reflection s<sub>&alpha;</sub>; the
coroot &alpha;<sup>star</sup> acts on the coroot space via the coreflection
s<sub>&alpha;</sub><sup>star</sup>.


<H5><A NAME = "12065">SimpleReflectionMatrices(R) : RootSys -&gt; []</A></H5>
<H5>SimpleCoreflectionMatrices(R) : RootSys -&gt; []</H5>

<PRE>    Basis: MonStgElt                    Default: "Standard"</PRE>
<BLOCKQUOTE>
The sequence of  matrices giving the action of the simple
(co)roots of the root system R on the (co)root
space, i.e. the matrices of s<sub>&alpha;<sub>1</sub></sub>, ..., s<sub>&alpha;<sub>n</sub></sub>
(respectively, s<sub>&alpha;<sub>1</sub></sub><sup>star</sup>, ..., s<sub>&alpha;<sub>n</sub></sub><sup>star</sup>).
</BLOCKQUOTE>
<H5><A NAME = "12066">ReflectionMatrices(R) : RootSys -&gt; []</A></H5>
<H5>CoreflectionMatrices(R) : RootSys -&gt; []</H5>

<PRE>    Basis: MonStgElt                    Default: "Standard"</PRE>
<BLOCKQUOTE>
The sequence of matrices giving the action of the (co)roots of
the root system R on the (co)root
space, i.e. the matrices of s<sub>&alpha;<sub>1</sub></sub>, ..., s_(&alpha;<sub>2N</sub>)
(respectively, s<sub>&alpha;<sub>1</sub></sub><sup>star</sup>, ..., s_(&alpha;<sub>2N</sub>)<sup>star</sup>).
</BLOCKQUOTE>
<H5><A NAME = "12067">ReflectionMatrix(R, r) : RootSys, RngIntElt -&gt; []</A></H5>
<H5>CoreflectionMatrix(R, r) : RootSys, RngIntElt -&gt; []</H5>

<PRE>    Basis: MonStgElt                    Default: "Standard"</PRE>
<BLOCKQUOTE>
The matrix giving the action of the rth (co)root of the root system
R on the (co)root space, i.e. the matrix of s<sub>&alpha;<sub>r</sub></sub>
(respectively, s<sub>&alpha;<sub>r</sub></sub><sup>star</sup>).
</BLOCKQUOTE>
<H5><A NAME = "12068">SimpleReflectionPermutations(R) : RootSys -&gt; []</A></H5>
<BLOCKQUOTE>
The sequence of permutations giving the action of the simple (co)roots
of the root system R on the (co)roots.  
This action is the same for roots and coroots.
</BLOCKQUOTE>
<H5><A NAME = "12069">ReflectionPermutations(R) : RootSys -&gt; []</A></H5>
<BLOCKQUOTE>
The sequence of permutations giving the action of the (co)roots of the 
root system R on the (co)roots.   
This action is the same for roots and coroots.
</BLOCKQUOTE>
<H5><A NAME = "12070">ReflectionPermutation(R, r) : RootSys, RngIntElt -&gt; []</A></H5>
<BLOCKQUOTE>
The permutation giving the action of the rth (co)root of the root
system R on the (co)roots.
This action is the same for roots and coroots.
</BLOCKQUOTE>
<H5><A NAME = "12071">ReflectionWords(R) : RootSys -&gt; []</A></H5>
<BLOCKQUOTE>
The sequence of words  in the simple reflections for all
the reflections of the root system R.
These words are given as sequences of integers.
In other words, if [a<sub>1</sub>, ..., a<sub>l</sub>] = ReflectionWords(R)[r],
then s<sub>&alpha;<sub>r</sub></sub> = s_(&alpha;<sub>a<sub>1</sub></sub>) ... s_(&alpha;<sub>a<sub>l</sub></sub>).
</BLOCKQUOTE>
<H5><A NAME = "12072">ReflectionWord(R, r) : RootSys, RngIntElt -&gt; []</A></H5>
<BLOCKQUOTE>
The word in the simple reflections for the rth
reflection of the root system R.
The word is given as a sequence of integers.
In other words, if [a<sub>1</sub>, ..., a<sub>l</sub>] = ReflectionWord(R, r),
then s<sub>&alpha;<sub>r</sub></sub> = s_(&alpha;<sub>a<sub>1</sub></sub>) ... s_(&alpha;<sub>a<sub>l</sub></sub>).
</BLOCKQUOTE>
<HR>
<H3><A NAME = "12073">Example <TT>RootSys_Action (H102E12)</TT></A></H3>
<P>
<P>
<PRE>
&gt; R := RootSystem("B3");
&gt; mx := ReflectionMatrix(R, 4);
&gt; perm := ReflectionPermutation(R, 4);
&gt; wd := ReflectionWord(R, 4);
&gt; RootPosition(R, Root(R,2) * mx) eq 2^perm;
true
&gt; perm eq &amp;*[ ReflectionPermutation(R, r) : r in wd ];
true
&gt; 
&gt; mx := CoreflectionMatrix(R, 4);
&gt; CorootPosition(R, Coroot(R,2) * mx) eq 2^perm;
true
</PRE>
<HR>
<H4><A NAME = "12074">Operations and Properties for  Roots and Coroot Indices</A></H4>



<H5><A NAME = "12075">Sum(R, r, s) : RootSys, RngIntElt, RngIntElt -&gt; RngIntElt</A></H5>
<BLOCKQUOTE>
The index of the sum of the rth and sth roots in the crystallographic 
root system R, or 0 if the sum is not a root.
In other words, if t=hbox(Sum(R,r,s))ne0 then 
&alpha;<sub>t</sub>=&alpha;<sub>r</sub> + &alpha;<sub>s</sub>. 
We require &alpha;<sub>r</sub>&ne;&#8723;&alpha;<sub>s</sub>.
</BLOCKQUOTE>
<H5><A NAME = "12076">IsPositive(R, r) : RootSys, RngIntElt -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if, and only if, the rth (co)root of the root system R is a 
positive root.
</BLOCKQUOTE>
<H5><A NAME = "12077">IsNegative(R, r) : RootSys, RngIntElt -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if, and only if, the rth (co)root of the root system R is a 
negative root.
</BLOCKQUOTE>
<H5><A NAME = "12078">Negative(R, r) : RootSys, RngIntElt -&gt; RngIntElt</A></H5>
<BLOCKQUOTE>
The index of the negative of the rth (co)root of the root system R.  
In other words, if s = hbox(Negative(R,r)) then &alpha;<sub>s</sub>= - &alpha;<sub>r</sub>.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "12079">Example <TT>RootSys_RootArithmetic (H102E13)</TT></A></H3>
<P>
<P>
<PRE>
&gt; R := RootSystem("G2");
&gt; Sum(R, 1, Negative(R,5));
10
&gt; IsPositive(R, 10);
false
&gt; Negative(R, 10);
4
&gt; P := PositiveRoots(R);
&gt; P[1] - P[5] eq -P[4];
true
</PRE>
<HR>
<H5><A NAME = "12080">RootHeight(R, r) : RootSys, RngIntElt -&gt; RngIntElt</A></H5>
<H5>CorootHeight(R, r) : RootSys, RngIntElt -&gt; RngIntElt</H5>
<BLOCKQUOTE>
The height of the rth (co)root of the root system 
R, 
i.e. the sum of the coefficients of &alpha;<sub>r</sub> 
(respectively, &alpha;<sub>r</sub><sup>star</sup>)
with respect to the simple (co)roots.
</BLOCKQUOTE>
<H5><A NAME = "12081">RootNorms(R) : RootSys -&gt; [RngIntElt]</A></H5>
<H5>CorootNorms(R) : RootSys -&gt; [RngIntElt]</H5>
<BLOCKQUOTE>
The sequence of squares of the 
lengthsof the (co)roots
of the root system R.
</BLOCKQUOTE>
<H5><A NAME = "12082">RootNorm(R, r) : RootSys, RngIntElt -&gt; RngIntElt</A></H5>
<H5>CorootNorm(R, r) : RootSys, RngIntElt -&gt; RngIntElt</H5>
<BLOCKQUOTE>
The square of the length of the rth (co)root of the root system R.
</BLOCKQUOTE>
<H5><A NAME = "12083">IsLongRoot(R, r) : RootSys, RngIntElt -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if, and only if, the rth root of the root system R is long.
This only makes sense for irreducible crystallographic root systems.
Note that for non-reduced root systems, the roots which are not indivisible 
are actually longer than the long ones.
</BLOCKQUOTE>
<H5><A NAME = "12084">IsShortRoot(R, r) : RootSys, RngIntElt -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if, and only if, the rth root of the root system R is short.
This only makes sense for irreducible crystallographic root systems.
</BLOCKQUOTE>
<H5><A NAME = "12085">IsIndivisibleRoot(R, r) : RootSys, RngIntElt -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if, and only if, the rth root of the root system R is indivisible, ie, &alpha;<sub>r</sub>/2 is not a root.
</BLOCKQUOTE>
<H5><A NAME = "12086">LeftString(R, r, s) : RootSys, RngIntElt, RngIntElt -&gt; RngIntElt</A></H5>
<BLOCKQUOTE>
Indices in the crystallographic root system R of the left string through &alpha;<sub>s</sub> in the
direction of &alpha;<sub>r</sub>, i.e. the indices of 
&alpha;<sub>s</sub> - &alpha;<sub>r</sub>, &alpha;<sub>s</sub> - 2&alpha;<sub>r</sub>, ..., &alpha;<sub>s</sub> - p&alpha;<sub>r</sub>.   
In other words, this returns the sequence [r<sub>1</sub>, ..., r<sub>p</sub>] where 
&alpha;<sub>r<sub>i</sub></sub>=&alpha;<sub>s</sub> - i&alpha;<sub>r</sub> and &alpha;<sub>s</sub> - (p + 1)&alpha;<sub>r</sub> is not a root.  
We require that &alpha;<sub>r</sub>&ne;&#8723;&alpha;<sub>s</sub>.
</BLOCKQUOTE>
<H5><A NAME = "12087">RightString(R, r, s) : RootSys, RngIntElt, RngIntElt -&gt; RngIntElt</A></H5>
<BLOCKQUOTE>
Indices in the crystallographic root system R of the left string through &alpha;<sub>s</sub> in the
direction of &alpha;<sub>r</sub>, i.e. the indices of 
&alpha;<sub>s</sub> + &alpha;<sub>r</sub>, &alpha;<sub>s</sub> + 2&alpha;<sub>r</sub>, ..., &alpha;<sub>s</sub> + q&alpha;<sub>r</sub>. In other words,
this returns the sequence [r<sub>1</sub>, ..., r<sub>q</sub>] where
&alpha;<sub>r<sub>i</sub></sub>=&alpha;<sub>s</sub> + i&alpha;<sub>r</sub> and &alpha;<sub>s</sub> + (q + 1)&alpha;<sub>r</sub> is not a root.  
We require that &alpha;<sub>r</sub>&ne;&#8723;&alpha;<sub>s</sub>.
</BLOCKQUOTE>
<H5><A NAME = "12088">LeftStringLength(R, r, s) : RootSys, RngIntElt, RngIntElt -&gt; RngIntElt</A></H5>
<BLOCKQUOTE>
The largest p such that &alpha;<sub>s</sub> - p&alpha;<sub>r</sub> is a root.  
We require that the root system R be crystallographic and &alpha;<sub>s</sub>&ne;&#8723;&alpha;<sub>r</sub>.  
</BLOCKQUOTE>
<H5><A NAME = "12089">RightStringLength(R, r, s) : RootSys, RngIntElt, RngIntElt -&gt; RngIntElt</A></H5>
<BLOCKQUOTE>
The largest q such that &alpha;<sub>s</sub> + q&alpha;<sub>r</sub> is a root.
We require that the root system R be crystallographic and &alpha;<sub>s</sub>&ne;&#8723;&alpha;<sub>r</sub>.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "12090">Example <TT>RootSys_RootOperations (H102E14)</TT></A></H3>
<P>
<P>
<PRE>
&gt; R := RootSystem("G2");
&gt; RootHeight(R, 5);
4
&gt; F := CoxeterForm(R);
&gt; v := Root(R, 5);
&gt; (v*F, v) eq RootNorm(R, 5);
true
&gt; IsLongRoot(R, 5);
true
&gt; LeftString(R, 1, 5);
[ 4, 3, 2 ]
&gt; roots := Roots(R);
&gt; for i in [1..3] do
&gt;   RootPosition(R, roots[5]-i*roots[1]);
&gt; end for;
4
3
2
&gt; R := RootSystem("BC2");
&gt; Root(R,2), IsIndivisibleRoot(R,2);
(0 1) true
&gt; Root(R,4), IsIndivisibleRoot(R,4);
(0 2) false
</PRE>
<HR>
<H5><A NAME = "12091">AdditiveOrder(R) : RootSys -&gt; SeqEnum</A></H5>
<BLOCKQUOTE>
An additive orderon the positive roots of the
root system R,
ie. a sequence containing the numbers 1, ..., N in some order so
that &alpha;<sub>r</sub> + &alpha;<sub>s</sub>=&alpha;<sub>t</sub> implies t is between r and s.  This is
computed using the techniques of <A  HREF = "text1078.htm#bib_Papi">[Pap94]</A>.
</BLOCKQUOTE>
<H5><A NAME = "12092">IsAdditiveOrder(R, Q) : RootSys, [RngIntElt] -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if, and only if, the sequence Q gives an additive order on a set
of positive roots of the root system R.  
Q must be a sequence of integers in the range [1..N], where N is the number
of positive roots of R, with no gaps or repeats.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "12093">Example <TT>RootSys_AdditiveOrder (H102E15)</TT></A></H3>
<P>
<P>
<PRE>
&gt; R := RootSystem("A5");
&gt; a := AdditiveOrder(R);
&gt; Position(a, 2);
6
&gt; Position(a, 3);
10
&gt; Position(a, Sum(R, 2, 3));
7
</PRE>
<HR>
<PRE></PRE> <A  HREF = "text1085.htm">[Next]</A><A  HREF = "text1083.htm">[Prev]</A> <A  HREF = "text1085.htm">[Right]</A> <A  HREF = "text1083.htm">[Left]</A> <A  HREF = "text1079.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<br><small>Version: V2.22 of <I>
Thu Jun  9 16:37:49 EST 2016
</I></small>
</body></html>