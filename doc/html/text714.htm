<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <link rel='stylesheet' href='help.css' type='text/css'>
  <TITLE>Subgroups</TITLE>
</head>
<body BGCOLOR="#FFFFFF">

 <A  HREF = "text715.htm">[Next]</A><A  HREF = "text713.htm">[Prev]</A> <A  HREF = "text715.htm">[Right]</A> <A  HREF = "text713.htm">[Left]</A> <A  HREF = "text706.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<PRE></PRE><H3><A NAME = "8081">Subgroups</A></H3>

<P>
<P>
Subgroups of pc-groups are treated as independent pc-groups in their
own right, with the subgroup relationship maintained in internal data
structures.  Thus, a subgroup has generators and a pc-presentation
and one can apply any of the functions described earlier for groups.
Furthermore, there are a variety of functions and operations specifically
involving subgroups.



<H5>Subsections</H5>
<UL>
<LI> <A  HREF = "text714.htm#8082">Definition of Subgroups by Generators</A>
<LI> <A  HREF = "text714.htm#8086">Membership and Coercion</A>
<LI> <A  HREF = "text714.htm#8093">Inclusion and Equality</A>
<LI> <A  HREF = "text714.htm#8101">Standard Subgroup Constructions</A>
<LI> <A  HREF = "text714.htm#8112">Properties of Subgroups</A>
<LI> <A  HREF = "text714.htm#8115">Predicates for Subgroups</A>
<LI> <A  HREF = "text714.htm#8123">Hall &pi;-Subgroups and Sylow Systems</A>
<LI> <A  HREF = "text714.htm#8131">Conjugacy Classes of Subgroups</A>
</UL>
<H4><A NAME = "8082">Definition of Subgroups by Generators</A></H4>

<P>
<P>
The most flexible method of defining a subgroup is to list generators
or normal generators for the subgroup.


<H5><A NAME = "8083">sub&lt;G | L&gt; : GrpPC, List -&gt; GrpPC, Map</A></H5>
<BLOCKQUOTE>
Construct the subgroup H of the pc-group G generated by the elements
specified by the terms of the <I>generator list</I> L.
<P>
A term L[i] of the generator list may consist of any of the following objects:
<DL COMPACT class='compact'>
<DT>(a)</DT><DD>An element liftable to G (in particular, any element of G);
<DT>(b)</DT><DD>A subgroup of G;
<DT>(c)</DT><DD>A set or sequence of (a), or (b).
<P>
<P>
</DL>
The collection of words and groups specified by the list must all belong to the
group G and H will be constructed as a subgroup of G.
<P>
The subgroup H is defined to be
generated by the words specified directly by terms L[i]
together with the stored generating words for any groups specified by terms
of L[i]. Magma will compute a set of pc-generators for H and, if
H is a p-group, a minimal generating set.
<P>
The inclusion map from H to G is returned as well.
</BLOCKQUOTE>
<H5><A NAME = "8084">ncl&lt;G | L&gt; : GrpPC, List -&gt; GrpPC, Map</A></H5>
<BLOCKQUOTE>
Construct the subgroup N of the pc-group G as the normal closure
of the subgroup generated by the elements specified by the terms of the
<I>generator list</I> L.
<P>
The possible forms of a term L[i] of the generator list are the
same as for the <TT>sub</TT>-constructor.
<P>
The inclusion map from N to G is returned as well.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "8085">Example <TT>GrpPC_sub_creation (H68E13)</TT></A></H3>
We define G to be Z<sub>5</sub> wr Z<sub>3</sub> and then create two
subgroups.  Notice that the <TT>ncl</TT>-constructor
builds a larger subgroup in this case.
<P>
<P>
<PRE>
&gt; G&lt;a,b,c,d&gt; := PolycyclicGroup&lt;a,b,c,d| a^3, b^5, c^5, d^5,
&gt;   b^a = c, c^a = d, d^a = b&gt;;
&gt; H := sub&lt;G| b,c&gt;;
&gt; Order(H);
25
&gt; IsAbelian(H);
true
&gt; IsNormal(G, H);
false
&gt; N := ncl&lt;G| b,c&gt;;
&gt; IsNormal(G, N);
true
&gt; Order(N);
125
</PRE>
<HR>
<H4><A NAME = "8086">Membership and Coercion</A></H4>

<P>
<P>
There are several functions and operators which allow one to
take advantage of the subgroup relationship to rewrite elements
from one presentation to another.  That is, if x is an element of
H which is a subgroup of G, then x has a representation as
a normal word in the pc-generators of H, but also has a
representation as a (different) normal word in the pc-generators
of G.  The coercion operator and inclusion map allow one to
compute one of these words based on the other, thus shifting where
we view the element in question.
<P>
Magma keeps track of the various relationships between
subgroups in a group.  Thus, if H is a subgroup of K which
is a subgroup of G, then H can also be considered a subgroup
G.  Similarly, in situations involving elements of two
groups, A and B, Magma will often try to find
a <I>covering group</I> C which contains both of A and B.
In this case, the elements may be automatically coerced into
the covering group.


<H5><A NAME = "8087">g in G : GrpPCElt, GrpPC -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Given an element g and a group G, return <TT>true</TT> if g is an element
of G, <TT>false</TT> otherwise.  In order for this comparison to make sense,
both g and G must be contained in some covering group.
</BLOCKQUOTE>
<H5><A NAME = "8088">g notin G : GrpPCElt, GrpPC -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Given an element g and a group G, return <TT>true</TT> if g is not an
element of G, <TT>false</TT> otherwise. In order for this comparison to make sense,
both g and G must be contained in some covering group.
</BLOCKQUOTE>
<H5><A NAME = "8089">G ! g : GrpPC, GrpPCElt -&gt; GrpPCElt</A></H5>
<BLOCKQUOTE>
Given an element g belonging to some subgroup H of the group G,
rewrite g as an element of G.
</BLOCKQUOTE>
<H5><A NAME = "8090">H ! g : GrpPC, GrpPCElt -&gt; GrpPCElt</A></H5>
<BLOCKQUOTE>
Given an element g belonging to the group G, and given a subgroup
H of G containing g, rewrite g as an element of H.
</BLOCKQUOTE>
<H5><A NAME = "8091">K ! g : GrpPC, GrpPCElt -&gt; GrpPCElt</A></H5>
<BLOCKQUOTE>
Given an element g belonging to the group H, and a group K, such that
H and K are subgroups of a covering group G, and both H and K contain g,
rewrite g as an element of K.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "8092">Example <TT>GrpPC_coercion (H68E14)</TT></A></H3>
We create two subgroups of a dihedral group.
<P>
<P>
<PRE>
&gt; G := DihedralGroup(GrpPC, 10);
&gt; C := sub&lt;G| G.2&gt;;
&gt; H := sub&lt;G| G.1, G.3&gt;;
&gt; H.1 in C;
false
&gt; H.2 in C;
true
&gt; Parent(H.1);
GrpPC : H of order 10 = 2 * 5
PC-Relations:
    H.1^2 = Id(H),
    H.2^5 = Id(H),
    H.2^H.1 = H.2^4
&gt; G!(H.1);
G.1
</PRE>
Magma will compute appropriate covering groups
as needed.
<P>
<P>
<PRE>
&gt; H.1*C.1;
G.1 * G.2 * G.3^2
&gt; x := (H.1, C.2);
&gt; x;
G.3^2
&gt; H!x;
H.2^2
&gt; C!x;
C.2^2
&gt; C!(H.2);
C.2
</PRE>
<HR>
<H4><A NAME = "8093">Inclusion and Equality</A></H4>



<H5><A NAME = "8094">S subset G : { GrpPCElt } , GrpPC -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Given a group G and a set S of elements belonging to a group H,
where G and H have some covering group, return <TT>true</TT> if S is
a subset of G, <TT>false</TT> otherwise.
</BLOCKQUOTE>
<H5><A NAME = "8095">S notsubset G : { GrpPCElt } , GrpPC -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Given a group G and a set S of elements belonging to a group H,
where G and H have some covering group, return <TT>true</TT> if S is
not a subset of G, <TT>false</TT> otherwise.
</BLOCKQUOTE>
<H5><A NAME = "8096">H subset G : GrpPC, GrpPC -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Given groups G and H, subgroups of some covering group, return
<TT>true</TT> if H is a subgroup of G, <TT>false</TT> otherwise.
</BLOCKQUOTE>
<H5><A NAME = "8097">H notsubset G : GrpPC, GrpPC -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Given groups G and H, subgroups of some covering group, return
<TT>true</TT> if H is not a subgroup of G, <TT>false</TT> otherwise.
</BLOCKQUOTE>
<H5><A NAME = "8098">G eq H : GrpPC, GrpPC -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Given groups G and H, subgroups of some covering group, return
<TT>true</TT> if G and H are the same group, <TT>false</TT> otherwise.
</BLOCKQUOTE>
<H5><A NAME = "8099">G ne H : GrpPC, GrpPC -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Given groups G and H, subgroups of some covering group, return
<TT>true</TT> if G and H are distinct groups, <TT>false</TT> otherwise.
</BLOCKQUOTE>
<H5><A NAME = "8100">InclusionMap(G, H) : GrpPC, GrpPC -&gt; Map</A></H5>
<BLOCKQUOTE>
The map from the subgroup H of G to G.
</BLOCKQUOTE>
<H4><A NAME = "8101">Standard Subgroup Constructions</A></H4>

<P>
<P>
<P>
The operators and functions which construct a subgroup of a pc-group always
return the subgroup as a pc-group.


<H5><A NAME = "8102">H ^ g : GrpPC, GrpPCElt -&gt; GrpPC</A></H5>
<H5>Conjugate(H, g) : GrpPC, GrpPCElt -&gt; GrpPC</H5>
<BLOCKQUOTE>
Construct the conjugate g<sup> - 1</sup> * H * g of the group H under the action
of the element g. The group H and the element g must belong
to a common group.
</BLOCKQUOTE>
<H5><A NAME = "8103">H meet K : GrpPC, GrpPC -&gt; GrpPC</A></H5>
<BLOCKQUOTE>
The intersection of groups H and K.  The algorithm used
for non-p-groups is described in <A  HREF = "text705.htm#bib_gs_intnorm">[GS90]</A>.
</BLOCKQUOTE>
<H5><A NAME = "8104">H meet:= K : GrpPC, GrpPC -&gt; GrpPC</A></H5>
<BLOCKQUOTE>
Replace H with the intersection of groups H and K.
</BLOCKQUOTE>
<H5><A NAME = "8105">CommutatorSubgroup(G, H, K) : GrpPC, GrpPC, GrpPC -&gt; GrpPC</A></H5>
<H5>CommutatorSubgroup(H, K) : GrpPC, GrpPC -&gt; GrpPC</H5>
<BLOCKQUOTE>
Construct the commutator subgroup of groups H and K, where H and
K are subgroups of a common group G.
</BLOCKQUOTE>
<H5><A NAME = "8106">Centralizer(G, g) : GrpPC, GrpPCElt -&gt; GrpPC</A></H5>
<H5>Centraliser(G, g) : GrpPC, GrpPCElt -&gt; GrpPC</H5>
<BLOCKQUOTE>
The centralizer of the element g in the group G.
</BLOCKQUOTE>
<H5><A NAME = "8107">Centralizer(G, H) : GrpPC, GrpPC -&gt; GrpPC</A></H5>
<H5>Centraliser(G, H) : GrpPC, GrpPC -&gt; GrpPC</H5>
<BLOCKQUOTE>
The centralizer of the subgroup H in the group G.
</BLOCKQUOTE>
<H5><A NAME = "8108">Core(G, H) : GrpPC, GrpPC -&gt; GrpPC</A></H5>
<BLOCKQUOTE>
The maximal normal subgroup of G that is contained in the subgroup
H of G.
</BLOCKQUOTE>
<H5><A NAME = "8109">H ^ G : GrpPC, GrpPC -&gt; GrpPC</A></H5>
<H5>NormalClosure(G, H) : GrpPC, GrpPC -&gt; GrpPC</H5>
<BLOCKQUOTE>
The normal closure of the subgroup H in the group G.
</BLOCKQUOTE>
<H5><A NAME = "8110">Normalizer(G, H) : GrpPC, GrpPC -&gt; GrpPC</A></H5>
<H5>Normaliser(G, H) : GrpPC, GrpPC -&gt; GrpPC</H5>
<BLOCKQUOTE>
The normalizer of the subgroup H of the group G.  The algorithm used
for non-p-groups is described in <A  HREF = "text705.htm#bib_gs_intnorm">[GS90]</A>.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "8111">Example <TT>GrpPC_subgroup-constructions (H68E15)</TT></A></H3>
We'll consider various subgroups of a direct product
of a cyclic group of order 6 and dihedral group of order 10.
<P>
<P>
<PRE>
&gt; G := DirectProduct(CyclicGroup(GrpPC,6), DihedralGroup(GrpPC,5));
&gt; x := G.3;
&gt; C := Centralizer(G,x);
&gt; C;
GrpPC : C of order 12 = 2^2 * 3
PC-Relations:
    C.1^2 = Id(C),
    C.2^2 = Id(C),
    C.3^3 = Id(C)
&gt; H := sub&lt;G|G.2,G.4&gt;;
&gt; Order(H);
15
</PRE>
We can compute the intersection using the <TT>meet</TT> operator.
<P>
<P>
<PRE>
&gt; K := H meet C;
&gt; K;
GrpPC : K of order 3
PC-Relations:
    K.1^3 = Id(K)
</PRE>
To get the join of two subgroups, we simply use the <TT>sub</TT>-constructor.
<P>
<P>
<PRE>
&gt; J := sub&lt;G|H, C&gt;;
&gt; J eq G;
true
</PRE>
<HR>
<H4><A NAME = "8112">Properties of Subgroups</A></H4>



<H5><A NAME = "8113">Index(G, H) : GrpPC, GrpPC -&gt; RngIntElt</A></H5>
<BLOCKQUOTE>
The index of the subgroup H in the group G, returned as an
ordinary integer.
</BLOCKQUOTE>
<H5><A NAME = "8114">FactoredIndex(G, H) : GrpPC, GrpPC -&gt; [&lt;RngIntElt, RngIntElt&gt;]</A></H5>
<BLOCKQUOTE>
The factored index of the subgroup H in the group G.
</BLOCKQUOTE>
<H4><A NAME = "8115">Predicates for Subgroups</A></H4>



<H5><A NAME = "8116">IsCentral(G, H) : GrpPC, GrpPC -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if the subgroup H of the group G lies in the centre of G,
<TT>false</TT> otherwise.
</BLOCKQUOTE>
<H5><A NAME = "8117">IsConjugate(G, H, K) : GrpPC, GrpPC, GrpPC -&gt; BoolElt, GrpPCElt</A></H5>
<BLOCKQUOTE>
Given a group G and subgroups H and K belonging to G, return the
value <TT>true</TT> if H and K are conjugate in G. The function returns a
second value in the event that the subgroups are conjugate: an element
z which conjugates H into K.
</BLOCKQUOTE>
<H5><A NAME = "8118">IsMaximal(G, H) : GrpPC, GrpPC -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if the subgroup H of the group G is a maximal subgroup of G,
<TT>false</TT> otherwise.
</BLOCKQUOTE>
<H5><A NAME = "8119">IsNormal(G, H) : GrpPC, GrpPC -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if the subgroup H of the group G is a normal subgroup of G,
<TT>false</TT> otherwise.
</BLOCKQUOTE>
<H5><A NAME = "8120">IsSelfNormalizing(G, H) : GrpPC, GrpPC -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if the subgroup H of the group G is self-normalizing
in G, <TT>false</TT> otherwise.
</BLOCKQUOTE>
<H5><A NAME = "8121">IsSubnormal(G, H) : GrpPC, GrpPC -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if the subgroup H of the group G is subnormal in G, <TT>false</TT>
otherwise.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "8122">Example <TT>GrpPC_sub-predicates (H68E16)</TT></A></H3>
<P>
<P>
<PRE>
&gt; G := PCGroup(Sym(4));
&gt; G;
GrpPC : G of order 24 = 2^3 * 3
PC-Relations:
    G.1^2 = Id(G),
    G.2^3 = Id(G),
    G.3^2 = Id(G),
    G.4^2 = Id(G),
    G.2^G.1 = G.2^2,
    G.3^G.1 = G.3 * G.4,
    G.3^G.2 = G.4,
    G.4^G.2 = G.3 * G.4
&gt; U := sub&lt;G|G.4&gt;;
&gt; IsNormal(G,U);
false
&gt; IsSubnormal(G,U);
true
</PRE>
Now, we try to construct a subnormal chain by taking
normalizers.
<P>
<P>
<PRE>
&gt; N1 := Normalizer(G,U);
&gt; Index(G,N1);
3
&gt; N2 := Normalizer(G,N1);
&gt; Index(G,N2);
3
&gt; N1 eq N2;
true
</PRE>
We're stuck.  However, we can work our way down with
<TT>NormalClosure</TT>.
<P>
<P>
<PRE>
&gt; M1 := NormalClosure(G,U);
&gt; U subset M1;
true
&gt; M1 subset U;
false
&gt; M2 := NormalClosure(M1,U);
&gt; M2 eq U;
true
</PRE>
Now, we work inside the Sylow 2-subgroup and look for
complements of the cyclic group of order 4 by brute
force.
<P>
<P>
<PRE>
&gt; S := Sylow(G,2);
&gt; S;
GrpPC : S of order 8 = 2^3
PC-Relations:
    S.2^S.1 = S.2 * S.3
&gt; T := sub&lt;S|S.1*S.2&gt;;
&gt; list := [];
&gt; for x in S do
&gt;   if (Order(x) ne 2) or (x in T) then
&gt;     continue;
&gt;   end if;
&gt;   Append(~list, sub&lt;S|x&gt;);
&gt; end for;
&gt; #list;
4
&gt; for i in [1..3], j in [i+1..4] do
&gt;   print i,j,IsConjugate(S,list[i],list[j]);
&gt; end for;
1 2 true S.1
1 3 false
1 4 false
2 3 false
2 4 false
3 4 true S.2
</PRE>
We see that T has two conjugacy classes of complements.
<HR>
<H4><A NAME = "8123">Hall &pi;-Subgroups and Sylow Systems</A></H4>

<P>
<P>
The functions given here all assume that G is a soluble group having
order p<sub>1</sub><sup>e<sub>1</sub></sup>p<sub>2</sub><sup>e<sub>2</sub></sup> ... p<sub>k</sub><sup>e<sub>k</sub></sup>.


<H5><A NAME = "8124">ComplementBasis(G) : GrpPC -&gt; [GrpPC]</A></H5>
<BLOCKQUOTE>
A complement basis of the soluble group G. This is a sequence of k subgroups
of G, where the i-th subgroup has order p<sub>1</sub><sup>e<sub>1</sub></sup> ... p<sub>i - 1</sub>^
(e<sub>i - 1</sub>) p<sub>i + 1</sub><sup>e<sub>i + 1</sub></sup> ... p<sub>k</sub><sup>e<sub>k</sub></sup>,
i.e. the complements of the k Sylow subgroups of G.
</BLOCKQUOTE>
<H5><A NAME = "8125">HallSubgroup(G, S) : GrpPC, { RngIntElt }  -&gt; GrpPC</A></H5>
<H5>HallSubgroup(G, S) : GrpPC, RngIntElt -&gt; GrpPC</H5>
<BLOCKQUOTE>
The Hall &pi;-subgroup of G, where &pi; is defined by S.  The argument
S may be a set of primes, a single prime, 
or the negation of a single prime.  If S = - p,
then the Hall p'-subgroup of G is returned.
</BLOCKQUOTE>
<H5><A NAME = "8126">pCore(G, S) : GrpPC, { RngIntElt }  -&gt; GrpPC</A></H5>
<H5>pCore(G, S) : GrpPC, RngIntElt -&gt; GrpPC</H5>
<BLOCKQUOTE>
The core of the Hall &pi;-subgroup, where &pi; is defined by the argument S,
which has the same interpretation as for <TT>HallSubgroup</TT>.
</BLOCKQUOTE>
<H5><A NAME = "8127">SylowBasis(G) : GrpPC -&gt; [GrpPC]</A></H5>
<BLOCKQUOTE>
A Sylow basis for the soluble group G. This is a sequence of k
subgroups of G, having orders p<sub>1</sub><sup>e<sub>1</sub></sup>, ..., p<sub>k</sub><sup>e<sub>k</sub></sup>,
i.e. the k Sylow subgroups of G.
</BLOCKQUOTE>
<H5><A NAME = "8128">SylowSubgroup(G, p) : GrpPC, RngIntElt -&gt; GrpPC</A></H5>
<H5>Sylow(G, p) : GrpPC, RngIntElt -&gt; GrpPC</H5>
<BLOCKQUOTE>
A Sylow p-subgroup for the group G.
</BLOCKQUOTE>
<H5><A NAME = "8129">SystemNormalizer(G) : GrpPC -&gt; GrpPC</A></H5>
<H5>SystemNormaliser(G) : GrpPC -&gt; GrpPC</H5>
<BLOCKQUOTE>
The system normalizer for the group G.  The system normalizer of
the complement basis &Sigma; = { H<sub>1</sub>, ..., H<sub>k</sub> } is defined
to be the intersection of the normalizers in G of each H<sub>i</sub>, ie.
N(&Sigma;) = &cap;<sub>i=1</sub><sup>k</sup> N<sub>G</sub>(H<sub>i</sub>).
The algorithm used is derived directly from the definition.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "8130">Example <TT>GrpPC_Hall (H68E17)</TT></A></H3>
Given the group D<sub>3</sub> wreath D<sub>5</sub>, we can
construct the Hall 2-subgroup as follows:
<P>
<P>
<PRE>
&gt; H := DihedralGroup(GrpPerm, 5);
&gt; G := WreathProduct(DihedralGroup(GrpPC, 3), DihedralGroup(GrpPC, 5),
&gt;         [H.2, H.1]);
&gt; H2 := HallSubgroup(G, 2);
&gt; Order(H2);
64
</PRE>
The Hall 2'-subgroup of the same group is constructed as follows:
<P>
<P>
<PRE>
&gt; H35 := HallSubgroup(G, -2);
&gt; Order(H35);
1215
</PRE>
<HR>
<H4><A NAME = "8131">Conjugacy Classes of Subgroups</A></H4>

<P>
<P>
Magma has functions for computing the subgroups of a group
that return the subgroups either as a list of conjugacy class 
representatives as or as a poset.  Details of these functions
may be found in Chapter <A  HREF = "text612.htm#6615">GROUPS</A>.  Here we mention
the basic functions for convenience.


<H5><A NAME = "8132">SubgroupClasses(G) : GrpPC -&gt; SeqEnum</A></H5>
<H5>Subgroups(G) : GrpPC -&gt; SeqEnum</H5>
<BLOCKQUOTE>
Conjugacy class representatives for all subgroups of G.
The algorithm was developed by M. Slattery and
is essentially that of <A  HREF = "text705.htm#bib_hulpke_subs">[Hul99]</A>
without the action of automorphisms.
</BLOCKQUOTE>
<H5><A NAME = "8133">AbelianSubgroups(G) : GrpPC -&gt; SeqEnum</A></H5>
<H5>CyclicSubgroups(G) : GrpPC -&gt; SeqEnum</H5>
<H5>ElementaryAbelianSubgroups(G) : GrpPC -&gt; SeqEnum</H5>
<H5>NilpotentSubgroups(G) : GrpPC -&gt; SeqEnum</H5>
<BLOCKQUOTE>
Conjugacy class representatives for all subgroups of
the indicated type in G. 
The algorithm used is essentially that of <A  HREF = "text705.htm#bib_hulpke_subs">[Hul99]</A>
without the action of automorphisms.  Appropriate filters
are applied to select the desired groups at each
successive quotient in the computation.
</BLOCKQUOTE>
<H5><A NAME = "8134">LowIndexSubgroups(G, n) : GrpPC, RngIntElt -&gt; []</A></H5>
<BLOCKQUOTE>
Conjugacy class representatives for all subgroups of G having
index &le;n in G.
</BLOCKQUOTE>
<H5><A NAME = "8135">MaximalSubgroups(G) : GrpPC -&gt; [GrpPC]</A></H5>
<BLOCKQUOTE>
A sequence of conjugacy class representatives for the maximal 
subgroups of G.  The algorithm, developed by 
Charles Leedham-Green, relies on computing a special presentation 
for G.
</BLOCKQUOTE>
<H5><A NAME = "8136">SubgroupLattice(G) : GrpPC -&gt; SubGrpLat</A></H5>
<BLOCKQUOTE>
The lattice of conjugacy classes of subgroups of G.
</BLOCKQUOTE>
<H5><A NAME = "8137">BurnsideMatrix(G) : GrpPC -&gt; AlgMatElt</A></H5>
<BLOCKQUOTE>
The Burnside matrix corresponding to the lattice of subgroups of G.
The (i, j)th entry of the matrix is the number of subgroups in class i
contained in a single subgroup of class j when i&le;j, and is the
number of subgroups of class i containing a given subgroup in class j
when i&ge;j.
</BLOCKQUOTE>
<H5><A NAME = "8138">TableOfMarks(G) : GrpPC -&gt; AlgMatElt</A></H5>
<BLOCKQUOTE>
Burnside's table of marks corresponding to the lattice of subgroups of G.
Rows correspond to marks for transitive permutation representations of G,
while the entries in column j are the number of fixed points of subgroup
class j in each transitive representation.
</BLOCKQUOTE>
<H5><A NAME = "8139">DisplayBurnsideMatrix(G) : GrpPC -&gt;</A></H5>
<BLOCKQUOTE>
Pretty-print the Burnside matrix corresponding to the lattice of
subgroups of G.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "8140">Example <TT>GrpPC_SubgroupClasses (H68E18)</TT></A></H3>
To show a bit about subgroup classes, we look at the direct
product of C<sub>3</sub> and D<sub>3</sub>.  First we list out the normal
subgroups of G.
<P>
<P>
<PRE>
&gt; G := DirectProduct(CyclicGroup(GrpPC,3),
&gt;                      DihedralGroup(GrpPC,3));
&gt; ns := NormalSubgroups(G);
&gt; ns;
Conjugacy classes of subgroups
------------------------------

[1]     Order 1            Length 1
        GrpPC of order 1
        PC-Relations:
[2]     Order 3            Length 1
        GrpPC of order 3
        PC-Relations:
            $.1^3 = Id($)
[3]     Order 3            Length 1
        GrpPC of order 3
        PC-Relations:
            $.1^3 = Id($)
[4]     Order 6            Length 1
        GrpPC of order 6 = 2 * 3
        PC-Relations:
            $.1^2 = Id($), 
            $.2^3 = Id($), 
            $.2^$.1 = $.2^2
[5]     Order 9            Length 1
        GrpPC of order 9 = 3^2
        PC-Relations:
            $.1^3 = Id($), 
            $.2^3 = Id($)
[6]     Order 18           Length 1
        GrpPC of order 18 = 2 * 3^2
        PC-Relations:
            $.1^2 = Id($), 
            $.2^3 = Id($), 
            $.3^3 = Id($), 
            $.3^$.1 = $.3^2
</PRE>
The normal subgroups sequence has a special printing routine.
Each entry in the sequence is actually a record.
<P>
<P>
<PRE>
&gt; ns[2];
rec&lt;recformat&lt;order, length, subgroup, presentation&gt; |
 order := 3, length := 1, subgroup := GrpPC of order 3
PC-Relations:
    $.1^3 = Id($)&gt;
</PRE>
We extract the two normal subgroups of order 3.
Each of them turn out to have one conjugacy class
of complements in G.  However, one of the complements
is normal and the other is not.
<P>
<P>
<PRE>
&gt; N1 := ns[2]`subgroup;
&gt; N2 := ns[3]`subgroup;
&gt; c1 := Complements(G,N1);
&gt; c1;
[
    GrpPC of order 6 = 2 * 3
    PC-Relations:
        $.1^2 = Id($), 
        $.2^3 = Id($), 
        $.2^$.1 = $.2^2
]
&gt; c2 := Complements(G,N2);
&gt; c2;
[
    GrpPC of order 6 = 2 * 3
    PC-Relations:
        $.1^2 = Id($), 
        $.2^3 = Id($)
]
&gt; Index(G,Normalizer(G,c1[1]));
1
&gt; Index(G,Normalizer(G,c2[1]));
3
</PRE>
We can look at the full list of classes of
subgroups of G to see that there are
three classes of non-normal subgroups
as well as the normal subgroups.
There are two non-normal subgroups of
order 3 in addition to N1 and N2.
<P>
<P>
<PRE>
&gt; Subgroups(G);
Conjugacy classes of subgroups
------------------------------

[ 1]    Order 1            Length 1
        GrpPC of order 1
        PC-Relations:
[ 2]    Order 2            Length 3
        GrpPC of order 2
        PC-Relations:
            $.1^2 = Id($)
[ 3]    Order 3            Length 1
        GrpPC of order 3
        PC-Relations:
            $.1^3 = Id($)
[ 4]    Order 3            Length 1
        GrpPC of order 3
        PC-Relations:
            $.1^3 = Id($)
[ 5]    Order 3            Length 2
        GrpPC of order 3
        PC-Relations:
            $.1^3 = Id($)
[ 6]    Order 6            Length 1
        GrpPC of order 6 = 2 * 3
        PC-Relations:
            $.1^2 = Id($), 
            $.2^3 = Id($), 
            $.2^$.1 = $.2^2
[ 7]    Order 6            Length 3
        GrpPC of order 6 = 2 * 3
        PC-Relations:
            $.1^2 = Id($), 
            $.2^3 = Id($)
[ 8]    Order 9            Length 1
        GrpPC of order 9 = 3^2
        PC-Relations:
            $.1^3 = Id($), 
            $.2^3 = Id($)
[ 9]    Order 18           Length 1
        GrpPC of order 18 = 2 * 3^2
        PC-Relations:
            $.1^2 = Id($), 
            $.2^3 = Id($), 
            $.3^3 = Id($), 
            $.3^$.1 = $.3^2
</PRE>
<HR>
<PRE></PRE> <A  HREF = "text715.htm">[Next]</A><A  HREF = "text713.htm">[Prev]</A> <A  HREF = "text715.htm">[Right]</A> <A  HREF = "text713.htm">[Left]</A> <A  HREF = "text706.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<br><small>Version: V2.22 of <I>
Thu Jun  9 16:37:49 EST 2016
</I></small>
</body></html>