<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <link rel='stylesheet' href='help.css' type='text/css'>
  <TITLE>Operations on the Set of Elements</TITLE>
</head>
<body BGCOLOR="#FFFFFF">

 <A  HREF = "text620.htm">[Next]</A><A  HREF = "text618.htm">[Prev]</A> <A  HREF = "text620.htm">[Right]</A> <A  HREF = "text618.htm">[Left]</A> <A  HREF = "text612.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<PRE></PRE><H3><A NAME = "6698">Operations on the Set of Elements</A></H3>




<H5>Subsections</H5>
<UL>
<LI> <A  HREF = "text619.htm#6699">Order and Index Functions</A>
<LI> <A  HREF = "text619.htm#6705">Membership and Equality</A>
<LI> <A  HREF = "text619.htm#6714">Set Operations</A>
<LI> <A  HREF = "text619.htm#6718">Random Elements</A>
<LI> <A  HREF = "text619.htm#6727">Action on a Coset Space</A>
</UL>
<H4><A NAME = "6699">Order and Index Functions</A></H4>



<H5><A NAME = "6700">Order(G) : GrpFin -&gt; RngIntElt</A></H5>
<H5># G : GrpFin -&gt; RngIntElt</H5>
<BLOCKQUOTE>
The order of the group G as an integer. If the order is not currently
known, it will be computed. Computing the order may fail for groups in the
category <A  HREF = "text809.htm#GrpFP"> <TT>GrpFP</TT></A>; cf. Chapter <A  HREF = "text808.htm#9089">FINITELY PRESENTED GROUPS</A>.
</BLOCKQUOTE>
<H5><A NAME = "6701">FactoredOrder(G) : GrpFin -&gt; [ &lt;RngIntElt, RngIntElt&gt; ]</A></H5>
<BLOCKQUOTE>
The order of the finite group G returned as a factored integer.
The factorization is returned
in the form of a sequence Q which is defined as follows: If
#G = p<sub>1</sub><sup>e<sub>1</sub></sup> ... p<sub>n</sub><sup>e<sub>n</sub></sup>,   e<sub>i</sub>&gt;0,
then Q will be the integer sequence
[ &lt; p<sub>1</sub>, e<sub>1</sub> &gt;, ..., &lt; p<sub>n</sub>, e<sub>n</sub> &gt; ].
If the orders of G is not known, it will be computed. Computing the order
may fail for groups in the category <A  HREF = "text809.htm#GrpFP"> <TT>GrpFP</TT></A>; cf. Chapter
<A  HREF = "text808.htm#9089">FINITELY PRESENTED GROUPS</A>.
</BLOCKQUOTE>
<H5><A NAME = "6702">Index(G, H) : GrpFin, GrpFin -&gt; RngIntElt</A></H5>
<BLOCKQUOTE>
The index of the subgroup H in the group G. The index is
returned as an integer.  Computing the index may fail for groups in
the category <A  HREF = "text809.htm#GrpFP"> <TT>GrpFP</TT></A>; cf. Chapter <A  HREF = "text808.htm#9089">FINITELY PRESENTED GROUPS</A>.
</BLOCKQUOTE>
<H5><A NAME = "6703">FactoredIndex(G, H) : GrpFin, GrpFin -&gt; [ &lt;RngIntElt, RngIntElt&gt; ]</A></H5>
<BLOCKQUOTE>
The index of the subgroup H in the group G. H must have finite index
in G. The index is
returned as a factored integer. The format is the same as for
<TT>FactoredOrder</TT>.   Computing the index may fail for groups in
the category <A  HREF = "text809.htm#GrpFP"> <TT>GrpFP</TT></A>; cf. Chapter <A  HREF = "text808.htm#9089">FINITELY PRESENTED GROUPS</A>.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "6704">Example <TT>Grp_Order (H62E16)</TT></A></H3>
Exploration of the order and index functions for a finitely presented group
and its subgroup:
<P>
<P>
<PRE>
&gt; Q&lt;s,t,u&gt;, h := Group&lt; s, t, u |
&gt;     t^2, u^17, s^2 = t^s = t, u^s = u^16, u^t = u &gt;;
&gt; Order(Q);
68
&gt; FactoredOrder(Q); 
[ &lt;2, 2&gt;, &lt;17, 1&gt; ]
&gt; S := sub&lt; Q | t*s^2, u^4 &gt;;
&gt; Index(Q, S);
4
&gt; #S;
17
</PRE>
<HR>
<H4><A NAME = "6705">Membership and Equality</A></H4>



<H5><A NAME = "6706">g in G : GrpFinElt, GrpFin -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Given a group element g and a group G, return
<TT>true</TT> if g is an element of G, <TT>false</TT> otherwise.
</BLOCKQUOTE>
<H5><A NAME = "6707">g notin G : GrpFinElt, GrpFin -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Given a group element g and a group G, return
<TT>true</TT> if g is not an element of G, <TT>false</TT> otherwise.
</BLOCKQUOTE>
<H5><A NAME = "6708">S subset G : { GrpFinElt }, GrpFin -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Given a group G and a set S of group elements belonging to a group H, 
where G and H belong the same generic group, return <TT>true</TT> if S is a 
subset of G, <TT>false</TT> otherwise.
</BLOCKQUOTE>
<H5><A NAME = "6709">S notsubset G : { GrpFinElt }, GrpFin -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Given a group G and a set S of group elements belonging to a group H, 
where G and H belong the same generic group, return <TT>true</TT> if S is not 
a subset of G, <TT>false</TT> otherwise.
</BLOCKQUOTE>
<H5><A NAME = "6710">H subset G : GrpFin, GrpFin -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Given groups G and H belonging to the same
generic group, return <TT>true</TT> if H is a subgroup of G, <TT>false</TT>
otherwise.
</BLOCKQUOTE>
<H5><A NAME = "6711">H notsubset G : GrpFin, GrpFin -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Given groups G and H belonging to the same generic group, 
return <TT>true</TT> if H is not a subgroup of G, <TT>false</TT> otherwise.
</BLOCKQUOTE>
<H5><A NAME = "6712">H eq G : GrpFin, GrpFin -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Given groups G and H belonging to the same generic group, 
return <TT>true</TT> if G and H are the same group, <TT>false</TT> otherwise.
</BLOCKQUOTE>
<H5><A NAME = "6713">H ne G : GrpFin, GrpFin -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Given groups G and H belonging to the same generic group, 
return <TT>true</TT> if G and H are distinct groups, <TT>false</TT> otherwise.
</BLOCKQUOTE>
<H4><A NAME = "6714">Set Operations</A></H4>



<H5><A NAME = "6715">NumberingMap(G) : GrpFin -&gt; Map</A></H5>
<BLOCKQUOTE>
Given a finite group G in the category <A  HREF = "text630.htm#GrpPerm"> <TT>GrpPerm</TT></A>, <A  HREF = "text654.htm#GrpMat"> <TT>GrpMat</TT></A>,
<A  HREF = "text707.htm#GrpPC"> <TT>GrpPC</TT></A> or <A  HREF = "text787.htm#GrpAb"> <TT>GrpAb</TT></A>, return a bijective mapping from the group G onto
the set of integers
 { 1 ... |G| }. The actual mapping depends upon
the particular representation of G.
</BLOCKQUOTE>
<H5><A NAME = "6716">Representative(G) : GrpFin -&gt; GrpFinElt</A></H5>
<H5>Rep(G) : GrpFin -&gt; GrpFinElt</H5>
<BLOCKQUOTE>
An element chosen from the group G.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "6717">Example <TT>Grp_SetOperations (H62E17)</TT></A></H3>
We use the function <TT>NumberingMap</TT> to construct
the multiplication table for the dihedral group of order 12.
<P>
<P>
<PRE>
&gt; G := DihedralGroup(6);
&gt; f := NumberingMap(G);
&gt; [ [ f(x*y) : y in G ] : x in G ];
[
    [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 ],
    [ 2, 3, 4, 5, 6, 1, 12, 7, 8, 9, 10, 11 ],
    [ 3, 4, 5, 6, 1, 2, 11, 12, 7, 8, 9, 10 ],
    [ 4, 5, 6, 1, 2, 3, 10, 11, 12, 7, 8, 9 ],
    [ 5, 6, 1, 2, 3, 4, 9, 10, 11, 12, 7, 8 ],
    [ 6, 1, 2, 3, 4, 5, 8, 9, 10, 11, 12, 7 ],
    [ 7, 8, 9, 10, 11, 12, 1, 2, 3, 4, 5, 6 ],
    [ 8, 9, 10, 11, 12, 7, 6, 1, 2, 3, 4, 5 ],
    [ 9, 10, 11, 12, 7, 8, 5, 6, 1, 2, 3, 4 ],
    [ 10, 11, 12, 7, 8, 9, 4, 5, 6, 1, 2, 3 ],
    [ 11, 12, 7, 8, 9, 10, 3, 4, 5, 6, 1, 2 ],
    [ 12, 7, 8, 9, 10, 11, 2, 3, 4, 5, 6, 1 ]
]
</PRE>
<HR>
<H4><A NAME = "6718">Random Elements</A></H4>



<H5><A NAME = "6719">Random(G: parameters) : GrpFin -&gt; GrpFinElt</A></H5>

<PRE>    Short: BoolElt                      Default: <TT>false</TT></PRE>
<BLOCKQUOTE>
A randomly chosen element for the group G. If a representation
of the carrier set of G has already been created, then the element 
chosen will be genuinely random. If such a representation has not 
yet been created, then the <I>random</I> element is chosen by
multiplying out a <I>random</I> word in the generators. Since it
is not usually practical to choose words long enough to
properly sample the elements of G, the element returned will
usually be biased. The boolean-valued parameter <TT>Short</TT> is
used in this situation to indicate that a short word will
suffice. Thus, if <TT>Random</TT> is invoked with <TT>Short</TT>
assigned the value <TT>true</TT> then the element is constructed
using a short word.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "6720">Example <TT>Grp_RandomOperations (H62E18)</TT></A></H3>
We illustrate the use of the function <TT>Random</TT> using the
wreath product of the symmetric group of degree 4 and the cyclic
group of order 6.
<P>
<P>
<PRE>
&gt; G := WreathProduct(Sym(4), CyclicGroup(6));
&gt; G;
Permutation group G acting on a set of cardinality 24
    (1, 5, 9, 13, 17, 21)(2, 6, 10, 14, 18, 22) (3, 7, 11, 15, 19, 23)
        (4, 8, 12, 16, 20, 24)
    (1, 2, 3, 4)
    (1, 2)
&gt; Order(G);
1146617856
&gt; Random(G);
(1, 17, 12, 4, 18, 10, 3, 20, 9, 2, 19, 11)(5, 22, 13, 6, 21, 15)
    (7, 24, 16)(8, 23, 14)
// We display the cycle structures of 10 random elements of G
&gt; R := [ CycleStructure(Random(G)) : i in [1..10] ];
&gt; R;
[
    [ &lt;6, 1&gt;, &lt;3, 6&gt; ],
    [ &lt;9, 1&gt;, &lt;6, 2&gt;, &lt;3, 1&gt; ],
    [ &lt;9, 2&gt;, &lt;3, 2&gt; ],
    [ &lt;12, 1&gt;, &lt;9, 1&gt;, &lt;3, 1&gt; ],
    [ &lt;18, 1&gt;, &lt;6, 1&gt; ],
    [ &lt;18, 1&gt;, &lt;6, 1&gt; ],
    [ &lt;12, 1&gt;, &lt;6, 2&gt; ],
    [ &lt;6, 3&gt;, &lt;2, 3&gt; ],
    [ &lt;6, 1&gt;, &lt;4, 3&gt;, &lt;2, 3&gt; ],
    [ &lt;6, 3&gt;, &lt;3, 2&gt; ]
]
</PRE>
<HR>
<H5><A NAME = "6721">RandomProcess(G) : GrpFin -&gt; Process</A></H5>
<H5>RandomProcessWithWords(G) : GrpFin -&gt; Process</H5>
<H5>RandomProcessWithValues(G, Q) : GrpFin, SeqEnum -&gt; Process</H5>
<H5>RandomProcessWithWordsAndValues(G, Q) : GrpFin, SeqEnum -&gt;Process</H5>

<PRE>    Slots: RngIntElt                    Default: 10</PRE>

<PRE>    Scramble: RngIntElt                 Default: 50</PRE>

<PRE>    WordGroup: GrpSLP                   Default: </PRE>
<BLOCKQUOTE>
Create a process to generate randomly chosen elements from the
group G. The process uses a variant of the product-replacement 
method similar to the <I>Rattle</I> method of <A  HREF = "text611.htm#bib_randomelementsvariants">[LGM02]</A>.
The generating set stored in the process has N elements, where N is 
the maximum of the specified value for <TT>Slots</TT> and <TT>Ngens</TT>(G) + 1.  
Initially they are the generators of G repeated as necessary and the 
accumulator is the identity.
Random elements are now produced by successive 
calls to <TT>Random(P)</TT>, where P is the process created by this 
function.  Each such call returns the current value of the accumulator,
modifying the generating set as for product-replacement, and modifying the
accumulator by multiplying by the new member of the generating set.
Setting <TT>Scramble := m</TT> causes m 
such operations to be performed before the process is returned.
<P>
The functions with words and values create a process that returns
extra group elements for each call. A process created with words
returns, as second return value for each call to <TT>Random(P)</TT>,
the <TT>GrpSLPElt</TT> describing the random element returned as a straight-line
program in the group generators. The parameter <TT>WordGroup</TT> may
be used to specify a particular group for the words to be elements of.
<P>
A process created with values takes as input a sequence of group elements Q
giving the values assigned to each generator of G. The second value returned
is the result of computing in parallel with these values as with the
generators of G. In particular, if the elements of Q are homomorphic images
of the generators of G, then the second return value from <TT>Random(P)</TT>
will be the image of the first under this homomorphism.
<P>
A process created with words and values does all of the above, with the
three return values of <TT>Random(P)</TT> being a random element of G, the
straight-line program and the value.
<P>
The use of this function on a finitely-presented group G
is not recommended. Since there is no reduction of words,
the random elements generated may be extremely long.
</BLOCKQUOTE>
<H5><A NAME = "6722">Random(P) : Process -&gt; GrpFinElt</A></H5>
<BLOCKQUOTE>
Given a random element process P created by the function
<TT>RandomProcess(G)</TT> for the finite group G,
construct a random element of G by forming a
random product over the expanded generating set constructed when the
process was created. For large permutation or matrix groups for which a
BSGS is not known, this function should be used in preference to
<TT>Random(G)</TT>. 
<P>
If the process was created with words or values then
there will be second and third return values as described under
<TT>RandomProcess</TT> above.
</BLOCKQUOTE>
<H5><A NAME = "6723">Random(P) : Process -&gt; GrpFinElt</A></H5>
<BLOCKQUOTE>
Given a random element process P created by the function
<TT>RandomProcess(G)</TT> for the finite group G, return G.
</BLOCKQUOTE>
<H5><A NAME = "6724">InitialiseProspector(G:parameters): GrpMat -&gt;</A></H5>
<H5>InitialiseProspector(G:parameters): GrpPerm -&gt;</H5>
<BLOCKQUOTE>
Initialise a product-replacement prospector for the given group.
This is an extension of the product-replacement algorithm that searches for 
an element x&isin;G such that some predicate is true for this element.
The prospector aims to find
elements x so that the corresponding straight-line program for x is short.
Statistical tests and various heuristics are used to achieve this.
<P>
Generally, output from product-replacement with short straight-line programs
is not very random. Prospector aims to run product-replacement until
the output looks random, then start a search for the element wanted. 
At all times, if the output starts to look non-random, or word lengths grow
too far without finding an element, the prospector may return to a previous
state of product replacement and try again, searching in a different direction.
The statistical tests are used to make concrete the notion of "looks random".
For permutation groups the test used is based on number of cycles of the
element.
For matrix groups the test statistic is the number of factors of the
characteristic polynomial.
</BLOCKQUOTE>
<H5><A NAME = "6725">Prospector(G, f:parameters): Grp, UserProgram -&gt; BoolElt, GrpElt, GrpSLPElt</A></H5>
<BLOCKQUOTE>
Run an initialised prospector for group G to find x&isin;G such that
f(x) is true. The first return value gives the success or failure of the
search. If this value is true, then the second and third return values are
x and a straight-line program giving x in terms of the group generators.
The parameter texttt{MaxTries} may be set to limit the number of random
selections made by the prospector when attempting to find x.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "6726">Example <TT>Grp_RandomProspector (H62E19)</TT></A></H3>
We find a random pair of generators for the symmetric group of degree 300
and use a random process to find an element which is a 300-cycle
as a straight-line program in the generators. The proportion of such elements
is 1 in 300, so we expect the program to have length 600.
<P>
<P>
<PRE>
&gt; SetSeed(1);
&gt; S := Sym(300);
&gt; repeat G := sub&lt;S|Random(S),Random(S)&gt;;
&gt; until IsSymmetric(G);
&gt; P := RandomProcessWithWords(G);
&gt; repeat x,w := Random(P);
&gt; until CycleStructure(x) eq [&lt;300,1&gt;];
&gt; #w;
936
</PRE>
Note that the group S, known to be a symmetric group, has an efficient
uniform random element generator available as above. The word length was
somewhat longer than the expected value.
Now we set up a prospector and use it to search for an element of the same
cycle structure. The defining word for the new element should be shorter than
the expected 600.
<P>
<P>
<PRE>
&gt; InitialiseProspector(G);
true
&gt; test := func&lt;x|CycleStructure(x) eq [&lt;300,1&gt;]&gt;;
&gt; repeat a,x,w := Prospector(G, test); until a;
&gt; #w;
206
&gt; Evaluate(w, [G.1,G.2]) eq x;
true
</PRE>
<HR>
<H4><A NAME = "6727">Action on a Coset Space</A></H4>



<H5><A NAME = "6728">CosetTable(G, H) : GrpFin, GrpFin -&gt; Map</A></H5>
<BLOCKQUOTE>
The (right) coset table for G over subgroup H relative
to its defining generators.
</BLOCKQUOTE>
<H5><A NAME = "6729">[Future release] CosetTable(G, f) : GrpFin, Hom(GrpFin) -&gt; Hom(GrpFin)</A></H5>
<BLOCKQUOTE>
The coset table for G corresponding to the permutation representation
f of G, where f is a homomorphism of G onto a transitive
permutation group.
</BLOCKQUOTE>
<H5><A NAME = "6730">Transversal(G, H) : Grp, Grp -&gt; {@ GrpElt  @}, Map</A></H5>
<H5>RightTransversal(G, H) : Grp, Grp -&gt; {@ GrpElt  @}, Map</H5>
<BLOCKQUOTE>
Given a group G and a subgroup H of G, this function returns
<DL COMPACT class='compact'>
<DT>(a)</DT><DD>An indexed set of elements T of G forming a right transversal for G
over H;
<DT>(b)</DT><DD>The corresponding transversal mapping &phi;: G -&gt; T.
If T = [t<sub>1</sub>, ..., t<sub>r</sub>] and g &isin;G, &phi; is defined by
&phi;(g) = t<sub>i</sub>, where g&isin;Ht<sub>i</sub>.</DL>
</BLOCKQUOTE>
<H5><A NAME = "6731">CosetAction(G, H) : Grp, Grp -&gt; Hom(Grp), GrpPerm, Grp</A></H5>
<BLOCKQUOTE>
Given a subgroup H  of the group G, construct the permutation
representation of G given by the action of G on the set of (right)
cosets of H in G. The function returns:
<DL COMPACT class='compact'>
<DT>(a)</DT><DD>The natural homomorphism f: G -&gt; L;
<DT>(b)</DT><DD>The induced group L;
<DT>(c)</DT><DD>The kernel K of the action (a subgroup of G).
<P>
<P>
</DL>
Note that G may be any type of group. If G is a finitely presented
group, then K may be returned undefined.
</BLOCKQUOTE>
<H5><A NAME = "6732">CosetImage(G, H) : Grp, Grp -&gt; GrpPerm</A></H5>
<BLOCKQUOTE>
Given a subgroup H of the group G, construct the image L of G
given by the action of G on the set of (right) cosets of H in G.
</BLOCKQUOTE>
<H5><A NAME = "6733">CosetKernel(G, H) : Grp, Grp -&gt; Grp</A></H5>
<BLOCKQUOTE>
Given a subgroup H of the group G, construct the kernel of the
action of G on the set of (right) cosets of H in G.
</BLOCKQUOTE>
<PRE></PRE> <A  HREF = "text620.htm">[Next]</A><A  HREF = "text618.htm">[Prev]</A> <A  HREF = "text620.htm">[Right]</A> <A  HREF = "text618.htm">[Left]</A> <A  HREF = "text612.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<br><small>Version: V2.22 of <I>
Thu Jun  9 16:37:49 EST 2016
</I></small>
</body></html>