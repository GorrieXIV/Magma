<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <link rel='stylesheet' href='help.css' type='text/css'>
  <TITLE>Construction of Elements</TITLE>
</head>
<body BGCOLOR="#FFFFFF">

 <A  HREF = "text615.htm">[Next]</A><A  HREF = "text613.htm">[Prev]</A> <A  HREF = "text615.htm">[Right]</A> <A  HREF = "text613.htm">[Left]</A> <A  HREF = "text612.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<PRE></PRE><H3><A NAME = "6618">Construction of Elements</A></H3>




<H5>Subsections</H5>
<UL>
<LI> <A  HREF = "text614.htm#6619">Construction of an Element</A>
<LI> <A  HREF = "text614.htm#6623">Coercion</A>
<LI> <A  HREF = "text614.htm#6625">Homomorphisms</A>
<LI> <A  HREF = "text614.htm#6631">Arithmetic with Elements</A>
</UL>
<H4><A NAME = "6619">Construction of an Element</A></H4>

<P>
<P>
Throughout this subsection we shall assume that the carrier set for
the group G is a subset of the set S. Thus, if G is a permutation
group on the set X, its carrier set will be a subset of Sym(X).


<H5><A NAME = "6620">elt&lt; G | L &gt; : Grp, List(Elt) -&gt; GrpElt</A></H5>
<BLOCKQUOTE>
Given a group G whose elements are a subset of the set S, 
and a list L of objects a<sub>1</sub>, a<sub>2</sub>, ..., a<sub>n</sub> 
defining an element of S,
construct this element g of S. Then, the element g will
be tested for membership of G, and if g is not an element
of G, the function will fail. If g does lie in G, g
will be returned with G as its parent. 
</BLOCKQUOTE>
<H5><A NAME = "6621">G ! Q : Grp, [ Elt ] -&gt; GrpElt</A></H5>
<BLOCKQUOTE>
Given a group G whose elements are a subset of the set S, 
and a sequence Q=[ a<sub>1</sub>, a<sub>2</sub>, ..., a<sub>n</sub> ]
defining an element of S,
construct this element g of S. Then, the element g will
be tested for membership of G, and if g is not an element
of G, the function will fail. If g does lie in G, g
will be returned with G as its parent. 
</BLOCKQUOTE>
<H5><A NAME = "6622">Identity(G) : Grp -&gt; GrpElt</A></H5>
<H5>Id(G) : Grp -&gt; GrpElt</H5>
<BLOCKQUOTE>
Construct the identity element in the group G.
</BLOCKQUOTE>
<H4><A NAME = "6623">Coercion</A></H4>



<H5><A NAME = "6624">G ! g : Grp, GrpElt -&gt; GrpElt</A></H5>
<BLOCKQUOTE>
Given a group G and an element g of H, where G and H are
subgroups of some common over-group and g is contained in G,
embed g in G. Thus this operator changes the parent of g into G.
The coercion may fail for groups in the category <A  HREF = "text809.htm#GrpFP"> <TT>GrpFP</TT></A>.
</BLOCKQUOTE>
<H4><A NAME = "6625">Homomorphisms</A></H4>



<H5><A NAME = "6626">hom&lt; G -&gt; H | L &gt; : Grp, Grp -&gt; Map</A></H5>
<BLOCKQUOTE>
Return the group homomorphism &phi; : G -&gt; H
defined by extending the map of the generators of G,
as given by the list L on the right side of the constructor.
Suppose that the generators of G are g<sub>1</sub>, ..., g<sub>n</sub>,
and that &phi;(g<sub>i</sub>)=h<sub>i</sub> for each i.
Then L must be one of the following:
<DL COMPACT class='compact'>
<DT>(a)</DT><DD>a list of the n 2-tuples &lt; g<sub>i</sub>, h<sub>i</sub> &gt; (order not important);
<DT>(b)</DT><DD>a list of the n arrow-pairs g<sub>i</sub> <TT>-&gt;</TT> h<sub>i</sub> (order not important);
<DT>(c)</DT><DD>h<sub>1</sub>, ..., h<sub>n</sub> (order is important).
<P>
<P>
</DL>
For its computations,
Magma often assumes that the mapping so defined is a homomorphism without
attempting to verify this.
<P>
<P>
For certain categories of groups, e.g. <A  HREF = "text832.htm#GrpGPC"> <TT>GrpGPC</TT></A>, the homomorphism
constructor provides some additional functionality. See the chapter on the
appropriate category for further information.
</BLOCKQUOTE>
<H5><A NAME = "6627">hom&lt; G -&gt; H | x : -&gt; e(x) &gt; : Grp, Grp -&gt; Map</A></H5>
<BLOCKQUOTE>
Return the group homomorphism &phi; : G -&gt; H
defined by the rule &phi;(x)=e(x),
where x is a general element of G and e(x) is an expression in x.
The symbol x may be any identifier name, and has local scope.
For its computations,
Magma assumes the expression defines a homomorphism,
but does not verify this.
</BLOCKQUOTE>
<H5><A NAME = "6628">IdentityHomomorphism(G) : Grp -&gt; Map</A></H5>
<BLOCKQUOTE>
Return the identity homomorphism &phi;: G -&gt; G: x |-&gt; x.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "6629">Example <TT>Grp_Homomorphisms (H62E1)</TT></A></H3>
Construction of an isomorphism from the cyclic group of order 15
to the abelian group isomorphic to Z/15Z,
by giving the image of the generator:
<P>
<P>
<PRE>
&gt; C15 := CyclicGroup(15);
&gt; C15;             
Permutation group C15 acting on a set of cardinality 15
Order = 15 = 3 * 5
    (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15)
&gt; A15 := AbelianGroup([15]);
&gt; A15;
Abelian Group isomorphic to Z/15
Defined on 1 generator
Relations:
    15*A15.1 = 0
&gt; iso11 := hom&lt; C15 -&gt; A15 | C15.1 -&gt; 11*A15.1 &gt;;
&gt; A15 eq iso11(C15);                       
true
&gt; forall{ &lt;c, d&gt; : c, d in C15 | iso11(c * d) eq iso11(c) * iso11(d) };
true
</PRE>
<HR>
<H3><A NAME = "6630">Example <TT>Grp_Homomorphisms-2 (H62E2)</TT></A></H3>
An endomorphism of the same cyclic group,
defined using an expression. The image is cyclic of order 5.
<P>
<P>
<PRE>
&gt; C15 := CyclicGroup(15);
&gt; h := hom&lt; C15 -&gt; C15 | g :-&gt; g^3 &gt;;
&gt; forall{ &lt;c, d&gt; : c, d in C15 | h(c * d) eq h(c) * h(d) };
true
&gt; im := h(C15);
&gt; im;
Permutation group im acting on a set of cardinality 15
Order = 5
    (1, 4, 7, 10, 13)(2, 5, 8, 11, 14)(3, 6, 9, 12, 15)
&gt; IsCyclic(im);
true
</PRE>
<HR>
<H4><A NAME = "6631">Arithmetic with Elements</A></H4>



<H5><A NAME = "6632">g * h : GrpElt, GrpElt -&gt; GrpElt</A></H5>
<BLOCKQUOTE>
Product of element g and element h, where g and
h belong to the same generic group U. If g and h both
belong to the same proper subgroup G of U, then the result
will be returned as an element of G; if g and h belong to
subgroups H and K of a subgroup G of U, then the product
is returned as an element of G.  Otherwise, the product is
returned as an element of U.  The product in abelian groups
is called the sum and is written <TT>g + h</TT> instead.
</BLOCKQUOTE>
<H5><A NAME = "6633">g ^ n : GrpElt, RngIntElt -&gt; GrpElt</A></H5>
<BLOCKQUOTE>
The n-th power of the group element g, where n is a positive, 
negative or zero integer.  In abelian groups, this is written as a
scalar product <TT>n * g</TT> instead.
</BLOCKQUOTE>
<H5><A NAME = "6634">g / h : GrpElt, GrpElt -&gt; GrpElt</A></H5>
<BLOCKQUOTE>
Product of the group element g by the inverse of the group element h,
i.e., the element gh<sup> - 1</sup>. Here g and h must belong to the same
generic group U. The rules for determining the parent group of
g / h are the same as for gh.  In abelian groups, this is written
additively as <TT>g - h</TT>.
</BLOCKQUOTE>
<H5><A NAME = "6635">g ^ h : GrpElt, GrpElt -&gt; GrpElt</A></H5>
<BLOCKQUOTE>
Conjugate of the group element g by the group element h, i.e.,
the element h<sup> - 1</sup>gh. Here g and h must belong to the
same generic group U.  The rules for determining the parent
group of g<sup>h</sup> are the same as for gh.  In abelian groups, this
operation does not exist.
</BLOCKQUOTE>
<H5><A NAME = "6636">(g, h) : GrpElt, GrpElt -&gt; GrpElt</A></H5>
<BLOCKQUOTE>
Commutator of the group elements g and h, i.e., the element
g<sup> - 1</sup>h<sup> - 1</sup>gh. Here g and h must belong to the same generic
group U. The rules for determining the parent group of (g, h) are
the same as those for gh.
</BLOCKQUOTE>
<H5><A NAME = "6637">(g<sub>1</sub>, ..., g<sub>r</sub>) : GrpElt, ..., GrpElt -&gt; GrpElt</A></H5>
<BLOCKQUOTE>
Given r elements g<sub>1</sub>, ..., g<sub>r</sub> belonging to a common group,
return their commutator. Commutators are <I>left-normed</I>, so they are
evaluated from left to right.
</BLOCKQUOTE>
<H5><A NAME = "6638">g eq h : GrpElt, GrpElt -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Given elements g and h belonging to the same generic group, 
return <TT>true</TT> if g and h are the same element, <TT>false</TT> otherwise.
</BLOCKQUOTE>
<H5><A NAME = "6639">g ne h : GrpElt, GrpElt -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Given elements g and h belonging to the same generic group, 
return <TT>true</TT> if g and h are distinct elements, <TT>false</TT> otherwise.
</BLOCKQUOTE>
<H5><A NAME = "6640">IsId(g) : GrpElt -&gt; BoolElt</A></H5>
<H5>IsIdentity(g) : GrpElt -&gt; BoolElt</H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if the group element g is the identity element.
</BLOCKQUOTE>
<H5><A NAME = "6641">Order(g) : GrpElt -&gt; RngIntElt</A></H5>
<BLOCKQUOTE>
The order of the group element g.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "6642">Example <TT>Grp_Arithmetic (H62E3)</TT></A></H3>
We illustrate the arithmetic operations by applying them
to some elements of Sym(9).
<P>
<P>
<PRE>
&gt; G := Sym(9);
&gt; x := G ! (1,2,4)(5,6,8)(3,9,7);
&gt; y := G ! (4,5,6)(7,9,8);
&gt; x*y;
(1, 2, 5, 4)(3, 8, 6, 7)
&gt; x^-1;
(1, 4, 2)(3, 7, 9)(5, 8, 6)
&gt; x^2;
(1, 4, 2)(3, 7, 9)(5, 8, 6)
&gt; x / y;
(1, 2, 6, 9, 8, 4)(3, 7)
&gt; x^y;
(1, 2, 5)(3, 8, 9)(4, 7, 6)
&gt; (x, y);
(1, 7, 3, 6)(4, 5, 9, 8)
&gt; x^y eq y^x;
false
&gt; CycleStructure(x^2*y);
[ &lt;6, 1&gt;, &lt;2, 1&gt;, &lt;1, 1&gt; ]
&gt; Degree(y);
6
&gt; Order(x^2*y);
6
</PRE>
<HR>
<PRE></PRE> <A  HREF = "text615.htm">[Next]</A><A  HREF = "text613.htm">[Prev]</A> <A  HREF = "text615.htm">[Right]</A> <A  HREF = "text613.htm">[Left]</A> <A  HREF = "text612.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<br><small>Version: V2.22 of <I>
Thu Jun  9 16:37:49 EST 2016
</I></small>
</body></html>