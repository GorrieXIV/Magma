<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <link rel='stylesheet' href='help.css' type='text/css'>
  <TITLE>Elementary Graph Predicates</TITLE>
</head>
<body BGCOLOR="#FFFFFF">

 <A  HREF = "text1794.htm">[Next]</A><A  HREF = "text1792.htm">[Prev]</A> <A  HREF = "text1794.htm">[Right]</A> <A  HREF = "text1792.htm">[Left]</A> <A  HREF = "text1782.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<PRE></PRE><H3><A NAME = "19832">Elementary Graph Predicates</A></H3>

<P>
<P>
<P>
<P>
<P>
<P>
Let G and H be two graphs.
For clarity, we list here the conditions under which
  G is equal to H and H is a subgraph of G.
The conditions take into account the fact that the graphs may have a support
  and that their vertex and edges may be decorated.
<P>
The graphs G and H are equal if and only if:
<DL COMPACT class='compact'>
<DT>-</DT><DD>they are of the same type,
<DT>-</DT><DD>they are structurally identical,
<DT>-</DT><DD>they have the same support,
<DT>-</DT><DD>they have identical vertex and edge labels,
<DT>-</DT><DD>if applicable, the total capacity from u to v in G 
         is equal to the   total capacity from u to v in H.
<P>
</DL>
Also, H is a subgraph of G if and only if:
<DL COMPACT class='compact'>
<DT>-</DT><DD>they are of the same type,
<DT>-</DT><DD>H is a structural subgraph of G,
<DT>-</DT><DD>any vertex <TT>v</TT> in H has the same support as the vertex
        <TT>VertexSet(G)!v</TT> in G,
<DT>-</DT><DD>any vertex <TT>v</TT>  in H has the same label as the vertex
        <TT>VertexSet(G)!v</TT> in G,
<DT>-</DT><DD>any edge <TT>e</TT> in H has the same label as the edge
        <TT>EdgeSet(G)!e</TT> in G,
<DT>-</DT><DD>if applicable, the total capacity from u to v in G 
        is at least as large as the   total capacity from u to v
        in H.
<P>
</DL>
Note that the truth value of the above two tests is not dependent
  on the weights of the edges of the graphs, should these
  edges be weighted.
One could argue that given this shortcoming, the tests should not 
  be dependent on the capacities of the edges either.
We welcome users' comments on this matter.


<H5><A NAME = "19833">u adj v : GrphVert, GrphVert -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Let u and v be two vertices of the same graph G.
If G is undirected, returns <TT>true</TT> if and only if u and v 
  are adjacent.
If G is directed, returns <TT>true</TT> if and only if there is an edge
  directed from u to v.
</BLOCKQUOTE>
<H5><A NAME = "19834">e adj f : GrphEdge, GrphEdge -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Let e and f be two edges of the same graph G.
If G is undirected, returns <TT>true</TT> if and only if e and f share
  a common vertex.
If G is directed, returns <TT>true</TT> if and only if the terminal 
  vertex of e (f) is the initial vertex of f (e).
</BLOCKQUOTE>
<H5><A NAME = "19835">u notadj v : GrphVert, GrphVert -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
The negation of the <TT>adj</TT> predicate applied to vertices.
</BLOCKQUOTE>
<H5><A NAME = "19836">e notadj f : GrphEdge, GrphEdge -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
The negation of the <TT>adj</TT> predicate applied to edges.
</BLOCKQUOTE>
<H5><A NAME = "19837">u in e : GrphVert, GrphEdge -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Let u be a vertex and e an edge of a graph G.
Returns <TT>true</TT> if and only if u is an end-vertex of e.
</BLOCKQUOTE>
<H5><A NAME = "19838">u notin e : GrphVert, GrphEdge -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
The negation of the <TT>in</TT> predicate applied to a vertex with 
 respect to an edge.
</BLOCKQUOTE>
<H5><A NAME = "19839">G eq H : GrphDir, GrphDir -&gt; BoolElt</A></H5>
<H5>G eq H : GrphUnd, GrphUnd -&gt; BoolElt</H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if the graphs G and H are identical, 
   otherwise <TT>false</TT>.
G and H are identical if and only if:
<DL COMPACT class='compact'>
<DT>-</DT><DD>they are structurally identical,
<DT>-</DT><DD>they have the same support,
<DT>-</DT><DD>they have identical vertex and edge labels,
<DT>-</DT><DD>if applicable, the total capacity from u to v in G 
         is equal to the   total capacity from u to v in H.
<P>
</DL>
Thus, as an example,
  if G and H are structurally identical graphs, and the
  vertices of G are labelled while the vertices of H are not,
  then <TT>G eq H</TT> returns <TT>false</TT>.
<P>
</BLOCKQUOTE>
<H5><A NAME = "19840">IsSubgraph(G, H) : Grph, Grph  -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if H is a subgraph of G, 
   otherwise <TT>false</TT>.
H is a subgraph of G if and only if:
<DL COMPACT class='compact'>
<DT>-</DT><DD>H can be determined to be a structural subgraph of G,
<DT>-</DT><DD>any vertex <TT>v</TT> in H has the same support as the vertex
	<TT>VertexSet(G)!v</TT> in G,
<DT>-</DT><DD>any vertex <TT>v</TT>  in H has the same label as the vertex
	<TT>VertexSet(G)!v</TT> in G,
<DT>-</DT><DD>any edge <TT>e</TT> in H has the same label as the edge
	<TT>EdgeSet(G)!e</TT> in G.
<DT>-</DT><DD>if applicable, the total capacity from u to v in G 
        is at least as large as the   total capacity from u to v
        in H.</DL>
</BLOCKQUOTE>
<H5><A NAME = "19841">IsBipartite(G) : GrphUnd -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if the graph G is a bipartite graph, otherwise <TT>false</TT>.
</BLOCKQUOTE>
<H5><A NAME = "19842">IsComplete(G) : Grph -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if the graph G on n vertices
  is the complete graph on n vertices, otherwise <TT>false</TT>.
</BLOCKQUOTE>
<H5><A NAME = "19843">IsEulerian(G) : Grph -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if the graph G is an eulerian graph, otherwise <TT>false</TT>.
A eulerian graph is a graph whose vertices have all even degree.
An eulerian digraph is a digraph whose vertices have same in and
  outdegree.
That is, if D is a digraph, D is eulerian if and only if
  <TT>OutDegree(v)</TT> equals <TT>InDegree(v)</TT> for all vertices
  v of D.
</BLOCKQUOTE>
<H5><A NAME = "19844">IsForest(G) : GrphUnd -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if the graph G is a forest, i.e. does not possess any cycles,
otherwise <TT>false</TT>.
</BLOCKQUOTE>
<H5><A NAME = "19845">IsEmpty(G) : Grph -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if the graph G is an empty graph, otherwise <TT>false</TT>.
A graph is empty if its edge-set E is empty.
</BLOCKQUOTE>
<H5><A NAME = "19846">IsNull(G) : Grph -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if the graph G is a null graph, otherwise <TT>false</TT>.
A graph is null if its vertex-set V  is empty.
</BLOCKQUOTE>
<H5><A NAME = "19847">IsPath(G) : Grph -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if the graph G is a path graph, otherwise <TT>false</TT>.
</BLOCKQUOTE>
<H5><A NAME = "19848">IsPolygon(G) : Grph -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if the graph G is a polygon graph, otherwise <TT>false</TT>.
</BLOCKQUOTE>
<H5><A NAME = "19849">IsRegular(G) : Grph -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if the graph G is a regular graph, otherwise <TT>false</TT>.
</BLOCKQUOTE>
<H5><A NAME = "19850">IsTree(G) : Grph -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if the graph G is a tree, otherwise <TT>false</TT>.
</BLOCKQUOTE>
<PRE></PRE> <A  HREF = "text1794.htm">[Next]</A><A  HREF = "text1792.htm">[Prev]</A> <A  HREF = "text1794.htm">[Right]</A> <A  HREF = "text1792.htm">[Left]</A> <A  HREF = "text1782.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<br><small>Version: V2.22 of <I>
Thu Jun  9 16:37:49 EST 2016
</I></small>
</body></html>