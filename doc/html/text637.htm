<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <link rel='stylesheet' href='help.css' type='text/css'>
  <TITLE>Subgroups</TITLE>
</head>
<body BGCOLOR="#FFFFFF">

 <A  HREF = "text638.htm">[Next]</A><A  HREF = "text636.htm">[Prev]</A> <A  HREF = "text638.htm">[Right]</A> <A  HREF = "text636.htm">[Left]</A> <A  HREF = "text629.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<PRE></PRE><H3><A NAME = "6996">Subgroups</A></H3>




<H5>Subsections</H5>
<UL>
<LI> <A  HREF = "text637.htm#6997">Construction of a Subgroup</A>
<LI> <A  HREF = "text637.htm#7003">Membership and Equality</A>
<LI> <A  HREF = "text637.htm#7012">Elementary Properties of a Subgroup</A>
<LI> <A  HREF = "text637.htm#7019">Standard Subgroups</A>
<LI> <A  HREF = "text637.htm#7034">Maximal Subgroups</A>
<LI> <A  HREF = "text637.htm#7040">Conjugacy Classes of Subgroups</A>
<LI> <A  HREF = "text637.htm#7051">Classes of Subgroups Satisfying a  Condition</A>
</UL>
<H4><A NAME = "6997">Construction of a Subgroup</A></H4>



<H5><A NAME = "6998">sub&lt;G | L&gt; : GrpPerm, List -&gt; GrpPerm</A></H5>
<BLOCKQUOTE>
Given the permutation group G, construct the subgroup H of G,
generated by the elements specified by the list L, where L is a
list of one or more items of the following types:
<DL COMPACT class='compact'>
<DT>(a)</DT><DD>A sequence of n integers defining a permutation of G;
<DT>(b)</DT><DD>A set or sequence of sequences of type (a);
<DT>(c)</DT><DD>An element of G;
<DT>(d)</DT><DD>A set or sequence of elements of G;
<DT>(e)</DT><DD>A subgroup of G;
<DT>(f)</DT><DD>A set or sequence of subgroups of G.
<P>
<P>
</DL>
Each element or group specified by the list must belong to the <I>same</I>
generic permutation group. The subgroup H will be constructed as a subgroup
of some group which contains each of the elements and groups specified in
the list.
<P>
The generators of H consist of the elements specified by the terms of
the list L together with the stored generators for groups
specified by terms of the list.  
</BLOCKQUOTE>
<H5><A NAME = "6999">ncl&lt;G | L&gt; : GrpPerm, List -&gt; GrpPerm</A></H5>
<BLOCKQUOTE>
Given the permutation group G, construct the subgroup H of
G that is the <I>normal closure</I> of the subgroup H
generated by the elements specified by the list L (see <A  HREF = "text628.htm#bib_perm-matrix-I">[BC82]</A>),
where the possibilities for L are the same as for
the <TT>sub</TT>-constructor.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "7000">Example <TT>GrpPerm_Constructors (H63E14)</TT></A></H3>
The group PGL(2, 7) in its natural action on projective
points is generated by the set of permutations
{ (1, 2, 3, 4, 5, 6, 7), (2, 4, 3, 7, 5, 6), (1, 8)(2, 7)(3, 4)(5, 6) }.
<P>
Using the above syntax, the group may be defined in any of the following ways:
<DL COMPACT class='compact'>
<DT>(a)</DT><DD>By means of a list of generating permutations written as products
of cycles:
<P>
<P>
</DL>
<PRE>
&gt; PGL27 := sub&lt; Sym(8) | (1,2,3,4,5,6,7), (2,4,3,7,5,6), (1,8)(2,7)(3,4)(5,6)&gt;;
&gt; PGL27;
Permutation group PGL27 acting on a set of cardinality 8
    (1, 2, 3, 4, 5, 6, 7)
    (2, 4, 3, 7, 5, 6)
    (1, 8)(2, 7)(3, 4)(5, 6)
</PRE>
<DL COMPACT class='compact'>
<DT>(b)</DT><DD>By means of a list of integer sequences representing generators:
<P>
<P>
</DL>
<PRE>
&gt; PGL27 := sub&lt; Sym(8) |
&gt;               [2,3,4,5,6,7,1,8], [1,4,7,3,6,2,5,8], [8,7,4,3,6,5,2,1] &gt;;
</PRE>
<DL COMPACT class='compact'>
<DT>(c)</DT><DD>In terms of preassigned elements of the symmetric group of
degree 8:
<P>
<P>
</DL>
<PRE>
&gt; S8 := Sym(8);
&gt; a := S8!(1,2,3,4,5,6,7);
&gt; b := S8!(2,4,3,7,5,6);
&gt; c := S8!(1,8)(2,7)(3,4)(5,6);
&gt; PGL27 := sub&lt;S8 | a, b, c&gt;;
</PRE>
<DL COMPACT class='compact'>
<DT>(d)</DT><DD>By means of a set of generators:
<P>
<P>
<P>
<P>
</DL>
<PRE>
&gt; S8 := Sym(8);
&gt; gens := { S8 | (1,2,3,4,5,6,7), (2,4,3,7,5,6), (1,8)(2,7)(3,4)(5,6) };
&gt; PGL27 := sub&lt;S8 | gens&gt;;
</PRE>
<DL COMPACT class='compact'>
<DT>(e)</DT><DD>By means of a sequence of generators:
<P>
<P>
<P>
<P>
</DL>
<PRE>
&gt; S8 := Sym(8);
&gt; gens := [ S8 | (1,2,3,4,5,6,7), (2,4,3,7,5,6), (1,8)(2,7)(3,4)(5,6) ];
&gt; PGL27 := sub&lt;S8 | gens&gt;;
</PRE>
<HR>
<H3><A NAME = "7001">Example <TT>GrpPerm_Constructors-2 (H63E15)</TT></A></H3>
A representation H of a 2-generator transitive group G
in its action on unordered pairs is constructed as follows:
<P>
<P>
<P>
<PRE>
&gt; G := AlternatingGroup(7);
&gt; deg1 := Degree(G);
&gt; pairs := [ { i, j } : j in [i+1..deg1], i in [1..deg1-1] ];
&gt; deg2 := #pairs;
&gt; h1 := [ Position(pairs, pairs[i] ^ G.1): i in [1..deg2] ];
&gt; h2 := [ Position(pairs, pairs[i] ^ G.2): i in [1..deg2] ];
&gt; H := sub&lt;Sym(deg2) | h1, h2&gt;;
&gt; H;
Permutation group H acting on a set of cardinality 21
 (2,3,4,5,6)(7,8,9,10,11)(12,16,19,21,15)(13,17,20,14,18),
 (1,7,2)(3,8,12)(4,9,13)(5,10,14)(6,11,15)
</PRE>
<HR>
<H3><A NAME = "7002">Example <TT>GrpPerm_Constructors-3 (H63E16)</TT></A></H3>
We illustrate the <TT>ncl</TT>-constructor by using it to construct 
the derived subgroup of the Hessian group H. We exploit the fact that the 
derived subgroup may be obtained as the normal closure of the subgroup generated 
by the commutators of the generators of H.
<P>
<P>
<P>
<PRE>
&gt; H := PermutationGroup&lt; 9 | (1,2,4)(5,6,8)(3,9,7), (4,5,6)(7,9,8) &gt;;
&gt; Order(H);
216
&gt; D := ncl&lt; H | (H.1, H.2) &gt;;
&gt; D;
Permutation group D acting on a set of cardinality 9
Order = 72 = 2^3 * 3^2
    (1, 7, 3, 6)(4, 5, 9, 8)
    (2, 9, 3, 5)(4, 6, 7, 8)
    (2, 6, 3, 8)(4, 5, 7, 9)
</PRE>
<HR>
<H4><A NAME = "7003">Membership and Equality</A></H4>



<H5><A NAME = "7004">g in G : GrpPermElt, GrpPerm -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Given a permutation g and a permutation group G, return
<TT>true</TT> if g is an element of G, <TT>false</TT> otherwise.
</BLOCKQUOTE>
<H5><A NAME = "7005">g notin G : GrpPermElt, GrpPerm -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Given a permutation g and a permutation group G, return
<TT>true</TT> if g is not an element of G, <TT>false</TT> otherwise.
</BLOCKQUOTE>
<H5><A NAME = "7006">S subset G : { GrpPermElt }, GrpPerm -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Given a permutation group G and a set S of permutations
belonging to a group H, where G and H belong the same
generic group, return <TT>true</TT> if S is a subset of G, <TT>false</TT> otherwise.
</BLOCKQUOTE>
<H5><A NAME = "7007">S notsubset G : { GrpPermElt }, GrpPerm -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Given a permutation group G and a set S of permutations
belonging to a group H, where G and H belong the same
generic group, return <TT>true</TT> if S is not a subset of G, <TT>false</TT>
otherwise.
</BLOCKQUOTE>
<H5><A NAME = "7008">H subset G : GrpPerm, GrpPerm -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Given permutation groups G and H belonging to the same
generic group, return <TT>true</TT> if H is a subgroup of G, <TT>false</TT>
otherwise.
</BLOCKQUOTE>
<H5><A NAME = "7009">H notsubset G : GrpPerm, GrpPerm -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Given permutation groups G and H belonging to the same
generic group, return <TT>true</TT> if H is not a subgroup of G,
<TT>false</TT> otherwise.
</BLOCKQUOTE>
<H5><A NAME = "7010">H eq G : GrpPerm, GrpPerm -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Given permutation groups G and H belonging to the same
generic group, return <TT>true</TT> if G and H are the same group,
<TT>false</TT> otherwise.
</BLOCKQUOTE>
<H5><A NAME = "7011">H ne G : GrpPerm, GrpPerm -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Given permutation groups G and H belonging to the same
generic group, return <TT>true</TT> if G and H are distinct groups,
<TT>false</TT> otherwise.
</BLOCKQUOTE>
<H4><A NAME = "7012">Elementary Properties of a Subgroup</A></H4>



<H5><A NAME = "7013">Index(G, H) : GrpPerm, GrpPerm -&gt; RngIntElt</A></H5>
<BLOCKQUOTE>
The index of the subgroup H in the group G. The index is
returned as an integer.  If the orders of G and H are not
known, they will be computed.
</BLOCKQUOTE>
<H5><A NAME = "7014">FactoredIndex(G, H) : GrpPerm, GrpPerm -&gt; [ &lt;RngIntElt, RngIntElt&gt; ]</A></H5>
<BLOCKQUOTE>
The index of the subgroup H in the group G. The index is
returned as a factored integer. 
The format is the same as for <TT>FactoredOrder</TT>. 
If the orders of G and H are not known, they will be computed.
</BLOCKQUOTE>
<H5><A NAME = "7015">IsCentral(G, H) : GrpPerm, GrpPerm -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if the subgroup H of the group G lies in the centre of
G, <TT>false</TT> otherwise.
</BLOCKQUOTE>
<H5><A NAME = "7016">IsNormal(G, H) : GrpPerm, GrpPerm -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if the subgroup H of the group G is a normal subgroup
of G, <TT>false</TT> otherwise.
</BLOCKQUOTE>
<H5><A NAME = "7017">IsSelfNormalizing(G, H) : GrpPerm, GrpPerm -&gt; BoolElt</A></H5>
<H5>IsSelfNormalising(G, H) : GrpPerm, GrpPerm -&gt; BoolElt</H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if the subgroup H of the group G is self-normalizing
in G, <TT>false</TT> otherwise.
</BLOCKQUOTE>
<H5><A NAME = "7018">IsSubnormal(G, H) : GrpPerm, GrpPerm -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if the subgroup H of the group G is subnormal in G,
<TT>false</TT> otherwise.
</BLOCKQUOTE>
<H4><A NAME = "7019">Standard Subgroups</A></H4>

<P>
<P>
<P>
<P>
<P>
Unless the order is already known, each of the functions in this family will
create a base and strong generating set for the group if one does not already
exist.


<H5><A NAME = "7020">H ^ g : GrpPerm, GrpPermElt -&gt; GrpPerm</A></H5>
<H5>Conjugate(H, g) : GrpPerm, GrpPermElt -&gt; GrpPerm</H5>
<BLOCKQUOTE>
Construct the conjugate g<sup> - 1</sup> * H * g of the permutation group
H by the permutation g. The group H and the element g
must belong to the same symmetric group.
</BLOCKQUOTE>
<H5><A NAME = "7021">H meet K : GrpPerm, GrpPerm -&gt; GrpPerm</A></H5>
<BLOCKQUOTE>
Given groups H and K which belong to the same symmetric
group, construct the intersection of H and K. The intersection
is found using the backtrack search of J. Leon <A  HREF = "text628.htm#bib_Leon2">[Leo97]</A>.
</BLOCKQUOTE>
<H5><A NAME = "7022">IntersectionWithNormalSubgroup(G, N: parameters) : GrpPerm, GrpPerm -&gt; GrpPerm</A></H5>

<PRE>    Check: BoolElt                      Default: <TT>true</TT></PRE>
<BLOCKQUOTE>
Given groups G and N which belong to the same symmetric group
and so that G normalises N, construct the intersection of G and N.
The algorithm used is that of Cooperman, Finkelstein and Luks 
<A  HREF = "text628.htm#bib_CFL-pointstabs">[CFL89]</A>, which uses a permutation representation of 
double the degree of G and N. Setting <TT>Check</TT> to <TT>false</TT>
suppresses checking that G normalises N.
</BLOCKQUOTE>
<H5><A NAME = "7023">CommutatorSubgroup(G, H, K) : GrpPerm, GrpPerm, GrpPerm -&gt; GrpPerm</A></H5>
<H5>CommutatorSubgroup(H, K) : GrpPerm, GrpPerm -&gt; GrpPerm</H5>
<BLOCKQUOTE>
Given groups H and K, both subgroups of the group G, construct 
the commutator subgroup of H and K in the group G. If K is a
subgroup of H, then the group G may be omitted.  The algorithm used 
is described in <A  HREF = "text628.htm#bib_perm-matrix-I">[BC82]</A>.
</BLOCKQUOTE>
<H5><A NAME = "7024">Centralizer(G, g: parameters) : GrpPerm, GrpPermElt -&gt; GrpPerm</A></H5>
<H5>Centraliser(G, g: parameters) : GrpPerm, GrpPermElt -&gt; GrpPerm</H5>
<BLOCKQUOTE>
Construct the centralizer of the permutation g in the group
G; g and G must belong to a common symmetric group.
A backtrack search through G as described in <A  HREF = "text628.htm#bib_Leon2">[Leo97]</A>
is employed. 
<P>
<P>
<PRE>
     Subgroup: GrpPerm                   Default: 
</PRE>
The parameter <TT>Subgroup</TT> may be used to supply
a known subgroup of the centralizer. This may speed the search.
</BLOCKQUOTE>
<H5><A NAME = "7025">Centralizer(G, H) : GrpPerm, GrpPerm -&gt; GrpPerm</A></H5>
<H5>Centraliser(G, H) : GrpPerm, GrpPerm -&gt; GrpPerm</H5>
<BLOCKQUOTE>
Construct the centralizer of the group H in the group G;
G and H must belong to a common symmetric group.
A backtrack search through G as described in <A  HREF = "text628.htm#bib_Leon2">[Leo97]</A>
is employed.
</BLOCKQUOTE>
<H5><A NAME = "7026">CentralizerOfNormalSubgroup(G, H) : GrpPerm, GrpPerm -&gt; GrpPerm</A></H5>
<BLOCKQUOTE>
Given G and H, belonging to a common symmetric group, with the
restriction that H is a normal subgroup of G, construct the centralizer of 
H in G. A polynomial-time reduction algorithm described in Beals
<A  HREF = "text628.htm#bib_beals-phd">[Bea93]</A> is used.
</BLOCKQUOTE>
<H5><A NAME = "7027">SectionCentraliser(G, H, K) : GrpPerm, GrpPerm, GrpPerm -&gt; GrpPerm</A></H5>
<H5>SectionCentralizer(G, H, K) : GrpPerm, GrpPerm, GrpPerm -&gt; GrpPerm</H5>
<BLOCKQUOTE>
Return the full preimage in G of the centralizer in G/K of H/K.
The groups H and K must be normal subgroups of G with K contained in H.
An algorithm of Luks <A  HREF = "text628.htm#bib_luks-polynomial">[Luk93]</A> is employed which involves 
computing the core of a subgroup in a group having twice the degree of G.
</BLOCKQUOTE>
<H5><A NAME = "7028">Core(G, H) : GrpPerm, GrpPerm -&gt; GrpPerm</A></H5>
<BLOCKQUOTE>
Given a subgroup H of the permutation group G, construct
the maximal normal subgroup of G that is contained in the
subgroup H. The algorithm employs repeated conjugation and intersection
using the backtrack search of Leon <A  HREF = "text628.htm#bib_Leon2">[Leo97]</A>.
</BLOCKQUOTE>
<H5><A NAME = "7029">H ^ G : GrpPerm, GrpPerm -&gt; GrpPerm</A></H5>
<H5>NormalClosure(G, H) : GrpPerm, GrpPerm -&gt; GrpPerm</H5>
<BLOCKQUOTE>
Given a subgroup H of the permutation group G, construct
the normal closure of H in G.
</BLOCKQUOTE>
<H5><A NAME = "7030">Normalizer(G, H: parameters) : GrpPerm, GrpPerm -&gt; GrpPerm</A></H5>
<H5>Normaliser(G, H: parameters) : GrpPerm, GrpPerm -&gt; GrpPerm</H5>

<PRE>    Subgroup: GrpPerm                   Default: H</PRE>

<PRE>    Bound: RngIntElt                    Default: </PRE>
<BLOCKQUOTE>
Given a subgroup H of the group G, construct the normalizer
of H in G. A backtrack search as described in  Leon <A  HREF = "text628.htm#bib_Leon2">[Leo97]</A> is
employed.
<P>
The parameter <TT>Subgroup</TT> may be used to pass the search a known subgroup
of the normalizer. The default value of the starting subgroup is H.
If <TT>Bound</TT> is set, the search will be terminated
once the normalizing group found has order at least equal to <TT>Bound</TT>.
If this does not happen, the search will complete as normal.
</BLOCKQUOTE>
<H5><A NAME = "7031">SymmetricNormalizer(G) : GrpPerm -&gt; GrpPerm</A></H5>

<PRE>    Subgroup: GrpPerm                   Default: H</PRE>

<PRE>    Bound: RngIntElt                    Default: </PRE>
<H5>SymmetricNormaliser(G) : GrpPerm -&gt; GrpPerm</H5>
<BLOCKQUOTE>
Given a permutation group G acting on the set X, return the
normalizer of G in the symmetric group on X. The parameters are as for
<TT>Normalizer</TT> above.
</BLOCKQUOTE>
<H5><A NAME = "7032">SylowSubgroup(G, p) : GrpPerm, RngIntElt -&gt; GrpPerm</A></H5>
<H5>Sylow(G, p) : GrpPerm, RngIntElt -&gt; GrpPerm</H5>
<BLOCKQUOTE>
Given a group G and a prime p, construct a Sylow
p-subgroup of G. The algorithm used is that of Cannon, Cox and
Holt <A  HREF = "text628.htm#bib_sylow-permg">[CCH97]</A>.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "7033">Example <TT>GrpPerm_SubgroupConstructions (H63E17)</TT></A></H3>
We illustrate the use of these functions by applying them to a
group of degree 30.
<P>
<P>
<PRE>
&gt; M := PermutationGroup&lt; 30 |
&gt;         (1,2,3)(4,14,8)(5,15,9)(6,13,7)(25,27,26),
&gt;         (4,20,13)(5,21,14)(6,19,15)(16,17,18)(27,28,29),
&gt;         (1, 15)(2, 13)(3, 14)(4, 22)(5, 23)(6, 24)(7, 18)(8, 16)
&gt;           (9, 17)(10, 21)(11, 19)(12, 20)(25, 29)(26, 27)(28, 30) &gt;;
&gt; FactoredOrder(M);
[ &lt;2, 8&gt;, &lt;3, 10&gt;, &lt;5, 1&gt; ]
&gt; S2 := SylowSubgroup(M, 2);
&gt; S2;
Permutation group S2 acting on a set of cardinality 30
Order = 256 = 2^8
    (1, 10)(2, 11)(3, 12)(4, 8)(5, 9)(6, 7)(13, 19)(14, 20)(15, 21)
        (16, 22)(17, 23)(18, 24)
    (1, 24)(2, 22)(3, 23)(4, 14)(5, 15)(6, 13)(7, 19)(8, 20)(9, 21)
        (10, 18)(11, 16)(12, 17)
    (4, 8)(5, 9)(6, 7)(13, 19)(14, 20)(15, 21)
    (4, 14)(5, 15)(6, 13)(7, 19)(8, 20)(9, 21)(25, 26)(29, 30)
    (1, 4)(2, 5)(3, 6)(7, 12)(8, 10)(9, 11)(13, 23)(14, 24)(15, 22)
        (16, 21)(17, 19)(18, 20)(25, 26)
    (27, 28)(29, 30)
    (27, 29)(28, 30)
    (25, 26)(29, 30)
</PRE>
<P>
We try to find a second Sylow subgroup S2a that has trivial intersection
with S2.
<P>
<P>
<P>
<PRE>
&gt; b := exists(t){ x : x in M | Order(S2 meet S2^x) eq 1 };
&gt; b;
true
&gt; S2a := S2^t;
&gt; N := Normalizer(M, S2);
&gt; N;
Permutation group N acting on a set of cardinality 30
Order = 768 = 2^8 * 3
    (4, 8)(5, 9)(6, 7)(13, 19)(14, 20)(15, 21)
    (4, 14)(5, 15)(6, 13)(7, 19)(8, 20)(9, 21)
    (1, 10)(2, 11)(3, 12)(4, 8)(5, 9)(6, 7)(13, 19)(14, 20)(15, 21)
        (16, 22)(17, 23)(18, 24)
    (1, 24)(2, 22)(3, 23)(4, 14)(5, 15)(6, 13)(7, 19)(8, 20)(9, 21)
        (10, 18)(11, 16)(12, 17)
    (1, 22, 12)(2, 23, 10)(3, 24, 11)(4, 21, 13)(5, 19, 14)(6, 20, 15)
        (7, 8, 9)(16, 17, 18)
    (27, 29)(28, 30)
    (1, 14, 24, 4)(2, 15, 22, 5)(3, 13, 23, 6)(7, 12, 19, 17)(8, 10, 20, 18)
        (9, 11, 21, 16)(29, 30)
    (4, 14)(5, 15)(6, 13)(7, 19)(8, 20)(9, 21)(25, 26)(29, 30)
    (27, 28)(29, 30)
</PRE>
<P>
Thus the Sylow 2-subgroup is normalized by an element of order 3.
<HR>
<H4><A NAME = "7034">Maximal Subgroups</A></H4>



<H5><A NAME = "7035">IsMaximal(G, H: parameters) : GrpPerm, GrpPerm -&gt; BoolElt</A></H5>

<PRE>    Al: MonStgElt                       Default: "Subgroups"</PRE>
<BLOCKQUOTE>
Returns <TT>true</TT> if the subgroup H of the group G is a maximal subgroup
of G. The algorithm used depends on the value of the parameter <TT>Al</TT>.
The default value <TT>Subgroups</TT> computes the maximal subgroups of G
if the index of H in G is over 1000 and the maximal subgroups are computable.The subgroup H is then tested for conjugacy with each class found. 
In the other cases, or when the <TT>Al</TT> parameter is set to
<TT>CosetImage</TT>, the function is evaluated by first calling
<TT>IsProbablyMaximal</TT> and if that returns <TT>true</TT> then constructing the
permutation representation of G on the cosets of H and
testing this representation for primitivity. 
</BLOCKQUOTE>
<H5><A NAME = "7036">IsProbablyMaximal(G, H: parameters) : GrpPerm, GrpPerm -&gt; BoolElt</A></H5>

<PRE>    Tries: RngIntElt                    Default: 20</PRE>
<BLOCKQUOTE>
Given a group G and a subgroup H of G, this function performs
a probabilistic test for the maximality of H in G. The test
involves adjoining random elements of G to H and determining 
if the result G. If not, then <TT>false</TT> is returned, otherwise <TT>true</TT> 
s returned.  The number of random elements used is controlled by 
the parameter <TT>Tries</TT>, which is set to 20 by default.
</BLOCKQUOTE>
<H5><A NAME = "7037">MaximalSubgroups(G: parameters) : GrpPerm -&gt; [ rec&lt; GrpPerm, RngIntElt, RngIntElt, GrpFP&gt; ]</A></H5>
<BLOCKQUOTE>
Construct the sequence of maximal subgroup classes of G.
This is equivalent to the command <TT>Subgroups(G: Al := "Maximal")</TT>. 
The same parameters as for <TT>Subgroups</TT> are available to limit
the search.
The algorithm is described in <A  HREF = "text628.htm#bib_maxsubgrp-permg">[CH04]</A>.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "7038">Example <TT>GrpPerm_Maximals (H63E18)</TT></A></H3>
The <TT>Subgroups</TT> family of commands can deal with fairly
large groups. We look at the maximal subgroups of the group of the 
4times4times4 Rubik's cube. This group has order about 
1.7times10<sup>55</sup>.
<P>
<P>
<P>
<PRE>
&gt; load rubik444;
Loading "/home/magma/libs/pergps/rubik444"
The automorphism group of the 4 x 4 x 4 Rubik cube.
The group is represented as a permutation group of degree 72.
Its order is
2^50 * 3^29 * 5^9 * 7^7 * 11^4 * 13^2 * 17^2 * 19^2 * 23^2.
Group: G
&gt; time max := MaximalSubgroups(G);
Time: 100.559
&gt; #max;
46
&gt; [Index(G, x`subgroup) : x in max];
[ 51090942171709440000, 51090942171709440000, 9161680528000,
9161680528000, 4509264634875, 4509264634875, 316234143225, 
316234143225, 96197645544, 96197645544, 1577585295, 
1577585295, 2496144, 2496144, 1961256, 1961256, 1307504, 
1307504, 346104, 346104, 42504, 42504, 2187, 1352078, 
1352078, 735471, 735471, 134596, 134596, 10626, 10626, 2024,
2024, 120, 276, 276, 56, 24, 24, 105, 28, 8, 35, 2, 2, 2 ]
</PRE>
<HR>
<H5><A NAME = "7039">MaximalSubgroups(G,N: parameters) : GrpPerm, GrpPerm -&gt;                           [ rec&lt; GrpPerm, RngIntElt, RngIntElt, GrpFP&gt; ]</A></H5>
<BLOCKQUOTE>
Construct the sequence of maximal subgroup classes of G that contain
the normal subgroup N of G. So this is equivalent to computing the
maximal subgroups of G that contain N. <I>Warning</I>: Some parameters
may have no effect.
</BLOCKQUOTE>
<H4><A NAME = "7040">Conjugacy Classes of Subgroups</A></H4>



<H5><A NAME = "7041">SubgroupClasses(G: parameters) : GrpPerm -&gt; [ rec&lt; GrpPerm, RngIntElt, RngIntElt, GrpFP&gt; ]</A></H5>
<H5>Subgroups(G: parameters) : GrpPerm -&gt; [ rec&lt; GrpPerm, RngIntElt, RngIntElt, GrpFP&gt; ]</H5>
<BLOCKQUOTE>
Representatives for the conjugacy classes of subgroups for the
group G. The subgroups are returned as a sequence of records
where the i-th record contains:
<DL COMPACT class='compact'>
<DT>(a)</DT><DD>A representative subgroup H for the i-th conjugacy 
class (field name <TT>subgroup</TT>).
<DT>(b)</DT><DD>The order of the subgroup (field name <TT>order</TT>).
<DT>(c)</DT><DD>The number of subgroups in the class (field name <TT>length</TT>).
<DT>(d)</DT><DD>[Optional] A presentation for H (field name <TT>presentation</TT>).
<P>
<P>
<P>
<P>
<P>
</DL>
<PRE>
     Al: MonStgElt                       Default: "All"
</PRE>
<TT>Al := "All"</TT>: Construct all subgroups of G.
<P>
<TT>Al := "Maximal"</TT>: Only construct maximal subgroups of G. This option
reduces the number of intersections with any elementary abelian layer that 
need be considered and eliminates the need to recursively apply the algorithm.
<P>
<TT>Al := "Normal"</TT>: Only construct normal subgroups of G. This option
does not use database lookup to find the normal subgroups of the radical 
quotient of G and also reduces the number of intersections with any layer 
that need be considered.
<P>
<P>
<PRE>
     LayerSizes: SeqEnum                 Default: See below
</PRE>
<TT>LayerSizes := [ 2, 5, 3, 4, 7, 3, 11, 2, 17, 1]</TT> is equivalent to
the default. When constructing an Elementary Abelian series for the group,
attempt to split 2-layers of size gt 2<sup>5</sup>, 3-layers of size gt 3<sup>4</sup>,
etc. The implied exponent for 13 is 2 and for all primes greater than 17
the exponent is 1.
<P>
<P>
<PRE>
     Series: SeqEnum                     Default: See below
</PRE>
Use the given elementary abelian series rather than constructing the
default series. The first subgroup in the series must be the solvable
radical of G. The subgroups must form a descending chain of normal
subgroups of G, such that each quotient is elementary abelian. The last
subgroup in the series must be either elementary abelian or trivial.
<P>
<P>
<PRE>
     Presentation: BoolElt               Default: <TT>false</TT>
</PRE>
<TT>Presentation := true</TT>: Construct a presentation for each subgroup.
<P>
<P>
<PRE>
     OrderEqual: RngIntElt               Default: 
</PRE>
<TT>OrderEqual := n</TT>: Only construct subgroups having order equal to n.
<P>
<P>
<PRE>
     OrderDividing: RngIntElt            Default: 
</PRE>
<TT>OrderDividing := n</TT>: Only construct subgroups having order dividing n.
<P>
<P>
<PRE>
     OrderMultipleOf: RngIntElt          Default: 
</PRE>
<TT>OrderMultipleOf := n</TT>: Only construct subgroups having order a multiple
of n.
<P>
<P>
<PRE>
     IndexLimit: RngIntElt               Default: 
</PRE>
<TT>IndexLimit := n</TT>: Only construct subgroups having index in G less than
or equal to n.
<P>
<P>
<PRE>
     IsElementaryAbelian: BoolElt        Default: <TT>false</TT>
</PRE>
<TT>IsElementaryAbelian := true</TT>: Only construct elementary abelian subgroups 
of G.
<P>
<P>
<PRE>
     IsCyclic: BoolElt                   Default: <TT>false</TT>
</PRE>
<TT>IsCyclic := true</TT>: Only construct cyclic subgroups of G.
<P>
<P>
<PRE>
     IsAbelian: BoolElt                  Default: <TT>false</TT>
</PRE>
<TT>IsAbelian := true</TT>: Only construct abelian subgroups of G.
<P>
<P>
<PRE>
     IsNilpotent: BoolElt                Default: <TT>false</TT>
</PRE>
<TT>IsNilpotent := true</TT>: Only construct nilpotent subgroups of G.
<P>
<P>
<PRE>
     IsSolvable: BoolElt                 Default: <TT>false</TT>
</PRE>
<TT>IsSolvable := true</TT>: Only construct solvable subgroups of G.
<P>
<P>
<PRE>
     IsNotSolvable: BoolElt              Default: <TT>false</TT>
</PRE>
<TT>IsNotSolvable := true</TT>: Only construct insolvable subgroups of G.
<P>
<P>
<PRE>
     IsPerfect: BoolElt                  Default: <TT>false</TT>
</PRE>
<TT>IsPerfect := true</TT>: Only construct perfect subgroups of G.
<P>
<P>
<PRE>
     IsRegular: BoolElt                  Default: <TT>false</TT>
</PRE>
<TT>IsRegular := true</TT>: Only construct regular subgroups of G.
<P>
<P>
<PRE>
     IsTransitive: BoolElt               Default: <TT>false</TT>
</PRE>
<TT>IsTransitive := true</TT>: Only construct transitive subgroups of G.
<P>
<P>
<P>
<B>The Algorithm:</B> (See Cannon, Cox and Holt <A  HREF = "text628.htm#bib_subgroups-permg">[CCH01]</A>)
This command proceeds by first
constructing an elementary abelian series for G together with 
G's radical quotient Q. We first attempt to locate the quotient in a 
database of groups with trivial Fitting subgroup. This database contains
all such groups of order up to 216 000, and all such which are 
perfect of order
up to 1 000 000. If Q is found then either all its subgroups,
or its maximal subgroups are read from the database. (In some cases only 
the maximal subgroups are stored.) If Q is not found then we attempt to
find the maximal subgroups of Q using a method of Derek Holt. For this to
succeed all simple factors of the socle of Q must be found in a second 
database which currently contains all simple groups of order less than 
1.6 x 10<sup>7</sup>, as well as M<sub>24</sub>, HS, J<sub>3</sub>,
McL, Sz(32) and L<sub>6</sub>(2). There are also special routines to handle 
numerous other groups. These include: A<sub>n</sub> for n &le;2499, 
L<sub>2</sub>(q), L<sub>3</sub>(q), L<sub>4</sub>(q), L<sub>5</sub>(q), L<sub>6</sub>(q) and L<sub>7</sub>(q) for all q,
U<sub>3</sub>(q) for all q,
U<sub>4</sub>(q) for all q,
S<sub>4</sub>(q) for all q, 
L<sub>d</sub>(2) for d &le;14, and the following groups:
U<sub>5</sub>(3), U<sub>6</sub>(2), U<sub>7</sub>(2), U<sub>8</sub>(2),
S<sub>6</sub>(3), S<sub>6</sub>(4), S<sub>6</sub>(5), S<sub>8</sub>(2), S<sub>8</sub>(3), S<sub>10</sub>(2), S<sub>12</sub>(2), 
O<sup>&#8723;</sup><sub>8</sub>(2), O<sup>&#8723;</sup><sub>8</sub>(3), O<sup>&#8723;</sup><sub>8</sub>(4), O<sup>&#8723;</sup><sub>10</sub>(2), O<sup>&#8723;</sup><sub>12</sub>(2),
O<sub>7</sub>(3), O<sub>7</sub>(5), O<sub>9</sub>(3), 
G<sub>2</sub>(4), G<sub>2</sub>(5), ()<sup>3</sup>D<sub>4</sub>(2), ()<sup>2</sup>F<sub>4</sub>(2)',
Co<sub>2</sub>, Co<sub>3</sub>, He, Fi<sub>22</sub>, Ru, Suz, ON.
<P>
If we have only maximal subgroups of Q, and more are required, we apply
the algorithm recursively to the maximal subgroups to determine all subgroups
of Q. This may take some time.
<P>
The subgroups are then extended to the
whole group by stepwise extension through each layer of the elementary 
abelian series. For each layer this involves determining all possible 
intersections of a subgroup with this layer and all extensions with this 
intersection. 
<P>
The limitations are that the simple factors of the socle of Q must be in 
the database, which is limited as above. Further, it may take
some time to construct all subgroups from the maximal subgroups first found,
and, if there is a large elementary abelian layer, there will be many 
possible intersections, which could also make the algorithm prohibitively slow.
<P>
There are numerous parameters for this function which allow the user to
place restrictions on which subgroup classes are constructed. Using these 
restrictions may help overcome the problems noted above.
</BLOCKQUOTE>
<H5><A NAME = "7042">SubgroupsLift(G, A, B, Q: parameters) : GrpPerm, GrpPerm, GrpPerm, SeqEnum -&gt; SeqEnum</A></H5>
<BLOCKQUOTE>
This function isolates one step of the extension process used by the
<TT>Subgroups</TT> family of functions. The argument 
Q is a sequence of records such
as returned by <TT>Subgroups(G)</TT>.
The groups A and B are normal subgroups of G with A/B elementary abelian.
The records in Q are interpreted as subgroups of G/A,
which are lifted to all possible corresponding subgroups of G/B, subject 
to the parameters given.
</BLOCKQUOTE>
<H5><A NAME = "7043">LowIndexSubgroups(G, n: parameters) : GrpPerm, RngIntElt -&gt; SeqEnum</A></H5>
<H5>LowIndexSubgroups(G, t: parameters) : GrpPerm, Tup -&gt; SeqEnum</H5>
<BLOCKQUOTE>
Returns a sequence of subgroups of G, each with index at most n.
The sequence will contain one representative from each conjugacy
class  of G-subgroups satisfying the index constraint.
The algorithm used is described in Cannon, Holt, Slattery &amp; Steel
<A  HREF = "text628.htm#bib_CHSS-lix">[CHSS03]</A>.
<P>
The previous version of the algorithm is available by setting the
parameter <TT>Algorithm</TT> to the string <TT>"Subgroups"</TT>.
In this case the group G is subject to the same restrictions as the group
input to the <TT>Subgroups</TT> function above.
<P>
In the second form t should be a pair of integers &lt; a, b &gt;,
and subgroups with index in the interval [a, b] will be returned.
<P>
Other parameters are <TT>Presentation</TT> which may be set <TT>true</TT> to return 
a second sequence of presentations of the groups found, and <TT>Print</TT>
which may be set to a positive integer to turn on diagnostic printing of 
the progress of the algorithms. 
</BLOCKQUOTE>
<H5><A NAME = "7044">LowIndexSubgroups(G, N, n: parameters) : GrpPerm, RngIntElt -&gt; SeqEnum</A></H5>
<H5>LowIndexSubgroups(G, N, t: parameters) : GrpPerm, Tup -&gt; SeqEnum</H5>
<BLOCKQUOTE>
Same as above, but only those subgroups containing the normal subgroup N
of G are returned. This is equivalent to computing the low index subgroups
of G/N. Only the <TT>Print</TT> parameter is available for this command.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "7045">Example <TT>GrpPerm_Subgroups (H63E19)</TT></A></H3>
With the <TT>Subgroups</TT> family of commands we can
get the entire collection of (classes of) subgroups of a group G.
We look at the double cover of M<sub>12</sub>.
<P>
<P>
<P>
<PRE>
&gt; load m12cover;
Loading "/home/magma/libs/pergps/m12cover"
The two-fold cover of the Mathieu group M12 on 24 letters.
Order is 190080 = 2^7 * 3^3 * 5 * 11.
Group: G
&gt; time s := SubgroupClasses(G);
Time: 4.469
&gt; #s;
293
</PRE>
<P>
This may be too many. The parameters allow us to restrict attention to a
subset of the subgroups.  We specify that the function is to return only 
the elementary abelian 2-subgroups of G.
<P>
<P>
<P>
<PRE>
&gt; se := SubgroupClasses(G : IsElementaryAbelian := true,
&gt;               OrderMultipleOf := 2);
&gt; #se;
14
&gt; se : Minimal;
Conjugacy classes of subgroups
------------------------------


[ 1]    Order 2            Length 1
        GrpPerm: $, Degree 24, Order 2
[ 2]    Order 2            Length 495
        GrpPerm: $, Degree 24, Order 2
[ 3]    Order 2            Length 495
        GrpPerm: $, Degree 24, Order 2
[ 4]    Order 4            Length 495
        GrpPerm: $, Degree 24, Order 2^2
[ 5]    Order 4            Length 495
        GrpPerm: $, Degree 24, Order 2^2
[ 6]    Order 4            Length 1485
        GrpPerm: $, Degree 24, Order 2^2
[ 7]    Order 4            Length 1980
        GrpPerm: $, Degree 24, Order 2^2
[ 8]    Order 4            Length 5940
        GrpPerm: $, Degree 24, Order 2^2
[ 9]    Order 8            Length 495
        GrpPerm: $, Degree 24, Order 2^3
[10]    Order 8            Length 495
        GrpPerm: $, Degree 24, Order 2^3
[11]    Order 8            Length 1485
        GrpPerm: $, Degree 24, Order 2^3
[12]    Order 8            Length 1980
        GrpPerm: $, Degree 24, Order 2^3
[13]    Order 8            Length 1980
        GrpPerm: $, Degree 24, Order 2^3
[14]    Order 16           Length 495
        GrpPerm: $, Degree 24, Order 2^4
</PRE>
<HR>
<H3><A NAME = "7046">Example <TT>GrpPerm_Subgroups-2 (H63E20)</TT></A></H3>
Using the <TT>SubgroupLattice</TT> function we obtain a
representative subgroup for each conjugacy class together with 
the inclusion relations between subgroups.
<P>
<B>WARNING:</B> <I>Computing the inclusions is very time consuming and 
should only be performed for small groups.</I>
<P>
<P>
<P>
<PRE>
&gt; G := PSL(2,9);
&gt; time L := SubgroupLattice(G);
Time: 0.20O
&gt; L; 
Partially ordered set of subgroup classes
-----------------------------------------

[ 1]  Order 1    Length 1   Maximal Subgroups:
---
[ 2]  Order 2    Length 45  Maximal Subgroups: 1
[ 3]  Order 3    Length 20  Maximal Subgroups: 1
[ 4]  Order 3    Length 20  Maximal Subgroups: 1
[ 5]  Order 5    Length 36  Maximal Subgroups: 1
---
[ 6]  Order 4    Length 15  Maximal Subgroups: 2
[ 7]  Order 4    Length 15  Maximal Subgroups: 2
[ 8]  Order 4    Length 45  Maximal Subgroups: 2
[ 9]  Order 6    Length 60  Maximal Subgroups: 2 3
[10]  Order 6    Length 60  Maximal Subgroups: 2 4
[11]  Order 9    Length 10  Maximal Subgroups: 3 4
[12]  Order 10   Length 36  Maximal Subgroups: 2 5
---
[13]  Order 8    Length 45  Maximal Subgroups: 6 7 8
[14]  Order 12   Length 15  Maximal Subgroups: 4 6
[15]  Order 12   Length 15  Maximal Subgroups: 3 7
[16]  Order 18   Length 10  Maximal Subgroups: 9 10 11
---
[17]  Order 24   Length 15  Maximal Subgroups: 10 13 14
[18]  Order 24   Length 15  Maximal Subgroups: 9 13 15
[19]  Order 36   Length 10  Maximal Subgroups: 8 16
[20]  Order 60   Length 6   Maximal Subgroups: 9 12 15
[21]  Order 60   Length 6   Maximal Subgroups: 10 12 14
---
[22]  Order 360  Length 1   Maximal Subgroups: 17 18 19 20 21

&gt; NumberOfInclusions(L!5, L!20);
6
&gt; L[5];
Permutation group acting on a set of cardinality 10
Order = 5
  (1, 8, 9, 3, 4)(2, 7, 5, 10, 6)
</PRE>
<P>
The order and class length of each class of subgroups is listed,
along with the information about where to find the maximal subgroups
of a member of this class. Further information about inclusions is
available from the lattice. We see that 6 members of class 5 are
contained in any fixed member of class 20.
<HR>
<H5><A NAME = "7047">SubgroupLattice(G) : GrpPerm -&gt; SubGrpLat</A></H5>
<BLOCKQUOTE>
The lattice of conjugacy classes of subgroups of G.
</BLOCKQUOTE>
<H5><A NAME = "7048">BurnsideMatrix(G) : GrpPerm -&gt; AlgMatElt</A></H5>
<BLOCKQUOTE>
The Burnside matrix corresponding to the lattice of subgroups of G.
The (i, j)th entry of the matrix is the number of subgroups in class i
contained in a single subgroup of class j when i&le;j, and is the
number of subgroups of class i containing a given subgroup in class j
when i&ge;j.
</BLOCKQUOTE>
<H5><A NAME = "7049">DisplayBurnsideMatrix(G) : GrpPerm -&gt;</A></H5>
<BLOCKQUOTE>
Pretty-print the Burnside matrix corresponding to the lattice of
subgroups of G.
</BLOCKQUOTE>
<H5><A NAME = "7050">TableOfMarks(G) : GrpPerm -&gt; AlgMatElt</A></H5>
<BLOCKQUOTE>
Burnside's table of marks corresponding to the lattice of subgroups of G.
Rows correspond to marks for transitive permutation representations of G,
while the entries in column j are the number of fixed points of subgroup
class j in each transitive representation.
</BLOCKQUOTE>
<H4><A NAME = "7051">Classes of Subgroups Satisfying a  Condition</A></H4>



<H5><A NAME = "7052">NormalSubgroups(G: parameters) : GrpPerm -&gt; [ rec&lt; GrpPerm, RngIntElt, RngIntElt, GrpFP&gt; ]</A></H5>
<BLOCKQUOTE>
Construct the sequence of normal subgroup classes of G.
This is equivalent to <TT>Subgroups(G: Al := "Normal")</TT>. 
The same parameters as for <TT>Subgroups</TT> are available to limit
the search.
</BLOCKQUOTE>
<H5><A NAME = "7053">ElementaryAbelianSubgroups(G: parameters) : GrpPerm -&gt; [ rec&lt; GrpPerm, RngIntElt, RngIntElt, GrpFP&gt; ]</A></H5>
<BLOCKQUOTE>
Construct the sequence of elementary abelian subgroups of G.
This is equivalent to <TT>Subgroups(G: IsElementaryAbelian := true)</TT>.
The same parameters as for <TT>Subgroups</TT> are available to limit
the search.
</BLOCKQUOTE>
<H5><A NAME = "7054">CyclicSubgroups(G: parameters) : GrpPerm -&gt; [ rec&lt; GrpPerm, RngIntElt, RngIntElt, GrpFP&gt; ]</A></H5>
<BLOCKQUOTE>
Construct the sequence of cyclic subgroups of G.
This is equivalent to <TT>Subgroups(G: IsCyclic := true)</TT>.
The same parameters as for <TT>Subgroups</TT> are available to limit
the search.
</BLOCKQUOTE>
<H5><A NAME = "7055">AbelianSubgroups(G: parameters) : GrpPerm -&gt; [ rec&lt; GrpPerm, RngIntElt, RngIntElt, GrpFP&gt; ]</A></H5>
<BLOCKQUOTE>
Construct the sequence of abelian subgroups of G.
Equivalent to <TT>Subgroups(G:</TT> <TT>IsAbelian := true)</TT>.
The same parameters as for <TT>Subgroups</TT> are available to limit
the search.
</BLOCKQUOTE>
<H5><A NAME = "7056">NilpotentSubgroups(G: parameters) : GrpPerm -&gt; [ rec&lt; GrpPerm, RngIntElt, RngIntElt, GrpFP&gt; ]</A></H5>
<BLOCKQUOTE>
Construct the sequence of nilpotent subgroups of G.
This is equivalent to <TT>Subgroups(G: IsNilpotent := true)</TT>.
The same parameters as for <TT>Subgroups</TT> are available to limit
the search.
</BLOCKQUOTE>
<H5><A NAME = "7057">SolvableSubgroups(G: parameters) : GrpPerm -&gt; [ rec&lt; GrpPerm, RngIntElt, RngIntElt, GrpFP&gt; ]</A></H5>
<BLOCKQUOTE>
Construct the sequence of solvable subgroups of G.
This is equivalent to <TT>Subgroups(G: IsSolvable := true)</TT>.
The same parameters as for <TT>Subgroups</TT> are available to limit
the search.
</BLOCKQUOTE>
<H5><A NAME = "7058">PerfectSubgroups(G: parameters) : GrpPerm -&gt; [ rec&lt; GrpPerm, RngIntElt, RngIntElt, GrpFP&gt; ]</A></H5>
<BLOCKQUOTE>
Construct the sequence of perfect subgroups of G.
Equivalent to <TT>Subgroups(G:</TT> <TT>IsNotSolvable := true)</TT>.
The same parameters as for <TT>Subgroups</TT> are available to limit
the search.
</BLOCKQUOTE>
<H5><A NAME = "7059">NonsolvableSubgroups(G: parameters) : GrpPerm -&gt; [ rec&lt; GrpPerm, RngIntElt, RngIntElt, GrpFP&gt; ]</A></H5>
<BLOCKQUOTE>
Construct the sequence of insolvable subgroups of G.
This is equivalent to <TT>Subgroups(G: IsNotSolvable := true)</TT>.
The same parameters as for <TT>Subgroups</TT> are available to limit
the search.
</BLOCKQUOTE>
<H5><A NAME = "7060">SimpleSubgroups(G: parameters) : GrpPerm -&gt; [ rec&lt; GrpPerm, RngIntElt, RngIntElt, GrpFP&gt; ]</A></H5>
<BLOCKQUOTE>
Construct the sequence of non-abelian simple subgroup classes of G.
This is equivalent to <TT>Subgroups(G: Al := "Simple")</TT>. 
The same parameters as for <TT>Subgroups</TT> are available to limit
the search.
</BLOCKQUOTE>
<PRE></PRE> <A  HREF = "text638.htm">[Next]</A><A  HREF = "text636.htm">[Prev]</A> <A  HREF = "text638.htm">[Right]</A> <A  HREF = "text636.htm">[Left]</A> <A  HREF = "text629.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<br><small>Version: V2.22 of <I>
Thu Jun  9 16:37:49 EST 2016
</I></small>
</body></html>