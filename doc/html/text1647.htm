<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <link rel='stylesheet' href='help.css' type='text/css'>
  <TITLE>Subgroups of Modular Abelian Varieties</TITLE>
</head>
<body BGCOLOR="#FFFFFF">

 <A  HREF = "text1648.htm">[Next]</A><A  HREF = "text1646.htm">[Prev]</A> <A  HREF = "text1648.htm">[Right]</A> <A  HREF = "text1646.htm">[Left]</A> <A  HREF = "text1635.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<PRE></PRE><H3><A NAME = "18442">Subgroups of Modular Abelian Varieties</A></H3>

<P>
<P>
<P>
<P>



<H5>Subsections</H5>
<UL>
<LI> <A  HREF = "text1647.htm#18443">Creation</A>
<LI> <A  HREF = "text1647.htm#18450">Elements</A>
<LI> <A  HREF = "text1647.htm#18456">Arithmetic</A>
<LI> <A  HREF = "text1647.htm#18464">Underlying Abelian Group and  Lattice</A>
<LI> <A  HREF = "text1647.htm#18468">Invariants</A>
<LI> <A  HREF = "text1647.htm#18475">Predicates and Comparisons</A>
</UL>
<H4><A NAME = "18443">Creation</A></H4>

<P>
<P>
<P>
Subgroups can be created from a sequence of elements of a modular 
abelian variety which generate it.
It is also possible to create n-torsion subgroups A[n] and to 
create subgroups as kernels of homomorphisms or by taking an image 
of the difference of two cusps.
<P>
If a subgroup G contains elements that are not known exactly (i.e.,
they are defined by floating point approximations to real homology
elements),  
a group of torsion points that approximates G can be found.


<H5><A NAME = "18444">Subgroup(X) : [ModAbVarElt] -&gt;  ModAbVarSubGrp</A></H5>
<BLOCKQUOTE>
The subgroup of A generated by the nonempty sequence X of 
elements of modular abelian variety A.  
</BLOCKQUOTE>
<H5><A NAME = "18445">ZeroSubgroup(A) : ModAbVar -&gt;  ModAbVarSubGrp</A></H5>
<BLOCKQUOTE>
The zero subgroup of the abelian variety A.  
</BLOCKQUOTE>
<H5><A NAME = "18446">nTorsionSubgroup(A, n) : ModAbVar, RngIntElt -&gt;  ModAbVarSubGrp</A></H5>
<BLOCKQUOTE>
The kernel A[n] of the multiplication by n isogeny on the modular abelian
variety A.  
</BLOCKQUOTE>
<H5><A NAME = "18447">nTorsionSubgroup(G, n) : ModAbVarSubGrp, RngIntElt -&gt;  ModAbVarSubGrp</A></H5>
<BLOCKQUOTE>
The kernel G[n] of the multiplication by n homomorphism on the subgroup
G of a modular abelian variety.  
</BLOCKQUOTE>
<H5><A NAME = "18448">ApproximateByTorsionGroup(G : parameters) : ModAbVarSubGrp -&gt;  ModAbVarSubGrp</A></H5>

<PRE>    Cutoff: RngIntElt                   Default: 10^3</PRE>
<BLOCKQUOTE>
The subgroup generated by torsion approximations of a set of 
generators of the subgroup G of a modular abelian variety.  
</BLOCKQUOTE>
<HR>
<H3><A NAME = "18449">Example <TT>ModAbVar_Subgrp-Creation (H142E103)</TT></A></H3>
First we list the elements of the 2-torsion subgroup
of the elliptic curve 100A, then we compute the 0
subgroup.
<P>
<P>
<PRE>
&gt; A := ModularAbelianVariety("100A"); A;
Modular abelian variety 100A of dimension 1 and level 2^2*5^2 
over Q
&gt; G := nTorsionSubgroup(A,2); G;
Finitely generated subgroup of abelian variety with invariants [ 2, 2 ]
&gt; Elements(G);
[
    0,
    Element of abelian variety defined by [1/2 0] modulo homology,
    Element of abelian variety defined by [0 1/2] modulo homology,
    Element of abelian variety defined by [1/2 1/2] modulo homology
]
&gt; ZeroSubgroup(A);
{ 0 }: finitely generated subgroup of abelian variety with 
invariants []
</PRE>
We can also use the <TT>nTorsionSubgroup</TT> command on
subgroups.
<P>
<P>
<PRE>
&gt; nTorsionSubgroup(G,2);
Finitely generated subgroup of abelian variety with 
invariants [ 2, 2 ]
&gt; nTorsionSubgroup(G,3);
{ 0 }: finitely generated subgroup of abelian variety with 
invariants []
</PRE>
<P>
One of the 2-torsion elements generates a subgroup H 
of order 2.
<P>
<P>
<PRE>
&gt; G.1;
Element of abelian variety defined by [0 1/2] modulo homology
&gt; H := Subgroup([G.1]); H;
Finitely generated subgroup of abelian variety
&gt; #H;
2
</PRE>
To illustrate the approximation command, we consider
the subgroup generated by an approximation to
one of the 2-torsion elements. 
<P>
<P>
<PRE>
&gt; K := Subgroup([1.00001*G.1]);
&gt; L := ApproximateByTorsionGroup(K);
Finitely generated subgroup of abelian variety with 
invariants [ 2 ]
&gt; L eq H;
true
</PRE>
<HR>
<H4><A NAME = "18450">Elements</A></H4>

<P>
<P>
<P>
These commands enumerate elements of a finite subgroup of a modular
abelian variety and allow access to the generators. 


<H5><A NAME = "18451">Elements(G) : ModAbVarSubGrp -&gt;  SeqEnum</A></H5>
<BLOCKQUOTE>
A sequence of all elements of the finite subgroup G of a modular 
abelian variety.  
</BLOCKQUOTE>
<H5><A NAME = "18452">Generators(G) : ModAbVarSubGrp -&gt;  SeqEnum</A></H5>
<BLOCKQUOTE>
A sequence of generators for the subgroup G of a modular abelian variety. 
These correspond to generators for the 
underlying abelian group.  
</BLOCKQUOTE>
<H5><A NAME = "18453">Ngens(G) : ModAbVarSubGrp -&gt;  RngIntElt</A></H5>
<BLOCKQUOTE>
The number generators of the subgroup G of a modular abelian variety.  
</BLOCKQUOTE>
<H5><A NAME = "18454">G . i : ModAbVarSubGrp, RngIntElt -&gt;  ModAbVarElt</A></H5>
<BLOCKQUOTE>
The i-th generator of the subgroup G of a modular abelian variety.  
</BLOCKQUOTE>
<HR>
<H3><A NAME = "18455">Example <TT>ModAbVar_Subgrp-Elements (H142E104)</TT></A></H3>
<P>
We illustrate each of the commands using the kernel
of the Hecke operator T<sub>3</sub> acting on J<sub>0</sub>(67).
<P>
<P>
<PRE>
&gt; J := JZero(67);
&gt; T := HeckeOperator(J,3);
&gt; G := Kernel(T);
&gt; #G;
4
&gt; Elements(G);
[
    0,
    Element of abelian variety defined by [0 0 1/2 0 0 -1/2 -1/2 0 1/2 0] modulo
    homology,
    Element of abelian variety defined by [1/2 -1/2 0 0 -1/2 0 0 -1/2 1/2 0] 
    modulo homology,
    Element of abelian variety defined by [1/2 -1/2 1/2 0 -1/2 -1/2 -1/2 -1/2 1 0] 
    modulo homology 
]
&gt; Generators(G);
[
    Element of abelian variety defined by [1/2 -1/2 0 0 -1/2 0 0 -1/2 1/2 0] 
    modulo homology,
    Element of abelian variety defined by [0 0 1/2 0 0 -1/2 -1/2 0 1/2 0] 
    modulo homology
]
&gt; Ngens(G);
2
&gt; G.1;
Element of abelian variety defined by [1/2 -1/2 0 0 -1/2 0 0 -1/2 1/2 0] modulo 
homology
&gt; G.2;
Element of abelian variety defined by [0 0 1/2 0 0 -1/2 -1/2 0 1/2 0] modulo 
homology
</PRE>
<HR>
<H4><A NAME = "18456">Arithmetic</A></H4>

<P>
<P>
<P>
  Quotients of abelian varieties by
  finite subgroups can be formed, finite subgroups can be intersected
  with other finite
  subgroups or abelian varieties, and the group generated
  by two subgroups can be computed.
<P>
  For several of the arithmetic operations below, finite groups or
  abelian varieties are replaced by their image in a common abelian
  variety, so the operation makes sense.  This common abelian variety
  is the one returned by <A  HREF = "text1641.htm#fce">FindCommonEmbeddings</A>.  Note
  that the "embedding" is only guaranteed to be an embedding
  up to isogeny.


<H5><A NAME = "18457">Quotient(A, G) : ModAbVar, ModAbVarSubGrp -&gt;  ModAbVar, MapModAbVar</A></H5>
<BLOCKQUOTE>
The quotient of the abelian variety A by the finite subgroup G of A, the 
isogeny A to A/G and an isogeny A/G to A, such that composition of 
the two isogenies is multiplication by the exponent of G.  
</BLOCKQUOTE>
<H5><A NAME = "18458">Quotient(G) : ModAbVarSubGrp -&gt;  ModAbVar, MapModAbVar, MapModAbVar</A></H5>
<BLOCKQUOTE>
The quotient A/G, where A is the ambient variety of the subgroup G
of an abelian variety, an 
isogeny from A to A/G with kernel G, and an isogeny from A/G to A 
such that the composition of the two isogenies is multiplication by the 
exponent of G.  
</BLOCKQUOTE>
<H5><A NAME = "18459">A / G : ModAbVar, ModAbVarSubGrp -&gt;  ModAbVar, MapModAbVar, MapModAbVar</A></H5>
<BLOCKQUOTE>
Given an abelian variety A and a subgroup G of an abelian variety
return the quotient A/G, the isogeny A to A/G with kernel G, and an 
isogeny A/G to A where A is not necessarily the ambient variety of G.  
</BLOCKQUOTE>
<H5><A NAME = "18460">A meet G : ModAbVar, ModAbVarSubGrp -&gt;  ModAbVarSubGrp</A></H5>
<H5>G meet A : ModAbVarSubGrp, ModAbVar -&gt;  ModAbVarSubGrp</H5>
<BLOCKQUOTE>
The intersection of the finite subgroup G of an abelian variety B 
with the abelian variety A. If A is not equal to B, then G and A 
are replaced by their image in a common abelian variety.  
</BLOCKQUOTE>
<H5><A NAME = "18461">G1 + G2 : ModAbVarSubGrp, ModAbVarSubGrp -&gt;  ModAbVarSubGrp</A></H5>
<BLOCKQUOTE>
The sum of the subgroups G<sub>1</sub> and G<sub>2</sub> of abelian varieties 
A<sub>1</sub> and A<sub>2</sub>. If A<sub>1</sub> is not equal to A<sub>2</sub>, then G<sub>1</sub> and G<sub>2</sub> are 
replaced by their image in a common abelian variety.  
</BLOCKQUOTE>
<H5><A NAME = "18462">G1 meet G2 : ModAbVarSubGrp, ModAbVarSubGrp -&gt;  ModAbVarSubGrp</A></H5>
<BLOCKQUOTE>
The intersection of the finite subgroups G<sub>1</sub> and G<sub>2</sub> of an 
abelian variety. If their ambient varieties are not equal, G<sub>1</sub> and G<sub>2</sub> 
are replaced by their image in a common abelian variety.  
</BLOCKQUOTE>
<HR>
<H3><A NAME = "18463">Example <TT>ModAbVar_Subgrp-Arithmetic (H142E105)</TT></A></H3>
<P>
We illustrate these commands using the 2-torsion of J<sub>0</sub>(67).
First we compute the kernel of T<sub>3</sub>, which is a 2-torsion group
of order 4.
<P>
<P>
<PRE>
&gt; J := JZero(67); J;
Modular abelian variety JZero(67) of dimension 5 and level 67 over Q
&gt; T := HeckeOperator(J,3); 
&gt; Factorization(CharacteristicPolynomial(T));
[
    &lt;x + 2, 2&gt;,
    &lt;x^2 - x - 1, 2&gt;,
    &lt;x^2 + 3*x + 1, 2&gt;
]
&gt; G := Kernel(T); #G;
4
</PRE>
Next we quotient J<sub>0</sub>(67) out by this subgroup of order 4.
<P>
<P>
<PRE>
&gt; A := Quotient(J,G); A;
Modular abelian variety of dimension 5 and level 67 over Q
</PRE>
The result is, of course, isogenous to J<sub>0</sub>(67).  Unfortunately,
testing of isomorphism in this generality is not yet implemented.
<P>
<P>
<PRE>
&gt; IsIsogenous(A,J);
true
&gt; Degree(ModularParameterization(A));
4
</PRE>
If the <TT>Quotient</TT> command is given only one argument
then the variety being quotiented out by is the ambient variety.
<P>
<P>
<PRE>
&gt; B := Quotient(G); B;
Modular abelian variety of dimension 5 and level 67 over Q
&gt; Degree(ModularParameterization(B));
4
</PRE>
We can also use the divides notation for quotients.
<P>
<P>
<PRE>
&gt; C := J/G; C;
Modular abelian variety of dimension 5 and level 67 over Q
</PRE>
Next we list the 2-torsion subgroups of the simple factors
of J<sub>0</sub>(67).  Interestingly, the sum of the 2-torsion
subgroups of these simple factors is much smaller than the
full 2-torsion subgroup J<sub>0</sub>(67)[2].
<P>
<P>
<PRE>
&gt; D := Decomposition(J); D;
[
    Modular abelian variety 67A of dimension 1, level 67 and 
    conductor 67 over Q,
    Modular abelian variety 67B of dimension 2, level 67 and 
    conductor 67^2 over Q,
    Modular abelian variety 67C of dimension 2, level 67 and 
    conductor 67^2 over Q
]
&gt; for A in D do print #(A meet G); end for;
4
1
1
&gt; G2 := nTorsionSubgroup(D[2],2);
&gt; G3 := nTorsionSubgroup(D[3],2);
&gt; H := G + G2 + G3;
&gt; #H;
64
&gt; H eq nTorsionSubgroup(J,2);
false
&gt; #nTorsionSubgroup(J,2);
1024
&gt; G2 eq G3;
true
&gt; G meet G2;
{ 0 }: finitely generated subgroup of abelian variety with invariants []
</PRE>
<HR>
<H4><A NAME = "18464">Underlying Abelian Group and  Lattice</A></H4>



<H5><A NAME = "18465">AbelianGroup(G) : ModAbVarSubGrp -&gt;  GrpAb, Map, Map</A></H5>
<BLOCKQUOTE>
Let G be a finitely generated subgroup of an abelian variety A.
Return an abstract abelian group H which
is isomorphic to G along with isomorphisms in both directions.
</BLOCKQUOTE>
<H5><A NAME = "18466">Lattice(G) : ModAbVarSubGrp -&gt;  Lat</A></H5>
<BLOCKQUOTE>
Let G be a finite torsion subgroup of its ambient abelian 
variety A whose elements are all known exactly, i.e. G is 
generated by elements of H<sub>1</sub>(A, Q )/H<sub>1</sub>(A, Z ). Return the lattice
L in the rational homology of A 
generated by H<sub>1</sub>(A, Z ) and all x such that G can be viewed as a   
set of equivalence classes of the form x + H<sub>1</sub>(A, Z ).
</BLOCKQUOTE>
<HR>
<H3><A NAME = "18467">Example <TT>ModAbVar_Subgrp-Underlying_Abelian_Group_and_Lattice (H142E106)</TT></A></H3>
This examples illustrate these 
commands for the 3-torsion subgroup of J<sub>0</sub>(11). 
<P>
<P>
<PRE>
&gt; A := JZero(11);
&gt; G := nTorsionSubgroup(A,3);
&gt; H,f,g := AbelianGroup(G);
&gt; H;
Abelian Group isomorphic to Z/3 + Z/3
Defined on 2 generators
Relations:
    3*H.1 = 0
    3*H.2 = 0
</PRE>
The lattice of G is 1/3 times the integral homology.
<P>
<P>
<PRE>
&gt; Lattice(G);
Lattice of rank 2 and degree 2
Basis:
[Identity matrix]
Basis Denominator: 3
&gt; L := IntegralHomology(A); L;
Standard Lattice of rank 2 and degree 2
&gt; Lattice(G)/L;
Abelian Group isomorphic to Z/3 + Z/3
Defined on 2 generators
Relations:
    3*$.1 = 0
    3*$.2 = 0
</PRE>
<HR>
<H4><A NAME = "18468">Invariants</A></H4>



<H5><A NAME = "18469">AmbientVariety(G) : ModAbVarSubGrp -&gt;  ModAbVar</A></H5>
<BLOCKQUOTE>
Let G be a finitely generated subgroup of an abelian variety. Return
the abelian variety whose elements were used to create G.
</BLOCKQUOTE>
<H5><A NAME = "18470">Exponent(G) : ModAbVarSubGrp -&gt;  RngIntElt</A></H5>
<BLOCKQUOTE>
Given a finitely generated subgroup G of an abelian variety, return the smallest 
positive integer e which kills G, i.e. such that eG = 0.
We assume G is finite.  
</BLOCKQUOTE>
<H5><A NAME = "18471">Invariants(G) : ModAbVarSubGrp -&gt;  SeqEnum</A></H5>
<BLOCKQUOTE>
Given a finitely generated subgroup of an abelian variety, return the invariants
of an abstract abelian group isomorphic to G.
</BLOCKQUOTE>
<H5><A NAME = "18472">Order(G) : ModAbVarSubGrp -&gt;  RngIntElt</A></H5>
<H5># G : ModAbVarSubGrp -&gt;  RngIntElt</H5>
<BLOCKQUOTE>
Given a finitely generated subgroup G of an abelian variety, 
return the number of elements in G, when G is
known to be finite (an error occurs otherwise).  
</BLOCKQUOTE>
<H5><A NAME = "18473">FieldOfDefinition(G) : ModAbVarSubGrp -&gt;  Fld</A></H5>
<BLOCKQUOTE>
Given a finitely generated subgroup G of an abelian variety
return a field over which the group
G is defined.  This is a field K such that if &sigma; is an
automorphism that fixes K, then &sigma;(G)=G.  Note that 
<I>K is not guaranteed to be minimal</I>.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "18474">Example <TT>ModAbVar_Subgrp-Invariants (H142E107)</TT></A></H3>
We illustrate each command using the kernel of T<sub>3</sub> on J<sub>0</sub>(67).
<P>
<P>
<PRE>
&gt; A := JZero(67);
&gt; T3 := HeckeOperator(A,3);
&gt; G := Kernel(T3); G;
Finitely generated subgroup of abelian variety with
[ 2, 2 ]
&gt; AmbientVariety(G);
Modular abelian variety JZero(67) of dimension 5 and level 67 over Q
&gt; Exponent(G);
2
&gt; Invariants(G);
[ 2, 2 ]
&gt; Order(G);
4
&gt; #G;
4
</PRE>
The field of definition of G is Q, since G is the kernel
of a homomorphism defined over Q (a Hecke operator).
<P>
<P>
<PRE>
&gt; FieldOfDefinition(G);
Rational Field
</PRE>
However, the field of definition of the subgroup of G generated
by one of the elements of G could take significant extra work
to determine.  Currently Magma simply chooses the easiest answer,
which is Qbar.
<P>
<P>
<PRE>
&gt; H := Subgroup([G.1]);
&gt; FieldOfDefinition(H);
Algebraically closed field with no variables
</PRE>
<HR>
<H4><A NAME = "18475">Predicates and Comparisons</A></H4>

<P>
<P>
<P>
A subgroup G of an abelian variety is finite 
exactly when every element of G
is known exactly, since then all elements are torsion and G is
finitely generated.
<P>
Abelian varieties and subgroups thereof can be tested for inclusion and 
equality.
Equality and subset testing is liberal, in that if the
ambient varieties containing the two groups are not equal, then Magma
attempts to find a natural embedding of both subgroups into a common
ambient variety, and checks equality or inclusion there.


<H5><A NAME = "18476">IsFinite(G) : ModAbVarSubGrp -&gt;  RngIntElt</A></H5>
<BLOCKQUOTE>
Return <TT>true</TT> if the subgroup G of a modular abelian variety
is known to be finite, i.e., generated by torsion 
elements. If G is not known exactly, i.e., has elements defined by floating 
point approximations to homology, then return <TT>false</TT>.  
</BLOCKQUOTE>
<H5><A NAME = "18477">G1 subset G2 : ModAbVarSubGrp, ModAbVarSubGrp -&gt;  BoolElt</A></H5>
<BLOCKQUOTE>
Return <TT>true</TT> if G1 is a subset of G2, where G1 and G2
are both subgroups of modular abelian varieties.  
</BLOCKQUOTE>
<H5><A NAME = "18478">G subset A : ModAbVarSubGrp, ModAbVar -&gt;  BoolElt</A></H5>
<BLOCKQUOTE>
Return <TT>true</TT> if the subgroup G is a subset of the abelian variety A. If A is not the 
ambient variety of G, then G and A are first mapped to a common ambient 
variety and compared.  
</BLOCKQUOTE>
<H5><A NAME = "18479">A subset G : ModAbVar, ModAbVarSubGrp -&gt;  BoolElt</A></H5>
<BLOCKQUOTE>
Return <TT>true</TT> if the abelian variety A is a subset of the finitely generated 
subgroup G of a modular abelian variety. This is true only if A is a point, i.e., the 0 
dimensional abelian variety.  
</BLOCKQUOTE>
<H5><A NAME = "18480">G1 eq G2 : ModAbVarSubGrp, ModAbVarSubGrp -&gt;  BoolElt</A></H5>
<BLOCKQUOTE>
Return <TT>true</TT> if the subgroups G<sub>1</sub> and G<sub>2</sub> of modular abelian varieties
are equal.  
</BLOCKQUOTE>
<HR>
<H3><A NAME = "18481">Example <TT>ModAbVar_Subgrp-Predicates_and_Comparisons (H142E108)</TT></A></H3>
We work with J<sub>0</sub>(389), but work in the +1 quotient of homology
for efficiency.  First we let A and B be the first and fifth 
factors in the decomposition of J, and let G and H be the
corresponding 5-torsion subgroups.
<P>
<P>
<PRE>
&gt; J := JZero(389,2,+1);
&gt; D := Decomposition(J);
&gt; A := D[1];
&gt; B := D[5];
&gt; G := nTorsionSubgroup(A,5);
&gt; H := nTorsionSubgroup(B,5);
</PRE>
Note that the torsion subgroups aren't as big because we are working
in the +1 quotient.
<P>
<P>
<PRE>
&gt; #G;
5
&gt; #H;
95367431640625
</PRE>
We now demonstrate each of the above commands for A, B, G, and H.
<P>
<P>
<PRE>
&gt; IsFinite(G);
true
&gt; A subset G;
false
&gt; ZeroModularAbelianVariety() subset G;
true
&gt; G subset A;
true
&gt; G subset B;
true
&gt; H subset A;
false
</PRE>
Since the ambient varieties of G and H are A and B,
respectively, the following commands implicitly embed G and H into
J<sub>0</sub>(389) and make comparisons there.
<P>
<P>
<PRE>
&gt; G subset H;
true
&gt; G eq H;
false
&gt; G eq G;
true
</PRE>
<P>
<P>
<P>
<PRE>
&gt; J := JZero(37);
&gt; A, B := Explode(Decomposition(J));
&gt; A2 := Kernel(nIsogeny(A,2));
&gt; B2 := Kernel(nIsogeny(B,2));
&gt; A2 eq B2;
true
&gt; x := A2.1;
&gt; x in B2;   // uses embedding of both into $J_0(37)$.
true
</PRE>
<HR>
<PRE></PRE> <A  HREF = "text1648.htm">[Next]</A><A  HREF = "text1646.htm">[Prev]</A> <A  HREF = "text1648.htm">[Right]</A> <A  HREF = "text1646.htm">[Left]</A> <A  HREF = "text1635.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<br><small>Version: V2.22 of <I>
Thu Jun  9 16:37:49 EST 2016
</I></small>
</body></html>