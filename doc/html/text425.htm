<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <link rel='stylesheet' href='help.css' type='text/css'>
  <TITLE>Creation of Elements</TITLE>
</head>
<body BGCOLOR="#FFFFFF">

 <A  HREF = "text426.htm">[Next]</A><A  HREF = "text424.htm">[Prev]</A> <A  HREF = "text426.htm">[Right]</A> <A  HREF = "text424.htm">[Left]</A> <A  HREF = "text421.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<PRE></PRE><H3><A NAME = "4389">Creation of Elements</A></H3>

<P>
<P>
The usual way of creating elements within an algebraically closed field A is by coercion
from the base field into A, or by construction of roots of polynomials over
A (and this may be done indirectly via other functions).



<H5>Subsections</H5>
<UL>
<LI> <A  HREF = "text425.htm#4390">Coercion</A>
<LI> <A  HREF = "text425.htm#4392">Roots</A>
<LI> <A  HREF = "text425.htm#4399">Variables</A>
</UL>
<H4><A NAME = "4390">Coercion</A></H4>



<H5>One(A) : FldAC -&gt; FldACElt</H5>

<H5>Identity(A) : FldAC -&gt; FldACElt</H5><P>

<H5>Zero(A) : FldAC -&gt; FldACElt</H5>

<H5>Representative(A) : FldAC -&gt; FldACElt</H5><P>


These generic functions create <TT>A!1</TT>, <TT>A!1</TT>, <TT>A!0</TT>
and <TT>A!0</TT>, respectively.


<H5><A NAME = "4391">A ! a : FldAC, RngElt -&gt; FldACElt</A></H5>
<BLOCKQUOTE>
Given a finite field A create the element specified by a; here
a is allowed to be an element coercible into A, which means
that a may be
<DL COMPACT class='compact'>
<DT>(i)</DT><DD>an element of A;
<DT>(ii)</DT><DD>an integer or rational.</DL>
</BLOCKQUOTE>
<H4><A NAME = "4392">Roots</A></H4>



<H5><A NAME = "4393"></A><A NAME = "FldAC:Roots">Roots</A>(f) : RngUPolElt -&gt; [ &lt; FldACElt, RngIntElt&gt; ]</H5>
<H5>Roots(f, A) : RngUPolElt, FldAC -&gt; [ &lt; FldACElt, RngIntElt&gt; ]</H5>

<PRE>    Max: RngIntElt                      Default: </PRE>
<BLOCKQUOTE>
Given a polynomial f over an algebraically closed field A, or given a polynomial f
over some subring of A together with A itself, this function
computes all roots of f in A, and returns a sorted sequence of
tuples (pairs), each consisting of a root of f in A and its
multiplicity.  Since A is algebraically closed, f always
splits completely.
<P>
If the parameter <TT>Max</TT> is set to a non-negative number m, at
most m roots are returned.  This feature can be quite useful
when one wishes, say, only one root of a polynomial and
not all the conjugates of the root, as they will cause
the field to have more variables than necessary and this can make
the full simplification of the field much more difficult later (if that
is requested).
<P>
<P>
<P>
Note that the function <TT>Factorization(f)</TT> is also supported,
and simply returns the linear factors and multiplicities corresponding
to the roots returned by <TT>Roots(f)</TT>.
</BLOCKQUOTE>
<H5><A NAME = "4394">RootOfUnity(n, A) : RngIntElt, FldAC -&gt; FldACElt</A></H5>
<BLOCKQUOTE>
Return a primitive n-th root of unity in A, i.e., an element
&omega;&isin;A such that &omega;<sup>n</sup> = 1 and &omega;<sup>i</sup> not=1 for 1&le;i&lt;n.
This always exists since the field is algebraically closed,
and the return value is invariable.
This function is equivalent to
<TT>Roots(CyclotomicPolynomial(n), A: Max := 1)[1, 1]</TT>.
</BLOCKQUOTE>
<H5><A NAME = "4395">SquareRoot(a) : FldACElt -&gt; FldACElt</A></H5>
<H5><A NAME = "FldAC:Sqrt">Sqrt</A>(a) : FldACElt -&gt; FldACElt</H5>
<BLOCKQUOTE>
A square root of the element a from the field 
A, i.e., an element y of A such that y<sup>2</sup> = a.
A square root always exists since the field is algebraically closed,
and the return value is invariable.
</BLOCKQUOTE>
<H5><A NAME = "4396">IsSquare(a) : FldACElt -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Return {<TT>true</TT>} and a square root of the element a from the field 
A, i.e., {<TT>true</TT>} and an element y of A such that y<sup>2</sup> = a.
A square root always exists since the field is algebraically closed,
and the return value is invariable.
</BLOCKQUOTE>
<H5><A NAME = "4397">Root(a, n) : FldACElt, RngIntElt -&gt; FldACElt</A></H5>
<BLOCKQUOTE>
Return an n-th root of the element a from the field A,
i.e., an element y of A such that y<sup>n</sup> = a.
A root always exists since the field is algebraically closed,
and the return value is invariable.
</BLOCKQUOTE>
<H5><A NAME = "4398">IsPower(a, n) : FldACElt, RngIntElt -&gt; BoolElt, FldACElt</A></H5>
<BLOCKQUOTE>
Return {<TT>true</TT>} and an n-th root of the element a from the field A,
i.e., {<TT>true</TT>} and an element y of A such that y<sup>n</sup> = a.
A root always exists since the field is algebraically closed,
and the return value is invariable.
</BLOCKQUOTE>
<H4><A NAME = "4399">Variables</A></H4>



<H5><A NAME = "4400">A . i : FldAC, RngIntElt -&gt; FldACElt</A></H5>
<BLOCKQUOTE>
Return the i-th variable of A.  i must be between 1 and the
rank of A (the current number of variables in A).  Initially A
has no variables, and new variables are only created by calling
<A  HREF = "text425.htm#FldAC:Roots">Roots</A> above (or similar functions such as
<A  HREF = "text425.htm#FldAC:Sqrt">Sqrt</A>).  As long as <A  HREF = "text430.htm#FldAC:Prune">Prune</A> or
<A  HREF = "text431.htm#FldAC:Absolutize">Absolutize</A> are not called (which shift the variable
numbers -- see below), the return value of this function is invariable,
so A.i for fixed i will always return the same mathematical object
despite any simplifications or constructions of new roots.  New roots
are always assigned higher generator numbers.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "4401">Example <TT>FldAC_Create (H42E1)</TT></A></H3>
We first show the most common way of creating roots: by the <A  HREF = "text425.htm#FldAC:Roots">Roots</A>
function.
<P>
<P>
<PRE>
&gt; A := AlgebraicClosure();
&gt; P&lt;x&gt; := PolynomialRing(IntegerRing());
&gt; r := Roots(x^3 + x + 1, A);
&gt; r;
[
    &lt;r1, 1&gt;,
    &lt;r2, 1&gt;,
    &lt;r3, 1&gt;
]
&gt; A;
Algebraically closed field with 3 variables
Defining relations:
[
    r3^3 + r3 + 1,
    r2^3 + r2 + 1,
    r1^3 + r1 + 1
]
&gt; a := r[1,1];
&gt; a^3 + a;    
-1
&gt; A.1;
r1
&gt; A.2;
r2
&gt; A.3;
r3
&gt; A.1 eq a;
true
</PRE>
It is often useful to use the <TT>Max</TT> parameter with the <A  HREF = "text425.htm#FldAC:Roots">Roots</A>
function.  Note that in this case A does not have the extra variables
found in the previous example.
<P>
<P>
<PRE>
&gt; A := AlgebraicClosure();
&gt; r := Roots(x^3 + x + 1, A: Max := 1);
&gt; A;
Algebraically closed field with 1 variable
Defining relations:
[
    r1^3 + r1 + 1
]
</PRE>
One can also create elements by <A  HREF = "text425.htm#FldAC:Sqrt">Sqrt</A>, etc.
<P>
<P>
<PRE>
&gt; A := AlgebraicClosure();
&gt; sqrt2 := Sqrt(A ! 2);
&gt; cube3 := Root(A!3, 3);
&gt; A;
Algebraically closed field with 2 variables
Defining relations:
[
    r2^3 - 3,
    r1^2 - 2
]
&gt; sqrt2^2;
2
&gt; cube3^3;
3
</PRE>
<HR>
<H3><A NAME = "4402">Example <TT>FldAC_SwinnertonDyer (H42E2)</TT></A></H3>
<P>
The n-th Swinnerton-Dyer polynomial is defined to be
&prod;(x &#8723; Sqrt(2) &#8723; Sqrt(3) &#8723; Sqrt(5) &#8723; ... &#8723; Sqrt(p<sub>n</sub>)),
where p<sub>i</sub> is the i-th prime and the product runs over all 2<sup>n</sup> possible
combinations of + and - signs.  Such polynomials lie in Z[x]
and are irreducible over Z.  It is very easy to compute them
using algebraically closed fields.  We simply construct the square
roots we need and multiply out the expression, coercing the resulting
polynomial to Z[x].
<P>
<P>
<PRE>
&gt; Z := IntegerRing();
&gt; function SwinnertonDyer(n)
&gt;     P := [2];
&gt;     for i := 2 to n do
&gt;         Append(~P, NextPrime(P[#P]));
&gt;     end for;
&gt;     A := AlgebraicClosure();
&gt;     S := [Sqrt(A ! p): p in P];
&gt;     P&lt;z&gt; := PolynomialRing(A);
&gt;     f := &amp;*[z + &amp;+[t[i]*S[i]: i in [1..n]]: t in CartesianPower({-1, 1}, n)];
&gt;     return PolynomialRing(Z) ! f;
&gt; end function;
&gt; P&lt;x&gt; := PolynomialRing(Z);
&gt; [SwinnertonDyer(i): i in [1..5]];
[
    x^2 - 2,
    x^4 - 10*x^2 + 1,
    x^8 - 40*x^6 + 352*x^4 - 960*x^2 + 576,
    x^16 - 136*x^14 + 6476*x^12 - 141912*x^10 + 1513334*x^8 - 
        7453176*x^6 + 13950764*x^4 - 5596840*x^2 + 46225,
    x^32 - 448*x^30 + 84864*x^28 - 9028096*x^26 + 602397952*x^24 - 
        26625650688*x^22 + 801918722048*x^20 - 16665641517056*x^18 + 
        239210760462336*x^16 - 2349014746136576*x^14 + 
        15459151516270592*x^12 - 65892492886671360*x^10 + 
        172580952324702208*x^8 - 255690851718529024*x^6 + 
        183876928237731840*x^4 - 44660812492570624*x^2 + 
        2000989041197056
]
</PRE>
The Swinnerton-Dyer polynomials yield worse-case inputs for the
Berlekamp-Zassenhaus factorization algorithm for polynomials over Z,
but they are no longer difficult to factor using van Hoeij's new
algorithm (see Example <A  HREF = "text217.htm#1862">H23E6</A>).
<P>
We can even define a simple extension of the
Swinnerton-Dyer polynomials.
Let Q = { q<sub>1</sub>, ..., q<sub>n</sub> } be a set of n distinct primes or
negatives of primes.  Define:
(GSD)<sub>Q</sub> := &prod;(x &#8723; Sqrt(q<sub>1</sub>) &#8723; Sqrt(q<sub>2</sub>) &#8723; ... &#8723; Sqrt(q<sub>n</sub>)),
where the product runs over all 2<sup>n</sup> possible combinations of + and
- signs.  Then (GSD)<sub>Q</sub> &isin;Z[x], is irreducible over Z, has
degree 2<sup>n</sup>, and has at least 2<sup>n - 1</sup> factors mod any prime.  A
function to compute these polynomials is only a slight variation on
the previous function.
<P>
<P>
<PRE>
&gt; function GSD(Q)
&gt;     n := #Q;
&gt;     A := AlgebraicClosure();
&gt;     S := [Sqrt(A ! x): x in Q];
&gt;     z := PolynomialRing(A).1;
&gt;     f := &amp;*[z + &amp;+[t[i]*S[i]: i in [1..n]]: t in CartesianPower({-1, 1}, n)];
&gt;     return PolynomialRing(Z) ! f;
&gt; end function;
</PRE>
One can multiply (GSD)<sub>Q</sub> for various Q to construct more reducible
polynomials with many modular factors.  We first note the effects
of changing the sign of the input primes.
<P>
<P>
<PRE>
&gt; GSD([2, 3, 5]);
x^8 - 40*x^6 + 352*x^4 - 960*x^2 + 576
&gt; GSD([-2, -3, -5]);
x^8 + 40*x^6 + 352*x^4 + 960*x^2 + 576
&gt; GSD([-2, 3, 5]);
x^8 - 24*x^6 + 224*x^4 + 960*x^2 + 1600
&gt; GSD([2, -3, 5]);
x^8 - 16*x^6 + 184*x^4 + 960*x^2 + 3600
&gt; GSD([2, 3, -5]);
x^8 + 152*x^4 + 1920*x^2 + 5776
</PRE>
We now form a polynomial f which is the product of two degree-64
irreducible polynomials.  f has at least 64 factors modulo any prime,
but is not difficult to factor using van Hoeij's algorithm.
<P>
<P>
<PRE>
&gt; f := GSD([2, 3, 5, 7, 11, 13])*GSD([-2, -3, -5, -7, -11, -13]);            
&gt; Degree(f);
128
&gt; Max([Abs(x): x in Coefficients(f)]);  
74356932844713201802276382813294219572861455394629943303351262856515487990904 17
&gt; time L:=Factorization(f);
Time: 9.850
&gt; [Degree(t[1]): t in L];
[ 64, 64 ]
&gt; Max([Abs(x): x in Coefficients(L[1,1])]);
1771080720430629161685158978892152599456 11
</PRE>
<HR>
<H3><A NAME = "4403">Example <TT>FldAC_Puiseux (H42E3)</TT></A></H3>
This example shows how one can compute Puiseux expansions over an
algebraic closure.  The <A  HREF = "text553.htm#Newton:PuiseuxExpansion">PuiseuxExpansion</A> function calls the
<A  HREF = "text425.htm#FldAC:Roots">Roots</A> function internally as it needs to.
<P>
<P>
<PRE>
&gt; A := AlgebraicClosure();
&gt; S&lt;y&gt; := PuiseuxSeriesRing(A);
&gt; P&lt;x&gt; := PolynomialRing(S);
&gt; f := (x^2 - y^2 - 1)^5 + x*y + 1;
&gt; time S := PuiseuxExpansion(f, 3);
Time: 0.210
&gt; S;
[
    r1*y + (102/2525*r1 - 2/505)*y^3 + O(y^4),
    r2*y + (102/2525*r2 - 2/505)*y^3 + O(y^4),
    r3 + (1/10*r3^2 - 1/10)*y + (-101/1000*r3^7 + 101/200*r3^5 - 
        209/200*r3^3 + 26/25*r3)*y^2 + O(y^3),
    r4 + (1/10*r4^2 - 1/10)*y + (-101/1000*r4^7 + 101/200*r4^5 - 
        209/200*r4^3 + 26/25*r4)*y^2 + O(y^3),
    r5 + (1/10*r5^2 - 1/10)*y + (-101/1000*r5^7 + 101/200*r5^5 - 
        209/200*r5^3 + 26/25*r5)*y^2 + O(y^3),
    r6 + (1/10*r6^2 - 1/10)*y + (-101/1000*r6^7 + 101/200*r6^5 - 
        209/200*r6^3 + 26/25*r6)*y^2 + O(y^3),
    r7 + (1/10*r7^2 - 1/10)*y + (-101/1000*r7^7 + 101/200*r7^5 - 
        209/200*r7^3 + 26/25*r7)*y^2 + O(y^3),
    r8 + (1/10*r8^2 - 1/10)*y + (-101/1000*r8^7 + 101/200*r8^5 - 
        209/200*r8^3 + 26/25*r8)*y^2 + O(y^3),
    r9 + (1/10*r9^2 - 1/10)*y + (-101/1000*r9^7 + 101/200*r9^5 - 
        209/200*r9^3 + 26/25*r9)*y^2 + O(y^3),
    r10 + (1/10*r10^2 - 1/10)*y + (-101/1000*r10^7 + 101/200*r10^5 - 
        209/200*r10^3 + 26/25*r10)*y^2 + O(y^3)
]
&gt; A;
Algebraically closed field with 10 variables
Defining relations:
[
    r10^8 - 5*r10^6 + 10*r10^4 - 10*r10^2 + 5,
    r9^8 - 5*r9^6 + 10*r9^4 - 10*r9^2 + 5,
    r8^8 - 5*r8^6 + 10*r8^4 - 10*r8^2 + 5,
    r7^8 - 5*r7^6 + 10*r7^4 - 10*r7^2 + 5,
    r6^8 - 5*r6^6 + 10*r6^4 - 10*r6^2 + 5,
    r5^8 - 5*r5^6 + 10*r5^4 - 10*r5^2 + 5,
    r4^8 - 5*r4^6 + 10*r4^4 - 10*r4^2 + 5,
    r3^8 - 5*r3^6 + 10*r3^4 - 10*r3^2 + 5,
    r2^2 + 1/5*r2 - 1,
    r1^2 + 1/5*r1 - 1
]
</PRE>
We check that f evaluated at each expansion in S is zero up to
the precision.
<P>
<P>
<PRE>
&gt; [Evaluate(f, p): p in S];
[
    O(y^5),
    O(y^5),
    O(y^3),
    O(y^3),
    O(y^3),
    O(y^3),
    O(y^3),
    O(y^3),
    O(y^3),
    O(y^3)
]
</PRE>
<HR>
<PRE></PRE> <A  HREF = "text426.htm">[Next]</A><A  HREF = "text424.htm">[Prev]</A> <A  HREF = "text426.htm">[Right]</A> <A  HREF = "text424.htm">[Left]</A> <A  HREF = "text421.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<br><small>Version: V2.22 of <I>
Thu Jun  9 16:37:49 EST 2016
</I></small>
</body></html>