<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <link rel='stylesheet' href='help.css' type='text/css'>
  <TITLE>Operations on Subalgebras and Ideals</TITLE>
</head>
<body BGCOLOR="#FFFFFF">

 <A  HREF = "text1140.htm">[Next]</A><A  HREF = "text1138.htm">[Prev]</A> <A  HREF = "text1140.htm">[Right]</A> <A  HREF = "text1138.htm">[Left]</A> <A  HREF = "text1130.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<PRE></PRE><H3><A NAME = "12814">Operations on Subalgebras and Ideals</A></H3>




<H5>Subsections</H5>
<UL>
<LI> <A  HREF = "text1139.htm#12818">Standard Ideals and Subalgebras</A>
<LI> <A  HREF = "text1139.htm#12826">Cartan and Toral Subalgebras</A>
<LI> <A  HREF = "text1139.htm#12835">Standard Series</A>
<LI> <A  HREF = "text1139.htm#12844">The Lie Algebra of Derivations</A>
</UL>
<H5><A NAME = "12815">DirectSum(L, M) : AlgLie, AlgLie -&gt; AlgLie</A></H5>
<H5>DirectSum(L, M) : AlgMatLie, AlgMatLie -&gt; AlgMatLie</H5>
<BLOCKQUOTE>
Given Lie algebras L and M, this intrinsic constructs a Lie algebra of 
dimension n + m, where n and m are the dimensions of L and M, 
respectively. The basis of the new algebra is the concatenation of the bases 
of L and M and the products a * b where a &isin;L and b &isin;M are 
defined to be zero.
</BLOCKQUOTE>
<H5><A NAME = "12816">IndecomposableSummands(L) : AlgLie -&gt; [ AlgLie ]</A></H5>
<H5>IndecomposableSummands(L) : AlgMatLie -&gt; [ AlgMatLie ]</H5>
<H5>DirectSumDecomposition(L) : AlgLie -&gt; [ AlgLie ]</H5>
<H5>DirectSumDecomposition(L) : AlgMatLie -&gt; [ AlgMatLie ]</H5>
<BLOCKQUOTE>
Given a Lie algebra L, the function returns the direct sum decomposition 
of L as a sequence of ideals of L whose sum is L and each of which 
cannot be further decomposed into a direct sum of ideals.
<P>
The algorithms used for this function are described in <A  HREF = "text1129.htm#bib_wdg-lie-alg">[dG00]</A>,
Para 4.12 (semisimple case), Para 1.15 (general case).
</BLOCKQUOTE>
<HR>
<H3><A NAME = "12817">Example <TT>AlgLie_DirectSumDecomposition (H106E37)</TT></A></H3>
We compute the direct sum decomposition of
the simple Lie algebra of type D<sub>2</sub> over the rational field.
<P>
<P>
<PRE>
&gt; L := LieAlgebra("D2", RationalField());
&gt; L;
Lie Algebra of dimension 6 with base ring Rational Field
&gt; D := DirectSumDecomposition(L);
&gt; D;
[
    Lie Algebra of dimension 3 with base ring Rational Field,
    Lie Algebra of dimension 3 with base ring Rational Field
]
&gt; Morphism(D[1], L); 
[ 0  1  0  0  0  0]
[ 0  0  1 -1  0  0]
[ 0  0  0  0  1  0]
&gt; Morphism(D[2], L);
[1 0 0 0 0 0]
[0 0 1 1 0 0]
[0 0 0 0 0 1]
</PRE>
<HR>
<H4><A NAME = "12818">Standard Ideals and Subalgebras</A></H4>



<H5><A NAME = "12819">Centre(L) : AlgLie -&gt; AlgLie</A></H5>
<H5>Centre(L) : AlgMatLie -&gt; AlgMatLie</H5>
<H5>Center(L) : AlgLie -&gt; AlgLie</H5>
<H5>Center(L) : AlgMatLie -&gt; AlgMatLie</H5>
<BLOCKQUOTE>
Given a Lie algebra L, returns the centreof L.
</BLOCKQUOTE>
<H5><A NAME = "12820">Centraliser(L, K) : AlgLie, AlgLie -&gt; AlgLie, Map</A></H5>
<H5>Centraliser(L, K) : AlgMatLie, AlgMatLie -&gt; AlgMatLie, Map</H5>
<H5>Centralizer(L, K) : AlgLie, AlgLie -&gt; AlgLie, Map</H5>
<H5>Centralizer(L, K) : AlgMatLie, AlgMatLie -&gt; AlgMatLie, Map</H5>
<BLOCKQUOTE>
Given a Lie algebra L and a subalgebra K of L,
returns the centraliserof K in L, 
and its injection into L.
</BLOCKQUOTE>
<H5><A NAME = "12821">Centraliser(L, x) : AlgLie, AlgLieElt -&gt; AlgLie, Map</A></H5>
<H5>Centraliser(L, x) : AlgMatLie, AlgMatLieElt -&gt; AlgMatLie, Map</H5>
<H5>Centralizer(L, x) : AlgLie, AlgLieElt -&gt; AlgLie, Map</H5>
<H5>Centralizer(L, x) : AlgMatLie, AlgMatLieElt -&gt; AlgMatLie, Map</H5>
<BLOCKQUOTE>
Given a Lie algebra L and an element x of L,
returns the centraliserof x in L, 
and its injection into L.
</BLOCKQUOTE>
<H5><A NAME = "12822">Normaliser(L, K) : AlgLie, AlgLie -&gt; AlgLie</A></H5>
<H5>Normaliser(L, K) : AlgMatLie, AlgMatLie -&gt; AlgMatLie</H5>
<H5>Normalizer(L, K) : AlgLie, AlgLie -&gt; AlgLie</H5>
<H5>Normalizer(L, K) : AlgMatLie, AlgMatLie -&gt; AlgMatLie</H5>
<BLOCKQUOTE>
Given a Lie algebra L and a subalgebra K of L,
returns the normaliserof 
K in L, and its injection into L.
</BLOCKQUOTE>
<H5><A NAME = "12823">SolubleRadical(L) : AlgLie -&gt; AlgLie</A></H5>
<H5>SolubleRadical(L) : AlgMatLie -&gt; AlgMatLie</H5>
<H5>SolvableRadical(L) : AlgLie -&gt; AlgLie</H5>
<H5>SolvableRadical(L) : AlgMatLie -&gt; AlgMatLie</H5>
<BLOCKQUOTE>
Given a Lie algebra L, returns the soluble radicalof L.
<P>
We refer to <A  HREF = "text1129.htm#bib_wdg-lie-alg">[dG00]</A>, Para 2.6 for the algorithm used to implement this
function.
</BLOCKQUOTE>
<H5><A NAME = "12824">Nilradical(L) : AlgLie -&gt; AlgLie</A></H5>
<H5>Nilradical(L) : AlgMatLie -&gt; AlgMatLie</H5>
<BLOCKQUOTE>
Given a Lie algebra L, returns the nilradicalof L.
<P>
The algorithm makes use of Cartan subalgebras. We refer to <A  HREF = "text1129.htm#bib_wdg-lie-alg">[dG00]</A>,
pp. 84, 85 for its description.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "12825">Example <TT>AlgLie_Operations (H106E38)</TT></A></H3>
We demonstrate the functions for performing basic operations with Lie algebras
such as centre, normalizer etc.
<P>
<P>
<PRE>
&gt; L := LieAlgebra("D4", RationalField());
&gt; L;
Lie Algebra of dimension 28 with base ring Rational Field
&gt; Centre(L);
Lie Algebra of dimension 0 with base ring Rational Field
&gt; K := sub&lt; L | [L.1, L.2, L.3] &gt;;
&gt; Centralizer(L, K);
Lie Algebra of dimension 10 with base ring Rational Field
&gt; Normalizer(L, K);
Lie Algebra of dimension 19 with base ring Rational Field
&gt; M := Centralizer(L, K);
&gt; S := SolvableRadical(M);
&gt; S;
Lie Algebra of dimension 10 with base ring Rational Field
&gt; Morphism(S, L);
[1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]
[0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]
[0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]
[0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]
[0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]
[0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]
[0 0 0 0 0 0 1 0 0 0 0 -1 0 0 0 -1 0 0 -1 0 0 0 0 0 0 0 0 0]
[0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]
[0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]
[0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0]
&gt; Nilradical(M);
Lie Algebra of dimension 9 with base ring Rational Field
</PRE>
<HR>
<H4><A NAME = "12826">Cartan and Toral Subalgebras</A></H4>



<H5><A NAME = "12827">CartanSubalgebra(L) : AlgLie -&gt; AlgLie</A></H5>
<H5>CartanSubalgebra(L) : AlgMatLie -&gt; AlgMatLie</H5>
<BLOCKQUOTE>
Given a Lie algebra L, this function returns a Cartan 
subalgebraof L.  
The algorithm works for Lie algebras L defined over a field F such that 
|F| &gt; dim L and for restricted Lie algebras of characteristic p.
If the Lie algebra does not fit into one of these classes then the
correctness of the output is not guaranteed.
<P>
The algorithm used is described in <A  HREF = "text1129.htm#bib_wdg-lie-alg">[dG00]</A>, Para 3.2. 
</BLOCKQUOTE>
<H5><A NAME = "12828">IsCartanSubalgebra(L, H) : AlgLie, AlgLie -&gt; BoolElt</A></H5>
<H5>IsCartanSubalgebra(L, H) : AlgMatLie, AlgMatLie -&gt; BoolElt</H5>
<BLOCKQUOTE>
The intrinsic returns <TT>true</TT> if H is a Cartan subalgebra of L, 
i.e., whether H is nilpotent and N<sub>L</sub>(H) = 0.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "12829">Example <TT>AlgLie_CartanSubalgebra (H106E39)</TT></A></H3>
We compute a Cartan subalgebra of the simple Lie algebra of type A<sub>4</sub> over
the rational field.
<P>
<P>
<PRE>
&gt; L := LieAlgebra("F4", RationalField());
&gt; L;
Lie Algebra of dimension 52 with base ring Rational Field
&gt; H := CartanSubalgebra(L);
Lie Algebra of dimension 4 with base ring Rational Field
&gt; H*H;
Lie Algebra of dimension 0 with base ring Rational Field
&gt; Normalizer(L, H);
Lie Algebra of dimension 4 with base ring Rational Field
</PRE>
<HR>
<H5><A NAME = "12830">SplittingCartanSubalgebra(L) : AlgLie -&gt; AlgLie</A></H5>
<H5><A NAME = "SplitMaximalToralSubalgebra">SplitMaximalToralSubalgebra</A>(L) : AlgLie -&gt; AlgLie</H5>
<BLOCKQUOTE>
Given a Lie algebra L over a field k of characteristic at least 5, 
a split Cartan subalgebra (equivalently, a split maximal toral
subalgebra) is computed for L. 
<P>
The algorithm used is discussed in <A  HREF = "text1129.htm#bib_CohenMurray2009">[CM09]</A>, Sections 5 and 6.
This algorithm is proved to work (<A  HREF = "text1129.htm#bib_CohenMurray2009">[CM09, Theorem 6.7]</A>) 
if L is the Lie algebra of a k-split connected reductive group. In other
cases, should the algorithm terminate, the output is guaranteed to be correct.
</BLOCKQUOTE>
<H5><A NAME = "12831">IsSplittingCartanSubalgebra(L, H) : AlgLie, AlgLie -&gt; BoolElt</A></H5>
<H5>IsSplittingCartanSubalgebra(L, H) : AlgMatLie, AlgMatLie -&gt; BoolElt</H5>
<BLOCKQUOTE>
Determine whether H is a splitting Cartan subalgebra of L, i.e., whether H
is a Cartan subalgebra and the adjoint action of H on L splits completely
over the coefficient ring of L.
</BLOCKQUOTE>
<H5><A NAME = "12832"></A><A NAME = "SplitToralSubalgebra">SplitToralSubalgebra</A>(L) : AlgLie -&gt; AlgLie</H5>

<PRE>    TryMaximal: .                       Default: <TT>true</TT></PRE>
<BLOCKQUOTE>
The intrinsic attempts to compute a split toral subalgebra of a Lie algebra L 
defined over a finite field k. This procedure uses a heuristic algorithm, 
described in <A  HREF = "text1129.htm#bib_Roozemond2010">[Roo10, Chapter 3]</A>, that works in many cases even 
if the characteristic of k is small. Moreover, it attempts to compute a split 
toral subalgebra of maximal size. 
<P>
If the function returns without error, the resulting subalgebra H is a split
toral subalgebra that does not lie inside a split toral subalgebra H' of 
larger dimension. It is, however, not guaranteed that H is of maximal dimension
among all split toral subalgebras.
<P>
The optional parameter <TT>TryMaximal</TT> may be used as follows.
If set to <TT>true</TT> (the default) the reductive rank r of L is computed first, and 
the algorithm attempts to compute a split toral subalgebra of dimension r. If set
to <TT>false</TT>, the first split toral subalgebra found is returned. Finally, if <TT>TryMaximal</TT>
is set to an integer n &ge;1, the algorithm attempts to find a split toral subalgebra
of dimension n. In the latter case, if no split toral subalgebra of dimension n can be found,
the biggest that has been found is returned; if on the other hand a split toral subalgebra of
dimension <I>larger</I> than n is encountered, that is returned.
</BLOCKQUOTE>
<H5><A NAME = "12833">IsSplitToralSubalgebra(L, H) : AlgLie, AlgLie -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Given a restrictable Lie algebra L over a finite field, the function returns
<TT>true</TT> is H is a split toral subalgebra of L, i.e., whether [H, H] = 0,
all elements of H are semisimple, and the basis elements are invariant
under the q-map associated to L.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "12834">Example <TT>AlgLie_SplitToral (H106E40)</TT></A></H3>
We construct a twisted Lie algebra L of type ()<sup>3</sup>D<sub>4</sub> over the field
k = GF(3<sup>3</sup>) and verify that the
subalgebra H returned by <TT>SplitToralSubalgebra</TT> is indeed a split toral 
subalgebra. Then, we test whether C = C<sub>L</sub>(H) is a (split) toral subalgebra of L.
<P>
<P>
<PRE>
&gt; k := GF(3, 3);
&gt; L, phi := TwistedLieAlgebra(TwistedRootDatum("D4" : Twist := 3), k);
&gt; H := SplitToralSubalgebra(L);
&gt; H;
Lie Algebra of dimension 2 with base ring GF(3^3)
&gt; IsSplitToralSubalgebra(L, H);
true
&gt; C := Centraliser(L,H); C;
Lie Algebra of dimension 4 with base ring GF(3^3)
&gt; IsToralSubalgebra(L,C), IsSplitToralSubalgebra(L, C);
true false
</PRE>
Now we let K be the big field, GF(3<sup>9</sup>), and test if C tensor K is a split toral
subalgebra of L tensor K.
<P>
<P>
<PRE>
&gt; LK := Codomain(phi);       
&gt; LK;
Lie Algebra of dimension 28 with base ring GF(3^9)
&gt; CK := sub&lt;LK | [ phi(b) : b in Basis(C) ]&gt;;
&gt; IsSplitToralSubalgebra(LK, CK);
true
</PRE>
<HR>
<H4><A NAME = "12835">Standard Series</A></H4>



<H5><A NAME = "12836">CompositionSeries(L) : AlgLie -&gt; [ Alg ], [ AlgLie ], AlgMatElt</A></H5>
<BLOCKQUOTE>
A composition series is computed for the (structure constant) Lie algebra L.
The function returns three values:
<DL COMPACT class='compact'>
<DT>(a)</DT><DD>a sequence containing the composition series as an ascending chain of
subalgebras such that the successive quotients are irreducible L-modules;
<DT>(b)</DT><DD>a sequence containing the composition factors as structure
constant algebras;
<DT>(c)</DT><DD>a transformation matrix to a basis compatible with the
composition series, that is, the first basis elements form a basis of the first
term of the composition series, the next extend these to a basis for the second
term etc.</DL>
</BLOCKQUOTE>
<H5><A NAME = "12837">CompositionFactors(L) : AlgLie -&gt; [ AlgLie ]</A></H5>
<BLOCKQUOTE>
Compute the composition factors of a composition series for the Lie
algebra L.  This function returns the same as the second return value
of <TT>CompositionSeries</TT> above, but will often be very much quicker.
</BLOCKQUOTE>
<H5><A NAME = "12838">MinimalIdeals(L : parameters) : AlgLie -&gt; [ AlgLie ], BoolElt</A></H5>

<PRE>    Limit: RngIntElt                    Default: &infin;</PRE>
<BLOCKQUOTE>
Returns the minimal left/right/two-sided ideals of the (structure constant)
Lie algebra L (in non-decreasing size).
If <TT>Limit</TT> is set to n, at most n ideals are calculated and the second
return value indicates whether all of the ideals were computed.
</BLOCKQUOTE>
<H5><A NAME = "12839">MaximalIdeals(L : parameters) : AlgLie -&gt; [ AlgLie ], BoolElt</A></H5>

<PRE>    Limit: RngIntElt                    Default: &infin;</PRE>
<BLOCKQUOTE>
Returns the maximal left/right/two-sided ideals of the (structure constant)
Lie algebra L (in non-decreasing size).
If <TT>Limit</TT> is set to n, at most n ideals are calculated and the second
return value indicates whether all of the ideals were computed.
</BLOCKQUOTE>
<H5><A NAME = "12840">DerivedSeries(L) : AlgLie -&gt; [ AlgLie ]</A></H5>
<H5>DerivedSeries(L) : AlgMatLie -&gt; [ AlgMatLie ]</H5>
<BLOCKQUOTE>
Given a Lie algebra L, this function returns
a sequence of ideals of L that form its derived
series. 
</BLOCKQUOTE>
<H5><A NAME = "12841">LowerCentralSeries(L) : AlgLie -&gt; [ AlgLie ]</A></H5>
<H5>LowerCentralSeries(L) : AlgMatLie -&gt; [ AlgMatLie ]</H5>
<BLOCKQUOTE>
Given a Lie algebra L, this function returns
a sequence of ideals of L that form its lower central
series. 
</BLOCKQUOTE>
<H5><A NAME = "12842">UpperCentralSeries(L) : AlgLie -&gt; [ AlgLie ]</A></H5>
<H5>UpperCentralSeries(L) : AlgMatLie -&gt; [ AlgMatLie ]</H5>
<BLOCKQUOTE>
Given a Lie algebra L, this function returns
a sequence of ideals of L that form the upper central seriesof L.
The function repeatedly uses the algorithm for computing centres
while keeping track of the pre-images of the ideals factored out.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "12843">Example <TT>AlgLie_Series (H106E41)</TT></A></H3>
We compute each of the type of series of a particular subalgebra of
the simple Lie algebra of type F<sub>4</sub> over the rational field.
<P>
<P>
<PRE>
&gt; L:=LieAlgebra("F4", RationalField());
&gt; L;
Lie Algebra of dimension 52 with base ring Rational Field
&gt; K:=sub&lt; L | [L.1, L.12, L.23, L.34, L.45] &gt;;
&gt; DerivedSeries(K);
[
    Lie Algebra of dimension 20 with base ring Rational Field,
    Lie Algebra of dimension 16 with base ring Rational Field,
    Lie Algebra of dimension 7 with base ring Rational Field,
    Lie Algebra of dimension 0 with base ring Rational Field
]
&gt; LowerCentralSeries(K);
[
    Lie Algebra of dimension 20 with base ring Rational Field,
    Lie Algebra of dimension 16 with base ring Rational Field,
    Lie Algebra of dimension 12 with base ring Rational Field,
    Lie Algebra of dimension 8 with base ring Rational Field,
    Lie Algebra of dimension 5 with base ring Rational Field,
    Lie Algebra of dimension 2 with base ring Rational Field,
    Lie Algebra of dimension 1 with base ring Rational Field,
    Lie Algebra of dimension 0 with base ring Rational Field
]
&gt; UpperCentralSeries(K);
[
    Lie Algebra of dimension 2 with base ring Rational Field,
    Lie Algebra of dimension 3 with base ring Rational Field,
    Lie Algebra of dimension 5 with base ring Rational Field,
    Lie Algebra of dimension 8 with base ring Rational Field,
    Lie Algebra of dimension 12 with base ring Rational Field,
    Lie Algebra of dimension 16 with base ring Rational Field,
    Lie Algebra of dimension 20 with base ring Rational Field
]
</PRE>
<HR>
<H4><A NAME = "12844">The Lie Algebra of Derivations</A></H4>



<H5><A NAME = "12845">LieAlgebraOfDerivations(L) : AlgLie -&gt; AlgLie, Rec</A></H5>
<BLOCKQUOTE>
Given a Lie algebra L, this function constructs its Lie algebra of derivations 
Der(L).  As second return value, a record containing maps from L to Der(L) 
and vice versa, and from Der(L) to the matrix Lie algebra acting on L
is returned.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "12846">Example <TT>AlgLie_LieAlgebraOfDerivations (H106E42)</TT></A></H3>
We consider the Lie algebra of derivations of D<sub>4</sub> in characteristic 2 or,
more precisely, the 26-dimensional simple constituent L that exists in all
varieties of D<sub>4</sub> in characteristic 2.
<P>
<P>
<PRE>
&gt; SetSeed(1);
&gt; R := RootDatum("D4");
&gt; D4 := LieAlgebra(R, GF(2));
&gt; pos,neg,cart := StandardBasis(D4);
&gt; L := D4*D4; L;
Lie Algebra of dimension 26 with base ring GF(2)
&gt; IsSimple(L);
true
&gt; DerL, maps := LieAlgebraOfDerivations(L);
&gt; DerL;
Lie Algebra of dimension 52 with base ring GF(2)
&gt; SemisimpleType(DerL);
F4 
</PRE>
So the Lie algebra of derivations is of type F<sub>4</sub>. Let us consider
one of the maps that was returned as second value.
<P>
<P>
<PRE>
&gt; maps;
rec&lt;recformat&lt;mp_DerL_to_L: Map, mp_L_to_DerL: Map, mp_DerL_to_mats: 
Map, mp_mats_to_DerL: Map&gt; | 
    mp_DerL_to_L := Mapping from: AlgLie: DerL to AlgLie: L given by a
        rule [no inverse],
    mp_L_to_DerL := Mapping from: AlgLie: L to AlgLie: DerL given by a
        rule [no inverse],
    mp_DerL_to_mats := Mapping from: AlgLie: DerL to Matrix Lie 
        Algebra given by a rule [no inverse],
    mp_mats_to_DerL := Mapping from: Matrix Lie Algebra to AlgLie: 
        DerL given by a rule [no inverse]&gt;
&gt; adL := AdjointRepresentation(L);
&gt; f := maps`mp_DerL_to_mats;
&gt; [ f(b) in Image(adL) : b in Basis(DerL) ];
[ false, true, true, true, true, true, true, true, false, false, true,
false, true, false, false, false, true, false, true, true, true, 
false, false, false, true, true, false, false, false, true, true, 
false, false, false, true, true, false, false, true, false, true, 
false, true, false, false, false, true, false, true, false, false, 
false ]
</PRE>
So, unsurprisingly, some of the basis elements of Der(L) are actually
elements from L, but others are not. We consider one more of these
maps and investigate how L lies in Der(L).
<P>
<P>
<PRE>
&gt; g := maps`mp_L_to_DerL;
&gt; I := ideal&lt;DerL | [ g(b) : b in Basis(L) ]&gt;; I;
Lie Algebra of dimension 26 with base ring GF(2)
&gt; pos2, neg2, cart2 := ChevalleyBasis(DerL, SplitToralSubalgebra(DerL));
&gt; [i : i in [1..#pos2] | pos2[i] in I ];
[ 3, 4, 6, 7, 8, 10, 12, 13, 15, 17, 19, 21 ]
&gt; RF4 := RootDatum("F4");
&gt; [ i : i in [1..NumPosRoots(RF4)] | IsShortRoot(RF4, i) ];
[ 3, 4, 6, 7, 8, 10, 12, 13, 15, 17, 19, 21 ]
</PRE>
So we conclude that the original Lie algebra L of type D<sub>4</sub> exists as
the short roots of the Lie algebra of derivations Der(L) of type F<sub>4</sub>.
<HR>
<PRE></PRE> <A  HREF = "text1140.htm">[Next]</A><A  HREF = "text1138.htm">[Prev]</A> <A  HREF = "text1140.htm">[Right]</A> <A  HREF = "text1138.htm">[Left]</A> <A  HREF = "text1130.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<br><small>Version: V2.22 of <I>
Thu Jun  9 16:37:49 EST 2016
</I></small>
</body></html>