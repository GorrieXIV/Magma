<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <link rel='stylesheet' href='help.css' type='text/css'>
  <TITLE>Boolean Values</TITLE>
</head>
<body BGCOLOR="#FFFFFF">

 <A  HREF = "text9.htm">[Next]</A><A  HREF = "text7.htm">[Prev]</A> <A  HREF = "text9.htm">[Right]</A> <A  HREF = "text7.htm">[Left]</A> <A  HREF = "text3.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<PRE></PRE><H3><A NAME = "31">Boolean Values</A></H3>

<P>
<P>
This section deals with logical values ("Booleans").
<P>
Booleans are primarily of importance as (return) values for (intrinsic)
predicates. It is important to know that the truth-value of the operators
<TT>and</TT> and <TT>or</TT>
is always evaluated <I>left to right</I>, that is, the left-most clause
is evaluated first, and if that determines the value of the operator
evaluation is aborted; if not, the next clause is evaluated, etc.
So, for example, if x is a boolean, it is safe (albeit silly) to type:
<P>
<P>
<PRE>
&gt; if x eq true or x eq false or x/0 eq 1 then
&gt;    "fine";
&gt; else
&gt;    "error";
&gt; end if;
</PRE>
even though x/0 would cause an error ("Bad arguments", not
"Division by zero"!) upon evaluation,
because the truth value will have been determined before the evaluation of
<TT>x/0</TT> takes place.



<H5>Subsections</H5>
<UL>
<LI> <A  HREF = "text8.htm#32">Creation of Booleans</A>
<LI> <A  HREF = "text8.htm#37">Boolean Operators</A>
<LI> <A  HREF = "text8.htm#42">Equality Operators</A>
<LI> <A  HREF = "text8.htm#48">Iteration</A>
</UL>
<H4><A NAME = "32">Creation of Booleans</A></H4>



<H5><A NAME = "33">Booleans() : -&gt; Bool</A></H5>
<BLOCKQUOTE>
The Boolean structure.
</BLOCKQUOTE>
<H5><A NAME = "34"># B : Bool -&gt; RngIntElt</A></H5>
<BLOCKQUOTE>
Cardinality of Boolean structure (2).
</BLOCKQUOTE>
<H5><A NAME = "35">true</A></H5>
<H5>false</H5>
<BLOCKQUOTE>
The Boolean elements.
</BLOCKQUOTE>
<H5><A NAME = "36">Random(B) : Bool -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Return a random Boolean.
</BLOCKQUOTE>
<H4><A NAME = "37">Boolean Operators</A></H4>



<H5><A NAME = "38">x and y : BoolElt, BoolElt -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if both x and y are <TT>true</TT>, <TT>false</TT> otherwise.
If x is <TT>false</TT>, the expression for y is not evaluated.
</BLOCKQUOTE>
<H5><A NAME = "39">x or y: BoolElt, BoolElt -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if  x or y is <TT>true</TT> (or both are <TT>true</TT>), <TT>false</TT> otherwise.
If x is <TT>true</TT>, the expression for y is not evaluated.
</BLOCKQUOTE>
<H5><A NAME = "40">x xor y: BoolElt, BoolElt -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if either x or y is <TT>true</TT> (but not both), <TT>false</TT> otherwise.
</BLOCKQUOTE>
<H5><A NAME = "41">not  x : BoolElt -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Negate the truth value of x.
</BLOCKQUOTE>
<H4><A NAME = "42">Equality Operators</A></H4>

<P>
<P>
<P>
Magma provides two equality operators: <TT>eq</TT> for strong (comparable)
equality testing, and <TT>cmpeq</TT> for weak equality testing.  The operators
depend on the concept of <I>comparability</I>.  Objects x and y in
Magma are said to be <I>comparable</I> if both of the following points hold:
<DL COMPACT class='compact'>
<DT>(a)</DT><DD>x and y are both elements of a structure S or there is a structure
S such x and y will be coerced into S by automatic coercion;
<DT>(b)</DT><DD>There is an equality test for elements of S defined within Magma.
<P>
</DL>
The possible automatic coercions are listed in the descriptions of the various
Magma modules.  For instance, the table in the introductory chapter
on rings shows that integers can be coerced automatically into the rational
field so an integer and a rational are comparable.


<H5><A NAME = "43">x eq y : Any, Any -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
If x and y are comparable, return <TT>true</TT> if x equals y (which will
always work by the second rule above).  If x and y are not comparable, 
an error results.
</BLOCKQUOTE>
<H5><A NAME = "44">x ne y : Any, Any -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
If x and y are comparable, return <TT>true</TT> if x does not equal y.
If x and y are not comparable, an error results.
</BLOCKQUOTE>
<H5><A NAME = "45">x cmpeq y : Any, Any -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
If x and y are comparable, return whether x equals y.
Otherwise, return <TT>false</TT>.  Thus this operator always returns a value and
an error never results.  It is useful when comparing two objects of
completely different types where it is desired that no error can happen.
However, it is strongly recommended that <TT>eq</TT> is usually used to
allow Magma to pick up common unintentional type errors.
</BLOCKQUOTE>
<H5><A NAME = "46">x cmpne y : Any, Any -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
If x and y are comparable, return whether x does not equal y.
Otherwise, return <TT>true</TT>.  Thus this operator always returns a value and
an error never results.  It is useful when comparing two objects of
completely different types where it is desired that no error can happen.
However, it is strongly recommended that <TT>ne</TT> is usually used to
allow Magma to pick up common unintentional type errors.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "47">Example <TT>State_Equality (H1E7)</TT></A></H3>
We illustrate the different semantics of <TT>eq</TT> and <TT>cmpeq</TT>.
<P>
<P>
<PRE>
&gt; 1 eq 2/2;
true
&gt; 1 cmpeq 2/2;
true
&gt; 1 eq "x";
Runtime error in 'eq': Bad argument types
&gt; 1 cmpeq "x";
false
&gt; [1] eq ["x"];
Runtime error in 'eq': Incompatible sequences
&gt; [1] cmpeq ["x"];
false
</PRE>
<HR>
<H4><A NAME = "48">Iteration</A></H4>

<P>
<P>
A Boolean structure B may be used for enumeration: <TT>for x in B do</TT>, and
<TT>x in B</TT> in set and sequence constructors.


<HR>
<H3><A NAME = "49">Example <TT>State_Booleans (H1E8)</TT></A></H3>
The following program checks that the functions <TT>ne</TT> and <TT>xor</TT>
coincide.
<P>
<P>
<PRE>
&gt; P := Booleans();
&gt; for x, y in P do
&gt;      (x ne y) eq (x xor y);
&gt; end for;
true
true
true
true
</PRE>
Similarly, we can test whether for any pair of Booleans x, y it is true that 
x = y iff (x ^ y) v (not x ^ not y).
<P>
<P>
<PRE>
&gt; equal := true;
&gt; for x, y in P do
&gt;     if (x eq y) and not ((x and y) or (not x and not y)) then
&gt;         equal := false;
&gt;     end if;
&gt; end for;
&gt; equal;
true
</PRE>
<HR>
<PRE></PRE> <A  HREF = "text9.htm">[Next]</A><A  HREF = "text7.htm">[Prev]</A> <A  HREF = "text9.htm">[Right]</A> <A  HREF = "text7.htm">[Left]</A> <A  HREF = "text3.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<br><small>Version: V2.22 of <I>
Thu Jun  9 16:37:49 EST 2016
</I></small>
</body></html>