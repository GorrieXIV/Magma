<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <link rel='stylesheet' href='help.css' type='text/css'>
  <TITLE>Operations on Sets</TITLE>
</head>
<body BGCOLOR="#FFFFFF">

 <A  HREF = "text92.htm">[Next]</A><A  HREF = "text90.htm">[Prev]</A> <A  HREF = "text92.htm">[Right]</A> <A  HREF = "text90.htm">[Left]</A> <A  HREF = "text85.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<PRE></PRE><H3><A NAME = "694">Operations on Sets</A></H3>




<H5>Subsections</H5>
<UL>
<LI> <A  HREF = "text91.htm#695">Boolean Functions and Operators</A>
<LI> <A  HREF = "text91.htm#707">Binary Set Operators</A>
<LI> <A  HREF = "text91.htm#713">Other Set Operations</A>
</UL>
<H4><A NAME = "695">Boolean Functions and Operators</A></H4>

<P>
<P>
As explained in the Introduction (Chapter <A  HREF = "text80.htm#588">INTRODUCTION TO AGGREGATES</A>), when elements are taken out
of a set their parent will be the universe of the set
(or, if the universe is itself a set, the universe of
the universe, etc.); in particular, the set itself is not the parent.
Hence equality testing on set elements is in fact equality testing between
two elements of certain algebraic structures, and the sets are
irrelevant. We only list the (in)equality operator for convenience
here.
<P>
Element membership testing is of critical importance for all types
of sets.
<P>
Testing whether or not R is a subset of S can be done
if R is an enumerated or indexed set and S is any
set; hence (in)equality testing is only possible
between sets that are not formal sets.


<H5><A NAME = "696">IsNull(R) : SetEnum -&gt; BoolElt</A></H5>
<H5>IsNull(R) : SetIndx -&gt; BoolElt</H5>
<H5>IsNull(R) : SetMulti -&gt; BoolElt</H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if and only if the enumerated, indexed, or multi- set R is
empty and does not have its universe defined.
</BLOCKQUOTE>
<H5><A NAME = "697">IsEmpty(R) : SetEnum -&gt; BoolElt</A></H5>
<H5>IsEmpty(R) : SetIndx -&gt; BoolElt</H5>
<H5>IsEmpty(R) : SetMulti -&gt; BoolElt</H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if and only if the enumerated, indexed or multi- set R is empty.
</BLOCKQUOTE>
<H5><A NAME = "698">x eq y : Elt, Elt -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Given an element x of a set R with universe U
and an element y of a set S with universe V, where
a common overstructure W can be found
with U&sub;W&sup;V (see the Introduction (Chapter <A  HREF = "text80.htm#588">INTRODUCTION TO AGGREGATES</A>)
for details on overstructures),
return <TT>true</TT> if and only if
x and y are equal as elements of W.
<P>
</BLOCKQUOTE>
<H5><A NAME = "699">x ne y : Elt, Elt -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Given an element x of a set R with universe U
and an element y of a set S with universe V, where
a common overstructure W can be found
with U&sub;W&sup;V (see the Introduction (Chapter <A  HREF = "text80.htm#588">INTRODUCTION TO AGGREGATES</A>) 
for details on overstructures),
return <TT>true</TT> if and only if
x and y are distinct as elements of W.
</BLOCKQUOTE>
<H5><A NAME = "700">x in R : Elt, Set -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if and only if the element x is a member of the set R.
If x is not an element of the universe U of R,
it is attempted to coerce x into U; if this fails, an error
occurs.
</BLOCKQUOTE>
<H5><A NAME = "701">x notin R : Elt, Set -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if and only if the element x is not a member 
of the set R.
If x is not an element of the parent structure U of R,
it is attempted to coerce x into U; if this fails, an error
occurs.
</BLOCKQUOTE>
<H5><A NAME = "702">R subset S : SetEnum, Set -&gt; BoolElt</A></H5>
<H5>R subset S : SetIndx, Set -&gt; BoolElt</H5>
<H5>R subset S : SetMulti, Set -&gt; BoolElt</H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if the enumerated, indexed or multi- set R 
is a subset of the 
set S, <TT>false</TT> otherwise.  For multisets, if an element x of R has
multiplicity n in R, the multiplicity of x in S must be at least n.
Coercion of the elements of R into S is attempted if
necessary, and an error occurs if this fails.
</BLOCKQUOTE>
<H5><A NAME = "703">R notsubset S : SetEnum, Set -&gt; BoolElt</A></H5>
<H5>R notsubset S : SetIndx, Set -&gt; BoolElt</H5>
<H5>R notsubset S : SetMulti, Set -&gt; BoolElt</H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if the enumerated, indexed, or multi- set R is a not a subset of the 
set S, <TT>false</TT> otherwise.
Coercion of the elements of R into S is attempted if
necessary, and an error occurs if this fails.
</BLOCKQUOTE>
<H5><A NAME = "704">R eq S : Set, Set -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if and only if R and S are identical sets, where R and S are
enumerated, indexed or multi- sets
For indexed sets, the index function is irrelevant for deciding equality.
For multisets, matching multiplicities must also be equal.
Coercion of the elements of R into S is attempted if
necessary, and an error occurs if this fails.
</BLOCKQUOTE>
<H5><A NAME = "705">R ne S : Set, Set -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if and only if R and S are distinct sets,  where R and S are
enumerated indexed, or multi- sets.
For indexed sets, the index function is irrelevant for deciding equality.
For multisets, matching multiplicities must also be equal.
Coercion of the elements of R into S is attempted if
necessary, and an error occurs if this fails.
</BLOCKQUOTE>
<H5><A NAME = "706">IsDisjoint(R, S) : SetEnum, SetEnum -&gt; BoolElt</A></H5>
<H5>IsDisjoint(R, S) : SetIndx, SetIndx -&gt; BoolElt</H5>
<H5>IsDisjoint(R, S) : SetMulti, SetMulti -&gt; BoolElt</H5>
<BLOCKQUOTE>
Returns <TT>true</TT> iff the enumerated, indexed or multi- sets R and S are disjoint.
Coercion of the elements of R into S is attempted if
necessary, and an error occurs if this fails.
</BLOCKQUOTE>
<H4><A NAME = "707">Binary Set Operators</A></H4>

<P>
<P>
For each of the following operators, R and S are sets of the same type.
If R and S are both formal sets, then
an error will occur unless both have been constructed with the same
carrier structure F in the definition. If R and S are both enumerated,
indexed, or multi- sets, then an error occurs unless the universes of R and
S are compatible, as defined in the Introduction to this Part 
(Chapter <A  HREF = "text80.htm#588">INTRODUCTION TO AGGREGATES</A>).
<P>
<P>
Note that 
<P>
<P>
<PRE>
Q := { ! x in R !}
</PRE>
converts an enumerated set R into a formal set Q.


<H5><A NAME = "708">R join S : SetEnum, SetEnum -&gt; SetEnum</A></H5>
<H5>R join S : SetIndx, SetIndx -&gt; SetIndx</H5>
<H5>R join S : SetMulti, SetMulti -&gt; SetMulti</H5>
<H5>R join S : SetFormal, SetFormal -&gt; SetFormal</H5>
<BLOCKQUOTE>
Union of the sets R and S (see above for the restrictions on
R and S).  For multisets, matching multiplicities are added in the
union.
</BLOCKQUOTE>
<H5><A NAME = "709">R meet S : SetEnum, SetEnum -&gt; SetEnum</A></H5>
<H5>R meet S : SetIndx, SetIndx -&gt; SetIndx</H5>
<H5>R meet S : SetMulti, SetMulti -&gt; SetMulti</H5>
<H5>R meet S : SetFormal, SetFormal -&gt; SetFormal</H5>
<BLOCKQUOTE>
Intersection of the sets R and S (see above for the restrictions on
R and S).  For multisets, the minimum of matching multiplicities is
stored in the intersection.
</BLOCKQUOTE>
<H5><A NAME = "710">R diff S : SetEnum, SetEnum -&gt; SetEnum</A></H5>
<H5>R diff S : SetIndx, SetIndx -&gt; SetIndx</H5>
<H5>R diff S : SetMulti, SetMulti -&gt; SetMulti</H5>
<H5>R diff S : SetFormal, SetFormal -&gt; SetFormal</H5>
<BLOCKQUOTE>
Difference of the sets R and S. i.e., the set consisting 
of those elements of R which are not members of S (see above for
the restrictions on R and S).
For multisets, the difference contains any elements of R remaining
after removing the corresponding elements of S the appropriate
number of times.
</BLOCKQUOTE>
<H5><A NAME = "711">R sdiff S : SetEnum, SetEnum -&gt; SetEnum</A></H5>
<H5>R sdiff S : SetIndx, SetIndx -&gt; SetIndx</H5>
<H5>R sdiff S : SetMulti, SetMulti -&gt; SetMulti</H5>
<H5>R sdiff S : SetFormal, SetFormal -&gt; SetFormal</H5>
<BLOCKQUOTE>
Symmetric difference of the sets R and S. i.e., the set 
consisting of those elements which are members of either 
R or S but not both (see above for the restrictions on
R and S).
Alternatively, it is the union of the difference of R with S
and the difference of S with R.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "712">Example <TT>Set_Join (H9E11)</TT></A></H3>
<P>
<P>
<PRE>
&gt; R := { 1, 2, 3 };
&gt; S := { 1, 1/2, 1/3 };
&gt; R join S;
{ 1/3, 1/2, 1, 2, 3 }
&gt; R meet S;
{ 1 }
&gt; R diff S;
{ 2, 3 }
&gt; S diff R;
{ 1/3, 1/2 }
&gt; R sdiff S;
{ 1/3, 1/2, 2, 3 }
</PRE>
<HR>
<H4><A NAME = "713">Other Set Operations</A></H4>



<H5><A NAME = "714">Multiplicity(S, x) : SetMulti, Elt -&gt; RngIntElt</A></H5>
<BLOCKQUOTE>
Return the multiplicity in multiset S of element x.  If x is not
in S, zero is returned.
</BLOCKQUOTE>
<H5><A NAME = "715">Multiplicities(S) : SetMulti -&gt; SeqEnum</A></H5>
<BLOCKQUOTE>
Returns the sequence of multiplicities of distinct elements in the
multiset S.  The order is the same as the internal enumeration order
of the elements.
</BLOCKQUOTE>
<H5><A NAME = "716">Subsets(S) : SetEnum -&gt; SetEnum</A></H5>
<BLOCKQUOTE>
The set of all subsets of S.
</BLOCKQUOTE>
<H5><A NAME = "717">Subsets(S, k) : SetEnum, RngIntElt -&gt; SetEnum</A></H5>
<BLOCKQUOTE>
The set of subsets of S of size k.  If k is larger than the cardinality
of S then the result will be empty.
</BLOCKQUOTE>
<H5><A NAME = "718">RandomSubset(S, k) : SetEnum, RngIntElt -&gt; SetEnum</A></H5>
<BLOCKQUOTE>
A random subset of S of size k.  It is an error if k is larger
than the size of S.
</BLOCKQUOTE>
<H5><A NAME = "719">Multisets(S, k) : SetEnum, RngIntElt -&gt; SetEnum</A></H5>
<BLOCKQUOTE>
The set of multisets consisting of k not necessarily distinct elements of
S.
</BLOCKQUOTE>
<H5><A NAME = "720">Subsequences(S, k) : SetEnum, RngIntElt -&gt; SetEnum</A></H5>
<BLOCKQUOTE>
The set of sequences of length k with elements from S.
</BLOCKQUOTE>
<H5><A NAME = "721">Permutations(S) : SetEnum -&gt; SetEnum;</A></H5>
<BLOCKQUOTE>
The set of permutations (stored as sequences) of the elements of S.
</BLOCKQUOTE>
<H5><A NAME = "722">Permutations(S, k) : SetEnum, RngIntElt -&gt; SetEnum;</A></H5>
<BLOCKQUOTE>
The set of permutations (stored as sequences) of each of the subsets of
S of cardinality k.
</BLOCKQUOTE>
<PRE></PRE> <A  HREF = "text92.htm">[Next]</A><A  HREF = "text90.htm">[Prev]</A> <A  HREF = "text92.htm">[Right]</A> <A  HREF = "text90.htm">[Left]</A> <A  HREF = "text85.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<br><small>Version: V2.22 of <I>
Thu Jun  9 16:37:49 EST 2016
</I></small>
</body></html>