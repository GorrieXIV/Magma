<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <link rel='stylesheet' href='help.css' type='text/css'>
  <TITLE>Element Operations</TITLE>
</head>
<body BGCOLOR="#FFFFFF">

 <A  HREF = "text227.htm">[Next]</A><A  HREF = "text225.htm">[Prev]</A> <A  HREF = "text227.htm">[Right]</A> <A  HREF = "text225.htm">[Left]</A> <A  HREF = "text222.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<PRE></PRE><H3><A NAME = "1940">Element Operations</A></H3>




<H5>Subsections</H5>
<UL>
<LI> <A  HREF = "text226.htm#1941">Arithmetic Operators</A>
<LI> <A  HREF = "text226.htm#1942">Equality and Membership</A>
<LI> <A  HREF = "text226.htm#1943">Predicates on Ring Elements</A>
<LI> <A  HREF = "text226.htm#1946">Coefficients, Monomials and Terms</A>
<LI> <A  HREF = "text226.htm#1971">Degrees</A>
<LI> <A  HREF = "text226.htm#1975">Univariate Polynomials</A>
<LI> <A  HREF = "text226.htm#1980">Derivative, Integral</A>
<LI> <A  HREF = "text226.htm#1985">Evaluation, Interpolation</A>
<LI> <A  HREF = "text226.htm#1990">Quotient and Reductum</A>
<LI> <A  HREF = "text226.htm#1994">Diagonalizing a Polynomial of Degree 2</A>
</UL>
<H4><A NAME = "1941">Arithmetic Operators</A></H4>

<P>
<P>
The usual unary and binary ring operations are available
for multivariate polynomials.
<P>
For polynomial
rings over fields division by elements of the coefficient
field are allowed (with the result in the original polynomial ring).
The operator <TT>div</TT> has slightly different semantics
from the univariate case: if b divides a, that is,
if there exists a polynomial
q&isin;P such that a = b.q&isin;P then q will
be the result of <TT>a div b</TT>, but if such polynomial does not exist
an error results.


<H5>+ a : RngMPolElt -&gt; RngMPolElt</H5>

<H5>- a : RngMPolElt -&gt; RngMPolElt</H5><P>

<H5>a + b : RngMPolElt, RngMPolElt -&gt; RngMPolElt</H5>

<H5>a - b : RngMPolElt, RngMPolElt -&gt; RngMPolElt</H5>

<H5>a * b : RngMPolElt, RngMPolElt -&gt; RngMPolElt</H5>

<H5>a ^ k : RngMPolElt, RngIntElt -&gt; RngMPolElt</H5>

<H5>a / b : RngMPolElt, RngMPolElt -&gt; FldFunMElt</H5>

<H5>a div b : RngMPolElt, RngMPolElt -&gt; RngMPolElt</H5><P>

<H5>a +:= b : RngMPolElt, RngMPolElt -&gt; RngMPolElt</H5>

<H5>a -:= b : RngMPolElt, RngMPolElt -&gt; RngMPolElt</H5>

<H5>a *:= b : RngMPolElt, RngMPolElt -&gt; RngMPolElt</H5>

<H5>a div:= b : RngMPolElt, RngMPolElt -&gt; RngMPolElt</H5><P>


<H4><A NAME = "1942">Equality and Membership</A></H4>



<H5>a eq b : RngMPolElt, RngMPolElt -&gt; BoolElt</H5>

<H5>a ne b : RngMPolElt, RngMPolElt -&gt; BoolElt</H5><P>

<H5>a in R : RngMPolElt, Rng -&gt; BoolElt</H5>

<H5>a notin R : RngMPolElt, Rng -&gt; BoolElt</H5><P>


<H4><A NAME = "1943">Predicates on Ring Elements</A></H4>

<P>
<P>
The list belows contains the general ring element predicates.
Also, the <TT>IsDivisibleBy</TT> function allows a divisibility test,
and the <TT>IsAlgebraicallyDependent</TT> function determines if a set
of ring elements is algebraically dependent.
Note that not all functions are available for every coefficient
ring. 


<H5>IsZero(f) : RngMPolElt -&gt; BoolElt</H5>

<H5>IsOne(f) : RngMPolElt -&gt; BoolElt</H5>

<H5>IsMinusOne(f) : RngMPolElt -&gt; BoolElt</H5><P>

<H5>IsNilpotent(f) : RngMPolElt -&gt; BoolElt</H5>

<H5>IsIdempotent(f) : RngMPolElt -&gt; BoolElt</H5><P>

<H5>IsUnit(f) : RngMPolElt -&gt; BoolElt</H5>

<H5>IsZeroDivisor(f) : RngMPolElt -&gt; BoolElt</H5>

<H5>IsRegular(f) : RngMPolElt -&gt; BoolElt</H5><P>

<H5>IsIrreducible(f) : RngMPolElt -&gt; BoolElt</H5>

<H5>IsPrime(f) : RngMPolElt -&gt; BoolElt</H5><P>


<H5><A NAME = "1944">IsDivisibleBy(a, b) : RngMPolElt, RngMPolElt -&gt; BoolElt, RngMPolElt</A></H5>
<BLOCKQUOTE>
Given elements a, b in a multivariate polynomial ring P, this
function returns whether the polynomial a is divisible by b in P,
that is, if and only if there exists q&isin;P such that a=q.b.
If <TT>true</TT> is returned, the quotient polynomial q is also returned.
</BLOCKQUOTE>
<H5><A NAME = "1945">IsAlgebraicallyDependent(S) : RngMPolElt -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> iff the set S of multivariate polynomials is algebraically dependent.
</BLOCKQUOTE>
<H4><A NAME = "1946">Coefficients, Monomials and Terms</A></H4>

<P>
<P>
<P>
Many of the functions in this subsection come in three different
forms: one in which no variable is specified, which usually
returns values in the coefficient ring, and two in which a particular
variable is referred, either by name or by number, and these usually
return values in the polynomial ring itself.


<H5><A NAME = "1947">Coefficients(f) : RngMPolElt -&gt; [ RngElt ]</A></H5>
<BLOCKQUOTE>
Given a multivariate polynomial f with coefficients in R, this
function returns a sequence of `base' coefficients, that is, a
sequence of elements of R occurring as
coefficients of the monomials in f. Note that the monomials
are ordered, and that the sequence of coefficients corresponds
exactly to the sequence of monomials returned by <TT>Monomials(f)</TT>.
</BLOCKQUOTE>
<H5><A NAME = "1948">Coefficients(f, i) : RngMPolElt, RngIntElt -&gt; [ RngElt ]</A></H5>
<H5>Coefficients(f, v) : RngMPolElt, RngMPolElt -&gt; [ RngElt ]</H5>
<BLOCKQUOTE>
Given a multivariate polynomial f&isin;P = R[x<sub>1</sub>, ..., x<sub>n</sub>], this
function returns a sequence of coefficients with respect to a given
variable v=x<sub>i</sub>, that is, the function returns a sequence of elements
of P that form the coefficients of the powers of v (in ascending order)
when f is regarded as a polynomial &sum;<sub>j</sub> c<sub>j</sub> x<sub>i</sub><sup>j</sup>; note that
the variable x<sub>i</sub> itself will not occur in the coefficients.
There are two ways to indicate with respect to which variable the coefficients
are to be taken: either one specifies i, the integer 1&le;i&le;n
that is the number of the variable (upon creation of P, corresponding
to <TT>P.i</TT>) or the variable v itself (as an element of P).
</BLOCKQUOTE>
<H5><A NAME = "1949">Coefficient(f, i, k) : RngMPolElt, RngIntElt, RngIntElt -&gt; RngElt</A></H5>
<H5>Coefficient(f, v, k) : RngMPolElt, RngMPolElt, RngIntElt -&gt; RngElt</H5>
<BLOCKQUOTE>
Given a multivariate polynomial f&isin;P = R[x<sub>1</sub>, ..., x<sub>n</sub>], this
function returns the coefficient of v<sup>k</sup>=x<sub>i</sub><sup>k</sup>, that is,
the function returns the element of P that forms the coefficient
of the k-th power of x<sub>i</sub>, when f is regarded as a polynomial
&sum;<sub>j</sub> c<sub>j</sub> x<sub>i</sub><sup>j</sup>; note that
the variable x<sub>i</sub> itself will not occur in the coefficient.
There are two ways to indicate with respect to which variable the coefficient
is to be taken: either one specifies i, the integer 1&le;i&le;n
that is the number of the variable (upon creation of P, corresponding
to <TT>P.i</TT>) or the variable v itself (as an element of P).
</BLOCKQUOTE>
<H5><A NAME = "1950">LeadingCoefficient(f) : RngMPolElt -&gt; RngElt</A></H5>
<BLOCKQUOTE>
Given a multivariate polynomial f with coefficients in R, this
function returns the leading coefficient of f as an element
of R; this is the coefficient of the leading monomial of f,
that is, the first among the monomials occurring
in f with respect to the ordering of monomials used in P.
</BLOCKQUOTE>
<H5><A NAME = "1951">LeadingCoefficient(f, i) : RngMPolElt, RngIntElt -&gt; RngElt</A></H5>
<H5>LeadingCoefficient(f, v) : RngMPolElt, RngMPolElt -&gt; RngElt</H5>
<BLOCKQUOTE>
Given a multivariate polynomial f&isin;P = R[x<sub>1</sub>, ..., x<sub>n</sub>], this
function returns the element of P that forms the coefficient
of the largest power of v=x<sub>i</sub> that occurs with non-zero
coefficient in f, when f is regarded as a polynomial
&sum;<sub>j</sub> c<sub>j</sub> x<sub>i</sub><sup>j</sup>; note that
the variable x<sub>i</sub> itself will not occur in the coefficient.
There are two ways to indicate with respect to which variable the leading
coefficient is to be taken: either one specifies i, the integer 1&le;i&le;n
that is the number of the variable (upon creation of P, corresponding
to <TT>P.i</TT>) or the variable v itself (as an element of P).
</BLOCKQUOTE>
<H5><A NAME = "1952">Length(f) : RngMPolElt -&gt; RngIntElt</A></H5>
<BLOCKQUOTE>
Given a multivariate polynomial f, return the length of f, i.e.,
the number of terms of f.
</BLOCKQUOTE>
<H5><A NAME = "1953">TrailingCoefficient(f) : RngMPolElt -&gt; RngElt</A></H5>
<BLOCKQUOTE>
Given a multivariate polynomial f with coefficients in R, this
function returns the trailing coefficient of f as an element
of R; this is the coefficient of the trailing monomial of f,
that is, the last among the monomials occurring
in f with respect to the ordering of monomials used in P.
</BLOCKQUOTE>
<H5><A NAME = "1954">TrailingCoefficient(f, i) : RngMPolElt, RngIntElt -&gt; RngElt</A></H5>
<H5>TrailingCoefficient(f, v) : RngMPolElt, RngMPolElt -&gt; RngElt</H5>
<BLOCKQUOTE>
Given a multivariate polynomial f&isin;P = R[x<sub>1</sub>, ..., x<sub>n</sub>], this
function returns the element of P that forms the coefficient
of the least power of v=x<sub>i</sub> that occurs with non-zero
coefficient in f, when f is regarded as a polynomial
&sum;<sub>j</sub> c<sub>j</sub> x<sub>i</sub><sup>j</sup>; note that
the variable x<sub>i</sub> itself will not occur in the coefficient.
There are two ways to indicate with respect to which variable the leading
coefficient is to be taken: either one specifies i, the integer 1&le;i&le;n
that is the number of the variable (upon creation of P, corresponding
to <TT>P.i</TT>) or the variable v itself (as an element of P).
</BLOCKQUOTE>
<H5><A NAME = "1955">CoefficientDenominator(f) : RngMPolElt -&gt; RngElt</A></H5>
<H5>CoefficientNumerator(f) : RngMPolElt -&gt; RngElt</H5>
<BLOCKQUOTE>
Given a multivariate polynomial f with coefficients in Q, a rational function field or a field of fractions of an order of a number or function field,
return the LCM of the denominators
of the coefficients of f (<TT>CoefficientDenominator</TT>)
or the product of that LCM with f itself (<TT>CoefficientNumerator</TT>).
</BLOCKQUOTE>
<H5><A NAME = "1956">MonomialCoefficient(f, m) : RngMPolElt, RngMPolElt -&gt; RngElt</A></H5>
<BLOCKQUOTE>
Given a multivariate polynomial f and a monomial m, both in P&isin;R[x<sub>1</sub>, ..., x<sub>n</sub>], this function returns the coefficient with which m
occurs in f as an element of R.
</BLOCKQUOTE>
<H5><A NAME = "1957">Monomials(f) : RngMPolElt -&gt; [ RngMPolElt ]</A></H5>
<BLOCKQUOTE>
Given a multivariate polynomial f&isin;P, this
function returns a sequence of monomials, that is, a
sequence of monomial elements of P occurring
in f. Note that the monomials in P
are ordered, and that the sequence of monomials corresponds
exactly to the sequence of coefficients returned by <TT>Coefficients(f)</TT>.
</BLOCKQUOTE>
<H5><A NAME = "1958">CoefficientsAndMonomials(f) : RngMPolElt -&gt; [ RngElt ], [ RngMPolElt ]</A></H5>
<BLOCKQUOTE>
Given a multivariate polynomial f&isin;P, this
function returns parallel sequences C and M of the coefficients
and monomials, respectively, of f.  Thus this function is equivalent
to calling <TT>Coefficients</TT> and <TT>Monomials</TT> separately, but
is more efficient (particularly for large polynomials) since only
one scan of the polynomial needs to be done.
</BLOCKQUOTE>
<H5><A NAME = "1959">LeadingMonomial(f) : RngMPolElt -&gt; RngMPolElt</A></H5>
<BLOCKQUOTE>
Given a multivariate polynomial f&isin;P this function returns
the leading monomial of f, that is, the first monomial element
of P that occurs in f, with respect to the
ordering of monomials used in P.
</BLOCKQUOTE>
<H5><A NAME = "1960">Terms(f) : RngMPolElt -&gt; [ RngMPolElt ]</A></H5>
<BLOCKQUOTE>
Given a multivariate polynomial f&isin;P, this function returns the sequence
of (non-zero) terms of f as elements of P. The terms are ordered
according to the ordering on the monomials in P. Consequently
the i-th element of this sequence of terms will be equal to
the product of the i-th element of the sequence of coefficients
and the i-th element of the sequence of monomials.
</BLOCKQUOTE>
<H5><A NAME = "1961">Terms(f, i) : RngMPolElt, RngIntElt -&gt; [ RngMPolElt ]</A></H5>
<H5>Terms(f, v) : RngMPolElt, RngMPolElt -&gt; [ RngMPolElt ]</H5>
<BLOCKQUOTE>
Given a multivariate polynomial f&isin;P = R[x<sub>1</sub>, ..., x<sub>n</sub>], this
function returns a sequence of terms with respect to a given
variable v=x<sub>i</sub>, that is, the function returns a sequence of elements
of P that form the terms (ascending order) of
f regarded as a polynomial &sum;<sub>j</sub> c<sub>j</sub> x<sub>i</sub><sup>j</sup>.
There are two ways to indicate with respect to which variable the terms
are to be ordered: either one specifies i, the integer 1&le;i&le;n
that is the number of the variable (upon creation of P, corresponding
to <TT>P.i</TT>) or the variable v itself (as an element of P).
</BLOCKQUOTE>
<H5><A NAME = "1962">Term(f, i, k) : RngMPolElt, RngIntElt, RngIntElt -&gt; RngMPolElt</A></H5>
<H5>Term(f, v, k) : RngMPolElt, RngMPolElt, RngIntElt -&gt; RngMPolElt</H5>
<BLOCKQUOTE>
Given a multivariate polynomial f&isin;P = R[x<sub>1</sub>, ..., x<sub>n</sub>], this
function returns the k-th term of f (with k&ge;0), that is,
the function returns the term of f involving
the k-th power of x<sub>i</sub>, when f is regarded as a polynomial
&sum;<sub>j</sub> c<sub>j</sub> x<sub>i</sub><sup>j</sup>.
There are two ways to indicate with respect to which variable the term
is to be taken: either one specifies i, the integer 1&le;i&le;n
that is the number of the variable (upon creation of P, corresponding
to <TT>P.i</TT>) or the variable v itself (as an element of P).
</BLOCKQUOTE>
<H5><A NAME = "1963">LeadingTerm(f) : RngMPolElt -&gt; RngMPolElt</A></H5>
<BLOCKQUOTE>
Given a multivariate polynomial f&isin;P, this
function returns the leading term of f as an element
of P; this is the product of the leading monomial and the leading
coefficient
that is, the first among the monomial terms occurring
in f with respect to the ordering of monomials used in P.
</BLOCKQUOTE>
<H5><A NAME = "1964">LeadingTerm(f, i) : RngMPolElt, RngIntElt -&gt; RngMPolElt</A></H5>
<H5>LeadingTerm(f, v) : RngMPolElt, RngMPolElt -&gt; RngMPolElt</H5>
<BLOCKQUOTE>
Given a multivariate polynomial f&isin;P = R[x<sub>1</sub>, ..., x<sub>n</sub>], this
function returns the element of P that forms the leading term
of f when f is regarded as a polynomial
&sum;<sub>j</sub> c<sub>j</sub> x<sub>i</sub><sup>j</sup>. Thus it is the term involving the largest
power of x<sub>i</sub> that occurs with non-zero coefficient.
There are two ways to indicate with respect to which variable the leading
coefficient is to be taken: either one specifies i, the integer 1&le;i&le;n
that is the number of the variable (upon creation of P, corresponding
to <TT>P.i</TT>) or the variable v itself (as an element of P).
</BLOCKQUOTE>
<H5><A NAME = "1965">TrailingTerm(f) : RngMPolElt -&gt; RngElt</A></H5>
<BLOCKQUOTE>
Given a multivariate polynomial f&isin;P, this
function returns the trailing term of f as an element
of P; this is
the last among the monomial terms occurring
in f with respect to the ordering of monomials used in P.
</BLOCKQUOTE>
<H5><A NAME = "1966">TrailingTerm(f, i) : RngMPolElt, RngIntElt -&gt; RngElt</A></H5>
<H5>TrailingTerm(f, v) : RngMPolElt, RngMPolElt -&gt; RngElt</H5>
<BLOCKQUOTE>
Given a multivariate polynomial f&isin;P = R[x<sub>1</sub>, ..., x<sub>n</sub>], this
function returns the element of P that forms the trailing term
of f when f is regarded as a polynomial
&sum;<sub>j</sub> c<sub>j</sub> x<sub>i</sub><sup>j</sup>. Thus it is the term involving the least
power of x<sub>i</sub> that occurs with non-zero coefficient.
There are two ways to indicate with respect to which variable the leading
coefficient is to be taken: either one specifies i, the integer 1&le;i&le;n
that is the number of the variable (upon creation of P, corresponding
to <TT>P.i</TT>) or the variable v itself (as an element of P).
</BLOCKQUOTE>
<H5><A NAME = "1967">Exponents(f) : RngMPolElt -&gt; [ RngIntElt ]</A></H5>
<BLOCKQUOTE>
Given a single term f (a polynomial having exactly one term) in 
a polynomial ring of rank n, return the exponents of the monomial
of f, as a sequence of length n of integers.
(The coefficient of f is ignored; it need not be 1.)
</BLOCKQUOTE>
<H5><A NAME = "1968">Monomial(P, E) : RngMPol, [ RngIntElt ] -&gt; RngMPolElt</A></H5>
<BLOCKQUOTE>
Given a multivariate polynomial ring P = R[x<sub>1</sub>, ..., x<sub>n</sub>], and
a sequence E of non-negative integers, return the monomial
(x<sub>1</sub>)<sup>E[1]</sup> ... (x<sub>n</sub>)<sup>E[n]</sup> in P.  This function is a
semi-inverse of <TT>Exponents</TT>.
</BLOCKQUOTE>
<H5><A NAME = "1969">Polynomial(C, M) : [RngElt], [RngMPolElt] -&gt; RngMPolElt</A></H5>
<BLOCKQUOTE>
Given a length-k sequence C of coefficients in a ring R and a
length-k sequence M of monomials of a polynomial ring R,
return the multivariate polynomial f&isin;R whose coefficients
are C and monomials are M.
(Thus for any f&isin;R, <TT>Polynomial(Coefficients(f), Monomials(f))</TT>
equals f.)
</BLOCKQUOTE>
<HR>
<H3><A NAME = "1970">Example <TT>RngMPol_Coefficients (H24E4)</TT></A></H3>
In this and the next example we illustrate the coefficient and term
functions, using the polynomial in three variables x, y, z over
the rational field that is given by f=(2x + y)z<sup>3</sup> + 11xyz + x<sup>2</sup>y<sup>2</sup>.
<P>
<P>
<PRE>
&gt; R&lt;x, y, z&gt; := PolynomialAlgebra(RationalField(), 3);
&gt; f := (2*x+y)*z^3+11*x*y*z+x^2*y^2;
&gt; f;
x^2*y^2 + 11*x*y*z + 2*x*z^3 + y*z^3
&gt; Coefficients(f);
[ 1, 11, 2, 1 ]
&gt; Monomials(f);
[
   x^2*y^2,
   x*y*z,
   x*z^3,
   y*z^3
]
&gt; CoefficientsAndMonomials(f);
[ 1, 11, 2, 1 ]
[
    x^2*y^2,
    x*y*z,
    x*z^3,
    y*z^3
]
&gt; Terms(f);
[
   x^2*y^2,
   11*x*y*z,
   2*x*z^3,
   y*z^3
]
&gt; Coefficients(f, y);
[
   2*x*z^3,
   11*x*z + z^3,
   x^2
]
&gt; Terms(f, 2);    
[
   2*x*z^3,
   11*x*y*z + y*z^3,
   x^2*y^2
]
&gt; MonomialCoefficient(f, x*y*z);
11
&gt; LeadingTerm(f);
x^2*y^2
&gt; LeadingTerm(f, z);
2*x*z^3 + y*z^3
&gt; LeadingCoefficient(f, z);
2*x + y
&gt; Polynomial([1, 2, 3], [x*y, y, z^2]);  
x*y + 2*y + 3*z^2
</PRE>
<HR>
<H4><A NAME = "1971">Degrees</A></H4>



<H5><A NAME = "1972">Degree(f, i) : RngMPolElt, RngIntElt -&gt; RngIntElt</A></H5>
<H5>Degree(f, v) : RngMPolElt, RngMPolElt -&gt; RngIntElt</H5>
<BLOCKQUOTE>
Given a multivariate polynomial f&isin;P = R[x<sub>1</sub>, ..., x<sub>n</sub>], this
function returns the degree of f in v<sup>k</sup>=x<sub>i</sub><sup>k</sup>, that is,
the function returns the degree of f when it is regarded as a polynomial
&sum;<sub>j</sub> c<sub>j</sub> x<sub>i</sub><sup>j</sup>. The resulting integer is thus the largest power
of x<sub>i</sub> occurring in any monomial of f.
There are two ways to indicate with respect to which variable the degree
is to be taken: either one specifies i, the integer 1&le;i&le;n
that is the number of the variable (upon creation of P, corresponding
to <TT>P.i</TT>) or the variable v itself (as an element of P).
If f is the zero polynomial, the return value is always -1.
</BLOCKQUOTE>
<H5><A NAME = "1973">TotalDegree(f) : RngMPolElt -&gt; RngIntElt</A></H5>
<BLOCKQUOTE>
Given a multivariate polynomial f&isin;P = R[x<sub>1</sub>, ..., x<sub>n</sub>], this
function returns the total degree of f, which is the maximum
of the total degrees of all monomials that occur in f.
The total degree of a monomial m is the sum
of the exponents of the indeterminates that make up m.
Note that this ignores the weights on the variables if there are any
(see the section on graded polynomial rings below).
If f is the zero polynomial, the return value is -1.
</BLOCKQUOTE>
<H5><A NAME = "1974">LeadingTotalDegree(f) : RngMPolElt -&gt; RngIntElt</A></H5>
<BLOCKQUOTE>
Given a multivariate polynomial f&isin;P = R[x<sub>1</sub>, ..., x<sub>n</sub>], this
function returns the leading total degree of f, which is the 
total degree of the leading monomial of f.
If f is the zero polynomial, the return value is -1.
</BLOCKQUOTE>
<H4><A NAME = "1975">Univariate Polynomials</A></H4>



<H5><A NAME = "1976">IsUnivariate(f) : RngMPolElt -&gt; BoolElt, RngUPolElt, RngIntElt</A></H5>
<BLOCKQUOTE>
Given a multivariate polynomial f&isin;R[x<sub>1</sub>, ..., x<sub>n</sub>], this
function returns whether f is in fact a univariate polynomial
in one of its indeterminates x<sub>1</sub>, ..., x<sub>n</sub>. If true is returned,
then the function also returns a univariate version u of f and
(the first) i such that f is univariate in x<sub>i</sub>. Note that
there will only be ambiguity about i if f is a constant polynomial.
The univariate polynomial u will be an element of R[x] with
the same coefficients as f.
</BLOCKQUOTE>
<H5><A NAME = "1977">IsUnivariate(f, i) : RngMPolElt, RngIntElt -&gt; BoolElt, RngUPolElt</A></H5>
<H5>IsUnivariate(f, v) : RngMPolElt, RngMPolElt -&gt; BoolElt, RngUPolElt</H5>
<BLOCKQUOTE>
Given a multivariate polynomial f&isin;R[x<sub>1</sub>, ..., x<sub>n</sub>], this
function returns whether f is in fact a univariate polynomial
in x<sub>i</sub>. If true is returned,
then the function also returns a univariate version u of f,
which will be an element of the univariate
polynomial ring R[x] with the same coefficients as f.
The indeterminate x<sub>i</sub> should either be specified as a (polynomial)
argument v or as an integer i.
</BLOCKQUOTE>
<H5><A NAME = "1978">UnivariatePolynomial(f) : RngMPolElt -&gt; RngUPolElt</A></H5>
<BLOCKQUOTE>
Given a multivariate polynomial f&isin;R[x<sub>1</sub>, ..., x<sub>n</sub>], which
is known to be a univariate polynomial
in x<sub>i</sub> for some i with 1&le;i&le;n, return
a univariate version u of f,
which will be an element of the univariate
polynomial ring R[x] with the same coefficients as f.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "1979">Example <TT>RngMPol_UnivariatePolynomial (H24E5)</TT></A></H3>
Suppose we have two bivariate polynomials f and g over some ring.
<P>
<P>
<PRE>
&gt; P&lt;x,y&gt; := PolynomialRing(GF(5), 2);
&gt; f := x^2 - y + 3;
&gt; g := y^3 - x*y + x;
</PRE>
If we compute the resultant in either variable of the two polynomials,
then we can apply <TT>UnivariatePolynomial</TT> to this to obtain a
univariate version of it, from which we can compute the roots.
<P>
<P>
<PRE>
&gt; ry := Resultant(f, g, y);       
&gt; ry;
4*x^6 + x^4 + x^3 + 3*x^2 + 2*x + 3
&gt; Roots(UnivariatePolynomial(ry));
[ &lt;3, 1&gt; ]
&gt; Evaluate(f, x, 3);
4*y + 2
&gt; Evaluate(g, x, 3);
y^3 + 2*y + 3
&gt; GCD($1, $2);
y + 3
&gt; rx := Resultant(f, g, x); 
&gt; rx;
y^6 + 4*y^3 + 3*y + 3
&gt; Roots(UnivariatePolynomial(rx));
[ &lt;2, 1&gt; ]
&gt; Evaluate(f, y, 2);
x^2 + 1
&gt; Evaluate(g, y, 2);
4*x + 3
&gt; GCD($1, $2);
x + 2
</PRE>
<HR>
<H4><A NAME = "1980">Derivative, Integral</A></H4>



<H5><A NAME = "1981">Derivative(f, i) : RngMPolElt, RngIntElt -&gt; RngMPolElt</A></H5>
<H5>Derivative(f, v) : RngMPolElt, RngMPolElt -&gt; RngMPolElt</H5>
<BLOCKQUOTE>
Given a multivariate polynomial f&isin;P, return the derivative
of f with respect to the variable v=x<sub>i</sub>, as an element of P.
There are two ways to indicate with respect to which variable the derivative
is to be taken: either one specifies i, the integer 1&le;i&le;n
that is the number of the variable (upon creation of P, corresponding
to <TT>P.i</TT>) or the variable v itself (as an element of P).
</BLOCKQUOTE>
<H5><A NAME = "1982">Derivative(f, k, i) : RngMPolElt, RngIntElt -&gt; RngMPolElt</A></H5>
<H5>Derivative(f, k, v) : RngMPolElt, RngMPolElt -&gt; RngMPolElt</H5>
<BLOCKQUOTE>
Given a multivariate
polynomial f&isin;P and an integer k &gt; 0, return the k-th derivative
of f with respect to the variable v=x<sub>i</sub>, as an element of P.
There are two ways to indicate with respect to which variable the derivative
is to be taken: either one specifies i, the integer 1&le;i&le;n
that is the number of the variable (upon creation of P, corresponding
to <TT>P.i</TT>) or the variable v itself (as an element of P).
</BLOCKQUOTE>
<H5><A NAME = "1983">Integral(f, i) : RngMPolElt, RngIntElt -&gt; RngMPolElt</A></H5>
<H5>Integral(f, v) : RngMPolElt, RngMPolElt -&gt; RngMPolElt</H5>
<BLOCKQUOTE>
Given a multivariate polynomial f&isin;P over a field of characteristic zero,
return the formal integral of f with respect to v=x<sub>i</sub>
as an element of P.
There are two ways to indicate with respect to which variable the integral
is to be taken: either one specifies i, the integer 1&le;i&le;n
that is the number of the variable (upon creation of P, corresponding
to <TT>P.i</TT>) or the variable v itself (as an element of P).
</BLOCKQUOTE>
<H5><A NAME = "1984">JacobianMatrix( [ f ] ) : [ RngMPolElt ] -&gt; RngMPol</A></H5>
<BLOCKQUOTE>
Creates the matrix with (i, j)'th entry the partial derivative of the i'th
polynomial in the list with the j'th indeterminate of its parent ring.
</BLOCKQUOTE>
<H4><A NAME = "1985">Evaluation, Interpolation</A></H4>



<H5><A NAME = "1986">Evaluate(f, s) : RngMPolElt, [ RngElt ] -&gt; RngElt</A></H5>
<H5>Evaluate(f, s) : RngMPolElt, &lt; RngElt, ..., RngElt &gt; -&gt; RngElt</H5>
<BLOCKQUOTE>
Given an element f of a polynomial ring P=R[x<sub>1</sub>, ..., x<sub>n</sub>]
and a sequence or tuple s of ring elements of length n, 
return the value of f at s, that is, obtained by
substituting x<sub>i</sub>=s[i].  
If the elements of
s can be lifted into the coefficient ring R,
then the result will be an element of R.
If the elements of
s cannot be lifted to the coefficient ring, then an attempt is made
to do a generic evaluation of f at s.  In this case, the result will
be of the same type as the elements of s.
</BLOCKQUOTE>
<H5><A NAME = "1987">Evaluate(f, i, r) : RngMPolElt, RngMPolElt, RngElt -&gt; RngMPolElt</A></H5>
<H5>Evaluate(f, v, r) : RngMPolElt, RngMPolElt, RngElt -&gt; RngMPolElt</H5>
<BLOCKQUOTE>
Given an element f of a multivariate polynomial ring P
and a ring element r return the value of f when the
variable v=x<sub>i</sub> is evaluated at r.
If r can be coerced into the coefficient
ring of P, the result will be an element in P again.  
Otherwise the other variables of P must be coercible into
the parent of r, and the result will have the same parent
as r.
</BLOCKQUOTE>
<H5><A NAME = "1988">Interpolation(I, V, i) : [ RngElt ], [ RngMPolElt ], RngIntElt -&gt; RngMPolElt</A></H5>
<H5>Interpolation(I, V, v) : [ RngElt ], [ RngMPolElt ], RngIntElt -&gt; RngMPolElt</H5>
<BLOCKQUOTE>
Let K be a  field, and P=K[x<sub>1</sub>, ..., x<sub>n</sub>] a multivariate
polynomial ring over K; let v=x<sub>i</sub> be the i-th indeterminate
of P. Given a sequence I of elements of K (the
interpolation points) and a sequence V of elements of P
(the interpolation values), both sequences of length k&gt;0,
return the unique polynomial f&isin;P of degree less than k in the
variable x<sub>i</sub> such that f(I[j]) = V[j], for j=1, ..., k.
The variable x<sub>i</sub> may not occur anywhere in the values V.
There are two ways to indicate with respect to which variable to interpolate:
either one specifies i, the integer 1&le;i&le;n
that is the number of the variable or the variable v itself (as a polynomial).
</BLOCKQUOTE>
<HR>
<H3><A NAME = "1989">Example <TT>RngMPol_Interpolate (H24E6)</TT></A></H3>
We define P=Q[x, y, z], and give an example
of interpolation.  We find a polynomial which,
when evaluated in the first variable x in the rational points
1, 2, 3, yields y, z, y + z respectively. We check the result
by evaluating.
<P>
<P>
<PRE>
&gt; Q := RationalField();
&gt; P&lt;x, y, z&gt; := PolynomialRing(Q, 3);
&gt; f := Interpolation([Q | 1, 2, 3], [y, z, y + z], 1);
&gt; f;
x^2*y - 1/2*x^2*z - 4*x*y + 5/2*x*z + 4*y - 2*z
&gt; [ Evaluate(f, 1, v) : v in [1, 2, 3] ];
[
   y,
   z,
   y + z
]
</PRE>
<HR>
<H4><A NAME = "1990">Quotient and Reductum</A></H4>



<H5><A NAME = "1991">f div g : RngMPolElt, RngMPolElt -&gt; RngMPolElt</A></H5>
<H5>ExactQuotient(f, g) : RngMPolElt, RngMPolElt -&gt; RngMPolElt</H5>
<BLOCKQUOTE>
The quotient of the multivariate polynomial f by g in
R[x<sub>1</sub>, ..., x<sub>n</sub>], provided the result
lies in P again. Here R must be a domain. If a polynomial q
in P exists such that f=q.g then it will be returned, but
if does not exist an error results.
</BLOCKQUOTE>
<H5><A NAME = "1992">Reductum(f) : RngMPolElt -&gt; RngMPolElt</A></H5>
<BLOCKQUOTE>
The reductum of a polynomial f, which is the polynomial obtained
by removing the leading term of f.
</BLOCKQUOTE>
<H5><A NAME = "1993">Reductum(f, i) : RngMPolElt, RngIntElt -&gt; RngMPolElt</A></H5>
<H5>Reductum(f, v) : RngMPolElt, RngMPolElt -&gt; RngMPolElt</H5>
<BLOCKQUOTE>
The reductum of a multivariate polynomial f&isin;R[x<sub>1</sub>, ..., x<sub>n</sub>] obtained
by removing the leading term with respect to the variable v=x<sub>i</sub>.
Here either v must be specified as a polynomial, or x<sub>i</sub> must be
specified by providing the integer i, with 1&le;i&le;n.
</BLOCKQUOTE>
<H4><A NAME = "1994">Diagonalizing a Polynomial of Degree 2</A></H4>

<P>
<P>
<P>
We provide two basic tools that deal with polynomial diagonalization.


<H5><A NAME = "1995">SymmetricBilinearForm(f) : RngMPolElt -&gt; ModMatRngElt</A></H5>
<BLOCKQUOTE>
The symmetric bilinear form
(as a matrix) of a multivariate polynomial of degree 2.
</BLOCKQUOTE>
<H5><A NAME = "1996">DiagonalForm(f) : RngMPolElt -&gt; RngMPolElt, ModMatRngElt</A></H5>
<BLOCKQUOTE>
The diagonal form of the multivariate polynomial of degree 2. 
Also returns the transformation matrix.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "1997">Example <TT>RngMPol_Sym_Bi_Linear (H24E7)</TT></A></H3>
<P>
<P>
<PRE>
&gt; Q := RationalField();
&gt; PR&lt;x, y, z&gt; := PolynomialRing(Q, 3);
&gt; g := 119/44*x^2 - 93759/41440*x*y + 390935/91427*x*z
&gt;      + 212/243*x - 3/17*y^2 + 52808/172227*y*z
&gt;      - 287/227*y + 537/934*z^2 - 127/422*z;
&gt; SymmetricBilinearForm(g);
[       119/44  -93759/82880 390935/182854       106/243]
[ -93759/82880         -3/17  26404/172227      -287/454]
[390935/182854  26404/172227       537/934      -127/844]
[      106/243      -287/454      -127/844             0]
&gt; DiagonalForm(g);
119/44*x^2 - 15798558582429/4*y^2 +
34932799628335074761085292707227419544217/934*z^2 -
176588732861018934524371210556883645619275217398116147234837710457404146371/2
&gt;
&gt; bl := SymmetricBilinearForm(g);
&gt; NBL := Matrix(PR, bl);
&gt; D, T := OrthogonalizeGram(bl);
&gt; NT := Matrix(PR, T);
&gt; C := Matrix(PR, [[x,y,z,1]]);
&gt; NC := C * NT;
&gt; NCT := Transpose(NC);
&gt; (NC * NBL * NCT)[1][1] eq DiagonalForm(g);
true
</PRE>
The last few statements demonstrate how the polynomial's diagonal form
is obtained from its symmetric bilinear form.
Note also that since the polynomial g is not homogeneous its
  symmetric bilinear form is given on four variables,
  the fourth variable being a homogenizing variable.
<HR>
<PRE></PRE> <A  HREF = "text227.htm">[Next]</A><A  HREF = "text225.htm">[Prev]</A> <A  HREF = "text227.htm">[Right]</A> <A  HREF = "text225.htm">[Left]</A> <A  HREF = "text222.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<br><small>Version: V2.22 of <I>
Thu Jun  9 16:37:49 EST 2016
</I></small>
</body></html>