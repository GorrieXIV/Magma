<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <link rel='stylesheet' href='help.css' type='text/css'>
  <TITLE>Creation Functions</TITLE>
</head>
<body BGCOLOR="#FFFFFF">

 <A  HREF = "text1573.htm">[Next]</A><A  HREF = "text1571.htm">[Prev]</A> <A  HREF = "text1573.htm">[Right]</A> <A  HREF = "text1571.htm">[Left]</A> <A  HREF = "text1570.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<PRE></PRE><H3><A NAME = "17600">Creation Functions</A></H3>




<H5>Subsections</H5>
<UL>
<LI> <A  HREF = "text1572.htm#17601">Ambient Spaces</A>
<LI> <A  HREF = "text1572.htm#17613">Base Extension</A>
<LI> <A  HREF = "text1572.htm#17617">Elements</A>
</UL>
<H4><A NAME = "17601">Ambient Spaces</A></H4>

<P>
<P>
<P>
The functions in this section are used to create spaces of modular forms.
Spaces of half-integral weight can also be created (see the next section).
<P>
For information on Dirichlet characters, see Section <A  HREF = "text179.htm#1432">Dirichlet Characters</A>.


<H5><A NAME = "17602">ModularForms(N) : RngIntElt -&gt; ModFrm</A></H5>
<BLOCKQUOTE>
The space M<sub>2</sub>(&Gamma;<sub>0</sub>(N), Z) of modular forms on &Gamma;<sub>0</sub>(N)
of weight 2.  See the documentation for <TT>ModularForms(N,k)</TT>
below, with k=2.
</BLOCKQUOTE>
<H5><A NAME = "17603">ModularForms(N, k) : RngIntElt, RngIntElt -&gt; ModFrm</A></H5>
<BLOCKQUOTE>
The space M<sub>k</sub>(&Gamma;<sub>0</sub>(N), Z) 
of weight k modular forms on &Gamma;<sub>0</sub>(N) over Z.
</BLOCKQUOTE>
<H5><A NAME = "17604">ModularForms(eps, k) : GrpDrchElt, RngIntElt -&gt; ModFrm</A></H5>
<BLOCKQUOTE>
Given a Dirichlet character <I>eps</I> and an integer k, this
returns a space of modular forms over the integers, of weight k, 
which under base extension becomes equal to the direct sum of the spaces 
M<sub>k</sub>(&Gamma;<sub>1</sub>(N), eps1) of weight k and nebentypus character <I>eps1</I>,
where <I>eps1</I>  runs over all Galois conjugates <I>eps</I>. 
</BLOCKQUOTE>
<H5><A NAME = "17605">ModularForms(chars, k) : [GrpDrchElt], RngIntElt -&gt; ModFrm</A></H5>
<BLOCKQUOTE>
The space of modular forms of weight k over the integers,
formed as the direct sum of spaces <TT>ModularForms(eps,k)</TT>,
summing over all <I>eps</I> in the given sequence <I>chars</I> 
of Dirichlet characters.
</BLOCKQUOTE>
<H5><A NAME = "17606">ModularForms(G, k) : GrpPSL2, RngIntElt -&gt; ModFrm</A></H5>
<H5>ModularForms(G) : GrpPSL2 -&gt; ModFrm</H5>
<BLOCKQUOTE>
The space M<sub>k</sub>(G, Z), where G is a congruence subgroup.  
The groups &Gamma;<sub>0</sub>(N) and &Gamma;<sub>1</sub>(N) are currently supported,
and can be created using the commands <TT>Gamma0(N)</TT> and 
<TT>Gamma1(N)</TT>, respectively.  When not specified, k = 2.
</BLOCKQUOTE>
<H5><A NAME = "17607">CuspForms(x) : Any -&gt; ModFrm</A></H5>
<H5>CuspForms(x, y) : Any, Any -&gt; ModFrm</H5>
<BLOCKQUOTE>
These commands are a shortcut, and return the <TT>CuspidalSubspace</TT>
of the corresponding full space of modular forms.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "17608">Example <TT>ModFrm_Creation-Space (H138E3)</TT></A></H3>
In this example, we illustrate each of the above constructors in turn.
First we create M<sub>2</sub>(&Gamma;<sub>0</sub>(65)).
<P>
<P>
<PRE>
&gt; M := ModularForms(65); M;
Space of modular forms on Gamma_0(65) of weight 2 and dimension 8 over
Integer Ring.
&gt; Dimension(M);
8
&gt; Basis(CuspidalSubspace(M));
[
    q + q^5 + 2*q^6 + q^7 + O(q^8),
    q^2 + 2*q^5 + 3*q^6 + 2*q^7 + O(q^8),
    q^3 + 2*q^5 + 2*q^6 + 2*q^7 + O(q^8),
    q^4 + 2*q^5 + 3*q^6 + 3*q^7 + O(q^8),
    3*q^5 + 5*q^6 + 2*q^7 + O(q^8)
]
</PRE>
Next we create M<sub>4</sub>(&Gamma;<sub>0</sub>(8)).
<P>
<P>
<PRE>
&gt; M := ModularForms(8,4); M;
Space of modular forms on Gamma_0(8) of weight 4 and dimension 5 over 
Integer Ring.
&gt; Dimension(M);
5
&gt; Basis(CuspidalSubspace(M));
[
    q - 4*q^3 - 2*q^5 + 24*q^7 + O(q^8)
]
</PRE>
<P>
Now we create the space M<sub>3</sub>(N, &epsilon;), where &epsilon; is a character
of level 20, conductor 5 and order 4.  
<P>
<P>
<PRE>
&gt; G := DirichletGroup(20,CyclotomicField(EulerPhi(20)));
&gt; chars := Elements(G);
&gt; #chars;
8
&gt; [Conductor(eps) : eps in chars];
[ 1, 4, 5, 20, 5, 20, 5, 20 ]
&gt; exists(eps){eps : eps in chars | Conductor(eps) eq 5 and IsOdd(eps)};
true
&gt; Order(eps);
4
&gt; M := ModularForms(eps, 3); M;
Space of modular forms on Gamma_1(20) with character all conjugates of
[$.2], weight 3, and dimension 18 over Integer Ring.
&gt; Dimension(EisensteinSubspace(M));
12
&gt; Dimension(CuspidalSubspace(M));
6
</PRE>
Next we create the direct sum of the spaces
M<sub>k</sub>(20, &epsilon;) as &epsilon; varies over the four mod 20 
characters of order at most 2, for k=2 and 3.
<P>
<P>
<PRE>
&gt; G := DirichletGroup(20, RationalField());   // (Z/20Z)^* --&gt; Q^*
&gt; chars := Elements(G); #chars;
4
&gt; M := ModularForms(chars,2); M;
Space of modular forms on Gamma_1(20) with characters all
conjugates of [1, $.1, $.2, $.1*$.2], weight 2, and dimension 12
over Integer Ring.
&gt; M := ModularForms(chars,3); M;
Space of modular forms on Gamma_1(20) with characters all
conjugates of [1, $.1, $.2, $.1*$.2], weight 3, and dimension 16
over Integer Ring.
</PRE>
Now we create the spaces M<sub>k</sub>(&Gamma;<sub>1</sub>(20)) for k=2, 3.
<P>
<P>
<PRE>
&gt; ModularForms(Gamma1(20)); 
Space of modular forms on Gamma_1(20) of weight 2 and dimension 22 
over Integer Ring.
&gt; ModularForms(Gamma1(20),3); 
Space of modular forms on Gamma_1(20) of weight 3 and dimension 34 
over Integer Ring.
</PRE>
We can also create the subspace of cuspforms directly:
<P>
<P>
<PRE>
&gt; CuspForms(Gamma1(20)); 
Space of modular forms on Gamma_1(20) of weight 2 and dimension 3
over Integer Ring.
&gt; CuspForms(Gamma1(20),3);
Space of modular forms on Gamma_1(20) of weight 3 and dimension 14 
over Integer Ring.
</PRE>
<HR>
<H5><A NAME = "17609">Half-integral Weight Forms</A></H5>

<P>
<P>
<P>
<P>
Spaces of modular forms of half-integral weight can also be constructed.  
For these spaces, <TT>CuspidalSubspace</TT> and <TT>qExpansionBasis</TT> are
available, as well as basic functionality such as element arithmetic.
More functionality will be added in future releases.
<P>
The algorithm for determining the q-expansion basis involves 
computing those of related integral-weight spaces (of weight either 
one half smaller or one half larger, and appropriate level and character).


<H5><A NAME = "17610">HalfIntegralWeightForms(N, w) : RngIntElt, FldRatElt -&gt; ModFrm</A></H5>
<BLOCKQUOTE>
The space of half-integral weight forms on <TT>Gamma0(N)</TT> and 
weight w. Here N should be a multiple of 4 and w a positive
element of Z + 1/2.
</BLOCKQUOTE>
<H5><A NAME = "17611">HalfIntegralWeightForms(chi, w) : GrpDrchElt, FldRatElt -&gt; ModFrm</A></H5>
<BLOCKQUOTE>
The space of half-integral weight forms on <TT>Gamma1(N)</TT> with 
character <TT>chi</TT> and weight w. The modulus of <TT>chi</TT> 
should be a multiple of 4, and w a positive element of Z + 1/2.
</BLOCKQUOTE>
<H5><A NAME = "17612">HalfIntegralWeightForms(G, w) : GrpPSL2, FldRatElt -&gt; ModFrm</A></H5>
<BLOCKQUOTE>
The space of half-integral weight forms on the congruence subgroup G 
and weight w. Here G must be contained in <TT>Gamma0(4)</TT>, 
and w is a positive element of Z + 1/2.
</BLOCKQUOTE>
<H4><A NAME = "17613">Base Extension</A></H4>

<P>
<P>
<P>
If M is a space of modular forms created using one of the
constructors in Section <A  HREF = "text1572.htm#17601">Ambient Spaces</A>, then
the base ring of M is Z.  Thus we can base
extend M to any ring R.  The examples below illustrate
some simple applications of <TT>BaseExtend</TT>.


<H5><A NAME = "17614">BaseExtend(M, R) : ModFrm, Rng -&gt; ModFrm, Map</A></H5>
<BLOCKQUOTE>
The base extension of the space M of modular forms 
to the ring R and the induced map from M to 
<TT>BaseExtend(M,R)</TT>.  The only requirement on R is that
there is a natural coercion map from the base ring of M 
to R.    For example, when <TT>BaseRing(M)</TT> is the 
integers, any ring R is allowed.
</BLOCKQUOTE>
<H5><A NAME = "17615">BaseExtend(M, phi) : ModFrm, Map -&gt; ModFrm, Map</A></H5>
<BLOCKQUOTE>
The base extension of the space M of modular forms 
to the ring R using the map 
&phi; : <TT>BaseRing(M)</TT> -&gt; R,
and the induced map from M to  <TT>BaseExtend(M,R)</TT>
</BLOCKQUOTE>
<HR>
<H3><A NAME = "17616">Example <TT>ModFrm_BaseExtend (H138E4)</TT></A></H3>
We first illustrate an Eisenstein series 
in M<sub>12</sub>(1) that is congruent to 1 modulo 3.
<P>
<P>
<PRE>
&gt; M&lt;q&gt; := EisensteinSubspace(ModularForms(1,12));
&gt; E12 := M.1; E12 + O(q^4);
691 + 65520*q + 134250480*q^2 + 11606736960*q^3 + O(q^4)
&gt; M3&lt;q3&gt; := BaseExtend(M,GF(3));
&gt; Dimension(M3);
1
&gt; M3.1+O(q3^20);
1 + O(q3^20)
</PRE>
This congruence can be proved by noting that the coefficient of q<sup>n</sup>
in the q-expansion of E<sub>12</sub>/65520, for any n&ge;1, is an
eigenvalue of a Hecke operator, hence an integer, and that 65520 is
divisible by 3.  Because E<sub>12</sub> is defined over Z the command
<TT>"E12Q/65520"</TT> would result in an error, so we first base extend
to Q.
<P>
<P>
<PRE>
&gt; MQ, phi := BaseExtend(M,RationalField());
&gt; E12Q := phi(E12);   
&gt; E12Q/65520;
691/65520 + q + 2049*q^2 + 177148*q^3 + 4196353*q^4 + 48828126*q^5 + 
362976252*q^6 + 1977326744*q^7 + O(q^8)
</PRE>
<P>
<P> 
It is possible to base extend to almost any silly commutative 
ring.
<P>
<P>
<PRE>
&gt; M := ModularForms(11,2);
&gt; R := PolynomialRing(GF(17),3);
&gt; MR&lt;q&gt; := BaseExtend(M,R); MR;
Space of modular forms on Gamma_0(11) of weight 2 and dimension 2 over
Polynomial ring of rank 3 over GF(17)
Lexicographical Order
Variables: $.1, $.2, $.3.
&gt; f := MR.1;  f + O(q^5);
1 + 12*q^2 + 12*q^3 + 12*q^4 + O(q^5)
&gt; f*(R.1+3*R.2) + O(q^4);
$.1 + 3*$.2 + (12*$.1 + 2*$.2)*q^2 + (12*$.1 + 2*$.2)*q^3 + O(q^4)
</PRE>
<HR>
<H4><A NAME = "17617">Elements</A></H4>



<H5><A NAME = "17618">M . i : ModFrm, RngIntElt -&gt; ModFrmElt</A></H5>
<BLOCKQUOTE>
The ith basis vector of the space of modular forms M.
</BLOCKQUOTE>
<H5><A NAME = "17619">M ! f : ModFrm, . -&gt; ModFrmElt</A></H5>
<BLOCKQUOTE>
The coercion of f into the space of modular forms M.   Here f can be a modular form,
a power series with absolute precision, or 
something that can be coerced into <TT>RSpace(M)</TT>.
</BLOCKQUOTE>
<H5><A NAME = "17620">ModularForm(E) : CrvEll -&gt; ModFrm</A></H5>
<BLOCKQUOTE>
The modular form associated to the elliptic curve E over Q.
(See Section <A  HREF = "text1588.htm#17720">Elliptic Curves</A>.)
</BLOCKQUOTE>
<HR>
<H3><A NAME = "17621">Example <TT>ModFrm_CreationElements (H138E5)</TT></A></H3>
<P>
<P>
<PRE>
&gt; M := ModularForms(Gamma0(11),2);
&gt; M.1;
1 + 12*q^2 + 12*q^3 + 12*q^4 + 12*q^5 + 24*q^6 + 24*q^7 + O(q^8)
&gt; M.2;
q - 2*q^2 - q^3 + 2*q^4 + q^5 + 2*q^6 - 2*q^7 + O(q^8)
&gt; R&lt;q&gt; := PowerSeriesRing(Integers());
&gt; f := M!(1 + q + 10*q^2 + O(q^3));
&gt; f;
1 + q + 10*q^2 + 11*q^3 + 14*q^4 + 13*q^5 + 26*q^6 + 22*q^7 + O(q^8)
&gt; Eltseq(f);
[ 1, 1 ]
</PRE>
<TT>Eltseq</TT> gives f as a linear combination of 
<TT>M.1</TT> and <TT>M.2</TT>.
Next we coerce f into M<sub>2</sub>(&Gamma;<sub>0</sub>(22)). 
<P>
<P>
<PRE>
&gt; M22 := ModularForms(Gamma0(22),2);
&gt; g := M22!f; g;
1 + q + 10*q^2 + 11*q^3 + 14*q^4 + 13*q^5 + 26*q^6 + 22*q^7 + O(q^8)
&gt; Eltseq(g);
[ 1, 1, 10, 11, 14 ]
</PRE>
The elliptic curve E defines an element of M<sub>2</sub>(&Gamma;<sub>0</sub>(11)).
<P>
<P>
<PRE>
&gt; E := EllipticCurve([ 0, -1, 1, -10, -20 ]);
&gt; Conductor(E);
11
&gt; f := ModularForm(E);
&gt; f;
q - 2*q^2 - q^3 + 2*q^4 + q^5 + 2*q^6 - 2*q^7 + O(q^8)
</PRE>
A new copy of S<sub>2</sub>(&Gamma;<sub>0</sub>(11)) was created as the space containing f
<P>
<P>
<PRE>
&gt; Sf := Parent(f);
&gt; Mf := AmbientSpace(Parent(f));
&gt; Sf; Mf;
Space of modular forms on Gamma_0(11) of weight 2 and dimension 1 over 
Integer Ring
Space of modular forms on Gamma_0(11) of weight 2 and dimension 2 over 
Integer Ring
&gt; IsIdentical(M, Mf);
false
&gt; M eq Mf;
true
&gt; f in Sf, f in Mf, f in M;
true false false
</PRE>
There is a canonical way to coerce f into M using its q-expansion.
<P>
<P>
<PRE>
&gt; IsCoercible(M, f);
true 
q - 2*q^2 - q^3 + 2*q^4 + q^5 + 2*q^6 - 2*q^7 - 2*q^9 - 2*q^10 + q^11 + O(q^12)
</PRE>
This coercion is applied automatically for some operations.
<P>
<P>
<PRE>
&gt; f + M.1;
1 + q + 10*q^2 + 11*q^3 + 14*q^4 + 13*q^5 + 26*q^6 + 22*q^7 + 36*q^8 + 34*q^9 
     + 46*q^10 + q^11 + O(q^12)
</PRE>
<HR>
<PRE></PRE> <A  HREF = "text1573.htm">[Next]</A><A  HREF = "text1571.htm">[Prev]</A> <A  HREF = "text1573.htm">[Right]</A> <A  HREF = "text1571.htm">[Left]</A> <A  HREF = "text1570.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<br><small>Version: V2.22 of <I>
Thu Jun  9 16:37:49 EST 2016
</I></small>
</body></html>