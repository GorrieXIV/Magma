<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <link rel='stylesheet' href='help.css' type='text/css'>
  <TITLE>Matrices and Modules</TITLE>
</head>
<body BGCOLOR="#FFFFFF">

 <A  HREF = "text555.htm">[Next]</A><A  HREF = "text557.htm">[Prev]</A> <A  HREF = "text555.htm">[Right]</A> <A  HREF = "text557.htm">[Left]</A> <A  HREF = "text556.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<PRE></PRE><H3><A NAME = "5912">Matrices and Modules</A></H3>

<P>
<P>
Since S<sub>p</sub><sup>&nu;</sup> and S<sub>u</sub><sup>&nu;</sup> are Euclidean, we can work with
canonical forms and modules over these rings. We consider S<sub>p</sub><sup>&nu;</sup> first.



<H5>Subsections</H5>
<UL>
<LI> <A  HREF = "text558.htm#5913">Matrices</A>
<LI> <A  HREF = "text558.htm#5928">Modules</A>
</UL>
<H4><A NAME = "5913">Matrices</A></H4>

<P>
<P>
The row-echelon form of a matrix over S<sub>p</sub><sup>&nu;</sup>
has pivot entries which are polynomials of the form
u<sup>d</sup> + &sum;<sub>j=0</sub><sup>d - 1</sup> b<sub>j</sub>u<sup>j</sup>qquad(where)qquad v(b<sub>j</sub>) + &nu; j &gt;&nu; d
for j in the sum, so that the Weierstrass degree is d
and the Gauss valuation is d&nu;.
<P>
The Hermite form additionally assures that the other entries in the columns
with pivots are polynomials of smaller degree, via taking Quotrem.
This can be made unique via suitable choices, and so provides a way
of testing equality of modules.
<P>
The Smith form is computed by creating a matrix of pivots corresponding
to a Hermite on the matrix and then a Hermite on the transpose.
One also demands recursive divisibility of the resulting diagonal terms.
<P>
Over S<sub>u</sub><sup>&nu;</sup> the picture is the same, except that pivot entries
of the echelon form are all <TT>CanonicalElement</TT>s, with similar
changes thereon. E.g., the Hermite form will have elements of smaller
valuation above the pivots.


<H5><A NAME = "5914">SpMatrixSpace (S, r, c) : SpRng, RngIntElt, RngIntElt -&gt; SpMatRng</A></H5>
<H5>SuMatrixSpace (S, r, c) : SuRng, RngIntElt, RngIntElt -&gt; SuMatRng</H5>
<BLOCKQUOTE>
Given an S<sub>p</sub><sup>&nu;</sup> of S<sup>&nu;</sup><sub>u</sub> ring and a (nonnegative)
number of rows and columns, construct the matrix space.
</BLOCKQUOTE>
<H5><A NAME = "5915">IdentityMatrix (S, n) : SpRng, RngIntElt -&gt; SpMat</A></H5>
<H5>IdentityMatrix (S) : SpMatRng -&gt; SpMat</H5>
<H5>ZeroMatrix (S) : SpMatRng -&gt; SpMat</H5>
<H5>ZeroMatrix (S, n) : SpRng, RngIntElt -&gt; SpMat</H5>
<H5>ZeroMatrix (S, r, c) : SpRng, RngIntElt, RngIntElt -&gt; SpMat</H5>
<H5>IdentityMatrix (S, n) : SuRng, RngIntElt -&gt; SuMat</H5>
<H5>IdentityMatrix (S) : SuMatRng -&gt; SuMat</H5>
<H5>ZeroMatrix (S) : SuMatRng -&gt; SuMat</H5>
<H5>ZeroMatrix (S, n) : SuRng, RngIntElt -&gt; SuMat</H5>
<H5>ZeroMatrix (S, r, c) : SuRng, RngIntElt, RngIntElt -&gt; SuMat</H5>
<BLOCKQUOTE>
Different ways of obtaining the zero matrix or identity matrix (if applicable)
of a matrix ring.
</BLOCKQUOTE>
<H5><A NAME = "5916">SpMatrix (A) : SeqEnum -&gt; SpMat</A></H5>
<H5>SpMatrix (r, c, A) : RngIntElt, RngIntElt, SeqEnum -&gt; SpMat</H5>
<H5>SpMatrix (v) : SeqEnum -&gt; SpMat</H5>
<H5>SpMatrix (A) : SeqEnum -&gt; SpMat</H5>
<H5>SuMatrix (r, c, A) : RngIntElt, RngIntElt, SeqEnum -&gt; SuMat</H5>
<H5>SuMatrix (v) : SeqEnum -&gt; SuMat</H5>
<BLOCKQUOTE>
Various ways of obtaining an <TT>SpMat</TT> or <TT>SuMat</TT>.
The first takes a sequence of sequences of <TT>SpElement</TT>s
or <TT>SuElement</TT>s, the second takes a row and column count
and a sequence of <TT>SpElement</TT>s or <TT>SuElement</TT>s,
and the third takes a sequence of <TT>SpVec</TT>s or <TT>SuVec</TT>s.
</BLOCKQUOTE>
<H5><A NAME = "5917">GaussValuations (M) : SpMat -&gt; SeqEnum</A></H5>
<H5>GaussValuations (M) : SuMat -&gt; SeqEnum</H5>
<BLOCKQUOTE>
Returns a sequence of sequences of the Gauss valuations
of the elements of a matrix. Since these can be <TT>ExtendedReals</TT>,
the valuations themselves are put in an array rather than a matrix.
</BLOCKQUOTE>
<H5><A NAME = "5918">WeierstrassDegrees (M) : SpMat -&gt; SeqEnum</A></H5>
<H5>WeierstrassDegrees (M) : SuMat -&gt; SeqEnum</H5>
<BLOCKQUOTE>
Returns a sequence of sequences of the Weierstrass degrees
of the elements of a matrix. Since these can be <TT>ExtendedReals</TT>,
the valuations themselves are put in an array rather than a matrix.
</BLOCKQUOTE>
<H5><A NAME = "5919">LeadingTerms (M) : SpMat -&gt; Mtrx</A></H5>
<H5>LeadingTerms (M) : SuMat -&gt; Mtrx</H5>
<BLOCKQUOTE>
Returns a matrix (defined over the underlying power or Laurent series ring)
which has the leading term of each element.
</BLOCKQUOTE>
<H5><A NAME = "5920">WeierstrassTerms (M) : SpMat -&gt; Mtrx</A></H5>
<H5>WeierstrassTerms (M) : SuMat -&gt; Mtrx</H5>
<BLOCKQUOTE>
Returns a matrix (defined over the underlying power or Laurent series ring)
which has the Weierstrass term of each element.
</BLOCKQUOTE>
<H5><A NAME = "5921">IsWeaklyZero (M) : SpMat -&gt; BoolElt</A></H5>
<H5>IsWeaklyZero (M) : SuMat -&gt; BoolElt</H5>
<BLOCKQUOTE>
Returns whether every element in the matrix is nearly zero.
</BLOCKQUOTE>
<H5><A NAME = "5922">EchelonForm (M) : SpMat -&gt; SpMat, SpMat</A></H5>
<H5>EchelonForm (M) : SuMat -&gt; SuMat, SuMat</H5>

<PRE>    Transform: BoolElt                  Default: <TT>false</TT></PRE>
<BLOCKQUOTE>
Returns the (row) echelon form E, and (if desired) the transform T
such that E=TM.
</BLOCKQUOTE>
<H5><A NAME = "5923">HermiteForm (M) : SpMat -&gt; SpMat, SpMat</A></H5>
<H5>HermiteForm (M) : SuMat -&gt; SuMat, SuMat</H5>

<PRE>    Transform: BoolElt                  Default: <TT>false</TT></PRE>
<BLOCKQUOTE>
Returns the Hermite form H, and (if desired) the transform T
such that H=TM.
</BLOCKQUOTE>
<H5><A NAME = "5924">SmithForm (M) : SpMat -&gt; SpMat, SpMat, SpMat</A></H5>
<H5>SmithForm (M) : SuMat -&gt; SuMat, SuMat, SuMat</H5>
<BLOCKQUOTE>
Returns the Smith form S, and (if desired) the transforms P, Q
such that S=PMQ.
</BLOCKQUOTE>
<H5><A NAME = "5925">Kernel (M) : SpMat -&gt; SpSpc</A></H5>
<H5>Kernel (M) : SuMat -&gt; SuSpc</H5>
<H5>Image (M) : SpMat -&gt; SpSpc</H5>
<H5>Image (M) : SuMat -&gt; SuSpc</H5>
<BLOCKQUOTE>
Return the kernel or image of an S<sub>p</sub><sup>&nu;</sup> or S<sub>u</sub><sup>&nu;</sup> matrix
as a module space. The <TT>Image</TT> also has a <TT>Transform</TT> parameter
that gives the inclusion.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "5926">Example <TT>RngSlope_sp-matrices (H55E3)</TT></A></H3>
Here are some basic examples of operations with matrices over S<sup>&nu;</sup><sub>p</sub>.
<P>
<P>
<P>
<PRE>
&gt; S&lt;u&gt; := SpRing (pAdicField (3, 20), 1/2); // slope 1/2
&gt; M := SpMatrix (2, 3, [ S | u^2/3,u/3^2,0, u^3,3^2*u,3*u ]);
&gt; E, T := EchelonForm (M : Transform); assert E eq T*M;
&gt; LeadingTerms (E);
[(3^-1 + O(3^19))*$.1^2  (3^-2 + O(3^18))*$.1  O($.1^20)]
[O($.1^20)               (3^2 + O(3^18))*$.1   (3 + O(3^21))*$.1]
&gt; WeierstrassTerms (E); // not the same
[(3^-1 + O(3^19))*$.1^2  (3^-2 + O(3^18))*$.1    O($.1^20)]
[O($.1^20)              -(3^-1 + O(3^19))*$.1^2  (3 + O(3^21))*$.1]
</PRE>
<P>
<P>
<P>
<PRE>
&gt; S&lt;u&gt; := SpRing (pAdicField (5, 10), 3/2); // slope 3/2
&gt; M := SpMatrix (3,5,[S|5^3,u,u^2/5,0,0, 0,0,25,u^3/25,3*5, 0,0,0,0,5^2]);
&gt; H, T := HermiteForm (M : Transform); assert H eq T*M;
&gt; WeierstrassTerms(H);
[5^3 + O(5^13)  $.1        O($.1^20)     -(5^-5 + O(5^5))*$.1^5  O($.1^20)]
[O($.1^20)      O($.1^20)  5^2 + O(5^9)  (5^-2 + O(5^8))*$.1^3   O($.1^20)]
[O($.1^20)      O($.1^20)  O($.1^20)     O($.1^20)               5^2 + O(5^12)]
&gt; X, P, Q := SmithForm (M : Transform); assert P*M*Q eq X;
&gt; WeierstrassTerms(X); // note that 5^3 divides 5^2 in this ring!
[5^3 + O(5^13)  O($.1^20)     O($.1^20)      O($.1^20)  O($.1^20)]
[O($.1^20)      5^2 + O(5^9)  O($.1^20)      O($.1^20)  O($.1^20)]
[O($.1^20)      O($.1^20)     5^2 + O(5^12)  O($.1^20)  O($.1^20)]
</PRE>
<HR>
<H3><A NAME = "5927">Example <TT>RngSlope_su-matrices (H55E4)</TT></A></H3>
Here are similar examples over S<sup>&nu;</sup><sub>u</sub>.
<P>
<P>
<P>
<PRE>
&gt; S&lt;u&gt; := SuRing (pAdicField (5, 15), 2/3); // slope 2/3
&gt; M := SuMatrix (2, 3, [ S | 5^2/u,0,u^2, u,5*u^2,5^3/u^2 ]);
&gt; E, T := EchelonForm (M : Transform); assert E eq T*M;
&gt; LeadingTerms (E);
[$.1        (5 + O(5^16))*$.1^2   (5^3 + O(5^18))*$.1^-2]
[O($.1^20)  5^3 + O(5^15)         (5^5 + O(5^20))*$.1^-4]
&gt; WeierstrassTerms (E); // not the same, in lower right
[$.1        (5 + O(5^16))*$.1^2  (5^3 + O(5^18))*$.1^-2]
[O($.1^20)  5^3 + O(5^15)        -$.1^2]
</PRE>
<P>
<P>
<P>
<PRE>
&gt; A := [S | 25/u,u,u^2/5,0,0, 0,0,25,125/u^2,50*u, 0,0,0,0,5*u^2];
&gt; M := SuMatrix (3, 5, A);
&gt; H, T := HermiteForm (M : Transform); assert H eq T*M;
&gt; W := WeierstrassTerms(H); W;
[$.1^2 (5^-2 + O(5^13))*$.1^4 (5^-3 + O(5^12))*$.1^5 O($.1^20) O($.1^20)]
[O($.1^20) O($.1^20) 5^2 + O(5^17) (5^3 + O(5^18))*$.1^-2 O($.1^20)]
[O($.1^20) O($.1^20) O($.1^20) O($.1^20) (5 + O(5^16))*$.1^2]
&gt; assert CanonicalElement (S, 4/3) eq S!W[1,1];
&gt; assert CanonicalElement (S, 2) eq S!W[2,3];
&gt; assert CanonicalElement (S, 7/3) eq S!W[3,5];
&gt; X, P, Q := SmithForm (M : Transform); assert X eq P*M*Q;
&gt; WeierstrassTerms(X);
[(5^-1 + O(5^14))*$.1^2 O($.1^20) O($.1^20) O($.1^20) O($.1^20)]
[O($.1^20) (5 + O(5^16))*$.1 O($.1^20) O($.1^20) O($.1^20)]
[O($.1^20) O($.1^20) (5 + O(5^16))*$.1^2 O($.1^20) O($.1^20)]
</PRE>
<HR>
<H4><A NAME = "5928">Modules</A></H4>

<P>
<P>
These are implemented as "vectors" over S<sup>&nu;</sup><sub>p</sub> or S<sup>&nu;</sup><sub>u</sub>.


<H5><A NAME = "5929">SpSpace (R, n) : SpRng, RngIntElt -&gt; SpSpc</A></H5>
<H5>SuSpace (R, n) : SuRng, RngIntElt -&gt; SuSpc</H5>
<BLOCKQUOTE>
Given an S<sup>&nu;</sup><sub>p</sub> or S<sup>&nu;</sup><sub>u</sub> ring and a nonnegative integer,
construct the module of that degree.
</BLOCKQUOTE>
<H5><A NAME = "5930">SpSpace (M) : SpMat -&gt; SpSpc</A></H5>
<H5>SuSpace (M) : SuMat -&gt; SuSpc</H5>
<BLOCKQUOTE>
Given an S<sup>&nu;</sup><sub>p</sub> or S<sup>&nu;</sup><sub>u</sub> matrix, construct the associated module space.
This always computes the Hermite form to use as the basis.
</BLOCKQUOTE>
<H5><A NAME = "5931">SpSpace (v) : SeqEnum -&gt; SpSpc</A></H5>
<H5>SuSpace (v) : SeqEnum -&gt; SuSpc</H5>
<BLOCKQUOTE>
Given a sequence of <TT>SpVec</TT>s or <TT>SuVec</TT>s,
construct the module space generated by them.
Again this always computes the Hermite form for the basis.
</BLOCKQUOTE>
<H5><A NAME = "5932">Ambient (S) : SpSpc -&gt; SpSpc</A></H5>
<H5>Ambient (S) : SuSpc -&gt; SuSpc</H5>
<BLOCKQUOTE>
Given a module space, return the (full) ambient space of dimension
equal to the degree.
</BLOCKQUOTE>
<H5><A NAME = "5933">Parent (v) : SpVec -&gt; SpSpc</A></H5>
<H5>Parent (v) : SuVec -&gt; SuSpc</H5>
<BLOCKQUOTE>
The Parent of an <TT>SpVec</TT> or <TT>SuVec</TT> is always its <TT>Ambient</TT> space.
</BLOCKQUOTE>
<H5><A NAME = "5934">ZeroVector (S) : SpSpc -&gt; SpVec</A></H5>
<H5>ZeroVector (S) : SuSpc -&gt; SuVec</H5>
<BLOCKQUOTE>
Return the zero vector of a module space.
</BLOCKQUOTE>
<H5><A NAME = "5935">SpVector (e) : SeqEnum -&gt; SpVec</A></H5>
<H5>SuVector (e) : SeqEnum -&gt; SuVec</H5>
<BLOCKQUOTE>
Given a sequence of S<sup>&nu;</sup><sub>p</sub> or S<sup>&nu;</sup><sub>u</sub> elements,
construct the vector of them.
</BLOCKQUOTE>
<H5><A NAME = "5936">Basis (S) : SpSpc -&gt; SeqEnum</A></H5>
<H5>Basis (S) : SuSpc -&gt; SeqEnum</H5>
<BLOCKQUOTE>
Given a module space, return a basis as a sequence of vectors.
</BLOCKQUOTE>
<H5><A NAME = "5937">BasisMatrix (S) : SpSpc -&gt; SpMat</A></H5>
<H5>BasisMatrix (S) : SuSpc -&gt; SuMat</H5>
<BLOCKQUOTE>
Given a module space, return a basis as a matrix.
</BLOCKQUOTE>
<H5><A NAME = "5938">Dimension (S) : SpSpc -&gt; RngIntElt</A></H5>
<H5>Dimension (S) : SuSpc -&gt; RngIntElt</H5>
<H5>Degree (S) : SpSpc -&gt; RngIntElt</H5>
<H5>Degree (S) : SuSpc -&gt; RngIntElt</H5>
<BLOCKQUOTE>
The dimension and degree of a module space.
</BLOCKQUOTE>
<H5><A NAME = "5939">LeadingTerms (v) : SpVec -&gt; ModTupRngElt</A></H5>
<H5>LeadingTerms (v) : SuVec -&gt; ModTupRngElt</H5>
<BLOCKQUOTE>
The leading term of each element in an <TT>SpVec</TT> or <TT>SuVec</TT>.
</BLOCKQUOTE>
<H5><A NAME = "5940">WeierstrassTerms (v) : SpVec -&gt; ModTupRngElt</A></H5>
<H5>WeierstrassTerms (v) : SuVec -&gt; ModTupRngElt</H5>
<BLOCKQUOTE>
The Weierstrass term of each element in an <TT>SpVec</TT> or <TT>SuVec</TT>.
</BLOCKQUOTE>
<H5><A NAME = "5941">GaussValuations (v) : SpVec -&gt; SeqEnum</A></H5>
<H5>GaussValuations (v) : SuVec -&gt; SeqEnum</H5>
<BLOCKQUOTE>
Returns a sequence of sequences of the Gauss valuations
of the elements of a matrix. Since these can be <TT>ExtendedReals</TT>,
the valuations themselves are put in an array rather than a vector.
</BLOCKQUOTE>
<H5><A NAME = "5942">WeierstrassDegrees (v) : SpVec -&gt; SeqEnum</A></H5>
<H5>WeierstrassDegrees (v) : SuVec -&gt; SeqEnum</H5>
<BLOCKQUOTE>
Returns a sequence of sequences of the Weierstrass degrees
of the elements of a vector. Since these can be <TT>ExtendedReals</TT>,
the valuations themselves are put in an array rather than a vector.
</BLOCKQUOTE>
<H5><A NAME = "5943">IsWeaklyZero (v) : SpVec -&gt; BoolElt</A></H5>
<H5>IsWeaklyZero (v) : SuVec -&gt; BoolElt</H5>
<BLOCKQUOTE>
Return whether an <TT>SpVec</TT> or <TT>SuVec</TT> is weakly zero.
</BLOCKQUOTE>
<H5><A NAME = "5944">M1 + M2 : SpSpc, SpSpc -&gt; SpSpc</A></H5>
<H5>M1 + M2 : SuSpc, SuSpc -&gt; SuSpc</H5>
<H5>DirectSum (M1, M2) : SpSpc, SpSpc -&gt; SpSpc</H5>
<H5>DirectSum (M1, M2) : SuSpc, SuSpc -&gt; SuSpc</H5>
<H5>M1 meet M2 : SpSpc, SpSpc -&gt; SpSpc</H5>
<H5>M1 meet M2 : SuSpc, SuSpc -&gt; SuSpc</H5>
<BLOCKQUOTE>
The sum and intersection of two module spaces.
The use of <TT>DirectSum</TT> requires the summands to be disjoint.
</BLOCKQUOTE>
<H5><A NAME = "5945">S * M : SpSpc, SpMat -&gt; SpSpc</A></H5>
<H5>S * M : SuSpc, SuMat -&gt; SuSpc</H5>
<BLOCKQUOTE>
The transformation of a module space by a matrix.
The basis of the reuslting space will be given in Hermite form.
</BLOCKQUOTE>
<H5><A NAME = "5946">IsConsistent (M, v) : SpMat, SpVec -&gt; BoolElt, SpVec</A></H5>
<H5>IsConsistent (M, v) : SuMat, SuVec -&gt; BoolElt, SuVec</H5>
<H5>IsConsistent (M, e) : SpMat, SeqEnum -&gt; BoolElt, SeqEnum</H5>
<H5>IsConsistent (M, e) : SuMat, SeqEnum -&gt; BoolElt, SeqEnum</H5>
<H5>IsConsistent (M, W) : SpMat, SpMat -&gt; BoolElt, SpMat, SpMat</H5>
<H5>IsConsistent (M, W) : SuMat, SpMat -&gt; BoolElt, SuMat, SuMat</H5>
<H5>v in M : SpVec, SpMat -&gt; BoolElt, SpVec</H5>
<H5>v in M : SuVec, SpMat -&gt; BoolElt, SuVec</H5>
<BLOCKQUOTE>
Determines whether xM=v is solvable, and it so returns such an x.
The second version takes an a sequence of vectors, and the third takes
a matrix (and also includes the kernel as a third return value).
</BLOCKQUOTE>
<H5><A NAME = "5947">IsSubspace (A, B) : SpSpc, SpSpc -&gt; BoolElt, SpMat</A></H5>
<H5>IsSubspace (A, B) : SuSpc, SuSpc -&gt; BoolElt, SuMat</H5>
<BLOCKQUOTE>
Determines whether A is a subspace of B, and if so gives an inclusion map.
Equality can be determined via symmetric inclusion, or alternatively via
the Hermite form (which should be unique) of the basis matrix.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "5948">Example <TT>RngSlope_sp-mod-basics (H55E5)</TT></A></H3>
<P>
Here are some basic examples of usage for modules.
<P>
<P>
<P>
<PRE>
&gt; S&lt;u&gt; := SpRing (pAdicField (5, 25), 1/2); // slope 1/2
&gt; A := SpSpace (S, 3);
&gt; A.1;
[ 1 + O(5^25) + O(u^20), O(u^20), O(u^20) ]
&gt; M := SpMatrix (2, 3, [ S | 5*u,5,u^2, 1/5,u^3,u ]);
&gt; B := SpSpace (M); assert Dimension(B) eq 2;
&gt; LeadingTerms(BasisMatrix(B));
[5^-1 + O(5^24) O($.1^20)    $.1]
[O($.1^20)      -5 + O(5^26) (24 + O(5^25))*$.1^2]
&gt; B eq SpSpace (VerticalJoin (M, M)); // also gives inclusion
true
&gt; A meet B eq B;
true
&gt; Image(M) eq B; // by definition
true
&gt; IsConsistent (M, A.1);
false
&gt; IsConsistent (M, B.1);
true
&gt; SpSpace([B.1]) + SpSpace([B.2]) eq B;
true
&gt; SpSpace([B.1]) + SpSpace([u * B.2]) eq B; // u does not invert
false
&gt; SpSpace([1/5 * B.1]) + SpSpace([5 * B.2]) eq B;
true
&gt; sub&lt;B|[B.1+B.2]&gt; + sub&lt;B|[B.2-B.1]&gt; eq sub&lt;B|[B.1,B.2]&gt;;
true
</PRE>
<HR>
<H3><A NAME = "5949">Example <TT>RngSlope_sp-kernel (H55E6)</TT></A></H3>
<P>
Here is an example over S<sup>&nu;</sup><sub>p</sub> with a nontrivial kernel.
<P>
<P>
<P>
<PRE>
&gt; S&lt;u&gt; := SpRing (pAdicField (7, 30), 1); // slope 1
&gt; M := SpMatrix(3,5,[S|1,0,u,u^2,u,  u^2/7,0,1,0,0, 0,0,1,0,u^4/7^2]);
&gt; ROWS := Rows(M);
&gt; V := u * ROWS[1] + u^2/7 * ROWS[3]; // create a kernel
&gt; MAT := SpMatrix(ROWS cat [Universe(ROWS)|V]); // 4 x 5
&gt; Dimension (SpSpace (MAT)); // 3
3
&gt; K := Kernel (MAT); K;
SpSpace of degree 4, dimension 1 over Sp-slope ring of slope 1 given
 by Power series ring in $.1 over pAdicField(7, 30)
Basis given by:
[ (-1 + O(7^30))*u + O(u^21), O(u^21),
  (-7^-1 + O(7^29))*u^2 + O(u^21), 1 + O(7^30) + O(u^21) ]
&gt; KK := Kernel(BasisMatrix(K)); KK;
SpSpace of degree 1, dimension 0 over Sp-slope ring of slope 1 given
 by Power series ring in $.1 over pAdicField(7, 30)
&gt; assert ZeroVector(Ambient(KK)) in KK;
</PRE>
<HR>
<H3><A NAME = "5950">Example <TT>RngSlope_su-module (H55E7)</TT></A></H3>
<P>
Here is an example over S<sup>&nu;</sup><sub>u</sub>.
<P>
<P>
<P>
<PRE>
&gt; S&lt;u&gt; := SuRing (pAdicField (7, 20), 5/4); // slope 5/4
&gt; A := SuSpace (S, 3);
&gt; B := SuSpace ([A.1, A.3]); // dimension 2
&gt; SuSpace([B.1]) + SuSpace([7^5/u^4 * B.2]) eq B; // slope 5/4
true
&gt; Basis(sub&lt;A|[A.1+A.3]&gt;)[1] in B;
true
&gt; M := SuMatrix (2, 3, [S | 7^2/u,7,5*7*u, 7,u^3,u^2 ]);
&gt; V := SuSpace(M);
&gt; I := V meet B; assert Dimension(I) eq 1;
&gt; v := Basis(I)[1]; assert v in I;
&gt; WeierstrassTerms(v);
(7 + O(7^21) O($.1^20) $.1^2)
&gt; WeierstrassDegrees(v);
[ 0, -Infinity, 2 ]
&gt; I + B eq B; assert v in B;
true
&gt; J := VerticalJoin (M, M);
&gt; SetSeed(1); // ensure example works
&gt; JJ := (SuMatrixSpace(S,4,4)!RandomSLnZ(4,8,16)) * J;
&gt; assert Dimension(Kernel(JJ)) eq 2;
&gt; assert Dimension(Image(JJ)) eq 2;
</PRE>
<P>
Note that the final commands, with the dimension of the kernel/image of the
given space, can sometimes fail for various reasons involving precision loss.
<PRE></PRE> <A  HREF = "text555.htm">[Next]</A><A  HREF = "text557.htm">[Prev]</A> <A  HREF = "text555.htm">[Right]</A> <A  HREF = "text557.htm">[Left]</A> <A  HREF = "text556.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<br><small>Version: V2.22 of <I>
Thu Jun  9 16:37:49 EST 2016
</I></small>
</body></html>