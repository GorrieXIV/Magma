<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <link rel='stylesheet' href='help.css' type='text/css'>
  <TITLE>Creation and Basic Functions</TITLE>
</head>
<body BGCOLOR="#FFFFFF">

 <A  HREF = "text1638.htm">[Next]</A><A  HREF = "text1636.htm">[Prev]</A> <A  HREF = "text1638.htm">[Right]</A> <A  HREF = "text1636.htm">[Left]</A> <A  HREF = "text1635.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<PRE></PRE><H3><A NAME = "18024">Creation and Basic Functions</A></H3>

<P>
<P>
<P>
The functions described below create modular abelian 
varieties, combine them together in various ways, and obtain
simple information about them. 
<P>
Modular abelian varieties are much less restricted than spaces of
modular symbols as one can take arbitrary finite direct sums.



<H5>Subsections</H5>
<UL>
<LI> <A  HREF = "text1637.htm#18025">Creating the Modular Jacobian  J<sub>0</sub>(N)</A>
<LI> <A  HREF = "text1637.htm#18028">Creating the Modular Jacobians J<sub>1</sub>(N) and J<sub>H</sub>(N)</A>
<LI> <A  HREF = "text1637.htm#18034">Abelian Varieties Attached to  Modular Forms</A>
<LI> <A  HREF = "text1637.htm#18043">Abelian Varieties Attached to  Modular Symbols</A>
<LI> <A  HREF = "text1637.htm#18048">Creation of Abelian Subvarieties</A>
<LI> <A  HREF = "text1637.htm#18054">Creation Using a Label</A>
<LI> <A  HREF = "text1637.htm#18057">Invariants</A>
<LI> <A  HREF = "text1637.htm#18071">Conductor</A>
<LI> <A  HREF = "text1637.htm#18074">Number of Points</A>
<LI> <A  HREF = "text1637.htm#18078">Inner Twists and Complex Multiplication</A>
<LI> <A  HREF = "text1637.htm#18083">Predicates</A>
<LI> <A  HREF = "text1637.htm#18103">Equality and Inclusion Testing</A>
<LI> <A  HREF = "text1637.htm#18108">Modular Embedding and Parameterization</A>
<LI> <A  HREF = "text1637.htm#18114">Coercion</A>
<LI> <A  HREF = "text1637.htm#18118">Modular Symbols to Homology</A>
<LI> <A  HREF = "text1637.htm#18123">Embeddings</A>
<LI> <A  HREF = "text1637.htm#18127">Base Change</A>
<LI> <A  HREF = "text1637.htm#18132">Additional Examples</A>
</UL>
<H4><A NAME = "18025">Creating the Modular Jacobian  J<sub>0</sub>(N)</A></H4>

<P>
<P>
<P>
The <TT>JZero</TT> command will create the Jacobian J<sub>0</sub>(N) of the
modular curve X<sub>0</sub>(N) (which parameterizes
  isomorphism classes of pairs of elliptic curves and cyclic subgroups
    of order N).  
Higher weight motivic analogues of this Jacobian can be created. 
Computations can be carried out
in the +1 or -1 quotient of homology for efficiency,
though certain results will be off by factors of 2.


<H5><A NAME = "18026">JZero(N : parameters) : RngIntElt -&gt;  ModAbVar</A></H5>
<H5>JZero(N, k : parameters) : RngIntElt, RngIntElt -&gt;  ModAbVar</H5>

<PRE>    Sign: RngIntElt                     Default: 0</PRE>
<BLOCKQUOTE>
Create the modular abelian variety J<sub>0</sub>(N) of level N and weight 2 or 
weight k&ge;2, i.e., the Jacobian of
the modular curve X<sub>0</sub>(N).  The parameter <TT>Sign</TT> determines
whether computations will be carried out in the +1 or -1 quotient of 
homology.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "18027">Example <TT>ModAbVar_Modabvar-Creating_the_Modular_Jacobian_$J_0(N)$ (H142E3)</TT></A></H3>
<P>
<P>
<PRE>

&gt; JZero(23);
Modular abelian variety JZero(23) of dimension 2 and level 23 over Q
&gt; JZero(23 : Sign := +1);
Modular abelian variety JZero(23) of dimension 2 and level 23 over Q
with sign 1
&gt; JZero(23,4);
Modular motive JZero(23,4) of dimension 5 and level 23 over Q
&gt; JZero(23,4 : Sign := -1);
Modular motive JZero(23,4) of dimension 5 and level 23 over Q with 
sign -1
&gt; JZero(389,2 : Sign := +1);
Modular abelian variety JZero(389) of dimension 32 and level 389 
over Q with sign 1
</PRE>
<HR>
<H4><A NAME = "18028">Creating the Modular Jacobians J<sub>1</sub>(N) and J<sub>H</sub>(N)</A></H4>

<P>
<P>
<P>
<P>
<P>
The <TT>JOne</TT> command creates the Jacobian of the modular curve
X<sub>1</sub>(N) (which parameterizes
  isomorphism classes of pairs of elliptic curves and cyclic subgroups
    of order N).  The command <TT>Js</TT> creates an abelian
variety isogenous to J<sub>1</sub>(N); more precisely it is the product of
abelian varieties J<sub>eps</sub>(N), where J<sub>eps</sub>(N) is the abelian
variety attached to all modular forms whose character is a Galois
conjugate of eps.  Creating J<sub>s</sub>(N) is much faster than creating
J<sub>1</sub>(N), since less time is spent finding the integral structure on
homology.
<P>
The  <TT>JH</TT> command  creates the  Jacobian  J<sub>H</sub>(N) of  the  curve
X<sub>H</sub>(N), which is the quotient of X<sub>1</sub>(N) by the subgroup H of the
integers modulo N.


<H5><A NAME = "18029">JOne(N : parameters) : RngIntElt -&gt;  ModAbVar</A></H5>
<H5>JOne(N, k : parameters) : RngIntElt, RngIntElt -&gt;  ModAbVar</H5>

<PRE>    Sign: RngIntElt                     Default: 0</PRE>
<BLOCKQUOTE>
Create the modular abelian variety J<sub>1</sub>(N) of level N and 
weight k, if given, 
or 2, i.e., the Jacobian of 
the modular curve X<sub>1</sub>(N). Note that creating and finding the integral 
structure on J<sub>s</sub>(N), which is isogenous to J<sub>1</sub>(N), is much faster. 
Computing with J<sub>1</sub>(N) may be expensive.
</BLOCKQUOTE>
<H5><A NAME = "18030">Js(N : parameters) : RngIntElt -&gt;  ModAbVar</A></H5>
<H5>Js(N, k : parameters) : RngIntElt, RngIntElt -&gt;  ModAbVar</H5>

<PRE>    Sign: RngIntElt                     Default: 0</PRE>
<BLOCKQUOTE>
A modular abelian variety that is Q-isogenous to the weight k (or 2) 
version of J<sub>1</sub>(N). More precisely, the direct sum of the modular 
abelian varieties attached to modular symbols spaces with Nebentypus.  
</BLOCKQUOTE>
<H5><A NAME = "18031">JH(N, d : parameters) : RngIntElt, RngIntElt -&gt;  ModAbVar</A></H5>
<H5>JH(N, k, d : parameters) : RngIntElt, RngIntElt, RngIntElt -&gt;  ModAbVar</H5>

<PRE>    Sign: RngIntElt                     Default: 0</PRE>
<BLOCKQUOTE>
Suppose H is some (cyclic) subgroup of G=(Z /NZ )<sup> * </sup> such that G/H has 
order d. Create the modular abelian variety J<sub>H</sub>(N) of level N
and weight k (or 2 if k not given), where 
J<sub>H</sub>(N) is 
<I>isogenous</I> to the Jacobian of the modular curve X<sub>H</sub>(N) associated to the 
subgroup of SL <sub>2</sub>(Z ) of matrices [a, b;c, d] with c divisible by N 
and a in H modulo N. It is the product of modular symbols varieties 
J(&epsilon; ) for all Dirichlet characters &epsilon;  that are trivial on H. 
<P>
The parameter <TT>Sign</TT> determines
whether computations will be carried out in the +1 or -1 quotient of 
homology.
</BLOCKQUOTE>
<H5><A NAME = "18032">JH(N, gens : parameters) : RngIntElt, [RngIntElt] -&gt;  ModAbVar</A></H5>
<H5>JH(N, k, gens : parameters) : RngIntElt, RngIntElt, [RngIntElt] -&gt;  ModAbVar</H5>

<PRE>    Sign: RngIntElt                     Default: 0</PRE>
<BLOCKQUOTE>
Let H be the subgroup of (Z /NZ )<sup> * </sup> generated by the sequence of integers,
gens. Create 
the modular abelian variety J<sub>H</sub>(N) of level N and weight k 
(or 2 if k not given), 
where J<sub>H</sub>(N) is isogenous to the Jacobian of 
the modular curve X<sub>H</sub>(N) associated to the subgroup of SL <sub>2</sub>(Z ) of 
matrices [a, b;c, d] with c divisible by N and a in H modulo N. It is 
the product of modular symbols variety J(&epsilon; ) for all Dirichlet 
characters &epsilon;  that are trivial on H.  
<P>
The parameter <TT>Sign</TT> determines
whether computations will be carried out in the +1 or -1 quotient of 
homology.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "18033">Example <TT>ModAbVar_Modabvar-Creating_the_Modular_Jacobians_$J_1(N)$_and_$J_H(N)$ (H142E4)</TT></A></H3>
<P>
<P>
<PRE>


&gt; JOne(13);
Modular abelian variety JOne(13) of dimension 2 and level 13 over Q
&gt; JOne(13,4);
Modular motive JOne(13,4) of dimension 15 and level 13 over Q
&gt; JOne(13,4 : Sign := 1);
Modular motive JOne(13,4) of dimension 15 and level 13 over Q
&gt; JH(13,6);
Modular abelian variety J_H(13) of dimension 2 and level 13 over Q
&gt; JH(13,3);
Modular abelian variety J_H(13) of dimension 0 and level 13 over Q
&gt; JH(13,[-1]);
Modular abelian variety J_H(13) of dimension 2 and level 13 over Q
&gt; JOne(17);
Modular abelian variety JOne(17) of dimension 5 and level 17 over Q
&gt; Js(17);
Modular abelian variety Js(17) of dimension 5 and level 17 over Q
&gt; IsIsogenous(JOne(17),Js(17));
true
&gt; Degree(NaturalMap(JOne(17),Js(17)));
16
&gt; JH(17,2);
Modular abelian variety J_H(17) of dimension 1 and level 17 over Q
&gt; JH(17,4);
Modular abelian variety J_H(17) of dimension 1 and level 17 over Q
&gt; JH(17,8);
Modular abelian variety J_H(17) of dimension 5 and level 17 over Q


</PRE>
<HR>
<H4><A NAME = "18034">Abelian Varieties Attached to  Modular Forms</A></H4>

<P>
<P>
<P>
<P>
<P>
The following commands create abelian varieties attached to spaces of modular
forms, sequences of spaces of forms, newforms, and characters.     If an input space
of modular forms is not cuspidal, Magma automatically replaces it with its
cuspidal subspace.


<H5><A NAME = "18035">ModularAbelianVariety(M : parameters) : ModFrm -&gt;  ModAbVar</A></H5>

<PRE>    Sign: RngIntElt                     Default: 0</PRE>
<BLOCKQUOTE>
The abelian variety attached to the modular forms space M.  
</BLOCKQUOTE>
<H5><A NAME = "18036">ModularAbelianVariety(X : parameters) : [ModFrm] -&gt;  ModAbVar</A></H5>

<PRE>    Sign: RngIntElt                     Default: 0</PRE>
<BLOCKQUOTE>
The abelian variety attached to the sequence X of modular forms 
spaces. This is the direct sum of the spaces attached to each element of the 
sequence.  
</BLOCKQUOTE>
<H5><A NAME = "18037">ModularAbelianVariety(eps : parameters) : GrpDrchElt -&gt;  ModAbVar</A></H5>
<H5>ModularAbelianVariety(eps, k : parameters) : GrpDrchElt, RngIntElt -&gt;   ModAbVar</H5>

<PRE>    Sign: RngIntElt                     Default: 0</PRE>
<BLOCKQUOTE>
The abelian variety associated to the dirichlet character &epsilon; . This corresponds to 
the space of modular forms of weight k and character any Galois 
conjugate of &epsilon; . We include all Galois conjugates in order to obtain 
an abelian variety that is defined over Q .  
</BLOCKQUOTE>
<H5><A NAME = "18038">ModularAbelianVariety(f) : ModFrmElt -&gt;  ModAbVar</A></H5>
<BLOCKQUOTE>
The abelian variety attached to the newform f.  
</BLOCKQUOTE>
<H5><A NAME = "18039">Newform(A) : ModAbVar -&gt;  ModFrmElt</A></H5>
<BLOCKQUOTE>
A newform f such that the modular abelian variety A is isogenous to the newform abelian 
variety A<sub>f</sub>. An error occurs if A is not attached to a newform.  
</BLOCKQUOTE>
<HR>
<H3><A NAME = "18040">Example <TT>ModAbVar_Modabvar-Abelian_Varieties_Attached_to_Modular_Forms (H142E5)</TT></A></H3>
<P>
We first create the modular abelian variety attached to the spaces
S<sub>2</sub>(&Gamma;<sub>0</sub>(11)) and S<sub>2</sub>(&Gamma;<sub>1</sub>(13)).  This is the direct
sum of J<sub>0</sub>(11) with J<sub>1</sub>(13).
<P>
<P>
<PRE>
&gt; X := [ModularForms(11,2), ModularForms(Gamma1(13),2)];
&gt; A := ModularAbelianVariety(X); A;
Modular abelian variety of dimension 3 and level 11*13 over Q
&gt; IsIsomorphic(A, JZero(11)*JOne(13));
true Homomorphism N(1) from modular abelian variety of dimension 
3 to JZero(11) x JOne(13) (not printing 6x6 matrix)
</PRE>
Next we create the modular abelian variety A attached to
S<sub>2</sub>(&Gamma;<sub>1</sub>(17)) along with J<sub>1</sub>(17) and J<sub>s</sub>(17).
We then note that A is isomorphic to J<sub>1</sub>(17), but there
is no reason that A should be isomorphic to J<sub>s</sub>(17) (they
are probably only isogenous).   This example illustrates
the fact that the abelian variety computed by Magma attached
to S<sub>2</sub>(&Gamma;<sub>1</sub>(17)) is J<sub>1</sub>(17) rather than J<sub>s</sub>(17).
(Recall that J<sub>s</sub>(N) is a product of copies of abelian
varieties corresponding to conjugacy classes of characters.)
<P>
<P>
<PRE>
&gt; A := ModularAbelianVariety(ModularForms(Gamma1(17),2)); A;
Modular abelian variety of dimension 5 and level 17 over Q
&gt; B := JOne(17); B;
Modular abelian variety JOne(17) of dimension 5 and level 17 over Q
&gt; C := Js(17); C;
Modular abelian variety Js(17) of dimension 5 and level 17 over Q
&gt; IsIsomorphic(A,B);
true Homomorphism from modular abelian variety of dimension 5 to 
JOne(17) (not printing 10x10 matrix)
&gt; Degree(NaturalMap(A,C));
16
</PRE>
<HR>
<H3><A NAME = "18041">Example <TT>ModAbVar_Modabvar-Abelian_Varieties_Attached_to_Modular_Forms3 (H142E6)</TT></A></H3>
If eps is a Dirichlet character and k&ge;2 is an integer,
let  S be the space of modular forms with weight k and
character a Galois conjugate of eps.  The command
<TT>ModularAbelianVariety(eps,k)</TT> computes the modular abelian
variety attached to S.
<P>
<P>
<PRE>
&gt; G&lt;eps&gt; := DirichletGroup(13,CyclotomicField(12));
&gt; Order(eps^2);
6
&gt; ModularAbelianVariety(eps^2);
Modular abelian variety of dimension 2 and level 13 over Q
&gt; ModularAbelianVariety(eps,3);
Modular motive of dimension 4 and level 13 over Q
</PRE>
Next we compute the modular abelian variety attached
to a newform in S<sub>2</sub>(&Gamma;<sub>1</sub>(25)).
<P>
<P>
<PRE>
&gt; S := CuspForms(Gamma1(25),2);
&gt; N := Newforms(S);
&gt; #N;
2
&gt; f := N[1][1];
&gt; PowerSeries(f,4);
q + a*q^2 + 1/1355*(941*a^7 + 4820*a^6 + 11150*a^5 + 11522*a^4 + 
    3582*a^3 + 10041*a^2 + 24432*a - 5718)*q^3 + O(q^4)
&gt; A_f := ModularAbelianVariety(f);
&gt; A_f;
Modular abelian variety Af of dimension 8 and level 5^2 over Q
</PRE>
The abelian variety A<sub>f</sub> also determines the newform:
<P>
<P>
<PRE>
&gt; PowerSeries(Newform(A_f),4);
q + a*q^2 + 1/1355*(941*a^7 + 4820*a^6 + 11150*a^5 + 11522*a^4 + 
    3582*a^3 + 10041*a^2 + 24432*a - 5718)*q^3 + O(q^4)
</PRE>
<HR>
<H3><A NAME = "18042">Example <TT>ModAbVar_Modabvar-Abelian_Varieties_Attached_to_Modular_Forms5 (H142E7)</TT></A></H3>
The <TT>Newform</TT> command works even if A wasn't explicitly created using a newform.
<P>
<P>
<PRE>
&gt; A := Decomposition(JZero(37))[1];
&gt; Newform(A);
q - 2*q^2 - 3*q^3 + 2*q^4 - 2*q^5 + 6*q^6 - q^7 + O(q^8)
</PRE>
<HR>
<H4><A NAME = "18043">Abelian Varieties Attached to  Modular Symbols</A></H4>

<P>
<P>
<P>
<P>
<P>
The commands below associate modular abelian varieties to
spaces of modular symbols and to sequences of spaces of modular symbols.
Conversely, they associate spaces of modular symbols to modular
abelian varieties.   If an input space of modular symbols is not
cuspidal, it is replaced by its cuspidal subspace.


<H5><A NAME = "18044">ModularAbelianVariety(M) : ModSym -&gt;  ModAbVar</A></H5>
<BLOCKQUOTE>
The abelian variety attached to the modular symbols space M.  
</BLOCKQUOTE>
<H5><A NAME = "18045">ModularAbelianVariety(X) : [ModSym] -&gt;  ModAbVar</A></H5>
<BLOCKQUOTE>
The abelian variety attached to the sequence X of modular symbols 
spaces.  
</BLOCKQUOTE>
<H5><A NAME = "18046">ModularSymbols(A) : ModAbVar -&gt;  SeqEnum</A></H5>
<BLOCKQUOTE>
A sequence of spaces of modular symbols associated to the abelian variety
A.  
</BLOCKQUOTE>
<HR>
<H3><A NAME = "18047">Example <TT>ModAbVar_Modabvar-Abelian_Varieties_Attached_to_Modular_Symbols (H142E8)</TT></A></H3>
<P>
We create modular abelian varieties attached to several spaces
of modular symbols.
<P>
<P>
<PRE>
&gt; M := ModularSymbols(37,2);
&gt; ModularAbelianVariety(M);
Modular abelian variety of dimension 2 and level 37 over Q
&gt; M := ModularSymbols(Gamma1(17));
&gt; ModularAbelianVariety(M);
Modular abelian variety of dimension 5 and level 17 over Q
</PRE>
Note that the sign of the space of modular symbols determines
the sign of the corresponding abelian variety.
<P>
<P>
<PRE>
&gt; M := ModularSymbols(Gamma1(17),2,+1);
&gt; A := ModularAbelianVariety(M); A;
Modular abelian variety of dimension 5 and level 17 over Q with sign 1
</PRE>
We can also create an abelian variety attached to any sequence 
of modular symbols spaces.
<P>
<P>
<PRE>
&gt; ModularAbelianVariety([ModularSymbols(11), ModularSymbols(Gamma1(13))]);
Modular abelian variety of dimension 3 and level 11*13 over Q
</PRE>
Conversely, there is a sequence of modular symbols spaces
associated to any abelian variety defined over Q.  These
need not be the same as the spaces used to define the 
modular abelian variety; instead they are what is used internally
in computations on that abelian variety.
<P>
<P>
<PRE>
&gt; ModularSymbols(JOne(13));
[
    Modular symbols space of level 13, weight 2, character $.1, 
    and dimension 2 over Cyclotomic Field of order 6 and degree 2
]
&gt; ModularSymbols(JZero(37));
[
    Modular symbols space for Gamma_0(37) of weight 2 and 
    dimension 4 over Rational Field
]
&gt; A := JOne(17);
&gt; ModularSymbols(A);
[
    Modular symbols space for Gamma_0(17) of weight 2 and 
    dimension 2 over Rational Field,
    Modular symbols space of level 17, weight 2, character $.1, 
    and dimension 2 over Cyclotomic Field of order 8 and degree 4
]
</PRE>
<HR>
<H4><A NAME = "18048">Creation of Abelian Subvarieties</A></H4>

<P>
<P>
<P>
Suppose A is an abelian variety and V is a vector subspace of
the rational homology H<sub>1</sub>(A, Q).    
Then it can be 
determined whether or not V is the rational homology of an abelian 
subvariety of A, and if so that abelian subvariety can be computed. 
<P>
The other commands below are used to create the zero-dimensional 
abelian variety.


<H5><A NAME = "18049">DefinesAbelianSubvariety(A, V) : ModAbVar, ModTupFld -&gt;                              BoolElt, ModAbVar</A></H5>
<BLOCKQUOTE>
Return <TT>true</TT> if and only if the subspace V of rational homology 
defines an abelian subvariety of the variety A. If so, also returns 
the abelian subvariety.  
<P>
This intrinsic relies on knowing
a complete decomposition of A as a product of simple abelian
varieties (so it is currently restricted to abelian varieties
for which such a decomposition can be computed in Magma, e.g., 
modular abelian varieties over Q).  
</BLOCKQUOTE>
<H5><A NAME = "18050">ZeroModularAbelianVariety() : -&gt;  ModAbVar</A></H5>
<BLOCKQUOTE>
The zero-dimensional abelian variety.  
</BLOCKQUOTE>
<H5><A NAME = "18051">ZeroModularAbelianVariety(k) : RngIntElt -&gt;  ModAbVar</A></H5>
<BLOCKQUOTE>
The zero-dimensional abelian variety of weight k.  
</BLOCKQUOTE>
<H5><A NAME = "18052">ZeroSubvariety(A) : ModAbVar -&gt;  ModAbVar</A></H5>
<BLOCKQUOTE>
Returns the zero subvariety of the abelian variety A. 
</BLOCKQUOTE>
<HR>
<H3><A NAME = "18053">Example <TT>ModAbVar_Modabvar-Creation_of_Abelian_Subvarieties (H142E9)</TT></A></H3>
<P>
We define two subspaces of the rational homology of J<sub>0</sub>(33);
one defines an abelian subvariety and the other does not.
<P>
<P>
<PRE>
&gt; A := JZero(33);
&gt; w3 := AtkinLehnerOperator(A,3);
&gt; W := Kernel(Matrix(w3)+1);
&gt; DefinesAbelianSubvariety(A,W);
true Modular abelian variety of dimension 1 and level 3*11 over Q
&gt; V := RationalHomology(A);
&gt; DefinesAbelianSubvariety(A,W + sub&lt;V|[V.1]&gt;);
false
</PRE>
<P>
We create several zero-dimensional abelian varieties.
<P>
<P>
<PRE>
&gt; ZeroModularAbelianVariety();
Modular abelian variety ZERO of dimension 0 and level 1 over Q
&gt; ZeroModularAbelianVariety(2);
Modular abelian variety ZERO of dimension 0 and level 1 over Q
&gt; ZeroSubvariety(JZero(11));
Modular abelian variety ZERO of dimension 0 and level 11 over Q
</PRE>
<HR>
<H4><A NAME = "18054">Creation Using a Label</A></H4>

<P>
<P>
<P>
<P>
<P>
As a useful shorthand, it is sometimes possible to create modular
abelian varieties by giving a short string.  If the string contains a
single integer N, e.g., 37, then the corresponding abelian variety
is J<sub>0</sub>(N).  If it is of the form <TT>"&lt;level&gt;k&lt;weight&gt;"</TT>, then it is
the possibly motivic J<sub>0</sub>(N) of weight k.  If it is of the form
<TT>"&lt;level&gt;k&lt;weight&gt;&lt;isogeny code&gt;"</TT>, where <TT>&lt;isogeny code&gt;</TT> is one
of <TT>"A"</TT>, <TT>"B"</TT>, ... <TT>"Z"</TT>, <TT>"AA"</TT>, <TT>"BB"</TT>, ... <TT>"ZZ"</TT>,
<TT>"AAA"</TT>, <TT>"BBB"</TT>, ... then the corresponding abelian variety is
<TT>JZero(N,k)(iso)</TT>, where iso is a positive integer, and
<TT>"A"</TT> corresponds to iso=1, <TT>"Z"</TT> to iso=26, 
<TT>"AA"</TT> to iso=27, <TT>"ZZ"</TT> to iso=52, <TT>"AAA"</TT> to 
iso=53, etc.
<P>
This labeling convention is the same as the one used for modular
symbols, and extends the one used for Cremona's database of elliptic
curves, except that Cremona's database contains some random scrambling
for levels between 56 and 450.  If the weight part of the label is
omitted, the weight is assumed to be 2.  To get the optimal quotient
of J<sub>0</sub>(N) with Cremona label s, set the optional parameter <TT>Cremona</TT> equal to true.


<H5><A NAME = "18055">ModularAbelianVariety(s : parameters) : MonStgElt -&gt;  ModAbVar</A></H5>

<PRE>    Sign: RngIntElt                     Default: 0</PRE>

<PRE>    Cremona: BoolElt                    Default: <TT>false</TT></PRE>
<BLOCKQUOTE>
The abelian variety defined by the string s.  
The parameter <TT>Sign</TT> determines
whether computations will be carried out in the +1 or -1 quotient of 
homology. If the parameter <TT>Cremona</TT> is set to <TT>true</TT>, the optimal
quotient of J<sub>0</sub>(N) with Cremona label s will be returned.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "18056">Example <TT>ModAbVar_Modabvar-Creation_Using_a_Label (H142E10)</TT></A></H3>
<P>
<P>
<PRE>


&gt; ModularAbelianVariety("37");
Modular abelian variety 37 of dimension 2 and level 37 over Q
&gt; ModularAbelianVariety("37A");
Modular abelian variety 37A of dimension 1 and level 37 over Q
&gt; ModularAbelianVariety("11k4A");
Modular motive 11k4A of dimension 2 and level 11 over Q
&gt; ModularAbelianVariety("65C");
Modular abelian variety 65C of dimension 2 and level 5*13 over Q
&gt; ModularDegree(ModularAbelianVariety("56A"));
4
&gt; ModularDegree(ModularAbelianVariety("56A" : Cremona := true));
2

</PRE>
<HR>
<H4><A NAME = "18057">Invariants</A></H4>

<P>
<P>
<P>
<P>
<P>
Commands are available which can retrieve
the base ring, dimension,
character of the defining modular form, a field of definition, the level,
the sign, the weights, and a short name of a modular abelian variety.


<H5><A NAME = "18058">BaseRing(A) : ModAbVar -&gt;  Rng</A></H5>
<BLOCKQUOTE>
The ring that the modular abelian variety A is defined over.  
</BLOCKQUOTE>
<H5><A NAME = "18059">Dimension(A) : ModAbVar -&gt;  RngIntElt</A></H5>
<BLOCKQUOTE>
The dimension of the modular abelian variety A.  
</BLOCKQUOTE>
<H5><A NAME = "18060">DirichletCharacter(A) : ModAbVar -&gt;  GrpDrchElt</A></H5>
<BLOCKQUOTE>
If the modular abelian variety A = A<sub>f</sub> is attached to a newform, returns the 
Nebentypus character of f. Since f is only well-defined up to 
Gal (Qbar/Q ) conjugacy, the character is also only well-defined up to 
Gal (Qbar/Q ) conjugacy.  
<P>
For information on Dirichlet characters, see <A  HREF = "text179.htm#1432">Dirichlet Characters</A>.
</BLOCKQUOTE>
<H5><A NAME = "18061">DirichletCharacters(A) : ModAbVar -&gt;  List</A></H5>
<BLOCKQUOTE>
List of all Dirichlet characters of spaces of modular symbols 
associated with the modular symbols abelian variety which parameterizes A.  
</BLOCKQUOTE>
<H5><A NAME = "18062">FieldOfDefinition(A) : ModAbVar -&gt;  Fld</A></H5>
<BLOCKQUOTE>
The best known field of definition of the modular abelian variety A.  
</BLOCKQUOTE>
<H5><A NAME = "18063">Level(A) : ModAbVar -&gt;  RngIntElt</A></H5>
<BLOCKQUOTE>
An integer N such that the modular abelian variety 
A is a quotient of a power of J<sub>1</sub>(N). Note 
that N need not be minimal. It is determined by how A is explicitly 
represented as a quotient of modular Jacobians.  
</BLOCKQUOTE>
<H5><A NAME = "18064">Sign(A) : ModAbVar -&gt;  RngIntElt</A></H5>
<BLOCKQUOTE>
The sign of the modular abelian variety 
A, which is either 0, -1, or +1. If the sign is 
+1 or -1, then 
only the corresponding complex-conjugation 
eigenspace of the homology of A is computed, 
so various computations will be off by a 
factor of 2.  
</BLOCKQUOTE>
<H5><A NAME = "18065">Weights(A) : ModAbVar -&gt;  Set</A></H5>
<BLOCKQUOTE>
The set of weights of the modular abelian variety A. 
The weight need not be unique since 
direct sums of modular symbols spaces of different weights are allowed.  
</BLOCKQUOTE>
<HR>
<H3><A NAME = "18066">Example <TT>ModAbVar_Modabvar-Invariants (H142E11)</TT></A></H3>
<P>
We illustrate all the commands for J<sub>0</sub>(23).
<P>
<P>
<PRE>
&gt; A := JZero(23);
&gt; BaseRing(A);
Rational Field
&gt; Dimension(A);
2
&gt; DirichletCharacter(A);
1
&gt; FieldOfDefinition(A);
Rational Field
&gt; Level(A);
23
&gt; Sign(A);
0
&gt; Weights(A);
{ 2 }
</PRE>
<HR>
<H3><A NAME = "18067">Example <TT>ModAbVar_Modabvar-Invariants2 (H142E12)</TT></A></H3>
This is an example of a nontrivial Dirichlet character.
<P>
<P>
<PRE>
&gt; eps := DirichletCharacter(JOne(23)(2)); eps;
$.1^2
&gt; Order(eps);
11
</PRE>
<HR>
<H3><A NAME = "18068">Example <TT>ModAbVar_Modabvar-Invariants3 (H142E13)</TT></A></H3>
We illustrate the <TT>Weights</TT> command in several cases.
<P>
<P>
<PRE>
&gt; Weights(JZero(11));
{ 2 }
&gt; Weights(JZero(11,4));
{ 4 }
&gt; Weights(JOne(13,3));
{ 3 }
&gt; Weights(DirectSum(JZero(11),JOne(13,3)));
{ 2, 3 }
&gt; Weights(DirectSum(JZero(11),JZero(13,3)));
{ 2 }
</PRE>
<HR>
<H3><A NAME = "18069">Example <TT>ModAbVar_Modabvar-Invariants3 (H142E14)</TT></A></H3>
We display a few fields of definition.
<P>
<P>
<PRE>
&gt; FieldOfDefinition(JOne(13));
Rational Field
&gt; FieldOfDefinition(BaseExtend(JZero(11),QuadraticField(7)));
Rational Field
&gt; FieldOfDefinition(ChangeRing(JZero(11),GF(7)));
Finite field of size 7
</PRE>
<HR>
<H3><A NAME = "18070">Example <TT>ModAbVar_Modabvar-Invariants4 (H142E15)</TT></A></H3>
In the following example we quotient J<sub>0</sub>(11) out by a 5-torsion point.
The resulting abelian variety might not be defined over Q, and the
<TT>FieldOfDefinition</TT> command currently plays it safe and returns 
Qbar.
<P>
<P>
<PRE>
&gt; A := JZero(11);
&gt; G := nTorsionSubgroup(A,5);
&gt; H := Subgroup([G.1]);
&gt; H;
Finitely generated subgroup of abelian variety with invariants [ 5 ]
&gt; FieldOfDefinition(A/H);
Algebraically closed field with no variables
</PRE>
<HR>
<H4><A NAME = "18071">Conductor</A></H4>

<P>
<P>
<P>
<P>
<P>
Let A be a modular abelian variety over Q.  The conductor command
computes the conductor of A by factoring A into newform abelian
varieties A<sub>f</sub> whose conductor is N<sup>d</sup>, where
N is the level of f and d is the dimension of A<sub>f</sub>.


<H5><A NAME = "18072">Conductor(A) : ModAbVar -&gt;  RngIntElt</A></H5>
<BLOCKQUOTE>
The conductor of the abelian variety A. We require that A is 
defined over Q . When A=A<sub>f</sub> is attached to a newform of level N, then 
the conductor of A is N<sup>d</sup>, where d is the dimension of A.  
</BLOCKQUOTE>
<HR>
<H3><A NAME = "18073">Example <TT>ModAbVar_Modabvar-Conductor (H142E16)</TT></A></H3>
<P>
<P>
<PRE>


&gt; Factorization(Conductor(JZero(33)));
[ &lt;3, 1&gt;, &lt;11, 3&gt; ]
&gt; Factorization(Conductor(JZero(11)^5));
[ &lt;11, 5&gt; ]
&gt; Factorization(Conductor(OldSubvariety(JZero(46))));
[ &lt;23, 4&gt; ]
&gt; Factorization(Conductor(JOne(25)));
[ &lt;5, 24&gt; ]


</PRE>
<HR>
<H4><A NAME = "18074">Number of Points</A></H4>

<P>
<P>
<P>
Given an abelian variety A over a field K a divisor and a
multiple of #A(K) can be computed. When finite, the multiple of the number of
rational points is computed using reduction mod primes up to 100.
Currently the lower bound is nontrivial only when A is a quotient
of J<sub>0</sub>(N).


<H5><A NAME = "18075">NumberOfRationalPoints(A) : ModAbVar -&gt;  RngIntElt, RngIntElt</A></H5>
<BLOCKQUOTE>
A divisor and a multiple of the cardinality of A(K), where A is a 
modular abelian variety defined over a field K. If K is an abelian number 
field, then we assume the Birch and Swinnerton-Dyer conjecture.  
</BLOCKQUOTE>
<H5><A NAME = "18076">#A : ModAbVar -&gt; RngIntElt</A></H5>
<BLOCKQUOTE>
The cardinality of A(K) where A is a modular abelian variety defined over
the field K if an exact value for this cardinality is known.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "18077">Example <TT>ModAbVar_Modabvar-Number_of_Points (H142E17)</TT></A></H3>
<P>
<P>
<PRE>
&gt; #JZero(11);
5
&gt; #JZero(23);
11
&gt; NumberOfRationalPoints(JZero(37));
Infinity Infinity
&gt; NumberOfRationalPoints(JOne(13));
1 19
&gt; NumberOfRationalPoints(JOne(23));
1 408991
&gt; Factorization(408991);
[ &lt;11, 1&gt;, &lt;37181, 1&gt; ]
&gt; NumberOfRationalPoints(ModularAbelianVariety("43B"));
7 7
</PRE>
<HR>
<H4><A NAME = "18078">Inner Twists and Complex Multiplication</A></H4>

<P>
<P>
<P>
<P>
<P>
If f is a newform then an <I>inner twist</I> of f is a Dirichlet
character &chi; such that the twist of f by &chi; equals a Galois
conjugate of f, at least at Fourier coefficients whose subscript is
coprime to some fixed integer.  A <I>CM twist</I> is a nontrivial
character &chi; such that f twisted by &chi; equals f, at least
at Fourier coefficients whose subscript is coprime to some fixed
integer.  The commands below find the CM and inner twists of the newform
corresponding to a newform abelian variety.
<P>
The optional parameter <TT>Proof</TT> to each command is by default <TT>false</TT>.  If <TT>true</TT>, it uses a huge number of terms of
q-expansions.
If <TT>false</TT>, it uses far less (and is hence very quick),
and in practice this should be fine.
The computation
of inner and CM twists is not provably correct, even if the <TT>Proof :=
true</TT> option is set.  It's very likely to be correct when
<TT>Proof := true</TT>, but not provably correct.  (More precisely, Magma only
checks that each twist is a twist to precision 10<sup> - 5</sup>, but does not
prove that this precision is sufficient.)


<H5><A NAME = "18079">CMTwists(A : parameters) : ModAbVar -&gt;  SeqEnum</A></H5>

<PRE>    Proof: BoolElt                      Default: <TT>false</TT></PRE>
<BLOCKQUOTE>
A sequence of the CM inner twist characters of the newform abelian variety A = A<sub>f</sub> 
that are defined over the base ring of A. To gain all CM twists, base 
extend to <TT>AlgebraicClosure(RationalField())</TT> first.  
</BLOCKQUOTE>
<H5><A NAME = "18080">InnerTwists(A : parameters) : ModAbVar -&gt;  SeqEnum</A></H5>

<PRE>    Proof: BoolElt                      Default: <TT>false</TT></PRE>
<BLOCKQUOTE>
A sequence of the inner twist characters of the newform abelian variety A = A<sub>f</sub> 
that are defined over the base ring of A. To gain all inner twists, first base 
extend to <TT>AlgebraicClosure(RationalField())</TT>.  
</BLOCKQUOTE>
<HR>
<H3><A NAME = "18081">Example <TT>ModAbVar_Modabvar-Inner_Twists_and_Complex_Multiplication (H142E18)</TT></A></H3>
We compute the inner twists for J<sub>1</sub>(13).
<P>
<P>
<PRE>
&gt; A := JOne(13); A;
Modular abelian variety JOne(13) of dimension 2 and level 13 over Q
&gt; CMTwists(A);
[]
&gt; A2 := BaseExtend(A,AlgebraicClosure(RationalField()));
&gt; CMTwists(A2);
[]
&gt; InnerTwists(A2);
[
    1,
    $.1^5
]
&gt; Parent($1[2]);
Group of Dirichlet characters of modulus 13 over Cyclotomic Field
of order 6 and degree 2
</PRE>
We compute the inner twists for the second newform factor
of J<sub>1</sub>(23).
<P>
<P>
<PRE>
&gt; A := Decomposition(JOne(23))[2]; A;
Modular abelian variety image(23A[2]) of dimension 10, level 23 
and conductor 23^10 over Q
&gt; InnerTwists(BaseExtend(A,AlgebraicClosure(RationalField())));
[
    1,
    $.1^20
]
</PRE>
The CM elliptic curve J<sub>0</sub>(32) has a nontrivial CM inner twist.
<P>
<P>
<PRE>
&gt; A := JZero(32);
&gt; InnerTwists(BaseExtend(A,AlgebraicClosure(RationalField())));
[
    1,
    $.1
]
&gt; CMTwists(BaseExtend(A,AlgebraicClosure(RationalField())));
[
    $.1
]
</PRE>
Quotients of J<sub>0</sub>(N) can also have nontrivial inner twists, which are
not CM twists.
<P>
<P>
<PRE>
&gt; J := JZero(81);
&gt; A := Decomposition(J)[1];
&gt; InnerTwists(BaseExtend(A,AlgebraicClosure(RationalField())));
[
    1,
    $.1
]
&gt; CMTwists(BaseExtend(A,AlgebraicClosure(RationalField())));
[]
&gt; Newform(A);
q + a*q^2 + q^4 - a*q^5 + 2*q^7 + O(q^8)
</PRE>
<HR>
<H3><A NAME = "18082">Example <TT>ModAbVar_Modabvar-Inner_Twists_and_Complex_Multiplication2 (H142E19)</TT></A></H3>
The following is an example of a 4-dimensional abelian variety A=A<sub>f</sub> in 
J<sub>0</sub>(512) that has four inner twists, none of which are CM twists.
One can use this fact to prove that if a<sub>p</sub> is a prime-indexed Fourier
coefficient of f, then a<sub>p</sub><sup>2</sup>&isin;Z.  Thus no single a<sub>p</sub> generates
the degree 4 field generated by all a<sub>n</sub>.
<P>
<P>
<PRE>
&gt; J := JZero(512, 2, +1);
&gt; A := Decomposition(J)[7]; A;
Modular abelian variety 512G of dimension 4, level 2^9 and 
conductor 2^36 over Q with sign 1
&gt; f := Newform(A); f;
q + 1/12*(a^3 - 30*a)*q^3 + 1/12*(-a^3 + 42*a)*q^5 +
     1/6*(-a^2 + 18)*q^7 + O(q^8)
&gt; Coefficient(f,3)^2;
6
&gt; Coefficient(f,5)^2;
12
&gt; Coefficient(f,7)^2;
8
&gt; Abar := BaseExtend(JZero(512,2,+1)(7),AlgebraicClosure(RationalField()));
&gt; InnerTwists(Abar);
[
    1,
    $.1,
    $.2,
    $.1*$.2
]
&gt; CMTwists(Abar);
[]
</PRE>
<HR>
<H4><A NAME = "18083">Predicates</A></H4>

<P>
<P>
<P>
<P>
<P>
Most of the predicates below work in full generality.  The ones whose
domain of applicability is somewhat limited are <TT>IsIsomorphic</TT>,
<TT>IsQuaternionic</TT>, and <TT>IsSelfDual</TT>.  
In theory, it is
possible to determine isomorphism for more general classes of modular
abelian varieties, but this has not yet been implemented.


<H5><A NAME = "18084">CanDetermineIsomorphism(A, B) : ModAbVar, ModAbVar -&gt;  BoolElt, BoolElt, MapModAbVar</A></H5>
<BLOCKQUOTE>
Return <TT>true</TT> if we can determine whether or not the modular abelian varieties A and B are isomorphic. 
If we can determine isomorphism, also returns <TT>true</TT> if A and B are 
isomorphic and an explicit isomorphism, or <TT>false</TT> if they are not isomorphic. If 
we can not determine isomorphism, also returns the reason why we cannot 
as a string. If A and B are simple and defined over Q , then 
there is an algorithm to determine whether or not A and B are isomorphic; 
it has been implemented in most (but not all) cases in Magma.
If one of A or B has simple factors of multiplicity one, then in 
principal it is possible, but the algorithm has not been programmed.  
</BLOCKQUOTE>
<H5><A NAME = "18085">HasMultiplicityOne(A) : ModAbVar -&gt;  BoolElt</A></H5>
<BLOCKQUOTE>
Return <TT>true</TT> if the simple factors of the modular abelian variety A appear with multiplicity one.  
</BLOCKQUOTE>
<H5><A NAME = "18086">IsAbelianVariety(A) : ModAbVar -&gt;  BoolElt</A></H5>
<BLOCKQUOTE>
Return <TT>true</TT> if A is an abelian variety, i.e., defined over a ring of 
characteristic 0 in which the conductor is invertible, or a finite field whose characteristic does 
not divide the conductor of A. For example, if A has positive 
dimension and is defined over Z , then Raynaud's theorem implies that A is 
not an abelian variety.  
</BLOCKQUOTE>
<H5><A NAME = "18087">IsAttachedToModularSymbols(A) : ModAbVar -&gt;  BoolElt</A></H5>
<BLOCKQUOTE>
Return <TT>true</TT> if the underlying homology of the modular abelian variety A is being computed using a 
space of modular symbols. For example, this will be true for J<sub>0</sub>(N) and 
for newform abelian varieties.  
</BLOCKQUOTE>
<H5><A NAME = "18088">IsAttachedToNewform(A) : ModAbVar -&gt;  BoolElt, ModAbVar, MapModAbVar</A></H5>
<BLOCKQUOTE>
Return <TT>true</TT> if the modular abelian variety A is isogenous to a newform abelian variety A<sub>f</sub>. This 
intrinsic also returns the abelian variety A<sub>f</sub> and an
explicit isogeny from A<sub>f</sub> to A.  
</BLOCKQUOTE>
<H5><A NAME = "18089">IsIsogenous(A, B) : ModAbVar, ModAbVar -&gt;  BoolElt</A></H5>
<BLOCKQUOTE>
Return <TT>true</TT> if the modular abelian varieties A and B are isogenous. If this can <I>not</I> be 
determined, an error occurs. It is 
always possible to determine whether or not A and B are isogenous when 
both are defined over Q .  
</BLOCKQUOTE>
<H5><A NAME = "18090">IsIsomorphic(A, B) : ModAbVar, ModAbVar -&gt;  BoolElt, MapModAbVar</A></H5>
<BLOCKQUOTE>
Return <TT>true</TT> if the modular abelian varieties A and B are isomorphic. If so, also returns an explicit 
isomorphism. This command will work if A and B are defined over Q  and the 
simple factors occur with multiplicity one, and may work otherwise, but an 
error may occur in the general case. Use the command 
<TT>CanDetermineIsomorphism</TT> to avoid getting an error.  
</BLOCKQUOTE>
<H5><A NAME = "18091">IsOnlyMotivic(A) : ModAbVar -&gt;  BoolElt</A></H5>
<BLOCKQUOTE>
Return <TT>true</TT> if any of the modular forms attached to the modular abelian
variety A have weight bigger 
than 2.  
</BLOCKQUOTE>
<H5><A NAME = "18092">IsQuaternionic(A) : ModAbVar -&gt;  BoolElt</A></H5>
<BLOCKQUOTE>
Return <TT>true</TT> if and only if some simple factor of the modular abelian
variety A over the base ring has 
quaternionic multiplication.  
</BLOCKQUOTE>
<H5><A NAME = "18093">IsSelfDual(A) : ModAbVar -&gt;  BoolElt</A></H5>
<BLOCKQUOTE>
Return <TT>true</TT> if the modular abelian
variety A is known to be isomorphic to its dual. An error occurs 
if Magma is unable to decide.  
</BLOCKQUOTE>
<H5><A NAME = "18094">IsSimple(A) : ModAbVar -&gt;  BoolElt</A></H5>
<BLOCKQUOTE>
Return <TT>true</TT> if and only if the modular abelian variety 
A has no proper abelian subvarieties over 
<TT>BaseRing(A)</TT>.  
</BLOCKQUOTE>
<HR>
<H3><A NAME = "18095">Example <TT>ModAbVar_Modabvar-Predicates (H142E20)</TT></A></H3>
We test whether a few objects are actually abelian varieties.
<P>
<P>
<PRE>
&gt; A := JZero(11);
&gt; A11 := ChangeRing(A,GF(11));
&gt; IsAbelianVariety(A11);
false
&gt; AZ := ChangeRing(A,Integers());
&gt; IsAbelianVariety(AZ);
false
&gt; A3 := ChangeRing(A,pAdicRing(3));
&gt; IsAbelianVariety(A3);
true
</PRE>
<HR>
<H3><A NAME = "18096">Example <TT>ModAbVar_Modabvar-Predicates2 (H142E21)</TT></A></H3>
A modular motive is sometimes also an abelian variety, but only over
the complex numbers. 
<P>
<P>
<PRE>
&gt; A := JZero(11,4); A;
Modular motive JZero(11,4) of dimension 2 and level 11 over Q
&gt; IsAbelianVariety(A);
false
&gt; IsOnlyMotivic(A);
true
&gt; IsAbelianVariety(BaseExtend(A,ComplexField()));
true
</PRE>
<HR>
<H3><A NAME = "18097">Example <TT>ModAbVar_Modabvar-Predicates3 (H142E22)</TT></A></H3>
Abelian varieties J<sub>0</sub>(N) and J<sub>s</sub>(N) are attached to modular symbols, as are
newform abelian varieties.
<P>
<P>
<PRE>
&gt; J := JZero(37);
&gt; IsAttachedToModularSymbols(J);
true
&gt; A := Decomposition(J)[1];
&gt; IsAttachedToModularSymbols(A);
false
&gt; t, Af := IsAttachedToNewform(A);
&gt; IsAttachedToModularSymbols(Af);
true
&gt; IsIsomorphic(A,Af);
true Homomorphism from 37A to 37A given on integral homology by:
[1 0]
[0 1]
&gt; IsAttachedToModularSymbols(Js(17));
true
&gt; IsAttachedToModularSymbols(JOne(17));
false
</PRE>
<HR>
<H3><A NAME = "18098">Example <TT>ModAbVar_Modabvar-Predicates4 (H142E23)</TT></A></H3>
We test isogeny between a few abelian varieties.
<P>
<P>
<PRE>
&gt; IsIsogenous(JZero(11),JOne(11));
true
&gt; IsIsogenous(JZero(11)*JZero(11),JZero(22));
true
&gt; IsIsogenous(JZero(11)*JZero(11),JZero(33));
false
&gt; IsIsogenous(JZero(11),JZero(14));
false
&gt; IsIsogenous(JZero(11)^2,JZero(22));
true
&gt; A := JZero(37)(2); B := JOne(13);
&gt; IsIsogenous(A*B*A, A*A*B);
true
&gt; A := JZero(43);
&gt; G := RationalCuspidalSubgroup(A);
&gt; IsIsogenous(A,A/G);
true
</PRE>
<P>
Next we test isomorphism between some abelian varieties.  
<P>
<P>
<PRE>
&gt; A := JZero(43);
&gt; G := RationalCuspidalSubgroup(A);
&gt; B := A/G;
&gt; CanDetermineIsomorphism(A,B);
true false
&gt; IsIsomorphic(A,B);
false
&gt; IsIsomorphic(JZero(11),JOne(11));
false
&gt; IsIsomorphic(JZero(13),JOne(13));
false
&gt; IsIsomorphic(Js(13),JOne(13));
true Homomorphism from Js(13) to JOne(13) given on integral 
homology by:
[ 0  0 -1  0]
[ 0  0  0 -1]
[ 1  0 -1  0]
[ 0  1  0 -1]
&gt; CanDetermineIsomorphism(Js(17),JOne(17));
false All tests failed to decide whether A and B are isomorphic.
</PRE>
<HR>
<H3><A NAME = "18099">Example <TT>ModAbVar_Modabvar-Predicates5 (H142E24)</TT></A></H3>
We test whether certain Jacobians have simple factors
with multiplicity one.
<P>
<P>
<PRE>
&gt; HasMultiplicityOne(JZero(43));
true
&gt; HasMultiplicityOne(JZero(33));
false
&gt; Decomposition(JZero(33));
[
    Modular abelian variety 33A of dimension 1, level 3*11 and 
    conductor 3*11 over Q,
    Modular abelian variety N(11,33,1)(11A) of dimension 1, level
    3*11 and conductor 11 over Q,
    Modular abelian variety N(11,33,3)(11A) of dimension 1, level
    3*11 and conductor 11 over Q
]
</PRE>
<HR>
<H3><A NAME = "18100">Example <TT>ModAbVar_Modabvar-Predicates6 (H142E25)</TT></A></H3>
We give an example of a non-quaternionic
surface.  
<P>
<P>
<PRE>
&gt; IsQuaternionic(JOne(13));
false
</PRE>
<HR>
<H3><A NAME = "18101">Example <TT>ModAbVar_Modabvar-Predicates7 (H142E26)</TT></A></H3>
Jacobians are self dual, and there is a surface of level 43 that is self dual and
a surface of level 69 that is not.
<P>
<P>
<PRE>
&gt; IsSelfDual(JOne(13));
true
&gt; IsSelfDual(JZero(69)(2));
false
</PRE>
<P>
The surface A below is isomorphic to its dual.
The natural polarization has kernel that is the kernel
of multiplication by 2.
<P>
<P>
<PRE>
&gt; A  := JZero(43)(2);
&gt; A;
Modular abelian variety 43B of dimension 2, level 43 and 
conductor 43^2 over Q
&gt; IsSelfDual(A);
true
&gt; phi := ModularPolarization(A);
&gt; Invariants(Kernel(phi));
[ 2, 2, 2, 2 ]
</PRE>
<HR>
<H3><A NAME = "18102">Example <TT>ModAbVar_Modabvar-Predicates8 (H142E27)</TT></A></H3>
We test a few abelian varieties for simplicity.
<P>
<P>
<PRE>
&gt; IsSimple(JOne(25));
false
&gt; IsSimple(JOne(13));
true
&gt; IsSimple(JZero(11)^10);
false
&gt; IsSimple(NewSubvariety(JZero(100)));
true
</PRE>
<HR>
<H4><A NAME = "18103">Equality and Inclusion Testing</A></H4>

<P>
<P>
<P>
<P>
<P>
These functions test whether two abelian varieties are exactly equal
or if one is a subset of another.


<H5><A NAME = "18104">A eq B : ModAbVar, ModAbVar -&gt;  BoolElt</A></H5>
<BLOCKQUOTE>
Return <TT>true</TT> if the modular abelian varieties A and B are equal.  
</BLOCKQUOTE>
<H5><A NAME = "18105">A subset B : ModAbVar, ModAbVar -&gt;  BoolElt</A></H5>
<BLOCKQUOTE>
Return <TT>true</TT> if the modular abelian variety A is a subset of the modular abelian variety B.  
</BLOCKQUOTE>
<HR>
<H3><A NAME = "18106">Example <TT>ModAbVar_Modabvar-Equality_and_Inclusion_Testing (H142E28)</TT></A></H3>
This example illustrates that taking the direct product of abelian varieties
is not commutative, as measured by equality (though it is as measured by isomorphism).
<P>
<P>
<PRE>
&gt; A := JZero(11);
&gt; B := JZero(14);
&gt; A*B eq A*B;
true
&gt; A*B eq B*A;
false
&gt; IsIsomorphic(A*B, B*A);
true Homomorphism N(1) from JZero(11) x JZero(14) to JZero(14) x JZero(11) 
given on integral homology by:
[0 0 1 0]
[0 0 0 1]
[1 0 0 0]
[0 1 0 0]
</PRE>
<HR>
<H3><A NAME = "18107">Example <TT>ModAbVar_Modabvar-Equality_and_Inclusion_Testing2 (H142E29)</TT></A></H3>
The first inclusion below is as expected, but the second
non-inclusion might be surprising.  We do not consider J<sub>0</sub>(11) as a
subset of J<sub>0</sub>(22), even though there is an injective map from one to
the other, since to be a subset is much stronger than just the
existence of an inclusion map.
<P>
<P>
<PRE>
&gt; JZero(37) subset JZero(37);
true
&gt; JZero(11) subset JZero(22);
false
&gt; IsInjective(NaturalMap(JZero(11),JZero(22)));
true
</PRE>
<HR>
<H4><A NAME = "18108">Modular Embedding and Parameterization</A></H4>

<P>
<P>
<P>
Every modular abelian variety A is equipped with a modular parameterization
and a modular embedding.  The modular parameterization is a surjective
homomorphism from a modular symbols abelian variety, such as J<sub>0</sub>(N).
The modular embedding is a homomorphism to a modular symbols abelian
variety, which is only guaranteed to be <I>injective in the category
of abelian varieties up to isogeny</I>, i.e., to have 
  finite kernel as a morphism of abelian varieties.   The structure of these two homomorphisms
is extremely important as they completely define A.


<H5><A NAME = "18109">CommonModularStructure(X) : [ModAbVar] -&gt;  List, List</A></H5>
<BLOCKQUOTE>
This intrinsic finds modular abelian varieties J<sub>e</sub> and J<sub>p</sub> 
associated to modular symbols and returns a list of finite-kernel maps from the 
abelian varieties in the sequence X to J<sub>e</sub> and a list of modular parameterizations 
from J<sub>p</sub> to the abelian varieties in X.  
</BLOCKQUOTE>
<H5><A NAME = "18110">ModularEmbedding(A) : ModAbVar -&gt;  MapModAbVar</A></H5>
<BLOCKQUOTE>
A morphism with finite kernel from the modular abelian variety
A to a modular abelian variety 
attached to modular symbols. This is only guaranteed to be an embedding in the 
category of abelian varieties up to isogeny.  
</BLOCKQUOTE>
<H5><A NAME = "18111">ModularParameterization(A) : ModAbVar -&gt;  MapModAbVar</A></H5>
<BLOCKQUOTE>
A surjective morphism to the modular abelian variety
A from an abelian variety attached to 
modular symbols.  
</BLOCKQUOTE>
<HR>
<H3><A NAME = "18112">Example <TT>ModAbVar_Modabvar-Modular_Embedding_and_Parameterization (H142E30)</TT></A></H3>
<P>
<P>
<PRE>
&gt; X := [JZero(11),ModularAbelianVariety("37B")];
&gt; CommonModularStructure(X);
[*
Homomorphism from JZero(11) to JZero(11) x JZero(37) given on integral 
homology by:
[1 0 0 0 0 0]
[0 1 0 0 0 0],
Homomorphism from 37B to JZero(11) x JZero(37) given on integral 
homology by:
[0 0 1 1 1 0]
[0 0 0 0 0 1]
*] [*
Homomorphism from JZero(11) x JZero(37) to JZero(11) (not printing 6x2 
matrix),
Homomorphism from JZero(11) x JZero(37) to 37B (not printing 6x2 
matrix)
*]
</PRE>
<HR>
<H3><A NAME = "18113">Example <TT>ModAbVar_Modabvar-Modular_Embedding_and_Parameterization2 (H142E31)</TT></A></H3>
This example illustrates that the modular "embedding" need
only be an embedding in the category of abelian varieties up to isogeny.
<P>
<P>
<PRE>
&gt; A := JZero(37)(1);
&gt; x := A![1/2,1];
&gt; B := A/Subgroup([x]);
&gt; e := ModularEmbedding(B);
&gt; e;
Homomorphism from modular abelian variety of dimension 1 to 
JZero(37)_Qbar given on integral homology by:
[ 1 -1  1  0]
[ 2 -2 -2  2]
&gt; IsInjective(e);
false
</PRE>
Moreover, the modular parameterization is surjective, but it need
be optimal (have connected kernel).
<P>
<P>
<PRE>
&gt; pi := ModularParameterization(B);
&gt; IsSurjective(pi);
true
&gt; ComponentGroupOfKernel(pi);
Finitely generated subgroup of abelian variety with invariants [ 2 ]
&gt; IsOptimal(pi);
false
</PRE>
<HR>
<H4><A NAME = "18114">Coercion</A></H4>

<P>
<P>
<P>
<P>
Coercion can be used to create points on modular abelian varieties from
vectors on a basis of integral homology, from other elements of modular
abelian varieties, or from modular symbols.  See the examples below,
especially the last one, to understand some of the subtleties of
coercion that arise because we view an abelian variety as a
vector space modulo a lattice, and that lattice can be embedded
in any way in Q<sup>n</sup>.


<H5><A NAME = "18115">A ! x : ModAbVar, . -&gt;  BoolElt, ModAbVarElt</A></H5>
<BLOCKQUOTE>
Coerce x into the modular abelian variety 
A. The argument x can be an element of a modular 
abelian variety, the integer 0, a sequence like that obtained by from <TT>Eltseq</TT> of 
element of A (i.e., a linear combination of <I>integral</I> homology), a 
vector on the basis for <I>rational</I> homology, or a tuple of the form 
&lt; P(X, Y), [u, v] &gt; defining a modular symbol.  
</BLOCKQUOTE>
<HR>
<H3><A NAME = "18116">Example <TT>ModAbVar_Modabvar-Coercion (H142E32)</TT></A></H3>
<P>
If you coerce a <I>sequence</I> of rationals or reals into an abelian variety
A, then Magma computes the corresponding linear combination of a basis of 
integral homology and returns the point it defines.   The sequence
must have length the rank of the integral homology.
<P>
<P>
<PRE>
&gt; JZero(11)![1/2,1/5];
Element of abelian variety defined by [1/2 1/5] modulo homology
</PRE>
If you coerce exactly two cusps (or extended reals) into A,
then Magma computes the point corresponding to that modular symbol.
<P>
<P>
<PRE>
&gt; JZero(11)![Cusps()|1/2,1/5];
0
&gt; JZero(11)![Sqrt(2),0];
Element of abelian variety defined by 
[1.41421356237309504&equiv;688724198 0] modulo homology
&gt; JZero(11)![Cusps()|0,Infinity()];     // cusps
Element of abelian variety defined by [0 1/5] modulo homology
&gt; JZero(11)![0,Infinity()];             // extended reals
Element of abelian variety defined by [0 1/5] modulo homology
</PRE>
Coercion of modular symbols also works for higher weight. 
<P>
<P>
<PRE>
&gt; JZero(11,4)![0,Infinity()];
Element of abelian variety defined by [-4/61 5/61 1/61 -1/61] 
modulo homology
&gt; R&lt;x,y&gt; := PolynomialRing(RationalField(),2);
&gt; JZero(11,4)!&lt;x^2,[0,Infinity()]&gt;;
Element of abelian variety defined by [-4/61 5/61 1/61 -1/61] 
modulo homology
&gt; JZero(11,4)!&lt;y^2,[0,Infinity()]&gt;;
Element of abelian variety defined by [44/61 -55/61 -11/61 11/61]
modulo homology
</PRE>
<P>
You can also coerce elements from abelian subvarieties into
an ambient abelian variety.
<P>
<P>
<PRE>
&gt; J := JZero(37); A := Decomposition(J)[1];
&gt; x := A![1/5,0];
&gt; Parent(x);
Modular abelian variety 37A of dimension 1, level 37 and 
conductor 37 over Q
&gt; x in J;
false
&gt; y := J!x; y;
Element of abelian variety defined by [1/5 -1/5 1/5 0] modulo 
homology
&gt; y in J;
true
&gt; Parent(y);
Modular abelian variety JZero(37) of dimension 2 and level 37 over Q
</PRE>
<P>
Coercion also provides an easy way to create the 0 element.
<P>
<P>
<PRE>
&gt; JZero(37)!0;
0
</PRE>
<HR>
<H3><A NAME = "18117">Example <TT>ModAbVar_Modabvar-Coercion2 (H142E33)</TT></A></H3>
The following example illustrates the subtlety of coercion
when the element being coerced in is a vector instead of a
sequence.   We create the quotient of J<sub>0</sub>(11) by a cyclic
subgroup of order 10.  The lattice that defines J<sub>0</sub>(11)
is Z x Z, but the lattice that defines this quotient
is (1/10)Z x Z.  Thus the natural quotient map on
vector spaces is defined by the identity matrix.  On the other
hand, the matrix
of the quotient with respect to a basis for integral homology
has determinant 10.
<P>
<P>
<PRE>
&gt; A := JZero(11);
&gt; x := A![1/10,0]; x;
Element of abelian variety defined by [1/10 0] modulo homology
&gt; Order(x);
10
&gt; B,pi := A/Subgroup([x]);
&gt; B;
Modular abelian variety of dimension 1 and level 11 over Qbar
&gt; pi;
Homomorphism from JZero(11)_Qbar to modular abelian variety of 
dimension 1 given on integral homology by:
[10  0]
[ 0  1]
&gt; Matrix(pi);
[1 0]
[0 1]
&gt; IntegralMatrix(pi);
[10  0]
[ 0  1]
&gt; base := Basis(IntegralHomology(B)); base;
[
    (1/10    0),
    (0 1)
]
</PRE>
If we coerce in the sequence [1/10,0] we get the point in B
that is represented by 1/10th of the first generator for 
homology.   If we coerce in the vector (1/10, 0), we instead
get the element of B represented by that element of the
rational homology, which is 0, since the lattice that defines
B is embedded in such a way that it contains (1/10, 0). 
<P>
<P>
<PRE>
&gt; y := B![1/10,0]; y;
Element of abelian variety defined by [1/10 0] modulo homology
&gt; Order(y);
10
&gt; z := B!base[1]; z;
0
</PRE>
<HR>
<H4><A NAME = "18118">Modular Symbols to Homology</A></H4>

<P>
<P>
<P>
Modular symbols determine elements of the rational homology of
J<sub>0</sub>(N), J<sub>1</sub>(N), etc., and hence of arbitrary modular abelian
varieties, by using the modular parameterization.  The commands below
convert from modular symbols, which are represented in various ways,
to vectors on the basis for rational or integral homology.  


<H5><A NAME = "18119">ModularSymbolToIntegralHomology(A, x) : ModAbVar, SeqEnum -&gt;  ModTupFldElt</A></H5>
<H5>ModularSymbolToIntegralHomology(A, x) : ModAbVar, Tup -&gt;  ModTupFldElt</H5>
<BLOCKQUOTE>
The element of integral homology of the abelian variety A,
naturally associated to the (formal) 
modular symbol x=P(X, Y){&alpha; , &beta; }, where &alpha; , &beta;  are in 
P<sup>1</sup>(Q ) and P is a homogeneous polynomial of degree 2. The returned 
vector is written with respect to the basis of integral homology. 
The argument x may be given as a sequence [&alpha;, &beta;] or as a tuple
&lt; P(X, Y), [&alpha;, &beta;] &gt; where &alpha; and &beta; are in
<TT>Cusps()</TT>.
</BLOCKQUOTE>
<H5><A NAME = "18120">ModularSymbolToRationalHomology(A, x) : ModAbVar, ModSymElt -&gt;  ModTupFldElt</A></H5>
<H5>ModularSymbolToRationalHomology(A, x) : ModAbVar, SeqEnum -&gt;  ModTupFldElt</H5>
<H5>ModularSymbolToRationalHomology(A, x) : ModAbVar, Tup -&gt;  ModTupFldElt</H5>
<BLOCKQUOTE>
The element of rational homology of the abelian variety A
naturally associated to the (formal) 
modular symbol x=P(X, Y){&alpha; , &beta; }, where &alpha; , &beta;  are in 
P<sup>1</sup>(Q ) and P is a homogeneous polynomial of degree 2. The returned 
vector is written with respect to the basis of rational homology. 
The argument x may be given as a modular symbol, a sequence [&alpha;, &beta;] or as a tuple
&lt; P(X, Y), [&alpha;, &beta;] &gt; where &alpha; and &beta; are in
<TT>Cusps()</TT>.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "18121">Example <TT>ModAbVar_Modabvar-Modular_Symbols_to_Homology (H142E34)</TT></A></H3>
<P>
<P>
<PRE>
&gt; A := JZero(11);
&gt; x := ModularSymbolToIntegralHomology(A,[0,Infinity()]); x;
(  0 1/5)
&gt; z := A!x; z;
Element of abelian variety defined by [0 1/5] modulo homology
&gt; Order(z);
5
&gt; A := JZero(47);
&gt; x := ModularSymbolToIntegralHomology(A,[0,Infinity()]); x;
(-1/23  3/23 -4/23  4/23 -3/23  1/23  2/23  8/23)
&gt; z := A!x;
&gt; Order(z);
23
</PRE>
<HR>
<H3><A NAME = "18122">Example <TT>ModAbVar_Modabvar-Modular_Symbols_to_Homology2 (H142E35)</TT></A></H3>
<P>
<P>
<PRE>
&gt; J := JZero(11,4);
&gt; IntegralHomology(J);
Lattice of rank 4 and degree 4
Basis:
( 3  1 -1 -1)
( 1 -1 -3  1)
( 2 -2  2  2)
( 2 -2  2 -2)
Basis Denominator: 8
&gt; ModularSymbolToIntegralHomology(J,[0,Infinity()]);
(-4/61  5/61  1/61 -1/61)
</PRE>
Notice that for weight greater than 2 the homogeneous polynomial
part of the modular symbol may be omitted.  If so, it defaults to x<sup>k - 2</sup>.
<P>
<P>
<PRE>
&gt; R&lt;x,y&gt; := PolynomialRing(RationalField(),2);
&gt; ModularSymbolToIntegralHomology(J,&lt;x^2,[0,Infinity()]&gt;);
(-4/61  5/61  1/61 -1/61)
&gt; ModularSymbolToIntegralHomology(J,&lt;y^2,[0,Infinity()]&gt;);
( 44/61 -55/61 -11/61  11/61)
</PRE>
The result of coercion to rational homology is different because it is
written in terms of the basis for rational homology instead of the
basis for integral homology, and in this example the two basis differ.
<P>
<P>
<PRE>
&gt; ModularSymbolToRationalHomology(J,[0,Infinity()]);
( -7/488  -9/488 -11/488  13/488)
</PRE>
<P>
Coercion is also a way to define torsion points on abelian varieties. 
<P>
<P>
<PRE>
&gt; JZero(37)![1/5,0,0,0];
Element of abelian variety defined by [1/5 0 0 0] modulo homology
</PRE>
<HR>
<H4><A NAME = "18123">Embeddings</A></H4>

<P>
<P>
<P>
The <TT>Embeddings</TT> command contains a list of embeddings (up to isogeny)
from A to other abelian varieties.  The <TT>AssertEmbedding</TT> command
allows you to add an embedding to the beginning of the list.   The embeddings
are used for computing intersections, sums, etc., with the embedding at
the front of the list having highest priority.


<H5><A NAME = "18124"></A><A NAME = "ModAbVar:embed">Embeddings</A>(A) : ModAbVar -&gt;  List</H5>
<BLOCKQUOTE>
A list of morphisms from the modular abelian variety 
A into abelian varieties, which are used 
in making sense of intersections, sums, etc. The embeddings at the 
beginning of the list take precedence over those that occur later. Note that 
these maps might not really be injective; e.g., the modular embedding, 
which need only be injective on homology, is at the end of this 
list.  
</BLOCKQUOTE>
<H5><A NAME = "18125">AssertEmbedding(~A, phi) : ModAbVar, MapModAbVar -&gt;</A></H5>
<BLOCKQUOTE>
Place the homomorphism &phi;  of abelian varieties 
at the beginning of <A  HREF = "text1637.htm#ModAbVar:embed">Embeddings</A><TT>(A)</TT> where A is a modular abelian variety. 
The morphism &phi;  must have finite kernel.  
</BLOCKQUOTE>
<HR>
<H3><A NAME = "18126">Example <TT>ModAbVar_Modabvar-Embeddings (H142E36)</TT></A></H3>
<P>
<P>
Every modular abelian variety comes equipped with at least one
embedding, the "modular embedding".
<P>
<P>
<PRE>
&gt; Embeddings(JZero(11));
[*
Homomorphism from JZero(11) to JZero(11) given on integral homology by:
[1 0]
[0 1]
*]
&gt; A := JZero(37)(1);
&gt; Embeddings(A);
[*
Homomorphism from 37A to JZero(37) given on integral homology by:
[ 1 -1  1  0]
[ 1 -1 -1  1]
*]
</PRE>
We add another embedding to the list of embeddings for A.
<P>
<P>
<PRE>
&gt; phi := NaturalMap(A,JZero(37*2));
&gt; AssertEmbedding(~A,phi);
&gt; Embeddings(A);
[*
Homomorphism N(1) from 37A to JZero(74) given on integral homology 
by:
[-1  1 -1  0  2 -1  1  0 -2  1 -2  2 -1  2 -1  1]
[-1  0  0  0  2 -1  1 -2  0  0 -1  1 -1  2  1 -1],
Homomorphism from 37A to JZero(37) given on integral homology by:
[ 1 -1  1  0]
[ 1 -1 -1  1]
*]
</PRE>
The following intersection would not make sense if we
hadn't chosen an embedding of A into J<sub>0</sub>(74).
<P>
<P>
<PRE>
&gt; B := Codomain(phi)(1); B;
Modular abelian variety 74A of dimension 2, level 2*37 and 
conductor 2^2*37^2 over Q
&gt; #(A meet B);
1
</PRE>
<HR>
<H4><A NAME = "18127">Base Change</A></H4>

<P>
<P>
<P>
The <TT>BaseExtend</TT> and <TT>ChangeRing</TT> commands allow you to change
the base ring of a modular abelian variety.  The <TT>BaseExtend</TT>
command is the same <TT>ChangeRing</TT>, but is more restrictive.  For
example, if A is over Q then <TT>BaseExtend(A,GF(2))</TT> is not
allowed, but <TT>ChangeRing(A,GF(2))</TT> is.  
<P>
Abelian varieties can have their base ring set to a finite field, but
there is very little that is implemented for abelian varieties over
finite fields.  Computing the number of points is implemented, but
creation of actual points or homomorphisms is not.


<H5><A NAME = "18128">CanChangeRing(A, R) : ModAbVar, Rng -&gt;  BoolElt, ModAbVar</A></H5>
<BLOCKQUOTE>
Return <TT>true</TT> if it is possible to change the base ring of the modular
abelian variety A to the ring R, and the modular abelian variety
over R when possible.  
</BLOCKQUOTE>
<H5><A NAME = "18129">ChangeRing(A, R) : ModAbVar, Rng -&gt;  ModAbVar</A></H5>
<BLOCKQUOTE>
Return the modular abelian variety obtained from the modular abelian variety
A having base ring R.
</BLOCKQUOTE>
<H5><A NAME = "18130">BaseExtend(A, R) : ModAbVar, Rng -&gt;  ModAbVar</A></H5>
<BLOCKQUOTE>
Extend the base ring of the modular abelian variety A to the ring R, 
if possible. This is a 
more restrictive version of <TT>ChangeRing</TT>.  
</BLOCKQUOTE>
<HR>
<H3><A NAME = "18131">Example <TT>ModAbVar_Modabvar-Base_Change (H142E37)</TT></A></H3>
<P>
We consider J<sub>1</sub>(13) over many fields and rings. 
<P>
<P>
<PRE>
&gt; A := JOne(13);
&gt; BaseExtend(A,CyclotomicField(7));
Modular abelian variety JOne(13) of dimension 2 and level 13 over 
Q(zeta_7)
&gt; BaseExtend(A,AlgebraicClosure(RationalField()));
Modular abelian variety JOne(13)_Qbar of dimension 2 and level 13 
over Qbar
&gt; BaseExtend(A,RealField());
Modular abelian variety JOne(13)_R of dimension 2 and level 13 over R
&gt; BaseExtend(A,ComplexField());
Modular abelian variety JOne(13)_C of dimension 2 and level 13 over C
&gt; ChangeRing(A,GF(3));
Modular abelian variety JOne(13)_GF(3) of dimension 2 and level 13 
over GF(3)
&gt; #ChangeRing(A,GF(3));
19 19
&gt; B := ChangeRing(A,GF(13)); B;
Modular abelian variety JOne(13)_GF(13) of dimension 2 and level 13
over GF(13)
&gt; IsAbelianVariety(B);
false
&gt; ChangeRing(A,Integers());
Modular abelian variety JOne(13)_Z of dimension 2 and level 13 over
Z
&gt; ChangeRing(A,PolynomialRing(RationalField(),10));
Modular abelian variety JOne(13) of dimension 2 and level 13 over 
Polynomial ring of rank 10 over Rational Field
Lexicographical Order
Variables: $.1, $.2, $.3, $.4, $.5, $.6, $.7, $.8, $.9, $.10
</PRE>
<HR>
<H4><A NAME = "18132">Additional Examples</A></H4>



<HR>
<H3><A NAME = "18133">Example <TT>ModAbVar_modabvar1 (H142E38)</TT></A></H3>
The simplest abelian variety is an abelian variety of dimension 0,
i.e., a point.
<P>
<P>
<PRE>
&gt; A := ZeroModularAbelianVariety(); A;
Modular abelian variety ZERO of dimension 0 and level 1 over Q
</PRE>
We create the Jacobian J<sub>0</sub>(22) of the modular curve
X<sub>0</sub>(22) as follows:
<P>
<P>
<PRE>
&gt; J := JZero(22); J;
Modular abelian variety JZero(22) of dimension 2 and level 2*11 over Q
</PRE>
Notice that A is a subset of J<sub>0</sub>(22).
<P>
<P>
<PRE>
&gt; A subset J;
true
</PRE>
We can also create the higher weight analogues J<sub>0</sub>(N, k) of J<sub>0</sub>(N),
which are motives defined over Q.  Many computations that make
sense for J<sub>0</sub>(N) also make sense for these higher weight analogues.
<P>
<P>
<PRE>
&gt; J4 := JZero(22,4); J4;
Modular motive JZero(22,4) of dimension 7 and level 2*11 over Q
&gt; IsOnlyMotivic(J4);
true
</PRE>
<P>
One can also create J<sub>1</sub>(N):
<P>
<P>
<PRE>
&gt; JOne(22); 
Modular abelian variety JOne(22) of dimension 6 and level 2*11 over Q
</PRE>
<P>
For efficiency purposes, it is often much quicker to do computations
working only with the +1 quotient of H<sub>1</sub>(J<sub>0</sub>(N), Z), 
or using only the -1 quotient.  These computations will be off
by powers of 2, or subgroups will be halved and off by a power of 2.
Nonetheless, if you know what you are doing, such computations can
be very useful.  Create J<sub>0</sub>(N), but working only with the +1
quotient of homology as follows:
<P>
<P>
<PRE>
&gt; Jplus := JZero(22,2,+1); Jplus;
Modular abelian variety JZero(22) of dimension 2 and level 2*11 over Q 
with sign 1
&gt; Sign(Jplus);
1
&gt; Sign(JZero(22));
0
</PRE>
Notice that the sign is printed out when it is 1 or -1.  Also,
sign 0 is shorthand for "no sign", i.e., working with the full
homology.  
<HR>
<H3><A NAME = "18134">Example <TT>ModAbVar_additional2 (H142E39)</TT></A></H3>
Let eps:(Z/NZ)<sup> * </sup>to Q(&zeta;<sub>n</sub>)<sup> * </sup> be Dirichlet character. The command 
<TT>ModularAbelianVariety(eps)</TT> creates the modular abelian
variety <I>over Q</I> corresponding to the cusp forms with
Dirichlet character any Galois conjugate of eps.
<P>
<P>
<PRE>
&gt; G&lt;eps&gt; := DirichletGroup(22,CyclotomicField(EulerPhi(22)));
&gt; Order(eps);
10
&gt; Conductor(eps);
11
&gt; A := ModularAbelianVariety(eps); A;
Modular abelian variety of dimension 0 and level 2*11 over Q
&gt; A := ModularAbelianVariety(eps^2); A;
Modular abelian variety of dimension 4 and level 2*11 over Q
</PRE>
<HR>
<H3><A NAME = "18135">Example <TT>ModAbVar_additional3 (H142E40)</TT></A></H3>
Let H be a subgroup of G=(Z/NZ)<sup> * </sup>.
The group (Z/NZ)<sup> * </sup> acts by diamond bracket operators as
a group of automorphisms on X<sub>1</sub>(N), and 
the modular curve X<sub>H</sub>(N) is the quotient of X<sub>1</sub>(N)
by the action of H.  Thus if H=1, then X<sub>H</sub>(N)=X<sub>1</sub>(N),
and if H=G, then X<sub>H</sub>(N)=X<sub>0</sub>(N).
The command <TT>JH(N,d)</TT> creates an abelian
variety <I>isogenous to</I> the Jacobian of X<sub>H</sub>(N), 
where d is the index of H in G (thus d=1 
corresponds to J<sub>0</sub>(N)). A weight k and sign (either 
0 or &#8723; 1) can be provided.
More precisely, <TT>JH(N,d)</TT> is the product of 
J(eps), where eps varies over Dirichlet characters
such that eps(H)={1}.
<P>
<P>
<PRE>
&gt; JH(22,1);
Modular abelian variety JZero(22) of dimension 2 and level 2*11 over Q
&gt; JH(22,10);
Modular abelian variety Js(22) of dimension 6 and level 2*11 over Q
&gt; JH(22,2);
Modular abelian variety J_H(22) of dimension 2 and level 2*11 over Q
</PRE>
As a shortcut, the command <TT>Js(N)</TT> creates a 
modular abelian variety that is isogenous to J<sub>1</sub>(N).  
Thus <TT>Js(N)</TT> is the same as <TT>JH(N,d)</TT>, where d is the
order of (Z/NZ)<sup> * </sup>.
<P>
<P>
<PRE>
&gt; Js(22);
Modular abelian variety Js(22) of dimension 6 and level 2*11 over Q
&gt; JH(22,10) eq Js(22);
true
</PRE>
<HR>
<H3><A NAME = "18136">Example <TT>ModAbVar_additional4 (H142E41)</TT></A></H3>
We can also create modular abelian varieties attached to 
spaces of modular forms and spaces of modular symbols:
<P>
<P>
<PRE>
&gt; ModularAbelianVariety(ModularForms(22));
Modular abelian variety of dimension 2 and level 2*11 over Q
&gt; ModularAbelianVariety(ModularSymbols(22));
Modular abelian variety of dimension 2 and level 2*11 over Q
</PRE>
<HR>
<H3><A NAME = "18137">Example <TT>ModAbVar_additional5 (H142E42)</TT></A></H3>
Here is another example, in which the space of modular forms
is on &Gamma;<sub>1</sub>(25).
<P>
<P>
<PRE>
&gt; M := ModularForms(Gamma1(25)); M;
Space of modular forms on Gamma_1(25) of weight 2 and dimension 
39 over Integer Ring.
&gt; S := CuspidalSubspace(M); S;
Space of modular forms on Gamma_1(25) of weight 2 and dimension 
12 over Integer Ring.
&gt; A := ModularAbelianVariety(S); A;
Modular abelian variety of dimension 12 and level 5^2 over Q
</PRE>
<HR>
<H3><A NAME = "18138">Example <TT>ModAbVar_additional6 (H142E43)</TT></A></H3>
We can also construct abelian varieties attached to newforms.
<P>
<P>
<PRE>
&gt; S := CuspForms(43);
&gt; N := Newforms(S); N;
[* [*
q - 2*q^2 - 2*q^3 + 2*q^4 - 4*q^5 + 4*q^6 + O(q^8)
*], [*
q + a*q^2 - a*q^3 + (-a + 2)*q^5 - 2*q^6 + (a - 2)*q^7 + O(q^8),
q + b*q^2 - b*q^3 + (-b + 2)*q^5 - 2*q^6 + (b - 2)*q^7 + O(q^8)
*] *]
&gt; f := N[2][1]; f;
q + a*q^2 - a*q^3 + (-a + 2)*q^5 - 2*q^6 + (a - 2)*q^7 + O(q^8)
&gt; A := ModularAbelianVariety(f); A;
Modular abelian variety Af of dimension 2 and level 43 over Q
&gt; Newform(A);
q + a*q^2 - a*q^3 + (-a + 2)*q^5 - 2*q^6 + (a - 2)*q^7 + O(q^8)
</PRE>
When possible, we can also obtain a newform that gives rise to
an abelian variety.
<P>
<P>
<PRE>
&gt; J := JZero(43);
&gt; D := Decomposition(J); D;
[
    Modular abelian variety 43A of dimension 1, level 43 and 
    conductor 43 over Q,
    Modular abelian variety 43B of dimension 2, level 43 and 
    conductor 43^2 over Q
]
&gt; Newform(D[2]);
q + a*q^2 - a*q^3 + (-a + 2)*q^5 - 2*q^6 + (a - 2)*q^7 + O(q^8)
</PRE>
<P>
We demonstrate here how modular abelian varieties may be described by a label, 
using the string "43B".  Continuing the previous code, we have:
<P>
<P>
<PRE>
&gt; A := ModularAbelianVariety("43B");
&gt; A eq D[2];
true
</PRE>
<HR>
<PRE></PRE> <A  HREF = "text1638.htm">[Next]</A><A  HREF = "text1636.htm">[Prev]</A> <A  HREF = "text1638.htm">[Right]</A> <A  HREF = "text1636.htm">[Left]</A> <A  HREF = "text1635.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<br><small>Version: V2.22 of <I>
Thu Jun  9 16:37:49 EST 2016
</I></small>
</body></html>