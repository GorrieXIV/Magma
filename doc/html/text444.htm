<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <link rel='stylesheet' href='help.css' type='text/css'>
  <TITLE>Creation of Algebraic Function  Fields and their Orders</TITLE>
</head>
<body BGCOLOR="#FFFFFF">

 <A  HREF = "text445.htm">[Next]</A><A  HREF = "text443.htm">[Prev]</A> <A  HREF = "text445.htm">[Right]</A> <A  HREF = "text443.htm">[Left]</A> <A  HREF = "text442.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<PRE></PRE><H3><A NAME = "4515">Creation of Algebraic Function  Fields and their Orders</A></H3>




<H5>Subsections</H5>
<UL>
<LI> <A  HREF = "text444.htm#4516">Creation of Algebraic Function Fields</A>
<LI> <A  HREF = "text444.htm#4528">Creation of Orders of Algebraic Function Fields</A>
<LI> <A  HREF = "text444.htm#4548">Orders and Ideals</A>
</UL>
<H4><A NAME = "4516">Creation of Algebraic Function Fields</A></H4>



<H5><A NAME = "4517">ext&lt; K | f &gt; : FldFunRat, RngUPolElt -&gt; FldFun</A></H5>
<H5>ext&lt; K | f &gt; : FldFun, RngUPolElt -&gt; FldFun</H5>
<H5>FunctionField(f : parameters) : RngUPolElt -&gt; FldFun</H5>

<PRE>    Check: BoolElt                      Default: <TT>true</TT></PRE>

<PRE>    Global: BoolElt                     Default: <TT>true</TT></PRE>
<BLOCKQUOTE>
Let k be a field and K = k(x) or K = k(x, &alpha;<sub>1</sub>, ..., &alpha;<sub>r</sub>) 
some finite extension of k(x). 
Given an irreducible and
separable polynomial f &isin;K[y] of degree greater than zero with
coefficients within K, create the
algebraic function field F= K[y] / &lt; f &gt; = k(x, &alpha;<sub>1</sub>, ...,
&alpha;<sub>r</sub>, &alpha;)
obtained by adjoining a root &alpha; of f to K.  F will be
viewed as a (finite) extension of K.  The polynomial f is also
allowed to be &isin;k[x][y].
<P>
<P>
The optional parameter <TT>Check</TT> may be used to prevent some conditions
from being tested. The default is <TT>Check := true</TT>,
so that f is verified to be irreducible and separable.
The optional parameter <TT>Global</TT> may be used to allow another copy of the 
field to be returned if it is set to <TT>false</TT>, otherwise if a field has already
been constructed using f over K and has not been deleted
then the existing field will be returned.
<P>
 The angle bracket notation may be used to assign the root
&alpha; to an identifier: <TT>F&lt;a&gt; := FunctionField(f)</TT>. 
</BLOCKQUOTE>
<H5><A NAME = "4518">FunctionField(f : parameters) : RngMPolElt -&gt; FldFun</A></H5>

<PRE>    Check: BoolElt                      Default: <TT>true</TT></PRE>

<PRE>    Global: BoolElt                     Default: <TT>true</TT></PRE>
<BLOCKQUOTE>
Let k be a field. Given an irreducible polynomial f &isin;k[x, y] of
degree greater than zero, create the algebraic function field F which
is the 
field of fractions of k[x, y] / &lt; f &gt;. 
The polynomial f must be
separable in at least one variable. F will be viewed as (infinite) extension
of k.
<P>
<P>
The optional parameter <TT>Check</TT> may be used to prevent some
conditions from being tested. The default is <TT>Check := true</TT>, so
that f is verified to be irreducible and separable in at least one
variable.
The optional parameter <TT>Global</TT> may be used to allow another copy of the 
field to be returned if it is set to <TT>false</TT>, otherwise if a field has already
been constructed using f over K and has not been deleted
then the existing field will be returned.
<P>
 The angle bracket notation may be used to assign the images of
x, y in F to identifiers: <TT>F&lt;a, b&gt; := FunctionField(f)</TT>.
</BLOCKQUOTE>
<H5><A NAME = "4519">FunctionField(S) : [RngUPolElt] -&gt; FldFun</A></H5>

<PRE>    Check: BoolElt                      Default: <TT>true</TT></PRE>
<BLOCKQUOTE>
Return the function field F whose defining polynomials are the polynomials
in the sequence S. If <TT>Check</TT> is set to <TT>false</TT> then it will 
not be checked the polynomials actually define a field.
</BLOCKQUOTE>
<H5><A NAME = "4520">HermitianFunctionField(p, d) : RngIntElt, RngIntElt -&gt; FldFun</A></H5>
<H5>HermitianFunctionField(q) : RngIntElt -&gt; FldFun</H5>
<BLOCKQUOTE>
Create the Hermitian function field F = GF(q<sup>2</sup>)(x, &alpha;) defined by
&alpha;<sup>q</sup> + &alpha; = x<sup>q + 1</sup>, where q is the d-th power of the
prime number p.
</BLOCKQUOTE>
<H5><A NAME = "4521">sub&lt;F | S&gt; : FldFun, [] -&gt; FldFun</A></H5>
<H5>sub&lt;F | s<sub>1</sub>, ..., s<sub>r</sub> &gt; : FldFun, [] -&gt; FldFun</H5>
<BLOCKQUOTE>
The subfield of the function field F containing the elements in the
sequence S or the elements s<sub>i</sub>.
</BLOCKQUOTE>
<H5><A NAME = "4522">AssignNames(~F, s) : FldFun, [ MonStgElt ] -&gt;</A></H5>
<H5>AssignNames(~a, s) : FldFunElt, [ MonStgElt ] -&gt;</H5>
<BLOCKQUOTE>
Procedure to change the name of the generating element(s) in the
function field F (a in F) to the contents of the sequence of strings s,
which must have length 1 or 2 in this case.
<P>
<P>
This procedure only changes the name(s) used in printing the elements of F.
It does <I>not</I> assign to any identifier(s)
the value(s) of the generator(s) in F; to do this, use an 
assignment statement, or use angle brackets when creating the field.
<P>
<P>
Note that since this is a procedure that modifies F,
it is necessary to have a reference <TT>~F</TT> to F (or a)
in the call to this function.
</BLOCKQUOTE>
<H5><A NAME = "4523">FunctionField(R) : Rng -&gt; FldFunG</A></H5>

<PRE>    Global: BoolElt                     Default: <TT>true</TT></PRE>

<PRE>    Type: Cat                           Default: {hbox <TT>FldFunRat</TT>}</PRE>
<BLOCKQUOTE>
Return the rational function field over R in one variable. If <TT>Global</TT>
is <TT>false</TT> then create a new copy of the field, otherwise reuse any 
globally created field which already exists. If <TT>Type</TT> is <TT>FldFun</TT>
create the field as an algebraic function field, 
otherwise create as a rational function field.
<P>
</BLOCKQUOTE>
<HR>
<H3><A NAME = "4524">Example <TT>FldFunG_Creation (H44E1)</TT></A></H3>
<P>
Let GF(5) be the finite field of five elements.
To create the function field extension GF(5)(x, &alpha;) / GF(5)(x), 
where &alpha; satisfies &alpha;<sup>2</sup> = 1/x, one may proceed in the
following, equivalent ways:
<P>
<P>
<P>
<PRE>
&gt; R&lt;x&gt; := FunctionField(GF(5));
&gt; P&lt;y&gt; := PolynomialRing(R);
&gt; F&lt;alpha&gt; := FunctionField(y^2 - 1/x);
&gt; F;
Algebraic function field defined over Univariate rational function field over
GF(5)
Variables: x by
y^2 + 4/x
</PRE>
or
<P>
<P>
<PRE>
&gt; R&lt;x&gt; := PolynomialRing(GF(5));
&gt; P&lt;y&gt; := PolynomialRing(R);
&gt; F&lt;alpha&gt; := FunctionField(x*y^2 - 1);
&gt; F;
Algebraic function field defined over Univariate rational function field over
GF(5)
Variables: x by
x*y^2 + 4
</PRE>
or
<P>
<P>
<PRE>
&gt; R&lt;x&gt; := FunctionField(GF(5));
&gt; P&lt;y&gt; := PolynomialRing(R);
&gt; F&lt;alpha&gt; := ext&lt; R | y^2 - 1/x &gt;;
&gt; F;
Algebraic function field defined over Univariate rational function field over
GF(5)
Variables: x by
y^2 + 4/x
</PRE>
<HR>
<H3><A NAME = "4525">Example <TT>FldFunG_creation-rel (H44E2)</TT></A></H3>
An extension of F may be created as follows.
<P>
<P>
<PRE>
&gt; R&lt;y&gt; := PolynomialRing(F);
&gt; FF&lt;beta&gt; := FunctionField(y^3 - x/alpha : Check := false);
&gt; FF;
Algebraic function field defined over F by
y^3 + 4*x^2*alpha
</PRE>
<HR>
<H3><A NAME = "4526">Example <TT>FldFunG_creation-non-simple (H44E3)</TT></A></H3>
To create a non--simple extension:
<P>
<P>
<P>
<PRE>
&gt; R&lt;x&gt; := FunctionField(GF(5));
&gt; P&lt;y&gt; := PolynomialRing(R);
&gt; FF&lt;alpha, beta&gt; := FunctionField([y^2 - 1/x, y^3 + x]);
&gt; FF;
Algebraic function field defined over Univariate rational function field over 
GF(5) by
y^2 + 4/x
y^3 + x
</PRE>
<P>
or
<P>
<P>
<P>
<PRE>
&gt; P&lt;y&gt; := PolynomialRing(F);
&gt; FF&lt;beta, gamma&gt; := FunctionField([y^2 - x/alpha, y^3 + x]);
&gt; FF;
Algebraic function field defined over F by
y^2 + 4*x^2*alpha
y^3 + x
</PRE>
<HR>
<H3><A NAME = "4527">Example <TT>FldFunG_creation_herm (H44E4)</TT></A></H3>
<P>
The creation of an Hermitian function field:
<P>
<P>
<P>
<PRE>
&gt; F := HermitianFunctionField(9);
&gt; F;
Algebraic function field defined over GF(3^4) by
y^9 + y + 2*x^10
</PRE>
<HR>
<H4><A NAME = "4528">Creation of Orders of Algebraic Function Fields</A></H4>

<P>
<P>
<P>
Equation orders, maximal orders and other orders 
of algebraic function fields can be
created.


<H5><A NAME = "4529">EquationOrderFinite(F) : FldFun -&gt; RngFunOrd</A></H5>
<BLOCKQUOTE>
Create the `finite' equation order of the function field 
F/k(x, &alpha;<sub>1</sub>, ..., &alpha;<sub>r</sub>), i.e.
k[x, d<sub>1</sub> &alpha;<sub>1</sub>, ..., d<sub>r</sub> &alpha;<sub>r</sub>, d &alpha;] 
where d<sub>j</sub>, d &isin;k[x] is chosen such that d<sub>j</sub> &alpha;<sub>j</sub>, d &alpha; are
integral over k[x].
</BLOCKQUOTE>
<H5><A NAME = "4530">MaximalOrderFinite(F) : FldFun -&gt; RngFunOrd</A></H5>
<BLOCKQUOTE>
Create the `finite' maximal order of the function field 
F/k(x, &alpha;<sub>1</sub>, ..., &alpha;<sub>r</sub>).
This is the integral closure of k[x, d<sub>1</sub> &alpha;<sub>1</sub>, ..., d<sub>r</sub> &alpha;<sub>r</sub>] 
in F.
</BLOCKQUOTE>
<H5><A NAME = "4531">EquationOrderInfinite(F) : FldFun -&gt; RngFunOrd</A></H5>
<BLOCKQUOTE>
Create the `infinite' equation order of the function field 
F/k(x, &alpha;<sub>1</sub>, ..., &alpha;<sub>r</sub>), i.e.
o<sub>&infin;</sub>[&alpha;<sub>1</sub>, ..., &alpha;<sub>r</sub>, &beta;] 
where o<sub>&infin;</sub> denotes the valuation ring of
the degree valuation in k(x) and &beta; is a primitive element of
F/k(x, &alpha;<sub>1</sub>, ..., &alpha;<sub>r</sub>) which is integral over o<sub>&infin;</sub>.
</BLOCKQUOTE>
<H5><A NAME = "4532">MaximalOrderInfinite(F) : FldFun -&gt; RngFunOrd</A></H5>
<BLOCKQUOTE>
Create the `infinite' maximal order of the function field 
F/k(x, &alpha;<sub>1</sub>, ..., &alpha;<sub>r</sub>).
This is the integral closure of o<sub>&infin;</sub> in F.
</BLOCKQUOTE>
<H5><A NAME = "4533">IntegralClosure(R, F) : Rng, FldFun -&gt; RngFunOrd</A></H5>
<BLOCKQUOTE>
The integral closure of the subring R of the function field F 
in itself.
</BLOCKQUOTE>
<H5><A NAME = "4534">EquationOrder(O) : RngFunOrd -&gt; RngFunOrd</A></H5>
<BLOCKQUOTE>
The equation order of the order O. An order whose basis is a transformation 
of that of O and is a power basis.
</BLOCKQUOTE>
<H5><A NAME = "4535"></A><A NAME = "FldFunG:max_ord_al">MaximalOrder</A>(O) : RngFunOrd -&gt; RngFunOrd</H5>

<PRE>    Discriminant: Any                   Default: </PRE>

<PRE>    Ramification: SeqEnum               Default: </PRE>

<PRE>    Al: MonStgElt                       Default: "Auto"</PRE>

<PRE>    SetVerbose("MaximalOrder", n):      Maximum: 5</PRE>
<BLOCKQUOTE>
The maximal order of the order O of an algebraic function field.
<P>
If O is a radical (pure) extension then specific code is
used to calculate each p-maximal order, rather than the Round 2 
method. 
In this case we can compute a pseudo basis for the p-maximal orders knowing only
the valuation of the constant coefficient of the defining polynomial at
p <A  HREF = "text441.htm#bib_suth-max-kummer">[Sut12]</A>.
<P>
<P>
If O is an Artin--Schreier extension then the maximal order can be computed
directly without computing the p-maximal orders. The proof of 
Proposition III.7.8 of <A  HREF = "text441.htm#bib_Stichtenoth">[Sti93]</A> gives us a start on some elements
which are a basis for the maximal order <A  HREF = "text441.htm#bib_suth-artin">[Sut13]</A>.
<P>
If the <TT>Discriminant</TT> or <TT>Ramification</TT> parameters are supplied an
algorithm (<A  HREF = "text441.htm#bib_buchman-lenstra">[BL94]</A>, Theorems 1.2 and 7.6) which can compute the maximal order given 
the discriminant of the
maximal order will be used. <TT>Discriminant</TT> must be an element of 
the coefficient ring of O if O
is a non relative order and must be an ideal of O
if O is a relative order. <TT>Ramification</TT>
must contain elements of the coefficient ring if O is a non relative order and
must contain ideals of O if O is a relative order.
The ramification sequence is taken to contain prime
factors of the discriminant. Only one of these parameters can be specified
and if one of them is then <TT>Al</TT> cannot be specified. Otherwise <TT>Al</TT> may
be set to <TT>"Round2"</TT> to avoid using the algorithms for the special cases 
above.
</BLOCKQUOTE>
<H5><A NAME = "4536">SetOrderMaximal(O, b) : RngFunOrd, BoolElt -&gt;</A></H5>
<BLOCKQUOTE>
Set the order O of a function field to be maximal if b is <TT>true</TT>
and to be non--maximal if b is <TT>false</TT>.
</BLOCKQUOTE>
<H5><A NAME = "4537">ext&lt;O | f&gt; : RngFunOrd, RngUPolElt -&gt; RngFunOrd</A></H5>

<PRE>    Check: Bool                         Default: <TT>true</TT></PRE>
<BLOCKQUOTE>
The order O with a root of f adjoined.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "4538">Example <TT>FldFunG_orders (H44E5)</TT></A></H3>
Creation of orders is shown below.
<P>
<P>
<PRE>
&gt; PR&lt;x&gt; := PolynomialRing(Rationals());
&gt; P&lt;y&gt; := PolynomialRing(PR);
&gt; FR1&lt;a&gt; := FunctionField(y^3 - x*y^2 + y + x^4);
&gt; P&lt;y&gt; := PolynomialRing(FR1);
&gt; FR2&lt;c&gt; := FunctionField(y^2 + y - a/x^5);
&gt; EFR1F := EquationOrderFinite(FR1);
&gt; MFR1F := MaximalOrderFinite(FR1);
&gt; EFR1I := EquationOrderInfinite(FR1);
&gt; MFR1I := MaximalOrderInfinite(FR1);
&gt; EFR2F := EquationOrderFinite(FR2);
&gt; MFR2F := MaximalOrderFinite(FR2);
&gt; EFR2I := EquationOrderInfinite(FR2);
&gt; MFR2I := MaximalOrderInfinite(FR2);
&gt; MaximalOrder(EFR2I); 
&gt;&gt; MaximalOrder(EFR2I);
               ^
Runtime error in 'MaximalOrder': Order must be defined over a maximal order
&gt; MFR2I;
Maximal Order of FR2 over MFR1I
&gt; P&lt;y&gt; := PolynomialRing(FR1);
&gt; MaximalOrder(ext&lt;MFR1F | y^2 + y - a*x^5&gt;); MFR2F;
Maximal Equation Order of Algebraic function field defined over FR1 by
y^2 + y - x^5*a over EFR1F
Maximal Order of FR2 over EFR1F
&gt; MaximalOrder(ext&lt;MFR1I | y^2 - 1/a&gt;);
Maximal Order of Algebraic function field defined over FR1 by
y^2 + 1/x^4*a^2 - 1/x^3*a + 1/x^4 over MFR1I
</PRE>
<HR>
<H3><A NAME = "4539">Example <TT>FldFunG_int_cl (H44E6)</TT></A></H3>
<P>
<P>
<PRE>
&gt; R&lt;x&gt; := FunctionField(GF(5));
&gt; P&lt;y&gt; := PolynomialRing(R);
&gt; f := y^3 + (4*x^3 + 4*x^2 + 2*x + 2)*y^2 + (3*x + 3)*y + 2;
&gt; F&lt;alpha&gt; := FunctionField(f);
&gt; IntegralClosure(R, F);
Algebraic function field defined over GF(5) by
y^3 + (4*x^3 + 4*x^2 + 2*x + 2)*y^2 + (3*x + 3)*y + 2
&gt; IntegralClosure(PolynomialRing(GF(5)), F);
Maximal Order of F over Univariate Polynomial Ring in x over GF(5)
&gt; IntegralClosure(ValuationRing(R), F);
Maximal Order of F over Valuation ring of Rational function field of 
rank 1 over GF(5)
Variables: x with generator 1/x
</PRE>
<HR>
<H5><A NAME = "4540">Order(O, T, d) : RngFunOrd, AlgMatElt, RngElt -&gt; RngFunOrd</A></H5>

<PRE>    Check: BoolElt                      Default: <TT>true</TT></PRE>
<BLOCKQUOTE>
Create the order whose basis is that of the order O multiplied by the matrix
T over the coefficient ring of O divided by the scalar d. If
the parameter <TT>Check</TT> is set to <TT>false</TT> then it will not be checked
that the result is actually an order (potentially expensive).
Note that this can result in a non-order being constructed which may cause errors later.
</BLOCKQUOTE>
<H5><A NAME = "4541">Order(O, M) : RngFunOrd, ModDed -&gt; RngFunOrd</A></H5>

<PRE>    NFBasis: BoolElt                    Default: <TT>true</TT></PRE>

<PRE>    Check: BoolElt                      Default: <TT>true</TT></PRE>
<BLOCKQUOTE>
Create the order whose basis is that of the order O multiplied by 
the dedekind module M. If the parameter
<TT>Check</TT> is set to <TT>false</TT> then it will not be checked that the result
is actually an order (potentially expensive).
Note that this can result in a non-order being constructed which may cause errors later.
If the parameter <TT>NFBasis</TT> is set to <TT>false</TT> then the <TT>PseudoGenerators</TT>
of the module M will be used rather than the <TT>PseudoBasis</TT>, however these
pseudo generators must also be a pseudo basis.
</BLOCKQUOTE>
<H5><A NAME = "4542">Order(O, S) : RngFunOrd, [FldFunElt] -&gt; RngFunOrd</A></H5>

<PRE>    Verify: BoolElt                     Default: <TT>true</TT></PRE>

<PRE>    Order: BoolElt                      Default: <TT>false</TT></PRE>
<BLOCKQUOTE>
Given a sequence S of elements in an algebraic function field F create the 
minimal order R of F which contains all elements of S.
<P>
The order O may be an order of F
which will be used as the suborder of R, in which case its
coefficient ring should be maximal, or O may be a maximal order of the
coefficient field of F.
<P>
If <TT>Verify</TT> is <TT>true</TT>, it is verified that the elements of S are integral
algebraic numbers. This can be a lengthy process if the field is of large
degree.
<P>
Setting <TT>Order</TT> to <TT>true</TT> assumes that the given elements actually
form a basis for the new order, thus it avoids testing for multiplicative
closure. Without this parameter the order returned will have a canonical
basis chosen with no direct relation to the input.
By default, products of the generators will be added until the module is closed
under multiplication.
Note that setting <TT>Order</TT> to <TT>true</TT> can result in a non-order 
being constructed if the elements in the sequence are not a basis
which may cause errors later.
<P>
If <TT>Order</TT> is set to <TT>true</TT> to specify the basis of the resulting order
rather than avoid the expense of the multiplicative closure computation, it can
be checked that the result O is an order using
<TT>Order(SubOrder(O), Matrix(CoefficientRing(O), M*d), d) where d is Denominator(M)
where M is BasisMatrix(O);</TT>. If O is not an order this will cause an error.
</BLOCKQUOTE>
<H5><A NAME = "4543">Simplify(O) : RngFunOrd -&gt; RngFunOrd</A></H5>
<BLOCKQUOTE>
Return the order O as a direct transformation of its equation order, instead
of a composition of transformations.
</BLOCKQUOTE>
<H5><A NAME = "4544">O1 + O2 : RngFunOrd, RngFunOrd -&gt; RngFunOrd</A></H5>
<BLOCKQUOTE>
The smallest common over order of O1 and O2 where O1 and O2 have the
same equation order.
</BLOCKQUOTE>
<H5><A NAME = "4545">O1 meet O2 : RngFunOrd, RngFunOrd -&gt; RngFunOrd</A></H5>
<BLOCKQUOTE>
The intersection of orders O1 and O2 which must have the same equation 
order.
</BLOCKQUOTE>
<H5><A NAME = "4546">AsExtensionOf(O1, O2) : RngFunOrd, RngFunOrd -&gt; RngFunOrd</A></H5>
<BLOCKQUOTE>
Return the order O1 as a transformation of the order O2 where O1
and O2 have the same coefficient ring.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "4547">Example <TT>FldFunG_order-create-more (H44E7)</TT></A></H3>
Some of the above order creations are shown below.
<P>
<P>
<PRE>
&gt; P&lt;x&gt; := PolynomialRing(GF(5));
&gt; P&lt;y&gt; := PolynomialRing(P);
&gt; F&lt;a&gt; := FunctionField(y^3 - x^4);
&gt; O := Order(EquationOrderFinite(F), MatrixAlgebra(Parent(x), 3)!1, Parent(x)!3);
&gt; O;
Order of F over Univariate Polynomial Ring in x over GF(5)
&gt; Basis(O);
[
    2,
    2*a,
    2*a^2
]
&gt; P&lt;y&gt; := PolynomialRing(O);
&gt; EO := ext&lt;MaximalOrder(O) | y^2 + O!(2*a)&gt;;
&gt; V := KModule(F, 2);
&gt; M := Module([V | [1, 0], [4, 3], [9, 2]]);
&gt; M;
Module over Maximal Order of F over Univariate Polynomial Ring in x over GF(5)
Ideal of Maximal Order of F over Univariate Polynomial Ring in x over GF(5)
Generator:
1 car Ideal of Maximal Order of F over Univariate Polynomial Ring in x over 
GF(5)
Generator:
2
&gt; O2 := Order(EO, M);
&gt; O2;
Order of Algebraic function field defined over F by
$.1^2 + 2*a over Maximal Order of F over Univariate Polynomial Ring in x over 
GF(5)
Transformation of EO

Transformation Matrix:
[[ 1, 0, 0 ] [ 0, 0, 0 ]]
[[ 0, 0, 0 ] [ 1, 0, 0 ]]
&gt; Basis(O2);
[ 1, $.1 ]
</PRE>
<HR>
<H4><A NAME = "4548">Orders and Ideals</A></H4>

<P>
<P>
<P>
Orders may be created using ideals of other orders. Ideals are discussed in
Section <A  HREF = "text454.htm#4777">Ideals</A>.


<H5><A NAME = "4549">MultiplicatorRing(I) : RngFunOrdIdl -&gt; RngFunOrd</A></H5>
<BLOCKQUOTE>
Returns the multiplicator ring of the ideal I of the order O, that is,
the subring of elements of the field of fractions of O that multiply
I into itself.
</BLOCKQUOTE>
<H5><A NAME = "4550">pMaximalOrder(O, p) : RngFunOrd, RngFunOrdIdl -&gt; RngFunOrd</A></H5>
<H5>pMaximalOrder(O, p) : RngFunOrd, RngElt -&gt; RngFunOrd</H5>
<BLOCKQUOTE>
The p-maximal over order of O where p is a prime polynomial or ideal
of the coefficient ring of O or an element of valuation 1 of the valuation
ring. 
<P>
If O is a Kummer extension then specific code is
used to calculate each p-maximal order, rather than the Round 2
method. In this case we know 1 or 2 elements which generate the p-maximal
order and can write the order down.
<P>
If O is an Artin--Schreier extension then we can also write down a basis
for the p-maximal order and avoid the Round 2 algorithm. We use 
<A  HREF = "text441.htm#bib_Stichtenoth">[Sti93]</A> Proposition III.7.8 to get a start on computing these
elements.
</BLOCKQUOTE>
<H5><A NAME = "4551">pRadical(O, p) : RngFunOrd, RngFunOrdIdl -&gt; RngFunOrdIdl</A></H5>
<H5>pRadical(O, p) : RngFunOrd, RngElt -&gt; RngFunOrdIdl</H5>
<BLOCKQUOTE>
Returns the p-radical of an order O for a prime p (polynomial or ideal
of the coefficient ring or element of valuation 1 of the valuation ring), 
defined as
the ideal consisting of elements of O for which some power lies in the
ideal pO.
<P>
It is possible to call this function even if p is not prime. In this case
the p-trace-radical will be computed, i.e.
{ x&isin;F | Tr(xO)&sube;C} for F the field of fractions of O
and C the order of p (if p is an ideal) or the parent of p otherwise.
If p is square free and all divisors are larger than the field
degree, this is the intersection of the radicals for all l dividing
p. 
</BLOCKQUOTE>
<PRE></PRE> <A  HREF = "text445.htm">[Next]</A><A  HREF = "text443.htm">[Prev]</A> <A  HREF = "text445.htm">[Right]</A> <A  HREF = "text443.htm">[Left]</A> <A  HREF = "text442.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<br><small>Version: V2.22 of <I>
Thu Jun  9 16:37:49 EST 2016
</I></small>
</body></html>