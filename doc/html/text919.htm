<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <link rel='stylesheet' href='help.css' type='text/css'>
  <TITLE>Operations on Algebras and their Elements</TITLE>
</head>
<body BGCOLOR="#FFFFFF">

 <A  HREF = "text920.htm">[Next]</A><A  HREF = "text918.htm">[Prev]</A> <A  HREF = "text920.htm">[Right]</A> <A  HREF = "text918.htm">[Left]</A> <A  HREF = "text916.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<PRE></PRE><H3><A NAME = "10340">Operations on Algebras and their Elements</A></H3>




<H5>Subsections</H5>
<UL>
<LI> <A  HREF = "text919.htm#10341">Operations on Algebras</A>
<LI> <A  HREF = "text919.htm#10353">Operations on Elements</A>
<LI> <A  HREF = "text919.htm#10358">Representations</A>
<LI> <A  HREF = "text919.htm#10362">Decomposition of an Algebra</A>
</UL>
<H4><A NAME = "10341">Operations on Algebras</A></H4>



<H5><A NAME = "10342">Centre(A) : AlgAss -&gt; AlgAss</A></H5>
<BLOCKQUOTE>
The centre of the associative algebra A.
</BLOCKQUOTE>
<H5><A NAME = "10343">Centralizer(A, S) : AlgAss, AlgAss -&gt; AlgAss</A></H5>
<H5>Centraliser(A, S) : AlgAss, AlgAss -&gt; AlgAss</H5>
<BLOCKQUOTE>
The centralizer of the subalgebra S of the associative algebra A, that is,
the subalgebra of A commuting elementwise with S.
</BLOCKQUOTE>
<H5><A NAME = "10344">Idealizer(A, B: parameters) : AlgAss, AlgAss -&gt; AlgAss</A></H5>
<H5>Idealiser(A, B: parameters) : AlgAss, AlgAss -&gt; AlgAss</H5>

<PRE>    Side: MonStgElt                     Default: "Both"</PRE>
<BLOCKQUOTE>
Given an associative algebra A and a subalgebra B of A,
compute the idealizer of B in A, that is, the largest subalgebra of A
in which B is an ideal.
By default the two-sided idealizer, that is, the largest subalgebra in which B
is a two-sided ideal, is found;
the left- or right-idealizer can be found by setting the parameter
<TT>Side</TT> to <TT>"Left"</TT> or <TT>"Right"</TT> respectively.
</BLOCKQUOTE>
<H5><A NAME = "10345">LieAlgebra(A) : AlgAss -&gt; AlgGen, Map</A></H5>
<BLOCKQUOTE>
For an associative structure constant algebra A, return the structure
constant algebra L with product given by the Lie bracket 
(a, b) |-&gt; a * b - b * a.
As a second value the map identifying the elements of A and L is returned.
</BLOCKQUOTE>
<H5><A NAME = "10346">CommutatorModule(A, B) : AlgAss, AlgAss -&gt; ModTupRng</A></H5>
<BLOCKQUOTE>
Let A and B be subalgebras of an associative algebra with underlying
module M.
This function returns the submodule of M which is spanned by the elements
[a, b] = a * b - b * a, a &isin;A, b &isin;B.
</BLOCKQUOTE>
<H5><A NAME = "10347">CommutatorIdeal(A, B) : AlgAss, AlgAss -&gt; AlgAss</A></H5>
<BLOCKQUOTE>
For two subalgebras A and B of an associative algebra, return the ideal
generated by all [a, b] = a * b - b * a, a &isin;A, b &isin;B.
</BLOCKQUOTE>
<H5><A NAME = "10348">LeftAnnihilator(A, B) : AlgAss, AlgAss -&gt; AlgAss, AlgAss</A></H5>
<BLOCKQUOTE>
For two subalgebras A and B of an associative algebra, return the
left annihilator of B in A; that is, the subalgebra of A
consisting of all elements a such that a * b = 0 for all b &isin;B.
</BLOCKQUOTE>
<H5><A NAME = "10349">RightAnnihilator(A, B) : AlgAss, AlgAss -&gt; AlgAss, AlgAss</A></H5>
<BLOCKQUOTE>
For two subalgebras A and B of an associative algebra, return the
right annihilator of B in A; that is, the subalgebra of A
consisting of all elements a such that b * a = 0 for all b &isin;B.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "10350">Example <TT>AlgAss_liealg (H86E1)</TT></A></H3>
<P>
We create the Lie algebra sl<sub>3</sub>(Q) as a structure constant algebra.
First, we construct gl<sub>3</sub>(Q) from the full matrix algebra M<sub>3</sub>(Q) and
get sl<sub>3</sub>(Q) as the derived algebra of gl<sub>3</sub>(Q).
<P>
<P>
<PRE>
&gt; gl3 := LieAlgebra(Algebra(MatrixRing(Rationals(), 3)));
&gt; sl3 := gl3 * gl3;
&gt; sl3;
Lie Algebra of dimension 8 with base ring Rational Field
</PRE>
Let's see how the first basis element acts.
<P>
<P>
<PRE>
&gt; for i in [1..8] do
&gt;     print sl3.i * sl3.1;
&gt; end for;
(0 0 0 0 0 0 0 0)
( 0 -1  0  0  0  0  0  0)
( 0  0 -2  0  0  0  0  0)
(0 0 0 1 0 0 0 0)
(0 0 0 0 0 0 0 0)
( 0  0  0  0  0 -1  0  0)
(0 0 0 0 0 0 2 0)
(0 0 0 0 0 0 0 1)
</PRE>
Since it acts diagonally, this element lies in a Cartan subalgebra. The next
candidate seems to be the fifth basis element.
<P>
<P>
<PRE>
&gt; for i in [1..8] do
&gt;     print sl3.i * sl3.5;
&gt; end for;
(0 0 0 0 0 0 0 0)
(0 1 0 0 0 0 0 0)
( 0  0 -1  0  0  0  0  0)
( 0  0  0 -1  0  0  0  0)
(0 0 0 0 0 0 0 0)
( 0  0  0  0  0 -2  0  0)
(0 0 0 0 0 0 1 0)
(0 0 0 0 0 0 0 2)
</PRE>
This also acts diagonally and commutes with <TT>sl3.1</TT>, hence we have luckily
found a full Cartan algebra in sl<sub>3</sub>(Q).
We can now easily work out the root system. Obviously the root spaces
correspond to the pairs <TT>(sl3.2, sl3.4)</TT>, <TT>(sl3.3, sl3.7)</TT> and 
<TT>(sl3.6, sl3.8)</TT>. The product of a positive root with its negative should 
lie in the Cartan algebra.
<P>
<P>
<PRE>
&gt; sl3.2*sl3.4;
( 1  0  0  0 -1  0  0  0)
&gt; sl3.3*sl3.7;
(1 0 0 0 0 0 0 0)
&gt; sl3.6*sl3.8;
(0 0 0 0 1 0 0 0)
</PRE>
Clearly some choices have to be made and we fix <TT>sl3.3</TT> as the element
e<sub>&alpha;</sub> corresponding to the first fundamental root &alpha;, <TT>sl3.7</TT>
as e<sub> - &alpha;</sub> and get <TT>sl3.1</TT> as h<sub>&alpha;</sub> = e<sub>&alpha;</sub> * e<sub> - &alpha;</sub>.
For the other fundamental root &beta; we have to find an element
e<sub>&beta;</sub> such that e<sub>&alpha;</sub> * e<sub>&beta;</sub> is non-zero.
<P>
<P>
<PRE>
&gt; sl3.3*sl3.2;
(0 0 0 0 0 0 0 0)
&gt; sl3.3*sl3.4;
( 0  0  0  0  0 -1  0  0)
&gt; sl3.3*sl3.6;
(0 0 0 0 0 0 0 0)
&gt; sl3.3*sl3.8;
(0 1 0 0 0 0 0 0)
</PRE>
We choose <TT>sl3.8</TT> as e<sub>&beta;</sub>, <TT>sl3.6</TT> as e<sub> - &beta;</sub> and
consequently <TT>-sl3.5</TT> as h<sub>&beta;</sub>. This now determines 
e<sub>&alpha; + &beta;</sub> to be <TT>sl3.2</TT> and e<sub> - &alpha; - &beta;</sub> to be 
<TT>sl3.4</TT>.
<HR>
<H5><A NAME = "10351"></A><A NAME = "RestrictionOfScalars">RestrictionOfScalars</A>(A) : AlgAss[FldAlg] -&gt; AlgAss, Map</H5>
<H5>RestrictionOfScalars(A) : AlgAss[FldFun] -&gt; AlgAss, Map</H5>
<H5>RestrictionOfScalars(A, F) : AlgAss[FldAlg], Fld -&gt; AlgAss, Map</H5>
<H5>RestrictionOfScalars(A, F) : AlgAss[FldFun], FldFunG -&gt; AlgAss, Map</H5>
<BLOCKQUOTE>
Given an associative algebra A over an algebraic number or function
field K and an optional
coefficient field F of K, return the algebra isomorphic to A whose 
coefficient field is F if given otherwise the coefficient field of K.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "10352">Example <TT>AlgAss_restrict (H86E2)</TT></A></H3>
We illustrate some computations of restricting scalars, first over the
coefficient field.
<P>
<P>
<PRE>
&gt; P&lt;x&gt; := PolynomialRing(Rationals());
&gt; F&lt;b&gt; := NumberField(x^3-3*x-1);
&gt; Z_F := MaximalOrder(F);
&gt; A&lt;alpha,beta,alphabeta&gt; := QuaternionAlgebra&lt;F | -3,b&gt;;
&gt; A := AssociativeAlgebra(A);
&gt; A;
Associative Algebra of dimension 4 with base ring F
&gt; RA, m := RestrictionOfScalars(A);
&gt; RA;
Associative Algebra of dimension 12 with base ring Rational Field
&gt; m;
Mapping from: AlgAss: A to AlgAss: RA given by a rule
&gt; m(A.1);
(1 0 0 0 0 0 0 0 0 0 0 0)
&gt; $1 @@ m;
(1 0 0 0)
&gt; RA.6 @@ m;
(  0 b^2   0   0)
&gt; m($1);
(0 0 0 0 0 1 0 0 0 0 0 0)
</PRE>
We now show an example where the scalars we are restricting to are not 
necessarily the
coefficient field but a coefficient field of the coefficient field.
<P>
<P>
<PRE>
&gt; P&lt;x&gt; := PolynomialRing(QuadraticField(23));
&gt; F&lt;b&gt; := NumberField(x^3-3*x-1);
&gt; Z_F := MaximalOrder(F);
&gt; A&lt;alpha,beta,alphabeta&gt; := QuaternionAlgebra&lt;F | -3,b&gt;;
&gt; A := AssociativeAlgebra(A);
&gt; RA, m := RestrictionOfScalars(A);
&gt; RA;
Associative Algebra of dimension 12 with base ring Quadratic Field with defining
polynomial x^2 - 23 over the Rational Field
&gt; m;
Mapping from: AlgAss: A to AlgAss: RA given by a rule
&gt; RA.6 @@ m;
(  0 b^2   0   0)
&gt; m($1);
(0 0 0 0 0 1 0 0 0 0 0 0)
&gt; RAQ, mQ := RestrictionOfScalars(A, Rationals());
&gt; RAQ, mQ;
Associative Algebra of dimension 24 with base ring Rational Field
Mapping from: AlgAss: A to AlgAss: RAQ given by a rule
&gt; mQ(A.1);
(1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)
&gt; $1 @@ mQ;
(1 0 0 0)
&gt; RAQ.15 @@ mQ;
(                 0                  0 b^2 + 2*$.1*b + 23                  0)
&gt; mQ($1);
(0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0)
</PRE>
<HR>
<H4><A NAME = "10353">Operations on Elements</A></H4>



<H5><A NAME = "10354">Centralizer(A, s) : AlgAss, AlgAssElt -&gt; AlgAss</A></H5>
<H5>Centraliser(A, s) : AlgAss, AlgAssElt -&gt; AlgAss</H5>
<BLOCKQUOTE>
The centralizer of the element s of the associative algebra A, that is,
the subalgebra of A commuting with s.
</BLOCKQUOTE>
<H5><A NAME = "10355">LieBracket(a, b) : AlgAssElt, AlgAssElt -&gt; AlgAssElt</A></H5>
<H5>(a, b) : AlgAssElt, AlgAssElt -&gt; AlgAssElt</H5>
<BLOCKQUOTE>
The Lie bracket a * b - b * a of a and b, where a and b
are elements of an associative algebra A.
</BLOCKQUOTE>
<H5><A NAME = "10356">IsScalar(a) : AlgAssElt -&gt; BoolElt, RngElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> (and a coerced to F) iff a belongs to the base ring F
of its parent algebra.
</BLOCKQUOTE>
<H5><A NAME = "10357">RepresentationMatrix(a, M : parameters) : AlgAssElt, AlgAss -&gt; AlgMatElt</A></H5>

<PRE>    Side: MonStgElt                     Default: "Right"</PRE>
<BLOCKQUOTE>
Returns the matrix representation of <TT>Side</TT>-multiplication by
the element a in the associative algebra A (which must have 1) on
the A-module M.
</BLOCKQUOTE>
<H4><A NAME = "10358">Representations</A></H4>



<H5><A NAME = "10359">MatrixAlgebra(A) : AlgAss -&gt; AlgMat</A></H5>
<BLOCKQUOTE>
For an associative algebra A of dimension n return an isomorphic
matrix algebra. If A contains the identity-element, the matrix algebra will be
of degree n, otherwise it will be of degree n + 1.
</BLOCKQUOTE>
<H5><A NAME = "10360">MatrixAlgebra(A, M : parameters) : AlgAss, AlgAss -&gt; AlgMat, Map</A></H5>

<PRE>    Side: MonStgElt                     Default: "Right"</PRE>
<BLOCKQUOTE>
Given a finite-dimensional R-algebra A and a <TT>Side</TT> A-module
M (both free as R-modules), return the matrix algebra of 
A-endomorphisms of M, and the R-algebra homomorphism from A
into this endomorphism ring.
</BLOCKQUOTE>
<H5><A NAME = "10361">RegularRepresentation(A : parameters) : AlgAss -&gt; AlgMat, Map</A></H5>

<PRE>    Side: MonStgElt                     Default: "Right"</PRE>
<BLOCKQUOTE>
For an associative algebra A of dimension n over R return its regular
representation.
If B = (e<sub>1</sub>, e<sub>2</sub>, ..., e<sub>n</sub>) is the stored basis for A, an element 
a &isin;A is mapped to the matrix in R<sup>n x n</sup> which has as its i-th
row the coordinates of e<sub>i</sub> * a with respect to B.
As a second map, the homomorphism of A onto the regular representation is
returned.
<P>
<P>
By default, the right-regular representation is computed. This can be changed
to the left-regular representation (in which the i-th row of the image of a
contains the coordinates of a * e<sub>i</sub>) by setting the parameter <TT>Side</TT> to
<TT>"Left"</TT>.
</BLOCKQUOTE>
<H4><A NAME = "10362">Decomposition of an Algebra</A></H4>

<P>
<P>
<P>
This section describes a few functions that can be used to obtain
information on the structure of a finite-dimensional associative algebra.


<H5><A NAME = "10363">JacobsonRadical(A) : AlgAssV -&gt; AlgAssV</A></H5>

<PRE>    Al: MonStgElt                       Default: em "Default"</PRE>
<BLOCKQUOTE>
This returns the largest nilpotent ideal of A. This function works
for finite-dimensional associative algebras defined over a field of
characteristic 0, or over a finite field. 
<P>
The algorithm used by default is taken from <A  HREF = "text915.htm#bib_cohen-ivanyos-wales">[CIW97]</A>.
The meataxe algorithm can be used by setting <TT>Al := "Meataxe"</TT>.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "10364">Example <TT>AlgAss_jac_rad (H86E3)</TT></A></H3>
We compute the Jacobson radical of the group algebra over the field
of three elements of a 3-group. In that case it is equal to the
augmentation ideal.
<P>
<P>
<PRE>
&gt; G:= SmallGroup( 27, 5 );
&gt; A:= GroupAlgebra( GF(3), G );
&gt; JacobsonRadical( A );
Ideal of dimension 26 of the group algebra A
</PRE>
<HR>
<H5><A NAME = "10365">DirectSumDecomposition(A) : AlgAssV -&gt; [ AlgAssV ], [ AlgAssVElt ]</A></H5>
<H5>IndecomposableSummands(A) : AlgAssV -&gt; [ AlgAssV ], [ AlgAssVElt ]</H5>
<BLOCKQUOTE>
Given an associative algebra A, return the direct sum decomposition of L as
a sequence of ideals of L whose sum is L and each of which cannot be
further decomposed into a direct sum of ideals.  The second sequence return 
contains the corresponding primitive central idempotents.
<P>
For a description of the algorithm we refer to <A  HREF = "text915.htm#bib_eberly-giesbrecht">[EG96]</A>.
</BLOCKQUOTE>
<H5><A NAME = "10366">CentralIdempotents(A) : AlgAssV -&gt; SeqEnum, SeqEnum</A></H5>
<BLOCKQUOTE>
Let Z be the centre of the associative algebra A, and let 
J(Z) denote its Jacobson radical. This function returns a
sequence of primitive orthogonal idempotents in Z such that
their images in Z/J(Z) span J(Z). Each such idempotent
generates a two-sided ideal in A. The second return value
is the sequence of these ideals.
<P>
In particular, if A is a semisimple algebra, then this function returns 
a sequence of primitive orthogonal idempotents spanning Z. Furthermore,
the ideals in the second sequence returned are simple algebras, and
their direct sum equals A.
<P>
For a description of the algorithm we refer to <A  HREF = "text915.htm#bib_eberly-giesbrecht">[EG96]</A>.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "10367">Example <TT>AlgAss_id_pots (H86E4)</TT></A></H3>
We compute the direct sum decomposition of a group algebra.
<P>
<P>
<PRE>
&gt; G:= SmallGroup( 10, 2 );
&gt; A:= GroupAlgebra( Rationals(), G );
&gt; ee, II:= CentralIdempotents( A );
&gt; ee[1];
1/10*Id(G) + 1/10*G.2 + 1/10*G.2^2 + 1/10*G.2^3 + 1/10*G.2^4 + 1/10*G.1 + 
1/10*G.1 * G.2 + 1/10*G.1 * G.2^2 + 1/10*G.1 * G.2^3 + 1/10*G.1 * G.2^4
&gt; II;
[
    Ideal of dimension 1 of the group algebra A
    Basis:
        Id(G) + G.2 + G.2^2 + G.2^3 + G.2^4 + G.1 + G.1 * G.2 + G.1 * G.2^2 + 
        G.1 * G.2^3 + G.1 * G.2^4,
    Ideal of dimension 1 of the group algebra A
    Basis:
        Id(G) + G.2 + G.2^2 + G.2^3 + G.2^4 - G.1 - G.1 * G.2 - G.1 * G.2^2 - 
        G.1 * G.2^3 - G.1 * G.2^4,
    Ideal of dimension 4 of the group algebra A
    Basis:
        Id(G) - G.2^4 + G.1 - G.1 * G.2^4
        G.2 - G.2^4 + G.1 * G.2 - G.1 * G.2^4
        G.2^2 - G.2^4 + G.1 * G.2^2 - G.1 * G.2^4
        G.2^3 - G.2^4 + G.1 * G.2^3 - G.1 * G.2^4,
    Ideal of dimension 4 of the group algebra A
    Basis:
        Id(G) - G.2^4 - G.1 + G.1 * G.2^4
        G.2 - G.2^4 - G.1 * G.2 + G.1 * G.2^4
        G.2^2 - G.2^4 - G.1 * G.2^2 + G.1 * G.2^4
        G.2^3 - G.2^4 - G.1 * G.2^3 + G.1 * G.2^4
]
</PRE>
We see that here the group algebra is the direct sum of two 1-dimensional
and two 4-dimensional ideals. The first idempotent is the sum over all group
elements divided by the group order.
<HR>
<PRE></PRE> <A  HREF = "text920.htm">[Next]</A><A  HREF = "text918.htm">[Prev]</A> <A  HREF = "text920.htm">[Right]</A> <A  HREF = "text918.htm">[Left]</A> <A  HREF = "text916.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<br><small>Version: V2.22 of <I>
Thu Jun  9 16:37:49 EST 2016
</I></small>
</body></html>