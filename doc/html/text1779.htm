<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <link rel='stylesheet' href='help.css' type='text/css'>
  <TITLE>Databases</TITLE>
</head>
<body BGCOLOR="#FFFFFF">

 <A  HREF = "text1782.htm">[Next]</A><A  HREF = "text1778.htm">[Prev]</A> [_____] <A  HREF = "text1778.htm">[Left]</A> <A  HREF = "text1774.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<PRE></PRE><H3><A NAME = "19657">Databases</A></H3>

<P>
<P>
<P>
Magma contains two databases of Hadamard matrices; the first database
includes all inequivalent matrices of degree at most 28, and examples
of matrices of all degrees up to 256.
The representatives used are the canonical forms (as output by
<TT>HadamardCanonicalForm</TT>), and matrices of a given degree are
ordered lexicographically (with 1 considered to be less than -1 for
the purposes of this ordering).
<P>
A database of skew-symmetric Hadamard matrices also exists;
in this case the matrices are not stored in canonical form, since
the canonical forms are not skew-symmetric.
With the exception of the creation routines, the intrinsics below
apply to both databases.



<H5>Subsections</H5>
<UL>
<LI> <A  HREF = "text1779.htm#19666">Updating the Databases</A>
</UL>
<H5><A NAME = "19658">HadamardDatabase() : -&gt; DB</A></H5>
<BLOCKQUOTE>
Returns the database of Hadamard matrices.
</BLOCKQUOTE>
<H5><A NAME = "19659">SkewHadamardDatabase() : -&gt; DB</A></H5>
<BLOCKQUOTE>
Returns the database of skew-symmetric Hadamard matrices.
</BLOCKQUOTE>
<H5><A NAME = "19660">Matrix(D, n, k) : DB, RngIntElt, RngIntElt -&gt; AlgMatElt</A></H5>
<BLOCKQUOTE>
Returns the kth matrix of degree n in the database D.
</BLOCKQUOTE>
<H5><A NAME = "19661">Matrices(D, n) : DB, RngIntElt -&gt; [ AlgMatElt ]</A></H5>
<BLOCKQUOTE>
Returns the sequence of all matrices of degree n that are stored in
the database D.
</BLOCKQUOTE>
<H5><A NAME = "19662">DegreeRange(D) : DB -&gt; RngIntElt, RngIntElt</A></H5>
<BLOCKQUOTE>
Returns the smallest and largest degrees of matrices in the database D.
</BLOCKQUOTE>
<H5><A NAME = "19663">Degrees(D) : DB -&gt; [ RngIntElt ]</A></H5>
<BLOCKQUOTE>
Returns the sequence of degrees for which there is at least one matrix of
that degree in the database D.
</BLOCKQUOTE>
<H5><A NAME = "19664">NumberOfMatrices(D, n) : DB, RngIntElt -&gt; RngIntElt</A></H5>
<BLOCKQUOTE>
Return the number of matrices of degree n in the database D.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "19665">Example <TT>Hadamard_hadamard_db_eg (H154E3)</TT></A></H3>
<P>
<P>
<PRE>
&gt; D := HadamardDatabase();
&gt; Matrix(D, 16, 3);
[ 1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1]
[ 1  1  1  1  1  1  1  1 -1 -1 -1 -1 -1 -1 -1 -1]
[ 1  1  1  1 -1 -1 -1 -1  1  1  1  1 -1 -1 -1 -1]
[ 1  1 -1 -1  1  1 -1 -1  1  1 -1 -1  1  1 -1 -1]
[ 1  1 -1 -1 -1  1  1 -1  1 -1 -1  1 -1 -1  1  1]
[ 1  1 -1 -1  1 -1 -1  1 -1  1  1 -1 -1 -1  1  1]
[ 1  1 -1 -1 -1 -1  1  1 -1 -1  1  1  1  1 -1 -1]
[ 1 -1 -1  1 -1 -1  1  1  1  1 -1 -1  1 -1 -1  1]
[ 1 -1 -1  1  1  1 -1 -1 -1 -1  1  1  1 -1 -1  1]
[ 1 -1  1 -1  1 -1  1 -1  1 -1  1 -1  1 -1  1 -1]
[ 1 -1  1 -1  1 -1 -1  1  1 -1 -1  1 -1  1 -1  1]
[ 1 -1  1 -1 -1  1  1 -1 -1  1  1 -1 -1  1 -1  1]
[ 1 -1  1 -1 -1  1 -1  1 -1  1 -1  1  1 -1  1 -1]
[ 1 -1 -1  1  1 -1  1 -1 -1  1 -1  1 -1  1  1 -1]
[ 1 -1 -1  1 -1  1 -1  1  1 -1  1 -1 -1  1  1 -1]
[ 1  1  1  1 -1 -1 -1 -1 -1 -1 -1 -1  1  1  1  1]
&gt; NumberOfMatrices(D, 20);
3
&gt; Degrees(D);
[ 1, 2, 4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 68, 72, 
76, 80, 84, 88, 92, 96, 100, 104, 108, 112, 116, 120, 124, 128, 132, 136, 140, 
144, 148, 152, 156, 160, 164, 168, 172, 176, 180, 184, 188, 192, 196, 200, 204, 
208, 212, 216, 220, 224, 228, 232, 236, 240, 244, 248, 252, 256 ]
&gt; [ NumberOfMatrices(D, n) : n in Degrees(D) ];
[ 1, 1, 1, 1, 1, 5, 3, 60, 487, 23, 218, 20, 500, 55, 562, 2, 3, 1, 2, 1, 2, 1, 
3, 2, 1, 1, 1, 1, 2, 2, 1, 3, 1, 1, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1,
1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 ]
</PRE>
<HR>
<H4><A NAME = "19666">Updating the Databases</A></H4>

<P>
<P>
<P>
The databases are noticeably incomplete (for example, it is known that
more than 60 000 Hadamard matrices exist for degree 32 whereas only
23 are in the database; also, only matrices of degrees 36, 44,
or 52 are present in the skew database).
The Magma group welcomes contributions of matrices not equivalent to
ones already present and will add them to future versions of the databases.
<P>
The functions in this section can be used to create new versions of the
databases.  
This allows users to include matrices not already present without having
to wait for new official versions of the databases.
These functions use a record whose format is not described, as this
record should only be manipulated by these functions.


<H5><A NAME = "19667">HadamardDatabaseInformation(D : parameters) : DB -&gt; Rec</A></H5>

<PRE>    Canonical: BoolElt                  Default: <TT>true</TT></PRE>
<BLOCKQUOTE>
This takes an existing Hadamard database and extracts the information
in it to an internal form which will be used by the other intrinsics.
This internal form is returned.  The parameter <TT>Canonical</TT> indicates
whether the entries in the database are known to be the canonical forms
or not.  It defaults to <TT>true</TT>, which is correct for the standard database;
it should be set to <TT>false</TT> if working with the skew database or a
user-created database where the entries are not canonical.
<P>
Note that the value of the <TT>Canonical</TT> parameter also controls whether
the database created from this data should store the canonical forms
or the original ones.  If you want to extract the matrices from a
canonical database but store them in a non-canonical one, you should
create the non-canonical database first --- using either this intrinsic
or <TT>HadamardDatabaseInformationEmpty</TT> ---
with <TT>Canonical</TT> set to <TT>false</TT> and then add the matrices from the
database with <TT>UpdateHadamardDatabase</TT> and <TT>Canonical</TT> set
to <TT>true</TT>.
</BLOCKQUOTE>
<H5><A NAME = "19668">HadamardDatabaseInformationEmpty(: parameters) : -&gt; Rec</A></H5>

<PRE>    Canonical: BoolElt                  Default: <TT>true</TT></PRE>
<BLOCKQUOTE>
Returns the internal data that would correspond to an empty database.
The parameter <TT>Canonical</TT> is used to indicate whether the entries
in the database should be written out in canonical form or not.
<P>
This allows the creation of a new database, or a slice of an existing
one, without including the entirety of a previous one.
</BLOCKQUOTE>
<H5><A NAME = "19669">UpdateHadamardDatabase(~R, S : parameters) : Rec, SeqEnum -&gt;</A></H5>

<PRE>    Canonical: BoolElt                  Default: <TT>false</TT></PRE>
<BLOCKQUOTE>
This augments the record R containing the database information with
the matrices in the sequence S.  The matrices are only added if they are
inequivalent with matrices already there.  Note that this requires
finding the canonical forms, which can be expensive.  If the matrices
in S are known to be in canonical form already then the parameter
<TT>Canonical</TT> should be set to <TT>true</TT>.
<P>
If the matrices of matching degree already in R are not known to
be canonical then their canonical forms must also be computed.  Again,
this can take significant time.  This is particularly troublesome for
the skew database, where the canonical forms are not stored.  For one
way to deal with this, see the description of <TT>WriteRawHadamardData</TT>
below.
</BLOCKQUOTE>
<H5><A NAME = "19670">WriteHadamardDatabase(S, ~R) : MonStgElt, Rec -&gt;</A></H5>
<BLOCKQUOTE>
This creates the database files <I>name</I><TT>.dat</TT> and <I>name</I><TT>.ind</TT>
from the database data R, where <I>name</I> is taken from the string S.
Since canonical forms may need to be computed during this
process, the data is passed with a variable reference so that this
computation is not lost.  (For instance, if one writes out the database,
then adds some more matrices and writes it out again.)
</BLOCKQUOTE>
<H5><A NAME = "19671">WriteRawHadamardData(S, R) : MonStgElt, Rec -&gt;</A></H5>
<BLOCKQUOTE>
This saves the data in R to the file whose name is given by the
string S.  When loaded, this file will define a single variable
<TT>data</TT> which will behave identically to R.  This is desirable for
the non-canonical databases since the canonical forms will not have to
be recomputed.
<P>
This routine destroys the original contents, if any, of the file.
</BLOCKQUOTE>
<H5><A NAME = "19672">SetVerbose("HadamardDB", v) : MonStgElt, RngIntElt -&gt;</A></H5>
<BLOCKQUOTE>
This procedure changes the verbose printing level for the Hadamard
database update routines.  The verbose value v should be an integer
in the range 0 to 3.  This can provide reassuring indications of
progress when a long update process is underway.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "19673">Example <TT>Hadamard_hadamard_db_update (H154E4)</TT></A></H3>
Here are some examples of how one might use these routines.  We
assume that the file <TT>matrixfile</TT> contains code that will define
a sequence S of Hadamard matrices when loaded.
<P>
<P>
<PRE>
&gt; D := HadamardDatabase();
&gt; #D;
5391
&gt; data := HadamardDatabaseInformation(D);
&gt; SetVerboseLevel("HadamardDB", 1);
&gt; load "matrixfile";
&gt; UpdateHadamardDatabase(~data, S);
3 new matrices added
&gt; WriteHadamardDatabase("~/data/hadamard", ~data);
Sorting matrices by canonical forms
Sorting by degrees
Computing size information
Writing data file
Data file written (2007 matrices total)


Writing index file
Index file written
</PRE>
This has created the files <TT>hadamard.dat</TT> and <TT>hadamard.ind</TT>
(in the directory <TT>~{</TT>/data}) containing the updated data for the
Hadamard database.
The file stems should be <TT>hadamard</TT> for the standard database, or
<TT>hadamard_skew</TT> for the database of skew-symmetric matrices; in
this case we wanted the former.
In order to use these files instead of the standard database, the
library root must be changed.  Database files are looked for in the
<TT>data</TT> subdirectory of the library root, so in this example the
library root should be changed to <TT>~{</TT>} in order to get the
newly created database.
<P>
<P>
<PRE>
&gt; SetLibraryRoot("~");
&gt; D := HadamardDatabase();
&gt; #D;
2007
</PRE>
Of course, the library root is used by other databases, so it would
be a good idea to set it back to its original value after creating
the modified database.  A better approach would be to encapsulate
this process in a function (which could be put into the user startup
file).
<P>
<P>
<PRE>
&gt; function MyHadamardDatabase()
&gt;     oldlibroot := GetLibraryRoot();
&gt;     SetLibraryRoot("~");
&gt;     D := HadamardDatabase();
&gt;     SetLibraryRoot(oldlibroot);
&gt;     return D;
&gt; end function;
&gt;
&gt; D := MyHadamardDatabase();
&gt; #D;
2007
</PRE>
If working with the database of skew-symmetric Hadamard matrices,
it will probably be desirable to use the raw data instead, since
the computation of the canonical forms takes a lot of time (about
23 minutes on a 750MHz machine).
This does have to be done, but by using the raw forms it will only
have to be done once, rather than each time.
<P>
<P>
<PRE>
&gt; D := SkewHadamardDatabase();
&gt; #D;
638
&gt; data := HadamardDatabaseInformationEmpty(: Canonical := false);
&gt; for n in Degrees(D) do
&gt;     UpdateHadamardDatabase(~data, Matrices(D, n));
&gt; end for;
&gt; WriteRawHadamardData("skewraw.m", data);
</PRE>
Now that the raw data has been created, it can be used in other
sessions to update the database (or the same session, of course).
<P>
<P>
<PRE>
&gt; load "skewraw.m";
&gt; load "matrixfile";
&gt; UpdateHadamardDatabase(~data, S);
&gt; WriteHadamardDatabase("~/data/hadamard_skew", ~data);
&gt; WriteRawHadamardData("skewraw.m", data);
</PRE>
Note that the updated raw form is saved as well as the database.
Now the new data can be accessed in the same way as the previous
database was.
<P>
<P>
<PRE>
&gt; SetLibraryRoot("~");
&gt; D := SkewHadamardDatabase();
&gt; #D;
641
</PRE>
As before, for maximum convenience access to the new database should
also be put into a function in the startup file.
<PRE></PRE> <A  HREF = "text1782.htm">[Next]</A><A  HREF = "text1778.htm">[Prev]</A> [_____] <A  HREF = "text1778.htm">[Left]</A> <A  HREF = "text1774.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<br><small>Version: V2.22 of <I>
Thu Jun  9 16:37:49 EST 2016
</I></small>
</body></html>