<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <link rel='stylesheet' href='help.css' type='text/css'>
  <TITLE>Introduction</TITLE>
</head>
<body BGCOLOR="#FFFFFF">

 <A  HREF = "text849.htm">[Next]</A><A  HREF = "text847.htm">[Prev]</A> <A  HREF = "text849.htm">[Right]</A> [____] <A  HREF = "text847.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<PRE></PRE><H3><A NAME = "9751">Introduction</A></H3>

<P>
<P>
<P>
This chapter deals with another, quite specialised, class of finitely presented
groups for which the word problem is solvable, the category of braid groups.
The corresponding Magma category is called <A NAME = "GrpBrd"><TT>GrpBrd</TT></A>.
<P>
<P>
The notion of braid groups was introduced by Artin <A  HREF = "text846.htm#bib_artin_braid_groups">[Art47]</A>,
who considered a sequence B<sub>n</sub> (n=1, 2, ...) of groups, where B<sub>n</sub> is
presented on n - 1 generators s<sub>1</sub>, ..., s<sub>n - 1</sub> with the defining
relations
<PRE>
     s_i s_j = s_j s_i                         (0 &lt; i &lt; j &lt; n, j-i &gt; 1)
     s_i s_{i+1} s_i = s_{i+1} s_i s_{i+1}     (0 &lt; i &lt; n-1)  .
</PRE>B<sub>n</sub> is called <I>braid group on n strings</I>. In the sequel, we
refer to the above presentation as <I>Artin presentation</I> and to
s<sub>1</sub>, ..., s<sub>n - 1</sub> as <I>Artin generators</I> of B<sub>n</sub>.
<P>
<P>
Birman, Ko and Lee introduced an alternative way of presenting braid groups
<A  HREF = "text846.htm#bib_braid_word_problem">[BKL98]</A>.  Here, B<sub>n</sub> is presented on n(n - 1)/2 generators
a<sub>r, t</sub> (n &ge;r &gt; t &ge;1) with the defining relations
<PRE>
    a_{t,s} a_{r,q} = a_{r,q} a_{t,s}   (n &ge;t &gt; s &ge;1, n &ge;r &gt; q &ge;1,
                                               (t-r)(t-q)(s-r)(s-q) &gt; 0)
    a_{t,s} a_{s,r} = a_{t,r} a_{t,s} = a_{s,r} a_{t,r}  (n &ge;t &gt; s &gt; r &gt; 0) .
</PRE>We refer to this presentation as <I>BKL presentation</I> and to
a<sub>r, t</sub> (n &ge;r &gt; t &ge;1) as <I>BKL generators</I> of B<sub>n</sub>.
<P>
<P>
<P>
A possible choice for the BKL generators in terms of Artin generators is
a<sub>r, t</sub> = (s<sub>r - 1</sub>...s<sub>t + 1</sub>) s<sub>t</sub> (s<sub>t + 1</sub><sup> - 1</sup>...s<sub>r - 1</sub><sup> - 1</sup>).
This identification is used in Magma.
<P>
<P>
<P>
Recently, braid groups came under consideration as possible sources for
public key cryptosystems <A  HREF = "text846.htm#bib_algebraic_public_key">[AAG99]</A>, <A  HREF = "text846.htm#bib_braid_cryptosystem">[KLC+00]</A>.
The features of braid groups which make them interesting for public key
cryptography are the following.
<P>
<DL COMPACT class='compact'>
<DT>-</DT><DD>The basic group operations in braid groups can be implemented
efficiently on a computer.
<DT>-</DT><DD>The word problem in braid groups is solvable, that is, there is
a normal form for elements of a braid group and elements can be compared.
Moreover, there are algorithms which are able to compute the normal form of
an element efficiently.
<DT>-</DT><DD>There are several problems in braid groups which are believed to be
mathematically hard and whose use for cryptographic purposes has been
suggested.  The most important examples are variations of the conjugacy
problem.
<P>
<P>
<P>
</DL>
However, both recent attacks on particular cryptosystems
<A  HREF = "text846.htm#bib_braid_attack_garber">[GKT+02]</A>, <A  HREF = "text846.htm#bib_braid_attack_hofheinz">[HS03]</A>, <A  HREF = "text846.htm#bib_braid_attack_hughes_la">[Hug02]</A>, <A  HREF = "text846.htm#bib_braid_attack_lee_lee">[LL02]</A>, <A  HREF = "text846.htm#bib_braid_attack_lee_park">[LP03]</A> and
advances in the analysis of the conjugacy problem
<A  HREF = "text846.htm#bib_braid_conjugacy_simultaneous">[GM02]</A>, <A  HREF = "text846.htm#bib_braid_ultrasummit">[Geb03]</A> in general
shed some doubts on the security of braid group cryptosystems.  At the time
of this writing it is an open question whether braid group cryptosystems can
be made secure by an appropriate choice of parameters and keys or whether they
have to be considered as insecure. More research into these issues is
necessary.
<P>
The Magma category <TT>GrpBrd</TT> was introduced mainly with these applications
in mind.  Focus was put on providing fast operations with elements and
on giving the user as much control over the details of computations as
possible.



<H5>Subsections</H5>
<UL>
<LI> <A  HREF = "text848.htm#9752">Lattice Structure and Simple Elements</A>
<LI> <A  HREF = "text848.htm#9753">Representing Elements of a Braid  Group</A>
<LI> <A  HREF = "text848.htm#9758">Normal Form for Elements of a Braid Group</A>
<LI> <A  HREF = "text848.htm#9759">Mixed Canonical Form and Lattice Operations</A>
<LI> <A  HREF = "text848.htm#9760">Conjugacy Testing and Conjugacy  Search</A>
</UL>
<H4><A NAME = "9752">Lattice Structure and Simple Elements</A></H4>

<P>
<P>
<P>
In this section we briefly recall the basic terminology used for describing
elements of braid groups.  More detailed descriptions can be found in
<A  HREF = "text846.htm#bib_epsteinetal">[ECH+92]</A> for the Artin presentation and in
<A  HREF = "text846.htm#bib_braid_word_problem">[BKL98]</A> for the BKL presentation.
<P>
<P>
We remark that both Artin presentation and BKL presentation are special
cases of so-called <I>Garside groups</I> <A  HREF = "text846.htm#bib_braid_garside_groups">[Deh02]</A>.
<P>
<P>
In the sequel, let M be either the Artin presentation or the BKL presentation
of the braid group B on n strings, let X denote the generators of M
and let R denote the relations of M.
As the relations in R do not contain inverses of generators, we can interpret
M as monoid presentation.  We denote the finitely presented monoid defined
by M by B^ +.  The natural homomorphism from B^ + to B can be shown to be
injective.  We identify its image with B^ + and call it the set of
<I>positive</I> elements of B.  Finally, we denote the identity of B by 1.
<P>
<P>
<P>
We can now define two partial orderings on B.  For elements u, v &isin;B we
say u preceq v, if there exists a positive element a such that ua = v,
and we say v succeq u, if there exists a positive element a such that
v = au.  Note that these partial orderings are different; u preceq v is
not equivalent to v succeq u.
<P>
<P>
<P>
B can be shown to be a lattice with respect to both partial
orderings, that is, for elements u, v &isin;B there are elements
d<sub>l</sub>, m<sub>l</sub>, d<sub>r</sub>, m<sub>r</sub> &isin;B such that
<PRE>
 d_l \preceq u, d_l \preceq v  and
      d \preceq u, d \preceq v  implies  d \preceq d_l  for all d in B
 u \preceq m_l, v \preceq m_l  and
      u \preceq m, v \preceq m  implies  m_l \preceq m  for all m in B
 u \succeq d_r, v \succeq d_r  and
      u \succeq d, v \succeq d  implies  d_r \succeq d  for all d in B
 m_r \succeq u, m_r \succeq v  and
      m \succeq u, m \succeq v  implies  m \succeq m_r  for all m in B
</PRE>We call d<sub>l</sub>, m<sub>l</sub>, d<sub>r</sub> and m<sub>r</sub> the <I>left-gcd</I>, the <I>left-lcm</I>,
the <I>right-gcd</I> and the <I>right-lcm</I>, respectively, of u and v.
<P>
<P>
<P>
It can be shown that the left-lcm of the elements of X and the right-lcm
of the elements of X are equal; we call this element the <I>fundamental
element</I> of the presentation M and denote it by D.  The fundamental
element is crucial for the study of braid groups.  One of its most important
properties is that a certain power D<sup>N</sup> of D generates the centre of B.
(N = 2 for the Artin presentation and N = n for the BKL presentation.)
Moreover, u preceq D<sup>k</sup> is equivalent to D<sup>k</sup> succeq u and
D<sup>k</sup> preceq u is equivalent to u succeq D<sup>k</sup> for all k &isin;Z, u &isin;B.
<P>
<P>
<P>
In Magma, the partial ordering preceq is provided as operator
<A  HREF = "text851.htm#GrpBrd:le">le</A> and the partial ordering succeq is provided as
operator <A  HREF = "text851.htm#GrpBrd:ge">ge</A>; see Section <A  HREF = "text851.htm#9832">Boolean Predicates for Elements</A>.
For a description of the functions computing lcm and gcd of elements,
see Section <A  HREF = "text851.htm#9847">Lattice Operations</A>.
<P>
<P>
<P>
The positive elements c of B satisfying c preceq D are called
<I>simple elements</I>; we denote the set of simple elements by C.
simple elements can be uniquely described by permutations on n points.
In Magma, a simple element c inducing a permutation &pi; on the strings
on which B is defined, is represented by the permutation &pi;<sup> - 1</sup>. 
<P>
<P>
<P>
If M is the Artin presentation, every permutation on n points
corresponds to a simple element, that is, |C| = n!.
<P>
<P>
<P>
If M is the BKL presentation, |C| = (2n)!/(n!(n + 1)!) and only
permutations on n points which are products of
parallel, descending cycles correspond to simple elements. Here, a cycle
(i<sub>1</sub>, ..., i<sub>r</sub>) is called <I>descending</I> if i<sub>1</sub>&gt; ... &gt;i<sub>r</sub>
and two descending cycles (i<sub>1</sub>, ..., i<sub>r</sub>) and (j<sub>1</sub>, ..., j<sub>s</sub>) are
called <I>parallel</I> if (i<sub>k</sub> - j<sub>l</sub>)(i<sub>k</sub> - j<sub>l'</sub>)(i<sub>k'</sub> - j<sub>l</sub>)(i<sub>k'</sub> - j<sub>l'</sub>) &gt; 0
for all 1&le;k, k'&le;r and 1&le;l, l'&le;s.  The descending cycle
(i<sub>1</sub>, ..., i<sub>r</sub>) corresponds to the element
a<sub>i<sub>1</sub>, i<sub>2</sub></sub>a<sub>i<sub>2</sub>, i<sub>3</sub></sub> ... a_(i<sub>r - 1</sub>, i<sub>r</sub>) of B.  It is obvious from the
defining relations that the simple elements defined by two parallel
descending cycles commute.
<P>
<P>
<P>
Every element u of B can be written in the form u = D<sup>l</sup> c<sub>1</sub> ... c<sub>k</sub>,
where l is a suitable integer and c<sub>1</sub>, ... c<sub>k</sub> are simple elements.
We call representations of this form <I>simple element representations</I>
or <I>canonical factor products</I> (CFP).


<H4><A NAME = "9753">Representing Elements of a Braid  Group</A></H4>

<P>
<P>
<P>
<P>
This section describes the ways in which elements of a braid group can be
represented internally by Magma.  From the user's point of view, this
mainly affects input and printing of elements.  This section is intended
to be a concise overview; for a detailed description of functions and for
examples we refer to Section <A  HREF = "text849.htm#9764">Constructing and Accessing  Braid Groups</A>,
Section <A  HREF = "text850.htm#9774">Creating Elements of a Braid  Group</A> and
Section <A  HREF = "text851.htm#9791">Accessing Information</A>.
<P>
<P>
<P>
Since an element of a braid group B can be represented either as word
in the generators or as product of simple elements (see Section
<A  HREF = "text851.htm#9847">Lattice Operations</A>)
with respect to either the Artin presentation or the BKL presentation of B,
there are four different ways of representing elements of B, which can
be used for entering or printing elements and for computing with elements.


<H5><A NAME = "9754">Automatic Conversions</A></H5>

<P>
<P>
<P>
Magma can work with all the above representations and conversions are
done automatically when necessary, for example, when multiplying an element
defined as word in the Artin generators with an element given as product
of simple elements for the BKL presentation.   Hence, the user normally
does not have do give too much thought about how elements are represented.
It should be noted, however, that automatic conversions can affect performance
and that in time critical situations, the best results in general are
obtained if automatic conversions are avoided.


<H5><A NAME = "9755">Default Presentations</A></H5>

<P>
<P>
<P>
When creating a braid group B using the command <A  HREF = "text849.htm#GrpBrd:BraidGroup">BraidGroup</A>,
the user can specify whether the Artin presentation or the BKL
presentation should be used as <I>default presentation</I> for B.
Unless specified otherwise by the user, this presentation is used in all
subsequent operations with B or with elements of B.  In particular,
group operations and printing of elements are performed with respect to this
presentation.  It is possible to change the default presentation using
the command <A  HREF = "text849.htm#GrpBrd:SetPresentation">SetPresentation</A>.  Certain commands accept a
parameter <TT>Presentation</TT>, which can be used to perform that command
with respect to a presentation other than the default presentation.


<H5><A NAME = "9756">Representation Used for Group Operations</A></H5>

<P>
<P>
<P>
By default, group operations with elements of a braid group B are performed
using representations of the elements as products of simple elements for
the default presentation of B.  Experienced users can change this
behaviour using the command <A  HREF = "text849.htm#GrpBrd:SetForceCFP">SetForceCFP</A>.  If this flag is
set to <TT>false</TT>, arguments of a group operation are not automatically converted
into CFP representation if both arguments are represented as words in the
generators of the default presentation of B, but the operation is performed,
if possible, using the word representations instead.


<H5><A NAME = "9757">Printing of Elements</A></H5>

<P>
<P>
<P>
The default printing format for an element u of a braid group B is that
both a representation of u as word in the generators of the default
presentation of B and a representation of u as product of
simple elements for the default presentation of B are printed.
<P>
<P>
<P>
Depending on the application, the user may wish to change the print format
so that only one of the above representations of u is printed.  This can
be achieved using the command <A  HREF = "text849.htm#GrpBrd:SetElementPrintFormat">SetElementPrintFormat</A>.


<H4><A NAME = "9758">Normal Form for Elements of a Braid Group</A></H4>

<P>
<P>
<P>
<P>
This section briefly describes the normal form for elements of braid groups.
For details we refer to <A  HREF = "text846.htm#bib_epsteinetal">[ECH+92]</A> and <A  HREF = "text846.htm#bib_braid_word_problem">[BKL98]</A>.
The Magma commands for computing normal forms are described in Section
<A  HREF = "text851.htm#9804">Computing Normal Forms of  Elements</A>.
<P>
<P>
Let B be the braid group on n strings and fix a presentation M for B,
either the Artin presentation or the BKL presentation.  A product of
simple elements
D<sup>l</sup> c<sub>1</sub> ... c<sub>k</sub> is said to be in <I>left normal form</I> with
respect to M,
if c<sub>1</sub> &ne;D, c<sub>k</sub> &ne;1 and (c<sub>i</sub><sup> - 1</sup>D) ^<sub>l</sub> c<sub>i + 1</sub> = 1 for
i = 1, ..., k - 1, where (c<sub>i</sub><sup> - 1</sup>D) ^<sub>l</sub> c<sub>i + 1</sub> denotes the left-gcd
of c<sub>i</sub><sup> - 1</sup>D and c<sub>i + 1</sub> with respect to the presentation M.
<P>
<P>
<P>
Similarly, we define c<sub>1</sub> ... c<sub>k</sub> D<sup>l</sup> to be in <I>right normal form</I>
with respect to M, if c<sub>k</sub> &ne;D, c<sub>1</sub> &ne;1 and
c<sub>i</sub> ^<sub>r</sub> (Dc<sub>i + 1</sub><sup> - 1</sup>) = 1 for i = 1, ..., k - 1, where ^<sub>r</sub>
denotes right-gcd with respect to the presentation M.
<P>
<P>
<P>
It can be shown that the numbers of simple elements and the powers of D
in the left and right normal forms of an element are equal, that is, if
x&isin;B has left normal form D<sup>l</sup> c<sub>1</sub> ... c<sub>k</sub> and right normal form
bar(c)<sub>1</sub> ... bar(c)<sub>k<sup>prime</sup></sub> D<sup>l<sup>prime</sup></sup> then k<sup>prime</sup>=k and
l<sup>prime</sup>=l.  In this situation we call l the <I>infimum</I>
of x, denoted by inf(x), k the <I>canonical length</I> of x,
denoted by len(x), and l + k the <I>supremum</I> of x,
denoted by sup(x). l is the maximal integer d satisfying
D<sup>d</sup>preceq x and l + k is the minimal integer d satisfying x preceq D<sup>d</sup>.
<P>
<P>
<P>
To bring a product D<sup>l</sup> c<sub>1</sub> ... c<sub>k</sub> of simple elements into left normal
form, we proceed by induction, assuming that D<sup>l</sup> c<sub>1</sub> ... c<sub>k - 1</sub> is in
left normal form.  For i = k - 1, ..., 1 we now compute
d = (c<sub>i</sub><sup> - 1</sup>D) ^<sub>l</sub> c<sub>i + 1</sub> and, if d &ne;1, replace c<sub>i</sub> by
c<sub>i</sub> d and c<sub>i + 1</sub> by d<sup> - 1</sup> c<sub>i + 1</sub>. Finally, we delete trailing trivial
simple elements and absorb simple elements equal to D into the leading
power of D.  The result can be shown to be in
left normal form <A  HREF = "text846.htm#bib_epsteinetal">[ECH+92]</A>, <A  HREF = "text846.htm#bib_braid_word_problem">[BKL98]</A>.
<P>
<P>
<P>
Both the theoretical complexity of this algorithm and its performance in
practice are determined by the gcd computations.
<P>
<P>
<P>
For the Artin presentation, the cost of computing the left-gcd of two
simple elements is O(n log n) <A  HREF = "text846.htm#bib_epsteinetal">[ECH+92]</A>, whence the complexity
of bringing a product of simple elements as above into left normal form is
O(k<sup>2</sup> n log n).
<P>
<P>
<P>
For the Artin presentation, the cost of computing the left-gcd of two
simple elements is O(n) <A  HREF = "text846.htm#bib_braid_word_problem">[BKL98]</A>, whence the complexity
of bringing a product of simple elements as above into left normal form is
O(k<sup>2</sup> n).
<P>
<P>
<P>
Computing right normal forms is analogous.


<H4><A NAME = "9759">Mixed Canonical Form and Lattice Operations</A></H4>

<P>
<P>
<P>
<P>
This section outlines the algorithms used for lattice operations in a braid
group.  Let u and v be elements of a braid group B and let M
be either the Artin presentation or the BKL presentation of B.
The Magma commands for computing mixed canonical forms are described in
Section <A  HREF = "text851.htm#9804">Computing Normal Forms of  Elements</A> and the commands providing lattice
operations are described in Section <A  HREF = "text851.htm#9847">Lattice Operations</A>.
<P>
<P>
Evaluating partial orderings for u and v with respect to M is
straightforward.  u preceq v if and only if u<sup> - 1</sup> v is a positive
element with respect to M.  The latter can be decided by computing
the left normal form D<sup>l</sup> c<sub>1</sub> ... c<sub>k</sub> of u<sup> - 1</sup> v with respect
to M: u<sup> - 1</sup> v is positive if and only if l&ge;0.  Evaluating
the partial ordering succeq is analogous.
<P>
<P>
<P>
We call the tuple &lt;a, b&gt; the <I>left-mixed canonical form</I> of an element
x&isin;B, if a = a<sub>1</sub> ... a<sub>k</sub> and b = b<sub>1</sub> ... b<sub>s</sub> are positive elements
in left normal form (a<sub>1</sub> = D, b<sub>1</sub> = D is permitted), x = a<sup> - 1</sup>b and the
left-gcd of a<sub>1</sub> and b<sub>1</sub> is trivial.
<P>
<P>
<P>
Similarly, we call the tuple &lt;a, b&gt; the <I>right-mixed canonical form</I>
of x, if a = a<sub>1</sub> ... a<sub>k</sub> and b = b<sub>1</sub> ... b<sub>s</sub> are positive elements
in right normal form (a<sub>k</sub> = D, b<sub>s</sub> = D is permitted), x = ab<sup> - 1</sup> and
the right-gcd of a<sub>k</sub> and b<sub>s</sub> is trivial.
<P>
<P>
<P>
It is not difficult to show that the left-gcd of u and v is given by
u a<sup> - 1</sup>, where &lt;a, b&gt; is the left-mixed canonical form of u<sup> - 1</sup>v,
and that the right-gcd of u and v is given by a<sup> - 1</sup>u, where
&lt;a, b&gt; is the right-mixed canonical form of u v<sup> - 1</sup> <A  HREF = "text846.htm#bib_epsteinetal">[ECH+92]</A>.
<P>
<P>
<P>
Similarly, the left-lcm of u and v is given by
ua, where &lt;a, b&gt; is the right-mixed canonical form of u<sup> - 1</sup>v
and the right-lcm of u and v is given by au, where
&lt;a, b&gt; is the left-mixed canonical form of u v<sup> - 1</sup>
<P>
<P>
<P>
Computing the left-mixed canonical form of an element x can, after
writing x=a<sup> - 1</sup>b with two positive elements a and b, easily be
reduced to computing repeatedly the left-normal forms of a and b
and cancelling the left-gcd of the leading simple elements. Computing
the right-mixed canonical form is analogous.


<H4><A NAME = "9760">Conjugacy Testing and Conjugacy  Search</A></H4>

<P>
<P>
<P>
<P>
Conjugacy testing, that is, deciding whether two given braids are conjugate,
and conjugacy search, that is, computing a conjugating
element for a pair of conjugate braids, are of particular
importance to public key cryptosystems based on braid groups.  Known
algorithms for both conjugacy testing and conjugacy search require the
(at least partial) computation of an invariant of the conjugacy classes
of the elements in question, either the <I>super summit set</I>
<A  HREF = "text846.htm#bib_braid_garside_alg">[Gar69]</A>, <A  HREF = "text846.htm#bib_braid_elrifai_morton">[ERM94]</A> or the <I>ultra summit set</I>
<A  HREF = "text846.htm#bib_braid_ultrasummit">[Geb03]</A>.
<P>
This section recalls the definition of these invariants and sketches the
algorithms used for computing them, for conjugacy testing and for conjugacy
search.  The relevant Magma commands are described in Section
<A  HREF = "text851.htm#9857">Invariants of Conjugacy Classes</A>.
<P>
For this section let B be a braid group and let M be either the
Artin presentation or the BKL presentation of B.


<H5><A NAME = "9761">Definition of the Class Invariants</A></H5>

<P>
<P>
<P>
<P>
We define two operations, the <I>cycling</I> operation cyc and the
<I>decycling</I> operation dec, each mapping an arbitrary element x&isin;B
to a conjugate of x as follows.
Let x&isin;B be a braid with left normal form x = D<sup>l</sup> c<sub>1</sub> ... c<sub>k</sub> as
defined in Section <A  HREF = "text848.htm#9758">Normal Form for Elements of a Braid Group</A>. If k=0, we define
cyc(x) = x and dec(x) = x.  Otherwise, we define
cyc(x) = D<sup>l</sup> c<sub>2</sub> ... c<sub>k</sub> (c<sub>1</sub>^(D<sup> - l</sup>)) and
dec(x) = D<sup>l</sup> (c<sub>k</sub><sup>D<sup>l</sup></sup>) c<sub>1</sub> ... c<sub>k - 1</sub>.
<P>
<P>
<P>
We now fix an element x&isin;B and consider the set C<sub>x</sub> of all
conjugates of x.  Proofs for the following
facts can be found in <A  HREF = "text846.htm#bib_epsteinetal">[ECH+92]</A> or <A  HREF = "text846.htm#bib_braid_word_problem">[BKL98]</A>.
<P>
<DL COMPACT class='compact'>
<DT>-</DT><DD>The set {inf(y) : y&isin;C<sub>x</sub>} is bounded above; we denote its
  maximum by ss - inf(x).
<DT>-</DT><DD>The set {sup(y) : y&isin;C<sub>x</sub>} is bounded below; we denote its
  minimum by ss - sup(x).
<DT>-</DT><DD>The maximum of inf on C<sub>x</sub> and the minimum of sup on
          C<sub>x</sub> can be achieved simultaneously.
<P>
<P>
<P>
</DL>
We define three sets of conjugates of x as follows.
<DL COMPACT class='compact'>
<DT>-</DT><DD>The set P<sub>x</sub> = { y&isin;C<sub>x</sub> : y &isin;B^ + }, containing the
          positive conjugates of x.
<DT>-</DT><DD>The set S<sub>x</sub> = { y&isin;C<sub>x</sub> : inf(y) = ss - inf(x), 
                                        sup(y) = ss - sup(x) },
          called the <I>super summit set</I> of x.
<DT>-</DT><DD>The set U<sub>x</sub> = { y&isin;S<sub>x</sub> : exists i&gt;0 : cyc<sup>i</sup>(y) = y },
          called the <I>ultra summit set</I> of x.
<P>
<P>
<P>
</DL>
Clearly, the sets P<sub>x</sub>, S<sub>x</sub> and U<sub>x</sub> only depend on the conjugacy class
of x.  Moreover, the set P<sub>x</sub> is empty if ss - inf(x) &lt; 0 and
it contains S<sub>x</sub> if ss - inf(x) &ge;0.
<P>
<P>
<P>
Proofs of the following properties can be found in <A  HREF = "text846.htm#bib_epsteinetal">[ECH+92]</A> and
<A  HREF = "text846.htm#bib_braid_word_problem">[BKL98]</A> for the sets P<sub>x</sub> and S<sub>x</sub> and in
<A  HREF = "text846.htm#bib_braid_ultrasummit">[Geb03]</A> for the set U<sub>x</sub>.
<P>
<DL COMPACT class='compact'>
<DT>-</DT><DD>The sets P<sub>x</sub>, S<sub>x</sub> and U<sub>x</sub> are finite.
<DT>-</DT><DD>The sets S<sub>x</sub> and U<sub>x</sub> are non-empty.
<DT>-</DT><DD>Representatives of P<sub>x</sub>, S<sub>x</sub> and U<sub>x</sub>, respectively, can be
          obtained from x by a finite number of cycling and decycling
          operations.</DL>


<H5><A NAME = "9762">Computing the Class Invariants</A></H5>

<P>
<P>
<P>
<P>
The main tools for computing the class invariants introduced in
Section <A  HREF = "text848.htm#9761">Definition of the Class Invariants</A> are the following "convexity" results
established in <A  HREF = "text846.htm#bib_braid_elrifai_morton">[ERM94]</A> and <A  HREF = "text846.htm#bib_braid_conjugacy">[FGM03]</A>
for the sets P<sub>x</sub> and S<sub>x</sub> and in <A  HREF = "text846.htm#bib_braid_ultrasummit">[Geb03]</A> for the set
U<sub>x</sub>.  Let I<sub>x</sub> &isin;{ P<sub>x</sub>, S<sub>x</sub>, U<sub>x</sub> }.
<P>
<DL COMPACT class='compact'>
<DT>-</DT><DD>For y, z&isin;I<sub>x</sub>, there exists a finite
   sequence y = y<sub>0</sub>, ..., y<sub>r</sub>=z such that for i=1, ..., r, y<sub>i</sub>&isin;I<sub>x</sub>
   and y<sub>i</sub> = y<sub>i - 1</sub><sup>c<sub>i</sub></sup> for a simple element c<sub>i</sub>.
<DT>-</DT><DD>For y&isin;I<sub>x</sub> and a simple element c, there exists a
   unique preceq-minimal element &iota;<sub>y</sub>(c) such that
   c preceq &iota;<sub>y</sub>(c) and y<sup>&iota;<sub>y</sub>(c)</sup> &isin;I<sub>x</sub>.  Moreover,
   &iota;<sub>y</sub>(c) is simple.
<P>
<P>
<P>
</DL>
By the above results, any non-empty subset I&sube;I<sub>x</sub> with the
property that y<sup>&iota;<sub>y</sub>(s)</sup> &isin;I for all y&isin;I and all generators
s of the presentation M is equal to I<sub>x</sub>.  In particular,
I<sub>x</sub> can be computed, starting from a single
representative, as closure under conjugation with minimal simple elements.
<P>
Algorithms for computing the minimal simple elements &iota;<sub>y</sub>(c) are given
in <A  HREF = "text846.htm#bib_braid_conjugacy">[FGM03]</A> for the case I<sub>x</sub> &isin;{P<sub>x</sub>, S<sub>x</sub>}  and in 
<A  HREF = "text846.htm#bib_braid_ultrasummit">[Geb03]</A> for the case I<sub>x</sub> = U<sub>x</sub>.
<P>
The Magma commands for computing the class invariants P<sub>x</sub>, S<sub>x</sub> and
U<sub>x</sub> as well as corresponding minimal simple elements &iota;<sub>y</sub>(c)
are described in Section <A  HREF = "text851.htm#9857">Invariants of Conjugacy Classes</A>.


<H5><A NAME = "9763">Conjugacy Testing and Conjugacy Search</A></H5>

<P>
<P>
<P>
<P>
Testing conjugacy of two braids x, y&isin;B can be performed using either
super summit sets or ultra summit sets.  It is obvious from the results
cited in Section <A  HREF = "text848.htm#9761">Definition of the Class Invariants</A> that the following are equivalent.
<P>
<DL COMPACT class='compact'>
<DT>-</DT><DD>x and y are conjugate in B.
<DT>-</DT><DD>S<sub>x</sub> = S<sub>y</sub>.
<DT>-</DT><DD>U<sub>x</sub> = U<sub>y</sub>.
<DT>-</DT><DD>S<sub>x</sub> &cap;S<sub>y</sub> &ne;emptyset.
<DT>-</DT><DD>U<sub>x</sub> &cap;U<sub>y</sub> &ne;emptyset.
<P>
<P>
<P>
</DL>
If x and y are conjugate, a conjugating element can be obtained by
establishing an element z&isin;S<sub>x</sub> &cap;S<sub>y</sub> or z&isin;U<sub>x</sub> &cap;U<sub>y</sub> both
as conjugate of x and of y and keeping track of the conjugating elements
in each step.
<P>
<P>
<P>
The size of super summit sets grows rapidly with increasing values of
braid index n and canonical length.  In general, computing super summit
sets is difficult or infeasible for braids on more than 5-10 strings, except
for very short canonical lengths.  Ultra summit sets, on the other hand
tend to be much smaller and can frequently be computed for braids on up
to 100 strings and canonical length up to 1000, provided sufficient memory is
available <A  HREF = "text846.htm#bib_braid_ultrasummit">[Geb03]</A>.  Conjugacy search may be successful
even in situations where the entire class invariant is too large to be
computed.
<P>
In Magma, conjugacy testing and conjugacy search based on ultra
summit sets is provided by the function <A  HREF = "text851.htm#GrpBrd:IsConjugate">IsConjugate</A>.  


<PRE></PRE> <A  HREF = "text849.htm">[Next]</A><A  HREF = "text847.htm">[Prev]</A> <A  HREF = "text849.htm">[Right]</A> [____] <A  HREF = "text847.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<br><small>Version: V2.22 of <I>
Thu Jun  9 16:37:49 EST 2016
</I></small>
</body></html>