<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <link rel='stylesheet' href='help.css' type='text/css'>
  <TITLE>Operations on Elements</TITLE>
</head>
<body BGCOLOR="#FFFFFF">

 <A  HREF = "text490.htm">[Next]</A><A  HREF = "text488.htm">[Prev]</A> <A  HREF = "text490.htm">[Right]</A> <A  HREF = "text488.htm">[Left]</A> <A  HREF = "text481.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<PRE></PRE><H3><A NAME = "5318">Operations on Elements</A></H3>




<H5>Subsections</H5>
<UL>
<LI> <A  HREF = "text489.htm#5319">Arithmetic</A>
<LI> <A  HREF = "text489.htm#5330">Equality and Membership</A>
<LI> <A  HREF = "text489.htm#5336">Properties</A>
<LI> <A  HREF = "text489.htm#5342">Precision and Valuation</A>
<LI> <A  HREF = "text489.htm#5351">Logarithms and Exponentials</A>
<LI> <A  HREF = "text489.htm#5355">Norm and Trace</A>
<LI> <A  HREF = "text489.htm#5367">Teichm&uuml;ller Lifts</A>
</UL>
<H4><A NAME = "5319">Arithmetic</A></H4>

<P>
<P>
For local ring elements the usual operations are available. 
The quotient of two elements can be computed when the result 
lies in the
ring (i.e. the valuation of the dividend is not smaller than that of the
divisor). The precision of the result is reduced by the valuation of the
divisor.
The result of an operation with elements of reduced precision will have as much
precision as possible. For addition and subtraction this is the minimum
of the precisions of the two elements.  For multiplication it is the minimum
of v<sub>1</sub> + k<sub>2</sub> and v<sub>2</sub> + k<sub>1</sub>, where v<sub>i</sub> and k<sub>i</sub> are the
valuations and precisions of the two elements, respectively.
<P>
For local field elements the operations are performed with the maximum precision
possible. For multiplication and division this is the minimum of the (relative)
precisions of the two elements. For addition and subtraction of elements
x and y with valuations v<sub>x</sub> and v<sub>y</sub> and precisions k<sub>x</sub> and k<sub>y</sub> 
the precision of x &#8723; y is min(v<sub>x</sub> + k<sub>x</sub>, v<sub>y</sub> + k<sub>y</sub>) - v<sub>p</sub>(x &#8723; y), which
may even be 0.


<H5><A NAME = "5320">- x : RngPadElt -&gt; RngPadElt</A></H5>
<H5>- x : RngPadResElt -&gt; RngPadResElt</H5>
<H5>- x : RngPadResExtElt -&gt; RngPadResExtElt</H5>
<H5>- x : FldPadElt -&gt; FldPadElt</H5>
<BLOCKQUOTE>
The negative of the element x.
</BLOCKQUOTE>
<H5><A NAME = "5321">x + y : RngPadElt, RngPadElt -&gt; RngPadElt</A></H5>
<H5>x + y : RngPadResElt, RngPadResElt -&gt; RngPadResElt</H5>
<H5>x + y : RngPadResExtElt, RngPadResExtElt -&gt; RngPadResExtElt</H5>
<H5>x + y : FldPadElt, FldPadElt -&gt; FldPadElt</H5>
<BLOCKQUOTE>
The sum of the elements x and y.
</BLOCKQUOTE>
<H5><A NAME = "5322">x - y : RngPadElt, RngPadElt -&gt; RngPadElt</A></H5>
<H5>x - y : RngPadResElt, RngPadResElt -&gt; RngPadResElt</H5>
<H5>x - y : RngPadResExtElt, RngPadResExtElt -&gt; RngPadResExtElt</H5>
<H5>x - y : FldPadElt, FldPadElt -&gt; FldPadElt</H5>
<BLOCKQUOTE>
The difference of the elements x and y.
</BLOCKQUOTE>
<H5><A NAME = "5323">x * y : RngPadElt, RngPadElt -&gt; RngPadElt</A></H5>
<H5>x * y : RngPadResElt, RngPadResElt -&gt; RngPadResElt</H5>
<H5>x * y : RngPadResExtElt, RngPadResExtElt -&gt; RngPadResExtElt</H5>
<H5>x * y : FldPadElt, FldPadElt -&gt; FldPadElt</H5>
<BLOCKQUOTE>
The product of the elements x and y.
</BLOCKQUOTE>
<H5><A NAME = "5324">x ^ k : RngPadElt, RngIntElt -&gt; RngPadElt</A></H5>
<H5>x ^ k : RngPadResElt, RngIntElt -&gt; RngPadResElt</H5>
<H5>x ^ k : RngPadResExtElt, RngIntElt -&gt; RngPadResExtElt</H5>
<H5>x ^ k : FldPadElt, RngIntElt -&gt; FldPadElt</H5>
<BLOCKQUOTE>
The k-th power of the element x. If k has valuation (when coerced) 
and x has precision less than that of its parent ring, the power x<sup>k</sup>
will have more precision than x.
</BLOCKQUOTE>
<H5><A NAME = "5325">x div y : RngPadElt, RngPadElt -&gt; RngPadElt</A></H5>
<H5>x div y : RngPadResElt, RngPadResElt -&gt; RngPadResElt</H5>
<H5>x div y : RngPadResExtElt, RngPadResExtElt -&gt; RngPadResExtElt</H5>
<H5>x div y : FldPadElt, FldPadElt -&gt; FldPadElt</H5>
<BLOCKQUOTE>
The quotient of the elements x and y. For elements of a local ring, this
results in an error if the valuation of x is smaller than that of y. 
</BLOCKQUOTE>
<H5><A NAME = "5326">x div:= y : RngPadElt, RngPadElt -&gt; RngPadElt</A></H5>
<H5>x div:= y : RngPadResElt, RngPadResElt -&gt; RngPadResElt</H5>
<H5>x div:= y : RngPadElt, RngPadElt -&gt; RngPadElt</H5>
<H5>x div:= y : FldPadElt, FldPadElt -&gt; FldPadElt</H5>
<BLOCKQUOTE>
Mutation operation: replace the element x by its quotient upon
division by y. For elements of a local ring, this
results in an error if the valuation of x is smaller than that of y. 
</BLOCKQUOTE>
<H5><A NAME = "5327">x / y : RngPadElt, RngPadElt -&gt; RngPadElt</A></H5>
<H5>x / y : FldPadElt, FldPadElt -&gt; FldPadElt</H5>
<BLOCKQUOTE>
The quotient of the elements x and y. For elements of a local ring, the
result will be returned in its field of fractions.
</BLOCKQUOTE>
<H5><A NAME = "5328">IsExactlyDivisible(x, y) : RngPadElt, RngPadElt -&gt; BoolElt, RngPadElt</A></H5>
<H5>IsExactlyDivisible(x, y) : RngPadResElt, RngPadResElt -&gt; BoolElt, RngPadResElt</H5>
<H5>IsExactlyDivisible(x, y) : RngPadResExtElt, RngPadResExtElt -&gt; BoolElt, RngPadResExtElt</H5>
<H5>IsExactlyDivisible(x, y) : FldPadElt, FldPadElt -&gt; BoolElt, FldPadElt</H5>
<BLOCKQUOTE>
Return <TT>true</TT> if x can be exactly divided by y; in this case also return the
quotient.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "5329">Example <TT>RngLoc_Division (H47E11)</TT></A></H3>
Division of non-units in the ring will yield a result in the field of
fractions.  In that case the result has reduced precision.  To ensure that the
result is returned as a ring element, the operator <TT>div</TT> should be used.
<P>
<P>
<PRE>
&gt; R := pAdicRing(2);
&gt; pi := UniformizingElement(R);
&gt; pi;
2 + O(2^20)
&gt; 1 / pi;
2^-1 + O(2^18)
&gt; Parent($1);
2-adic field
&gt; 1 div pi;

&gt;&gt; 1 div pi;
     ^
Runtime error in 'div': Division is not exact
&gt; IsExactlyDivisible(1, pi);
false
&gt; IsExactlyDivisible(pi^2, pi);
true 2 + O(2^20)
</PRE>
<HR>
<H4><A NAME = "5330">Equality and Membership</A></H4>

<P>
<P>
<P>
It is possible to test whether two local ring or field elements are equal only
in quotient rings.  Equality testing in free precision rings is disabled, as
there are several reasonable definitions of equality in an imprecise ring.


<H5><A NAME = "5331">x eq y : RngPadResElt, RngPadResElt -&gt; BoolElt</A></H5>
<H5>x eq y : RngPadResExtElt, RngPadResExtElt -&gt; BoolElt</H5>
<BLOCKQUOTE>
Given local ring or field elements x and y, return <TT>true</TT> if and only if x
and y are identical in value.  This operator is only defined in fixed
precision rings.
</BLOCKQUOTE>
<H5><A NAME = "5332">x ne y : RngPadResElt, RngPadResElt -&gt; BoolElt</A></H5>
<H5>x ne y : RngPadResExtElt, RngPadResExtElt -&gt; BoolElt</H5>
<BLOCKQUOTE>
Given local ring or field elements x and y, return <TT>true</TT> if and only if x
and y are not identical in value.  This operator is only defined in fixed
precision rings.
</BLOCKQUOTE>
<H5><A NAME = "5333">x in L : ., RngPad  -&gt; BoolElt</A></H5>
<H5>x in L : ., FldPad  -&gt; BoolElt</H5>
<BLOCKQUOTE>
Return <TT>true</TT> if and only if x lies in the local ring or field L.
</BLOCKQUOTE>
<H5><A NAME = "5334">x notin L : ., RngPad  -&gt; BoolElt</A></H5>
<H5>x notin L : ., FldPad  -&gt; BoolElt</H5>
<BLOCKQUOTE>
Return <TT>true</TT> if and only if x does not lie in the local ring or field L.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "5335">Example <TT>RngLoc_unram-ext (H47E12)</TT></A></H3>
We demonstrate how an unramified extension can be constructed from a given
degree.  The idea is to interpret the minimal polynomial of a primitive element
in the residue class field as a polynomial over Z<sub>p</sub>. The quotient of
Z<sub>p</sub>[x] by the ideal generated by this polynomial is isomorphic to the
unramified extension and a := /line(x) is a first approximation for the
p<sup>f</sup> - 1-th root of unity. This is improved by iterating a |-&gt; a<sup>p<sup>f</sup></sup>
until this remains fixed.
<P>
<P>
<PRE>
&gt; p := 2;
&gt; f := 5;
&gt; Zp := pAdicRing(p, 25);
&gt; R&lt;x&gt; := PolynomialRing(Zp);
&gt; g := R ! MinimalPolynomial(GF(p,f).1);
&gt; Q&lt;r&gt; := quo&lt;R | g&gt;;
&gt; a := [ r, r^(p^f) ];
&gt; while a[#a] ne a[#a-1] do
&gt;     print a[#a];
&gt;     Append(~a, a[#a]^(p^f));
&gt; end while;
34*r^4 - 44*r^3 + 58*r^2 - 23*r + 36
12522914*r^4 + 12522004*r^3 - 12174790*r^2 - 8200343*r - 10407260
8242594*r^4 + 12409364*r^3 + 5143098*r^2 + 15781737*r - 3636572
5490082*r^4 + 8804884*r^3 - 11109830*r^2 + 11456361*r + 11698852
-15481438*r^4 - 5875180*r^3 + 5667386*r^2 + 7262057*r - 884060
&gt; [ Minimum([ Valuation(c) : c in Eltseq(a[i] - a[i-1]) ]) : i in [2..#a-1] ]; 
[ 1, 6, 11, 16, 21 ]
</PRE>
The last statement demonstrates the convergence of the process.  The polynomial
defining the unramified extension could now easily be obtained as the minimal
polynomial of the fixed element.
<P>
<P>
<PRE>
&gt; U := ext&lt;Zp | f&gt;;
&gt; MinimalPolynomial(U ! Eltseq(a[#a]));
x^5 - 13205240*x^4 - 3159900*x^3 - 13778593*x^2 + 9730498*x - 1
</PRE>
<HR>
<H4><A NAME = "5336">Properties</A></H4>

<P>
<P>
Local ring and field elements can be tested for certain properties.  However,
note that in free precision rings and fields, exact zero, one, and
minus one elements do not exist, only approximations to such elements --- in
these cases, the predicates will always return <TT>false</TT>.


<H5><A NAME = "5337">IsZero(x) : RngPadElt -&gt; BoolElt</A></H5>
<H5>IsZero(x) : RngPadResElt -&gt; BoolElt</H5>
<H5>IsZero(x) : RngPadResExtElt -&gt; BoolElt</H5>
<H5>IsZero(x) : FldPadElt -&gt; BoolElt</H5>
<BLOCKQUOTE>
Given an element x of a local ring or field, return
<TT>true</TT> if and only if x is the zero element of its parent ring or field.
</BLOCKQUOTE>
<H5><A NAME = "5338">IsOne(x) : RngPadElt -&gt; BoolElt</A></H5>
<H5>IsOne(x) : RngPadResElt -&gt; BoolElt</H5>
<H5>IsOne(x) : RngPadResExtElt -&gt; BoolElt</H5>
<H5>IsOne(x) : FldPadElt -&gt; BoolElt</H5>
<BLOCKQUOTE>
Given an element x of a local ring or field, return
<TT>true</TT> if and only if x is the one element of its parent ring or field.
</BLOCKQUOTE>
<H5><A NAME = "5339">IsMinusOne(x) : RngPadElt -&gt; BoolElt</A></H5>
<H5>IsMinusOne(x) : RngPadResElt -&gt; BoolElt</H5>
<H5>IsMinusOne(x) : RngPadResExtElt -&gt; BoolElt</H5>
<H5>IsMinusOne(x) : FldPadElt -&gt; BoolElt</H5>
<BLOCKQUOTE>
Given an element x of a local ring or field, return
<TT>true</TT> if and only if x is the minus one element of its parent ring or field.
</BLOCKQUOTE>
<H5><A NAME = "5340">IsUnit(x) : RngPadElt -&gt; BoolElt</A></H5>
<H5>IsUnit(x) : RngPadResElt -&gt; BoolElt</H5>
<H5>IsUnit(x) : RngPadResExtElt -&gt; BoolElt</H5>
<H5>IsUnit(x) : FldPadElt -&gt; BoolElt</H5>
<BLOCKQUOTE>
Given an element x of a local ring or field, return
<TT>true</TT> if and only if x is a unit, that is, x has valuation 0.
</BLOCKQUOTE>
<H5><A NAME = "5341">IsIntegral(x) : RngPadElt -&gt; BoolElt</A></H5>
<H5>IsIntegral(x) : RngPadResElt -&gt; BoolElt</H5>
<H5>IsIntegral(x) : RngPadResExtElt -&gt; BoolElt</H5>
<H5>IsIntegral(x) : FldPadElt -&gt; BoolElt</H5>
<BLOCKQUOTE>
Given an element x of a local ring or field, return
<TT>true</TT> if and only if x has non-negative valuation.
</BLOCKQUOTE>
<H4><A NAME = "5342">Precision and Valuation</A></H4>

<P>
<P>
Note that the precision of an element may be modified.


<H5><A NAME = "5343">Parent(x) : RngPadElt -&gt; RngPad</A></H5>
<H5>Parent(x) : RngPadResElt -&gt; RngPadRes</H5>
<H5>Parent(x) : RngPadResExtElt -&gt; RngPadResExt</H5>
<H5>Parent(x) : FldPadElt -&gt; FldPad</H5>
<BLOCKQUOTE>
Return the parent local ring or field of the element x.
</BLOCKQUOTE>
<H5><A NAME = "5344">Precision(x) : RngPadElt -&gt; RngIntElt</A></H5>
<H5>Precision(x) : RngPadResElt -&gt; RngIntElt</H5>
<H5>Precision(x) : RngPadResExtElt -&gt; RngIntElt</H5>
<H5>Precision(x) : FldPadElt -&gt; RngIntElt</H5>
<BLOCKQUOTE>
For a local ring element x, returns the precision to which it is known; for a
local field element x, returns the precision to which its unit part is known.
</BLOCKQUOTE>
<H5><A NAME = "5345">AbsolutePrecision(x) : RngPadElt -&gt; RngIntElt</A></H5>
<H5>AbsolutePrecision(x) : RngPadResElt -&gt; RngIntElt</H5>
<H5>AbsolutePrecision(x) : RngPadResExtElt -&gt; RngIntElt</H5>
<H5>AbsolutePrecision(x) : FldPadElt -&gt; RngIntElt</H5>
<BLOCKQUOTE>
Returns the precision of a local ring or field element x.
</BLOCKQUOTE>
<H5><A NAME = "5346">RelativePrecision(x) : RngPadElt -&gt; RngIntElt</A></H5>
<H5>RelativePrecision(x) : RngPadResElt -&gt; RngIntElt</H5>
<H5>RelativePrecision(x) : RngPadResExtElt -&gt; RngIntElt</H5>
<H5>RelativePrecision(x) : FldPadElt -&gt; RngIntElt</H5>
<BLOCKQUOTE>
Returns the difference between the absolute precision and the valuation of the
local ring or field element x.
</BLOCKQUOTE>
<H5><A NAME = "5347">ChangePrecision(x, k) : RngUPolElt, RngIntElt -&gt; RngPadElt</A></H5>
<H5>ChangePrecision(~x, k) : RngUPolElt, RngIntElt -&gt; RngPadElt</H5>
<H5>ChangePrecision(x, k) : RngPadElt, RngIntElt -&gt; RngPadElt</H5>
<H5>ChangePrecision(~x, k) : RngPadElt, RngIntElt -&gt; RngPadElt</H5>
<H5>ChangePrecision(x, k) : FldPadElt, RngIntElt -&gt; FldPadElt</H5>
<H5>ChangePrecision(~x, k) : FldPadElt, RngIntElt -&gt; FldPadElt</H5>
<BLOCKQUOTE>
Given a local ring or field element or polynomial
over a local ring or field x and a non-negative single precision
integer k, change the precision of x to k.  If k is smaller than the
precision of x, x is truncated; if k is larger, then an element y is
returned such that v(x - y) &ge;k.  Note that the precision of an element
cannot be changed to be greater than its parent. Any attempt to do so will
result in the element gaining the precision of its parent.
</BLOCKQUOTE>
<H5><A NAME = "5348">Expand(x) : RngPadElt -&gt; RngPadElt</A></H5>
<H5>Expand(x) : FldPadElt -&gt; FldPadElt</H5>
<BLOCKQUOTE>
Change the precision of the local ring or field element x to be the maximum
precision allowed by its parent.  This results in an error if x is an element
of an unbounded free precision ring.
</BLOCKQUOTE>
<H5><A NAME = "5349">Valuation(x) : RngPadElt -&gt; RngIntElt</A></H5>
<H5>Valuation(x) : RngPadResElt -&gt; RngIntElt</H5>
<H5>Valuation(x) : RngPadResExtElt -&gt; RngIntElt</H5>
<H5>Valuation(x) : FldPadElt -&gt; RngIntElt</H5>
<BLOCKQUOTE>
Return the valuation of the local ring or field element x. This is always
bounded by the absolute precision of the element.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "5350">Example <TT>RngLoc_ofe (H47E13)</TT></A></H3>
The uses and properties of relative and absolute precision for field elements
are illustrated here, as well as the results of <TT>Expand</TT>.
<P>
<P>
<PRE>
&gt; R&lt;x&gt; := PolynomialRing(Integers());
&gt; K&lt;d&gt; := ext&lt;ext&lt;pAdicField(5, 100) | 2&gt; |  x^2 + 5&gt;;
&gt; x := d + d^7;
&gt; x;
-d*124 + O(d^200)
&gt; AbsolutePrecision(x);
200
&gt; RelativePrecision(x);
199
&gt; RelativePrecision(x + O(d^10));
9
&gt; AbsolutePrecision(x + O(d^10));
10
&gt; RelativePrecision(ChangePrecision(x, 19));
19
&gt; RelativePrecision(ChangePrecision(x, 10));
10
&gt; AbsolutePrecision(ChangePrecision(x, 10));
11
&gt; Expand(ChangePrecision(x, 10));
d*3001 + O(d^201)
&gt; Valuation(x);
1
&gt; ChangePrecision(x, 20) - (x + O(d^21));  
O(d^21)
</PRE>
The last two lines show that changing the precision of an element is 
equivalent to adding imprecision to the element effectively cancelling off
all terms beyond that of relative valuation 20.
<HR>
<H4><A NAME = "5351">Logarithms and Exponentials</A></H4>



<H5><A NAME = "5352">Log(x) : RngPadElt -&gt; RngPadElt</A></H5>
<H5>Log(x) : RngPadResElt -&gt; RngPadResElt</H5>
<H5>Log(x) : RngPadResExtElt -&gt; RngPadResExtElt</H5>
<H5>Log(x) : FldPadElt -&gt; FldPadElt</H5>
<BLOCKQUOTE>
The logarithm of the local ring or field element x, returned to the precision
of x.  Note that the power series of the logarithm function only converges if
the valuation of x - 1 is positive. For ring elements x, the answer lies in
the ring (and not its field of fractions) only if the valuation of x - 1 is
greater than or equal to the ramification degree of the ring divided by the
prime.
<P>
The rate of convergence of <TT>Log</TT> is dependent on the valuation of x - 1.
The greater the valuation the faster the convergence, as is illustrated in the
example below.
</BLOCKQUOTE>
<H5><A NAME = "5353">Exp(x) : RngPadElt -&gt; RngPadElt</A></H5>
<H5>Exp(x) : RngPadResElt -&gt; RngPadResElt</H5>
<H5>Exp(x) : RngPadResExtElt -&gt; RngPadResExtElt</H5>
<H5>Exp(x) : FldPadElt -&gt; FldPadElt</H5>
<BLOCKQUOTE>
The exponential of the local ring or field element x, returned to the
precision of x. Note that the power series of the exponential function only
converges if the valuation of x is strictly larger than e/(p - 1), where e
is the ramification degree of the parent ring of x.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "5354">Example <TT>RngLoc_log (H47E14)</TT></A></H3>
This example illustrates the relative timings of the <TT>Log</TT> function and the
<TT>Exp</TT> function for rings and fields and for various valuations of x - 1
or x as appropriate.
<P>
<P>
<PRE>
&gt; K := ext&lt;pAdicField(3, 20) | x^3 + x^2 + x + 2&gt;;
&gt; K&lt;d&gt; := ext&lt;K | x^3 + 3*x^2 + 3*x + 3&gt;;
&gt; L&lt;b&gt; := IntegerRing(K);
&gt; x := 1 + b;
&gt; time Log(x);
Time: 0.070
&gt; x := 1 + b^5;
&gt; time Log(x);
874050819*b^2 + 1624571442*b - 914550768
Time: 0.010
&gt; Valuation(Exp(Log(x)) - x);
60
&gt; x := b^2;
&gt; time Exp(x);
1418565628*b^2 + 1334033745*b + 905945461
Time: 0.170
&gt; Valuation(Log(Exp(x)) - x);
60
&gt; x := b^6;
&gt; time Exp(x);
1700312013*b^2 - 72781965*b + 1129064707
Time: 0.020
&gt; Valuation(Log(Exp(x)) - x);
60
</PRE>
<HR>
<H4><A NAME = "5355">Norm and Trace</A></H4>



<H5><A NAME = "5356">Norm(x) : RngPadElt -&gt; RngPadElt</A></H5>
<H5>Norm(x) : RngPadResElt -&gt; RngPadResElt</H5>
<H5>Norm(x) : RngPadResExtElt -&gt; RngElt</H5>
<H5>Norm(x) : FldPadElt -&gt; FldPadElt</H5>
<BLOCKQUOTE>
Given a local ring or field element x, return the norm of x over the base
ring of its parent.
</BLOCKQUOTE>
<H5><A NAME = "5357">Norm(x, R) : RngPadElt, RngPad -&gt; RngPadElt</A></H5>
<H5>Norm(x, R) : RngPadResElt, RngPadRes -&gt; RngPadResElt</H5>
<H5>Norm(x, R) : RngPadResExtElt, Rng -&gt; RngElt</H5>
<H5>Norm(x, R) : FldPadElt, FldPad -&gt; FldPadElt</H5>
<BLOCKQUOTE>
Given a local ring or field element x, return the norm of x over the local
ring or field R.  The ring R must be a subring of the parent of x.
</BLOCKQUOTE>
<H5><A NAME = "5358">Trace(x) : RngPadElt -&gt; RngPadElt</A></H5>
<H5>Trace(x) : RngPadResElt -&gt; RngPadResElt</H5>
<H5>Trace(x) : RngPadResExtElt -&gt; RngElt</H5>
<H5>Trace(x) : FldPadElt -&gt; FldPadElt</H5>
<BLOCKQUOTE>
Given a local ring or field element x, return the trace of x over the base
ring of its parent.  The trace is the product of all conjugates of x.
</BLOCKQUOTE>
<H5><A NAME = "5359">Trace(x, R) : RngPadElt, RngPad -&gt; RngPadElt</A></H5>
<H5>Trace(x, R) : RngPadResElt, RngPadRes -&gt; RngPadResElt</H5>
<H5>Trace(x, R) : RngPadResExtElt, Rng -&gt; RngElt</H5>
<H5>Trace(x, R) : FldPadElt, FldPad -&gt; FldPadElt</H5>
<BLOCKQUOTE>
Given a local ring or field element x, return the trace of x over the local
ring or field R.  The ring R must be a subring of the parent of x.  The
trace is the sum of all conjugates of x.
</BLOCKQUOTE>
<H5><A NAME = "5360">MinimalPolynomial(x) : RngPadElt -&gt; RngUPolElt</A></H5>
<H5>MinimalPolynomial(x) : RngPadResElt -&gt; RngUPolElt</H5>
<H5>MinimalPolynomial(x) : RngPadResExtElt -&gt; RngUPolElt</H5>
<H5>MinimalPolynomial(x) : FldPadElt -&gt; RngUPolElt</H5>
<BLOCKQUOTE>
Given a
local ring or field element x, return the minimal polynomial of x over the
base ring of its parent.
</BLOCKQUOTE>
<H5><A NAME = "5361">MinimalPolynomial(x, R) : RngPadElt, RngPad -&gt; RngUPolElt</A></H5>
<H5>MinimalPolynomial(x, R) : RngPadResElt, RngPadRes -&gt; RngUPolElt</H5>
<H5>MinimalPolynomial(x, R) : RngPadResExtElt, Rng -&gt; RngUPolElt</H5>
<H5>MinimalPolynomial(x, R) : FldPadElt, FldPad -&gt; RngUPolElt</H5>
<BLOCKQUOTE>
Given a local ring or field element x, return the minimal polynomial of x
over the local ring or field R.  The ring R must be a subring of the
parent of x.
<P>
</BLOCKQUOTE>
<H5><A NAME = "5362">CharacteristicPolynomial(x) : RngPadElt -&gt; RngUPolElt</A></H5>
<H5>CharacteristicPolynomial(x) : RngPadResElt -&gt; RngUPolElt</H5>
<H5>CharacteristicPolynomial(x) : RngPadResExtElt -&gt; RngUPolElt</H5>
<BLOCKQUOTE>
Given a
local ring element x, return the characteristic polynomial of x over the
base ring of its parent.
</BLOCKQUOTE>
<H5><A NAME = "5363">CharacteristicPolynomial(x, R) : RngPadElt, RngPad -&gt; RngUPolElt</A></H5>
<H5>CharacteristicPolynomial(x, R) : RngPadResElt, RngPadRes -&gt; RngUPolElt</H5>
<H5>CharacteristicPolynomial(x, R) : RngPadResExtElt, RngPadRes -&gt; RngUPolElt</H5>
<H5>CharacteristicPolynomial(x, R) : RngPadResExtElt, RngPadResExt -&gt; RngUPolElt</H5>
<BLOCKQUOTE>
Given a local ring or field element x, return the characteristic polynomial 
of x
over the local ring or field R.  The ring R must be a subring of the
parent of x.
<P>
</BLOCKQUOTE>
<H5><A NAME = "5364">GaloisImage(x, i) : RngPadElt, RngIntElt -&gt; RngPadElt</A></H5>
<H5>GaloisImage(x, i) : RngPadResElt, RngIntElt -&gt; RngPadResElt</H5>
<H5>GaloisImage(x, i) : RngPadResExtElt, RngIntElt -&gt; RngPadResExtElt</H5>
<H5>GaloisImage(x, i) : FldPadElt, RngIntElt -&gt; FldPadElt</H5>
<BLOCKQUOTE>
Given a local ring or field element x, return the image of x under the
Frobenius automorphism composed with itself i times, that is, a |-&gt; a<sup>(p<sup>i</sup>)</sup> where a is a p<sup>f</sup> - 1st root of unity of the parent of x.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "5365">Example <TT>RngLoc_agm (H47E15)</TT></A></H3>
One important application of the p-adics is to counting points on elliptic
curves over finite fields.  This example demonstrates how a simple version of
the Arithmetic-Geometric Mean (AGM) algorithm could be implemented in Magma.
<P>
<P>
<PRE>
&gt; d := 50;
&gt; FF := GF(2^d);
&gt; E := EllipticCurve([FF | 1, 0, 0, 0, Random(FF)]);
&gt; assert Degree(sub&lt;BaseRing(E) | jInvariant(E)&gt;) gt 2;
&gt; 
&gt; n := (d + 1) div 2 + 3;
&gt; R := ext&lt;pAdicRing(2) | d&gt;;
&gt; R`DefaultPrecision := n;
&gt; 
&gt; a6 := elt&lt;R | jInvariant(E)^-1, 1&gt;;
&gt; lambda := 1 + 8 * a6;
&gt; 
&gt; for k in [4..n] do
&gt;     ChangePrecision(~lambda, k + 2);
&gt;     lambda := (1 + lambda) * InverseSqrt(lambda) div 2;
&gt; end for;

&gt; lambda := 2 * lambda div (1 + lambda);
&gt; Exp(Trace(Log(lambda))); 
32196193 + O(2^26)
&gt; Trace(E) mod 2^26;
32196193
</PRE>
<HR>
<H5><A NAME = "5366">EuclideanNorm(x) : RngPadResElt -&gt; RngIntElt</A></H5>
<H5>EuclideanNorm(x) : RngRadResExtElt -&gt; RngIntElt</H5>
<BLOCKQUOTE>
Return the euclidean norm of the element x of a fixed precision local ring.
</BLOCKQUOTE>
<H4><A NAME = "5367">Teichm&uuml;ller Lifts</A></H4>

<P>
<P>
<P>
Another important operation is the determination of the canonical
<I>Teichm&uuml;ller lift</I> of an element u in the residue field of a
p-adic ring. By definition this is the unique root of unity of order
prime to p which reduces to u modulo the maximal ideal.


<H5><A NAME = "5368">TeichmuellerLift(u, R) : FldFinElt, RngPadResExt -&gt; RngPadResExtElt</A></H5>
<H5>TeichmuellerLift(u, R) : FldFinElt, RngPadRes -&gt; RngPadResElt</H5>
<BLOCKQUOTE>
For a fixed precision quotient ring R of the p-adics or
an unramified extension and a finite field element u, the function
attempts to coerce u into the residue class field of R and then computes
and returns its Teichm&uuml;ller lift to R. This uses a fast iterative
lifting method of Harley described in Chapter 12 of <A  HREF = "text480.htm#bib_hb_ec_hc_crypto">[C+05]</A>.
For unramified extensions this works most efficiently with <TT>Cyclotomic</TT>
or <TT>Gaussian Normal</TT> bases since it uses the Frobenius operation.
<P>
</BLOCKQUOTE>
<PRE></PRE> <A  HREF = "text490.htm">[Next]</A><A  HREF = "text488.htm">[Prev]</A> <A  HREF = "text490.htm">[Right]</A> <A  HREF = "text488.htm">[Left]</A> <A  HREF = "text481.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<br><small>Version: V2.22 of <I>
Thu Jun  9 16:37:49 EST 2016
</I></small>
</body></html>