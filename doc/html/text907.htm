<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <link rel='stylesheet' href='help.css' type='text/css'>
  <TITLE>Operations on Algebras and Subalgebras</TITLE>
</head>
<body BGCOLOR="#FFFFFF">

 <A  HREF = "text908.htm">[Next]</A><A  HREF = "text906.htm">[Prev]</A> <A  HREF = "text908.htm">[Right]</A> <A  HREF = "text906.htm">[Left]</A> <A  HREF = "text903.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<PRE></PRE><H3><A NAME = "10235">Operations on Algebras and Subalgebras</A></H3>




<H5>Subsections</H5>
<UL>
<LI> <A  HREF = "text907.htm#10236">Invariants of an Algebra</A>
<LI> <A  HREF = "text907.htm#10240">Changing Rings</A>
<LI> <A  HREF = "text907.htm#10243">Bases</A>
<LI> <A  HREF = "text907.htm#10248">Decomposition of an Algebra</A>
<LI> <A  HREF = "text907.htm#10257">Operations on Subalgebras</A>
</UL>
<H4><A NAME = "10236">Invariants of an Algebra</A></H4>



<H5><A NAME = "10237">CoefficientRing(A) : AlgGen -&gt; Rng</A></H5>
<H5>CoefficientField(A) : AlgGen -&gt; Rng</H5>
<H5>BaseRing(A) : AlgGen -&gt; Rng</H5>
<H5>BaseField(A) : AlgGen -&gt; Rng</H5>
<BLOCKQUOTE>
The coefficient ring (or base ring) over which the algebra A is defined.
</BLOCKQUOTE>
<H5><A NAME = "10238">Dimension(A) : AlgGen -&gt; RngIntElt</A></H5>
<BLOCKQUOTE>
The dimension of the algebra A.
</BLOCKQUOTE>
<H5><A NAME = "10239"># A : AlgGen -&gt; RngIntElt</A></H5>
<BLOCKQUOTE>
The cardinality of the algebra A if both R and the dimension of A are
finite.
Note that this cannot be computed if the dimension of A is too large.
<P>
<P>
</BLOCKQUOTE>
<H4><A NAME = "10240">Changing Rings</A></H4>

<P>
<P>


<H5><A NAME = "10241">ChangeRing(A, S) : AlgGen, Rng -&gt; AlgGen, Map</A></H5>
<BLOCKQUOTE>
Given an algebra A with base ring R, together with a ring S,
construct the algebra B with base ring S obtained by coercing the
coefficients of elements of A into S, together with the homomorphism
from A to B.
<P>
<P>
This function can not be applied if A is of type <TT>AlgGrpSub</TT>, as the 
parent structure of elements of A is the full group algebra of which A is a 
subalgebra.
</BLOCKQUOTE>
<H5><A NAME = "10242">ChangeRing(A, S, f) : AlgGen, Rng, Map -&gt; AlgGen, Map</A></H5>
<BLOCKQUOTE>
Given an algebra A with base ring R, together with a ring S
and a map f: R -&gt; S, construct the algebra B with base ring S
obtained by mapping the coefficients of elements of A into S via f,
together with the homomorphism from A to B.
<P>
<P>
As above, this function can not be applied if A is of type <TT>AlgGrpSub</TT>.
</BLOCKQUOTE>
<H4><A NAME = "10243">Bases</A></H4>

<P>
<P>
<P>
In general, every algebra comes with a basis, corresponding to its underlying
module structure. The only exception for that are group algebras in the
<TT>"Terms"</TT> representation, where the dimension of the algebra may be too 
large to create vectors of that degree.


<H5><A NAME = "10244">BasisElement(A, i) : AlgGen, RngIntElt -&gt; AlgGenElt</A></H5>
<H5>A . i : AlgGen, RngIntElt -&gt; AlgGenElt</H5>
<BLOCKQUOTE>
The i-th basis element of the algebra A.
</BLOCKQUOTE>
<H5><A NAME = "10245">Basis(A) : AlgGen -&gt; [ AlgGenElt ]</A></H5>
<BLOCKQUOTE>
The basis of the algebra A, as a sequence of elements of A.
<P>
<P>
Note that if A is of type <TT>AlgGrpSub</TT> the returned elements will be
elements of the full group algebra of which A is a subalgebra.
</BLOCKQUOTE>
<H5><A NAME = "10246">IsIndependent(Q) : [ AlgGen ] -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Given a sequence Q of elements of the R-algebra A, this functions returns
<TT>true</TT> if these elements are linearly independent over R; otherwise <TT>false</TT>.
</BLOCKQUOTE>
<H5><A NAME = "10247">ExtendBasis(S, A) : AlgGen, AlgGen -&gt; [ AlgElt ]</A></H5>
<H5>ExtendBasis(Q, A) : [ AlgGen ], AlgGen -&gt; [ AlgElt ]</H5>
<BLOCKQUOTE>
Given an algebra A and either a subalgebra S of dimension m of A or a 
sequence Q of m linearly independent elements of A, return a sequence
containing a basis of A such that the first m elements are the basis of
S resp. the elements in Q.
</BLOCKQUOTE>
<H4><A NAME = "10248">Decomposition of an Algebra</A></H4>

<P>
<P>
<P>
An algebra A can be regarded as a (left- or right-) module for itself.
If A is defined over a finite field, the machinery to decompose modules
over finite fields can be used to investigate the structure of the algebra A.


<H5><A NAME = "10249">CompositionSeries(A) : AlgGen -&gt; [ AlgGen ], [ AlgGen ], AlgMatElt</A></H5>
<BLOCKQUOTE>
Compute a composition series for the algebra A.
The function has three return values:
<DL COMPACT class='compact'>
<DT>(a)</DT><DD>a sequence containing the composition series as an ascending chain of
subalgebras such that the successive quotients are irreducible A-modules;
<DT>(b)</DT><DD>a sequence containing the composition factors as structure
constant algebras;
<DT>(c)</DT><DD>a transformation matrix to a basis compatible with the
composition series, that is, the first basis elements form a basis of the first
term of the composition series, the next extend these to a basis for the second
term etc.</DL>
</BLOCKQUOTE>
<H5><A NAME = "10250">CompositionFactors(A) : AlgGen -&gt; [ AlgGen ]</A></H5>
<BLOCKQUOTE>
Compute the composition factors of a composition series for the algebra A.
This function returns the same as the second return value of <TT>CompositionSeries</TT> above, but will often be very much quicker.
</BLOCKQUOTE>
<H5><A NAME = "10251">MinimalLeftIdeals(A : parameters) : AlgGen -&gt; [ AlgGen ], BoolElt</A></H5>
<H5>MinimalRightIdeals(A : parameters) : AlgGen -&gt; [ AlgGen ], BoolElt</H5>
<H5>MinimalIdeals(A : parameters) : AlgGen -&gt; [ AlgGen ], BoolElt</H5>

<PRE>    Limit: RngIntElt                    Default: &infin;</PRE>
<BLOCKQUOTE>
Return the minimal left/right/two-sided ideals of A (in non-decreasing size).
If <TT>Limit</TT> is set to n, at most n ideals are calculated and the second
return value indicates whether all of the ideals were computed.
</BLOCKQUOTE>
<H5><A NAME = "10252">MaximalLeftIdeals(A : parameters) : AlgGen -&gt; [ AlgGen ], BoolElt</A></H5>
<H5>MaximalRightIdeals(A : parameters) : AlgGen -&gt; [ AlgGen ], BoolElt</H5>
<H5>MaximalIdeals(A : parameters) : AlgGen -&gt; [ AlgGen ], BoolElt</H5>

<PRE>    Limit: RngIntElt                    Default: &infin;</PRE>
<BLOCKQUOTE>
Return the maximal left/right/two-sided ideals of A (in non-decreasing size).
If <TT>Limit</TT> is set to n, at most n ideals are calculated and the second
return value indicates whether all of the ideals were computed.
</BLOCKQUOTE>
<H5><A NAME = "10253">JacobsonRadical(A) : AlgGen -&gt; AlgGen</A></H5>
<BLOCKQUOTE>
Construct the Jacobson (or nilpotent) radical of A, that is, the
intersection of the maximal ideals of A (which is equal to the intersection
of the maximal left or right ideals).
</BLOCKQUOTE>
<H5><A NAME = "10254">IsSemisimple(A) : AlgGen -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Return <TT>true</TT> if the Jacobson radical of A is trivial; otherwise <TT>false</TT>.
</BLOCKQUOTE>
<H5><A NAME = "10255">IsSimple(A) : AlgGen -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Return <TT>true</TT> if A has no non-trivial composition factor; otherwise <TT>false</TT>.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "10256">Example <TT>AlgGen_quaternions (H84E1)</TT></A></H3>
<P>
We create a division algebra of dimension 4 over the rational field.
<P>
<P>
<PRE>
&gt; Q := MatrixAlgebra&lt; Rationals(), 4 |
&gt;    [0,1,0,0, -1,0,0,0, 0,0,0,-1, 0,0,1,0],
&gt;    [0,0,1,0, 0,0,0,1, -1,0,0,0, 0,-1,0,0]&gt;;
&gt; i := Q.1;
&gt; j := Q.2;
&gt; k := i*j;
&gt; Dimension(Q);
4
&gt; MinimalPolynomial( (1+i+j+k)/2 );
$.1^2 - $.1 + 1
</PRE>
<P>
Hence, the element <TT>(1+i+j+k)/2</TT> is integral. In fact,  together with
<TT>1</TT>, <TT>i</TT> and <TT>j</TT> it forms a Z-basis of a maximal order in <TT>Q</TT>.
We create this maximal order as a structure constant algebra over the integers.
<P>
<P>
<PRE>
&gt; a := [ Q!1, i, j, (1+i+j+k)/2 ];
&gt; T := MatrixAlgebra(Rationals(),4) ! &amp;cat[ Coordinates(Q,a[i]) : i in [1..4] ];
&gt; V := RSpace(Rationals(), 4);
&gt; C := [ V ! Coordinates(Q, a[i]*a[j]) * T^-1 : j in [1..4], i in [1..4] ];   
&gt; A := ChangeRing( Algebra&lt; V | C &gt;, Integers() );             
&gt; IsAssociative(A);
true
&gt; AA := AssociativeAlgebra(A);
&gt; AA;
Associative Algebra of dimension 4 with base ring Integer Ring
&gt; MinimalPolynomial(AA.4);
$.1^2 - $.1 + 1
</PRE>
<P>
The so constructed maximal order is ramified at 2 and &infin;, hence it should
be simple after reducing at odd primes.
<P>
<P>
<PRE>
&gt; for p in [ i : i in [1..100] | IsPrime(i) ] do
&gt;    if not IsSimple( ChangeRing( AA, GF(p) ) ) then
&gt;       print p;
&gt;    end if;
&gt; end for;
2
&gt; CS, CF, T := CompositionSeries( ChangeRing( AA, GF(2) ) );
&gt; T;
[1 0 1 0]
[0 1 1 0]
[0 0 1 0]
[0 0 0 1]
</PRE>
<P>
A glance at the preimages of the basis of the irreducible submodule
shows the ramification of AA at the prime 2.
<P>
<P>
<PRE>
&gt; MinimalPolynomial(AA.1 + AA.3);
$.1^2 - 2*$.1 + 2
&gt; MinimalPolynomial(AA.2 + AA.3);
$.1^2 + 2
</PRE>
<HR>
<H4><A NAME = "10257">Operations on Subalgebras</A></H4>



<H5><A NAME = "10258">IsZero(A) : AlgGen -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if the algebra A is trivial; otherwise <TT>false</TT>.
</BLOCKQUOTE>
<H5><A NAME = "10259">A eq B : AlgGen, AlgGen -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if the algebras A and B (having a common superalgebra) are equal;
otherwise <TT>false</TT>.
</BLOCKQUOTE>
<H5><A NAME = "10260">A ne B : AlgGen, AlgGen -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if the algebras A and B are not equal; otherwise <TT>false</TT>.
</BLOCKQUOTE>
<H5><A NAME = "10261">A subset B : AlgGen, AlgGen -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if A is a subalgebra of the algebra B; otherwise <TT>false</TT>.
</BLOCKQUOTE>
<H5><A NAME = "10262">A notsubset B : AlgGen, AlgGen -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if A is not a subalgebra of the algebra B; otherwise <TT>false</TT>.
</BLOCKQUOTE>
<H5><A NAME = "10263">A meet B : AlgGen, AlgGen -&gt; AlgGen</A></H5>
<BLOCKQUOTE>
The intersection of the algebras A and B, which must
have a common superalgebra.
</BLOCKQUOTE>
<H5><A NAME = "10264">A * B : AlgGen, AlgGen -&gt; AlgGen</A></H5>
<BLOCKQUOTE>
The algebra product A * B of the algebras A and B, which must
have a common superalgebra.
</BLOCKQUOTE>
<H5><A NAME = "10265">A ^ n : AlgGen, RngIntElt -&gt; AlgGen</A></H5>
<BLOCKQUOTE>
The (left-normed) n-th power of the algebra A, i.e.
(( ... (A * A) * ... ) * A).
</BLOCKQUOTE>
<H5><A NAME = "10266">Morphism(A, B) : AlgGen, AlgGen -&gt; Map</A></H5>
<BLOCKQUOTE>
The map giving the morphism from A to B. Either A is a subalgebra of B, 
in which case the embedding of A into B is returned, or B is a quotient
algebra of A, in which case the natural epimorphism from A onto B is 
returned.
</BLOCKQUOTE>
<PRE></PRE> <A  HREF = "text908.htm">[Next]</A><A  HREF = "text906.htm">[Prev]</A> <A  HREF = "text908.htm">[Right]</A> <A  HREF = "text906.htm">[Left]</A> <A  HREF = "text903.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<br><small>Version: V2.22 of <I>
Thu Jun  9 16:37:49 EST 2016
</I></small>
</body></html>