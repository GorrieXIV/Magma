<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <link rel='stylesheet' href='help.css' type='text/css'>
  <TITLE>Abelian, Nilpotent and Soluble  Quotient</TITLE>
</head>
<body BGCOLOR="#FFFFFF">

 <A  HREF = "text814.htm">[Next]</A><A  HREF = "text812.htm">[Prev]</A> <A  HREF = "text814.htm">[Right]</A> <A  HREF = "text812.htm">[Left]</A> <A  HREF = "text808.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<PRE></PRE><H3><A NAME = "9250">Abelian, Nilpotent and Soluble  Quotient</A></H3>




<H5>Subsections</H5>
<UL>
<LI> <A  HREF = "text813.htm#9251">Abelian Quotient</A>
<LI> <A  HREF = "text813.htm#9266">p-Quotient</A>
<LI> <A  HREF = "text813.htm#9267">The Construction of a p-Quotient</A>
<LI> <A  HREF = "text813.htm#9275">Nilpotent Quotient</A>
<LI> <A  HREF = "text813.htm#9282">Soluble Quotient</A>
</UL>
<H4><A NAME = "9251">Abelian Quotient</A></H4>

<P>
<P>
The functions in this section compute information about the abelian quotient
of an fp-group G. Some functions may require the computation of a coset
table. Experienced users can control the behaviour of an implicit coset
enumeration  with a set of global parameters. These global parameters can
be changed using the function <A  HREF = "text814.htm#GrpFP_1:SetGlobalTCParameters">SetGlobalTCParameters</A>. For a
detailed description  of the available parameters and their meanings, we
refer to Chapter <A  HREF = "text823.htm#9460">FINITELY PRESENTED GROUPS: ADVANCED</A>.
<P>
The functions returning the abelian quotient or the abelian quotient invariants
report an error if the abelian quotient cannot be computed, for example,
because the relation matrix is too large.  To avoid problems in user written
programs or loops, the functions <A  HREF = "text813.htm#GrpFP_1:HasComputableAbelianQuotient">HasComputableAbelianQuotient</A>
and <A  HREF = "text813.htm#GrpFP_1:HasInfiniteComputableAbelianQuotient">HasInfiniteComputableAbelianQuotient</A> can be used.


<H5><A NAME = "9252"></A><A NAME = "GrpFP_1:AbelianQuotient">AbelianQuotient</A>(G) : GrpFP -&gt; GrpAb, Map</H5>
<BLOCKQUOTE>
The maximal abelian quotient G/G<sup>prime</sup> of the group G as <TT>GrpAb</TT>
(cf. Chapter <A  HREF = "text786.htm#8898">ABELIAN GROUPS</A>). The natural epimorphism
&pi;:G -&gt; G/G<sup>prime</sup> is returned as second value.
</BLOCKQUOTE>
<H5><A NAME = "9253"></A><A NAME = "GrpFP_1:ElementaryAbelianQuotient">ElementaryAbelianQuotient</A>(G, p) : GrpFP, RngIntElt -&gt; GrpAb, Map</H5>
<BLOCKQUOTE>
The maximal p-elementary abelian quotient Q of the group G as
<TT>GrpAb</TT> (cf. Chapter <A  HREF = "text786.htm#8898">ABELIAN GROUPS</A>). The natural epimorphism
&pi;:G -&gt; Q is returned as second value.
</BLOCKQUOTE>
<H5><A NAME = "9254"></A><A NAME = "GrpFP_1:AbelianQuotientInvariants">AbelianQuotientInvariants</A>(G) : GrpFP -&gt; [ RngIntElt ]</H5>
<H5>AQInvariants(G) : GrpFP -&gt; [ RngIntElt ]</H5>
<BLOCKQUOTE>
Given a finitely presented group G, this function computes the elementary 
divisors of the derived quotient group G/G', by constructing the relation 
matrix for G and transforming it into Smith normal form. The algorithm 
used is an algorithm of Havas which does the reduction entirely over 
the ring of integers Z using clever heuristics to minimize the growth 
of coefficients. 
<P>
The divisors are returned as a sequence of integers.
</BLOCKQUOTE>
<H5><A NAME = "9255"></A><A NAME = "GrpFP_1:AbelianQuotientInvariants_sub">AbelianQuotientInvariants</A>(H) : GrpFP -&gt; [ RngIntElt ]</H5>
<H5>AQInvariants(H) : GrpFP -&gt; [ RngIntElt ]</H5>
<H5>AbelianQuotientInvariants(G, T) : GrpFP, Map -&gt; [ RngIntElt ]</H5>
<H5>AQInvariants(G, T) : GrpFP, Map -&gt; [ RngIntElt ]</H5>
<BLOCKQUOTE>
Given a subgroup H of the finitely presented group G, this function 
computes the elementary divisors of the derived quotient group of H.
(The coset table T may be used to define H.)
This is done by abelianising the Reidemeister-Schreier presentation for 
H and then proceeding as above. The divisors are returned as a sequence
of integers. 
</BLOCKQUOTE>
<H5><A NAME = "9256"></A><A NAME = "GrpFP_1:AbelianQuotientInvariants_mod">AbelianQuotientInvariants</A>(G, n) : GrpFP, RngIntElt -&gt; [ RngIntElt ]</H5>
<H5>AQInvariants(G, n) : GrpFP, RngIntElt -&gt; [ RngIntElt ]</H5>
<BLOCKQUOTE>
Given a finitely presented group G, this function computes the
elementary divisors of the quotient group G/N, where N is the normal
subgroup of G generated by the derived group G' together with all 
n-th powers of elements of G. The algorithm constructs the relation matrix
corresponding to the presentation of G and computes its Smith normal
form over the ring Z/nZ.  The calculation is particularly efficient
when n is a small prime.  The divisors are returned as a sequence of
integers.
</BLOCKQUOTE>
<H5><A NAME = "9257">AbelianQuotientInvariants(H, n) : GrpFP, RngIntElt -&gt; [ RngIntElt ]</A></H5>
<H5>AQInvariants(H, n) : GrpFP, RngIntElt -&gt; [ RngIntElt ]</H5>
<H5>AbelianQuotientInvariants(G, T, n) : GrpFP, Map, RngIntElt -&gt; [ RngIntElt ]</H5>
<H5>AQInvariants(G, T, n) : GrpFP, Map, RngIntElt -&gt; [ RngIntElt ]</H5>
<BLOCKQUOTE>
Given a subgroup H of the finitely presented group G, this function 
computes the elementary divisors of the quotient group H/N, where N 
is the normal subgroup of H generated by H' together with all n-th 
powers of elements of H. (The coset table T may be used to define H.)
This is done by abelianising the Reidemeister-Schreier presentation for 
H and then proceeding as above. The divisors are returned as a sequence
of integers. 
</BLOCKQUOTE>
<H5><A NAME = "9258"></A><A NAME = "GrpFP_1:HasComputableAbelianQuotient">HasComputableAbelianQuotient</A>(G) : GrpFP -&gt; BoolElt, GrpAb, Map</H5>
<BLOCKQUOTE>
Given an fp-group G, this function tests whether the abelian quotient of
G can be computed.  If so, it returns the value <TT>true</TT>, the abelian
quotient A of G and the natural epimorphism &pi;:G -&gt; A.  If the
abelian quotient of G cannot be computed, the value <TT>false</TT> is returned.
<P>
This function is especially useful to avoid runtime errors in user written
loops or functions.
</BLOCKQUOTE>
<H5><A NAME = "GrpFP_1:HasInfiniteComputableAbelianQuotient"></A><A NAME = "9259">HasInfiniteComputableAbelianQuotient(G) : GrpFP -&gt; BoolElt, GrpAb, Map</A></H5>
<BLOCKQUOTE>
Given an fp-group G, this function tests whether the abelian quotient of
G can be computed and is infinite.  If so, it returns the value <TT>true</TT>,
the abelian quotient A of G and the natural epimorphism
&pi;:G -&gt; A.  If the abelian quotient of G cannot be computed or
if it is finite, the value <TT>false</TT> is returned.
<P>
The function first checks the modular abelian invariants for a set of small
primes. If for one of these primes, the modular abelian quotient is trivial,
A must be finite and the function returns without actually computing the
abelian quotient.   If one is interested only in infinite quotients, this
heuristics may save time.
</BLOCKQUOTE>
<H5><A NAME = "9260">IsPerfect(G) : GrpFP -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Given an fp-group G, this function tries to decide whether G is perfect
by checking whether the abelian quotient of G is trivial. 
</BLOCKQUOTE>
<H5><A NAME = "9261">TorsionFreeRank(G) : GrpFP -&gt; RngIntElt</A></H5>
<BLOCKQUOTE>
Given the finitely presented group G, return the torsion-free rank of 
the derived quotient group of G.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "9262">Example <TT>GrpFP_1_F27 (H75E37)</TT></A></H3>
The Fibonacci group F(7) has the following 2-generator
presentation:
&lt;a, b  |  a<sup>2</sup>b<sup> - 2</sup>a<sup> - 1</sup>b<sup> - 2</sup>(a<sup> - 1</sup>b<sup> - 1</sup>)<sup>2</sup>, abab<sup>2</sup>abab<sup> - 1</sup>(ab<sup>2</sup>)<sup>2</sup>&gt;.
We proceed to investigate the structure of this group.
<P>
<P>
<PRE>
&gt; F&lt;a, b&gt; := FreeGroup(2);
&gt; F7&lt;a, b&gt; := quo&lt; F |  a^2*b^-2*a^-1*b^-2*(a^-1*b^-1)^2,
&gt;        a*b*a*b^2*a*b*a*b^-1*(a*b^2)^2 &gt;;
&gt; F7;
Finitely presented group F7 on 2 generators
Relations
       a^2 * b^-2 * a^-1 * b^-2 * a^-1 * b^-1 * a^-1 * b^-1 =Id(F7)
       a * b * a * b^2 * a * b * a * b^-1 * a * b^2 * a * b^2 = Id()7
</PRE>
We begin by determining the structure of the maximal abelian quotient of
F(7).
<P>
<P>
<PRE>
&gt; AbelianQuotientInvariants(F7);
[ 29 ]
</PRE>
The maximal abelian quotient of F(7) is cyclic of order 29. At this point
there is no obvious way to  proceed, so we attempt to determine the index of
some subgroups.
<P>
<P>
<PRE>
&gt; Index( F7, sub&lt; F7 | a &gt; );
1
</PRE>
We are in luck: F(7) is generated by a and so must be cyclic.
This fact coupled with the knowledge that its abelian quotient has
order 29 tells us that the group is cyclic of order 29.
<HR>
<H3><A NAME = "9263">Example <TT>GrpFP_1_modular-abelian-quotient (H75E38)</TT></A></H3>
The group G = (8, 7 | 2, 3) is defined by the presentation
&lt; a, b    |    a<sup>8</sup>, b<sup>7</sup>, (ab)<sup>2</sup>, (a<sup> - 1</sup>b)<sup>3</sup> &gt;.
We consider the subgroup H of G, generated by the words a<sup>2</sup> and
a<sup> - 1</sup>b:
<P>
<P>
<PRE>
&gt; G&lt;a, b&gt; := Group&lt;a, b| a^8, b^7, (a * b)^2, (a^-1 * b)^3&gt;;
&gt; H&lt;x, y&gt; := sub&lt; G | a^2, a^-1 * b &gt;;
</PRE>
The fastest way to determine the order of the maximal 2-elementary abelian
quotient of H is to use the function
<A  HREF = "text813.htm#GrpFP_1:AbelianQuotientInvariants_mod">AbelianQuotientInvariants</A>:
<P>
<P>
<PRE>
&gt; #AbelianQuotientInvariants(H,2);  
1
</PRE>
We see that the maximal 2-elementary abelian quotient of H has order 2<sup>1</sup>.
<HR>
<H5><A NAME = "9264">HasFiniteAbelianQuotient(G) : GrpFP -&gt; [ RngIntElt ]</A></H5>
<H5>HasFiniteAQ(G) : GrpFP -&gt; [ RngIntElt ]</H5>
<BLOCKQUOTE>
Return <TT>true</TT> if G has finite abelian quotient. 
The algorithm requires either a presentation for G, or the coset table
for G inside some supergroup of G which has a presentation.
If such a coset table cannot be computed, an error will result.
</BLOCKQUOTE>
<H5><A NAME = "9265">AQPrimes(G) : GrpFP -&gt; [ RngIntElt ]</A></H5>
<BLOCKQUOTE>
Return a sequence of primes containing all prime divisors of the order of
G/G', if this is finite. Note that there may be primes in the return sequence
which do not divide this order. If <TT>[ 0 ]</TT> is returned then G/G' is
infinite. If <TT>[]</TT> is returned, then G is perfect. The algorithm
requires either a presentation for G, or the coset table for G inside
some supergroup of G which has a presentation. If such a coset table cannot be
computed, an error will result.
</BLOCKQUOTE>
<H4><A NAME = "9266">p-Quotient</A></H4>

<P>
<P>
<P>
<P>
Let F be a finitely presented group, p a prime and c a
positive integer. A p-quotient algorithm constructs a consistent 
power-conjugate presentation
for the largest p-quotient of F having lower exponent-p class 
at most c.  The p-quotient algorithm used by Magma is 
part of the ANU p-Quotient program. For details of the algorithm, see
<A  HREF = "text807.htm#bib_newman_obrien">[NO96]</A>. In Magma the result is returned as
a group of type <TT>GrpPC</TT> (cf. Chapter <A  HREF = "text706.htm#7978">FINITE SOLUBLE GROUPS</A>).
<P>
<P>
<P>
<P>
Assume that the p-quotient has order p<sup>n</sup>, 
Frattini rank d, and that its
generators are a<sub>1</sub>, ..., a<sub>n</sub>.
Then the power-conjugate presentation constructed has the following
additional structure. The set {a<sub>1</sub>, ..., a<sub>d</sub>}
is a generating set for G.
For each a<sub>k</sub> in {a<sub>d + 1</sub>, ..., a<sub>n</sub>}, there is
at least one relation whose right hand side is a<sub>k</sub>.
One of these relations is taken as the <I>definition</I> of a<sub>k</sub>.
(The list of definitions is also returned by <TT>pQuotient</TT>.)
The  power-conjugate generators also have a <I>weight</I> associated 
with them: a generator is assigned a weight corresponding to the 
stage at which it is added and this weight is extended to all 
normal words in a natural way.
<P>
<P>
The p-quotient function and its associated commands allows
the user to construct a power-conjugate presentation (pcp)
for a p-group. Note that there is also a process version of the
p-quotient algorithm, which gives the user complete control over its
execution. For a description, we refer to Chapter <A  HREF = "text823.htm#9460">FINITELY PRESENTED GROUPS: ADVANCED</A>.


<H4><A NAME = "9267">The Construction of a p-Quotient</A></H4>



<P>
<P>
<P>
<P>
The parameters available for the function <A  HREF = "text813.htm#GrpFP_1:pQuotient">pQuotient</A> are:
<P>
var Exponent: RngIntElt                 Default: 0
If <TT>Exponent := m</TT>, enforce the exponent law, x<sup>m</sup> = 1, on the group.
<P>
var Metabelian: BoolElt                 Default: <TT>false</TT>
If <TT>Metabelian := true</TT>, then a consistent pcp is constructed for the
largest metabelian p-quotient of F having lower exponent-p class 
at most c.  
<P>
var Print: RngIntElt                    Default: 0
This parameter controls the volume of printing. By default its value
is that returned by <TT>GetVerbose("pQuotient")</TT>, which is
0 unless it has been changed through use of <TT>SetVerbose</TT>.
The effect is the following:
<P>
 <TT>Print := 0</TT>: 
No output.
<P>
 <TT>Print := 1</TT>: 
Report order of p-quotient at each class.
<P>
 <TT>Print := 2</TT>: 
Report statistics and redundancy information about tails, consistency, 
collection of relations and exponent enforcement components of calculation.
<P>
 <TT>Print := 3</TT>: 
Report in detail on the construction of each class.
<P>
<P>
Note that the presentation displayed is a <I>power-commutator</I> 
presentation (since this is the version stored by the p-quotient). 
<P>
var Workspace: RngIntElt                Default: 5000000
The amount of space requested for the p-quotient computation.
<H5><A NAME = "9268"></A><A NAME = "GrpFP_1:pQuotient">pQuotient</A>(F, p, c: parameters) : GrpFP, RngIntElt, RngIntElt -&gt; GrpPC, Map, SeqEnum , BoolElt</H5>
<BLOCKQUOTE>
Given an fp-group F, a prime p and a positive integer c, 
construct a pcp for the largest p-quotient G of F having lower 
exponent-p class at most c. If c is given as 0, then the
limit 127 is placed on the class.
The function also returns the natural homomorphism
&pi; from F to G, a sequence S describing the definitions of the
pc-generators of G and a flag indicating whether G is the maximal
p-quotient of F.
<P>
The k-th element of S is a sequence of two integers, describing the
definition of the k-th pc-generator G.k of G as follows.
<P>
<DL COMPACT class='compact'>
<DT>-</DT><DD>If S[k] = [0, r], then G.k is defined via the image of F.r under &pi;.
<P>
<DT>-</DT><DD>If S[k] = [r, 0], then G.k is defined via the power relation for G.r.
<P>
<DT>-</DT><DD>If S[k] = [r, s], then G.k is defined via the conjugate relation involving
G.r<sup>G.s</sup>.
<P>
<P>
<P>
<P>
</DL>
There exist a number of parameters for controlling the behaviour of this
function, which are described below.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "9269">Example <TT>GrpFP_1_pQuotient1 (H75E39)</TT></A></H3>
We construct the largest 2-quotient of class 6 for 
a two-generator, two-relator group.
<P>
<P>
<PRE>
&gt; F&lt;a,b&gt; := FreeGroup(2);
&gt; G := quo&lt; F | (b, a, a) = 1, (a * b * a)^4 = 1 &gt;;
&gt; Q, fQ := pQuotient(G, 2, 6);
&gt; Order(Q);
524288
&gt; fQ;
Mapping from: GrpFP: G to GrpPC: Q
</PRE>
<HR>
<H3><A NAME = "9270">Example <TT>GrpFP_1_pQuotient2 (H75E40)</TT></A></H3>
We construct the largest 3-quotient of class 6 for 
a two-generator group of exponent 9.
<P>
<P>
<PRE>
&gt; F&lt;a,b&gt; := FreeGroup(2);
&gt; G := quo&lt; F | a^3 = b^3 = 1 &gt;;
&gt; q := pQuotient(G, 3, 6: Print := 1, Exponent := 9);
Lower exponent-3 central series for G
Group: G to lower exponent-3 central class 1 has order 3^2
Group: G to lower exponent-3 central class 2 has order 3^3
Group: G to lower exponent-3 central class 3 has order 3^5
Group: G to lower exponent-3 central class 4 has order 3^7
Group: G to lower exponent-3 central class 5 has order 3^9
Group: G to lower exponent-3 central class 6 has order 3^11
</PRE>
<HR>
<H3><A NAME = "9271">Example <TT>GrpFP_1_pQuotient3 (H75E41)</TT></A></H3>
We use the metabelian parameter to construct a
metabelian 5-quotient of the group
 &lt; a, b | a<sup>625</sup> = b<sup>625</sup> = 1, (b, a, b) = 1, (b, a, a, a, a) = (b, a)<sup>5</sup>&gt;.
<P>
<P>
<PRE>
&gt; F&lt;a, b&gt; := FreeGroup(2);
&gt; G := quo&lt; F | a^625 = b^625 = 1, (b, a, b) = 1,
&gt;           (b, a, a, a, a) = (b, a)^5 &gt;;
&gt; q := pQuotient(G, 5, 20: Print := 1, Metabelian := true);
Lower exponent-5 central series for G
Group: G to lower exponent-5 central class 1 has order 5^2
Group: G to lower exponent-5 central class 2 has order 5^5
Group: G to lower exponent-5 central class 3 has order 5^8
Group: G to lower exponent-5 central class 4 has order 5^11
Group: G to lower exponent-5 central class 5 has order 5^12
Group: G to lower exponent-5 central class 6 has order 5^13
Group: G to lower exponent-5 central class 7 has order 5^14
Group: G to lower exponent-5 central class 8 has order 5^15
Group: G to lower exponent-5 central class 9 has order 5^16
Group: G to lower exponent-5 central class 10 has order 5^17
Group: G to lower exponent-5 central class 11 has order 5^18
Group: G to lower exponent-5 central class 12 has order 5^19
Group: G to lower exponent-5 central class 13 has order 5^20
Group completed. Lower exponent-5 central class = 13, order = 5^20
</PRE>
<HR>
<H3><A NAME = "9272">Example <TT>GrpFP_1_pQuotient4 (H75E42)</TT></A></H3>
In the final example, we construct the largest finite 2-generator 
group having exponent 5.
<P>
<P>
<PRE>
&gt; F := FreeGroup(2);
&gt; q := pQuotient (F, 5, 14: Print := 1, Exponent := 5);
Lower exponent-5 central series for F
Group: F to lower exponent-5 central class 1 has order 5^2
Group: F to lower exponent-5 central class 2 has order 5^3
Group: F to lower exponent-5 central class 3 has order 5^5
Group: F to lower exponent-5 central class 4 has order 5^8
Group: F to lower exponent-5 central class 5 has order 5^10
Group: F to lower exponent-5 central class 6 has order 5^14
Group: F to lower exponent-5 central class 7 has order 5^18
Group: F to lower exponent-5 central class 8 has order 5^22
Group: F to lower exponent-5 central class 9 has order 5^28
Group: F to lower exponent-5 central class 10 has order 5^31
Group: F to lower exponent-5 central class 11 has order 5^33
Group: F to lower exponent-5 central class 12 has order 5^34
Group completed. Lower exponent-5 central class = 12, order = 5^34
</PRE>
<HR>
<H5><A NAME = "9273"></A><A NAME = "HaspQuotientDefinitions">HaspQuotientDefinitions</A>(G) : GrpPC -&gt; BoolElt</H5>
<BLOCKQUOTE>
Given a pc-group G, this function returns <TT>true</TT> iff and only if G has generator
definitions set by <TT>pQuotient</TT>.
</BLOCKQUOTE>
<H5><A NAME = "9274">pQuotientDefinitions(G) : GrpPC -&gt; SeqEnum</A></H5>
<BLOCKQUOTE>
Given a pc-group G, this function returns the generator definitions set by <TT>pQuotient</TT>,
and will throw an error if none exist.
</BLOCKQUOTE>
<H4><A NAME = "9275">Nilpotent Quotient</A></H4>

<P>
<P>
<P>
A nilpotent quotient algorithm constructs, from a finite presentation
of a group, a polycyclic presentation of a nilpotent quotient of the
finitely presented group.
The nilpotent quotient algorithm used by Magma is the
Australian National University Nilpotent Quotient program, as described
in <A  HREF = "text807.htm#bib_nickel_nq">[Nic96]</A>. The version included in Magma is Version 2.2
of January 2007.
<P>
The lower central series  G<sub>0</sub>, G<sub>1</sub>, ... of a group  G can be defined 
inductively
as G<sub>0</sub> = G, G<sub>i</sub> = [G_(i - 1), G]. G is said to have nilpotency class c if
c is the smallest non-zero integer such that G<sub>c</sub> = 1. If N is a normal
subgroup  of G and  G/N is nilpotent, then N  contains   G<sub>i</sub>  for some
non-negative integer i. G has infinite nilpotent quotients if and only
if G/G<sub>1</sub> (the maximal abelian quotient of G) is infinite and a prime p 
divides a finite factor of a
nilpotent quotient if and only if p  divides a cyclic factor of G/G<sub>1</sub>.
The i-th (i  &gt; 1) factor  G<sub>i - 1</sub>/G<sub>i</sub> of the  lower central series  is
generated by the elements  [g, h]G<sub>i</sub>,  where g  runs through  a  set of
representatives of G/G<sub>1</sub> and h  runs through a set of  representatives
of G<sub>i - 2</sub>/G<sub>i - 1</sub>.
<P>
Any  finitely generated nilpotent group  is polycyclic and, therefore,
has  a subnormal series with  cyclic factors.  Such a subnormal series
can be used   to  represent  the group  in   terms of   a   polycyclic
presentation.    The ANU NQ  computes  successively  the factor groups
modulo  the terms of the lower  central series.   Each factor group is
represented by a special  form of polycyclic presentation, a nilpotent
presentation, that makes use of the  nilpotent structure of the factor
group. 
<P>
The algorithm has highly efficient code for enforcing the n-Engel
identity in nilpotent groups. When appropriate parameters are set,
the algorithm computes the largest n-Engel quotient of G/G<sub>c</sub>.
<P>
More generally, the algorithm has code for enforcing arbitrary identical
relations. You can even enforce relations which combine generators of G
with "free variables". (Werner Nickel calls these "identical generators".)
For instance, the relation <TT>(a,x) = 1</TT>, where a is a group generator
and x is a free variable, will force the construction of quotients where
the image of a is central.
<P>
Mike Vaughan-Lee offers advice on when to use the nilpotent quotient algorithm.
If you know nothing about the finitely presented group, it is probably a good
idea to look at the abelian quotient first. If the abelian quotient is trivial
then all nilpotent quotients will be trivial.
Similarly, if the abelian quotient is cyclic, then all nilpotent quotients
will be cyclic. Less trivially, if the abelian quotient is finite then all
nilpotent quotients will be finite and so will be the direct product of
finite p-groups. Moreover, the relevant primes p will all occur in the 
abelian quotient. Usually it will be more effective to use the p-quotient
algorithm to study the direct factors. However, if you want to study 3-Engel
quotients (say), then you are better using the nilpotent quotient
even when the abelian quotient is finite.


<P>
<P>
<P>
<P>
The parameters available for the function <A  HREF = "text813.htm#GrpFP_1:NilpotentQuotient">NilpotentQuotient</A>
are:
<P>
var NumberOfEngelGenerators: RngIntElt  Default: 1
Setting this parameter to k forces the first k generators to be left
or right Engel elements, provided one (or both) of the parameters
<TT>LeftEngel</TT> or <TT>RightEngel</TT> is positive. Otherwise it is ignored.
<P>
var LeftEngel: RngIntElt                Default: 0
Setting this parameter to n forces the first k generators g<sub>1</sub>, ..., g<sub>k</sub>
of the quotient Q to be left n-Engel elements. That is, they satisfy
[x, ..., x, g<sub>i</sub>] = 1 (x appearing n times) for all x in Q.
The value of k is determined by the parameter <TT>NumberOfEngelGenerators</TT>.
<P>
<P>
var RightEngel: RngIntElt               Default: 0
This is the same as for <TT>LeftEngel</TT>, but here the generators are
right n-Engel elements, so [g<sub>i</sub>, x, ..., x] = 1.
<P>
var Engel: RngIntElt                    Default: 0
Setting this parameter to n enforces the nth Engel law on the
quotient Q. That is, [x, y, ..., y]=1 (y appearing n times)
for all x, y in Q.
<P>
var SemigroupOnly: BoolElt              Default: <TT>true</TT>
This  option  causes the program to check only semigroup
words in the generating set of  the nilpotent quotient when
an Engel condition is enforced. If none of the Engel parameters
are set, then it is ignored.
<P>
var SemigroupFirst: BoolElt             Default: <TT>false</TT>
This  option  causes the program to check semigroup words
in the generating set of the quotient first and then all other words,
when an Engel condition is enforced. If <TT>SemigroupOnly</TT> is set, or
no Engel condition is enforced, then it is ignored.
<P>
var ReverseOrder: BoolElt               Default: <TT>false</TT>
In checking Engel identities, instances are processed in 
order of increasing weight.  This flag reverses the order.
<P>
var ReverseEngel: BoolElt               Default: <TT>false</TT>
This flag changes the Engel conditions from the first k generators,
to the <I>last</I> k generators.
<P>
var CheckFewInstances: BoolElt          Default: <TT>false</TT>
This option stops  checking the Engel  law at each class if
all  the checks   of a certain    weight did not  yield any
non-trivial instances of the law.
<P>
var Nickel: BoolElt                     Default: <TT>false</TT>
Enforce the identities x<sup>8</sup> and [[x<sub>1</sub>, x<sub>2</sub>, x<sub>3</sub>], [x<sub>4</sub>, x<sub>5</sub>, x<sub>6</sub>]]
on the nilpotent quotient.
<P>
var NumberOfFreeVariables: RngIntElt    Default: 0
If this parameter is set to n &gt; 0 then the last n variables of the
group are treated as variables rather than generators of the group. In any 
relation they are treated as standing for all group elements, enabling
the user to enforce identical relations on the quotient being computed.
The value of n must be less than the number of generators of the input group.
When this facility is used, the domain of the epimorphism returned is the
subgroup of G generated by the (first) non-free generators.
<P>
var PrintResult: BoolElt                Default: <TT>false</TT>
If set to true, this parameter switches on the printing of results given by
the stand alone version of NQ.
<H5><A NAME = "9276"></A><A NAME = "GrpFP_1:NilpotentQuotient">NilpotentQuotient</A>(G, c: parameters) : GrpFP, RngIntElt -&gt; GrpGPC, Map</H5>
<BLOCKQUOTE>
This function returns the class c nilpotent quotient of G as a group in
category <A  HREF = "text832.htm#GrpGPC"> <TT>GrpGPC</TT></A>, together with the epimorphism &pi; from G onto
this quotient. When c is set to zero, the function attempts to compute the
maximal nilpotent quotient of G.
Using the parameters described below, the user can enforce
certain conditions on the quotient found.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "9277">Example <TT>GrpFP_1_NilpotentQuotient0 (H75E43)</TT></A></H3>
Here is a finitely presented group. The abelian quotient is infinite,
so we look at the class 2 nilpotent quotient.
<P>
<P>
<PRE>
&gt; G := Group&lt;x,y,z|(x*y*z^-1)^2, (x^-1*y^2*z)^2, (x*y^-2*x^-1)^2 &gt;;
&gt; AbelianQuotient(G);
Abelian Group isomorphic to Z/2 + Z/2 + Z
Defined on 3 generators
Relations:
  2*$.1 = 0
  2*$.2 = 0
&gt; N := NilpotentQuotient(G,2); N;
GrpGPC : N of infinite order on 6 PC-generators
PC-Relations:
  N.1^2 = N.3^2 * N.5,
  N.2^2 = N.4 * N.6,
  N.4^2 = Id(N),
  N.5^2 = Id(N),
  N.6^2 = Id(N),
  N.2^N.1 = N.2 * N.4,
  N.3^N.1 = N.3 * N.5,
  N.3^N.2 = N.3 * N.6
</PRE>
<HR>
<H3><A NAME = "9278">Example <TT>GrpFP_1_NilpotentQuotient1 (H75E44)</TT></A></H3>
The free nilpotent group of rank r and class e is defined as
F / &gamma;<sub>e + 1</sub>(F),  where F is a free group of rank r and
&gamma;<sub>e + 1</sub>(F) denotes the (e + 1) st term  of the lower central
series of F.
<P>
We construct the free nilpotent group N of rank 2 and class 3 as
quotient of the free group F of rank 2 and the natural epimorphism
from F onto N.
<P>
<P>
<P>
<PRE>
&gt; F&lt;a,b&gt; := FreeGroup(2);
&gt; N&lt;[x]&gt;, pi := NilpotentQuotient(F, 3);
&gt; N;
GrpGPC : N of infinite order on 5 PC-generators
PC-Relations:
    x[2]^x[1] = x[2] * x[3], 
    x[2]^(x[1]^-1) = x[2] * x[3]^-1 * x[4], 
    x[3]^x[1] = x[3] * x[4], 
    x[3]^(x[1]^-1) = x[3] * x[4]^-1, 
    x[3]^x[2] = x[3] * x[5], 
    x[3]^(x[2]^-1) = x[3] * x[5]^-1
</PRE>
Using the function <A  HREF = "text841.htm#GrpGPC:NilpotencyClass">NilpotencyClass</A>, we check the nilpotency
class of the quotient.
<P>
<P>
<PRE>
&gt; NilpotencyClass(N);
3
</PRE>
<HR>
<H3><A NAME = "9279">Example <TT>GrpFP_1_NilpotentQuotient2 (H75E45)</TT></A></H3>
The Baumslag-Solitar groups 
 BS(p, q) = &lt; &lt;a, b|ab<sup>p</sup>a<sup> - 1</sup> = b<sup>q</sup> &gt; 
form a fascinating class of 1-relator groups. We compute the nilpotent of
class 4 quotient of two of them, and print out the resulting presentations,
and the structure of the generators.
<P>
<P>
<PRE>
&gt; G&lt;a,b&gt; := Group&lt;a,b|a*b*a^-1=b^4&gt;;
&gt; N,f := NilpotentQuotient(G,4);
&gt; N;
GrpGPC : N of infinite order on 5 PC-generators
PC-Relations:
  N.2^3 = N.3^2 * N.4^2 * N.5,
  N.3^3 = N.4^2 * N.5^2,
  N.4^3 = N.5^2,
  N.5^3 = Id(N),
  N.2^N.1 = N.2 * N.3,
  N.2^(N.1^-1) = N.2 * N.3^2 * N.4^2 * N.5,
  N.3^N.1 = N.3 * N.4,
  N.3^(N.1^-1) = N.3 * N.4^2 * N.5^2,
  N.4^N.1 = N.4 * N.5,
  N.4^(N.1^-1) = N.4 * N.5^2
&gt; for i := 1 to Ngens(N) do
&gt; N.i @@ f;
&gt; end for;
a
b
(b, a)
(b, a, a)
(b, a, a, a)
&gt; G&lt;a,b&gt; := Group&lt;a,b|a*b^2*a^-1=b^4&gt;;
&gt; N,f := NilpotentQuotient(G,4);
&gt; N;
GrpGPC : N of infinite order on 8 PC-generators
PC-Relations:
  N.2^2 = Id(N),
  N.3^2 = N.5 * N.8,
  N.4^2 = N.7,
  N.5^2 = N.8,
  N.6^2 = Id(N),
  N.7^2 = Id(N),
  N.8^2 = Id(N),
  N.2^N.1 = N.2 * N.3,
  N.2^(N.1^-1) = N.2 * N.3 * N.4 * N.5 * N.6,
  N.3^N.1 = N.3 * N.4,
  N.3^(N.1^-1) = N.3 * N.4 * N.6 * N.7,
  N.3^N.2 = N.3 * N.5,
  N.4^N.1 = N.4 * N.6,
  N.4^(N.1^-1) = N.4 * N.6,
  N.4^N.2 = N.4 * N.7,
  N.5^N.1 = N.5 * N.7,
  N.5^(N.1^-1) = N.5 * N.7,
  N.5^N.2 = N.5 * N.8
&gt; for i := 1 to Ngens(N) do
&gt; N.i @@ f;
&gt; end for;
a
b
(b, a)
(b, a, a)
(b, a, b)
(b, a, a, a)
(b, a, b, a)
(b, a, b, b)
</PRE>
<HR>
<H5><A NAME = "9280">SetVerbose("NilpotentQuotient", n) : MonStgElt, RngIntElt -&gt;</A></H5>
<BLOCKQUOTE>
Turn on and off the printing of information as the nilpotent quotient
algorithm proceeds. n may be set to any of 0, 1, 2 or 3.
Setting n to be 0 turns printing off, while successively higher
values for n print more and more information as the algorithm 
progresses. The default value of n is 0.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "9281">Example <TT>GrpFP_1_NilpotentQuotient3 (H75E46)</TT></A></H3>
We compute the maximal nilpotent quotient N1 of the group G given by the
following presentation
<P>
&lt; a, b, c, d, e | (b, a),  (c, a),  (d, a)=(c, b),  (e, a)=(d, b),  (e, b)=(d, c),  
 (e, c),  (e, d) &gt;.
<P>
<P>
<P>
<PRE>
&gt; F&lt;a,b,c,d,e&gt; := FreeGroup(5);
&gt; G&lt;a,b,c,d,e&gt; :=
&gt;          quo&lt;F | (b,a), (c,a),
&gt;          (d,a)=(c,b), (e,a)=(d,b), (e,b)=(d,c),
&gt;          (e,c), (e,d)&gt;;
&gt; N1&lt;[x]&gt;, pi1 := NilpotentQuotient(G, 0);
</PRE>
Using the function <A  HREF = "text841.htm#GrpGPC:NilpotencyClass">NilpotencyClass</A>, we check the nilpotency
class of the quotient. It turns out to have nilpotency class 6.
<P>
<P>
<PRE>
&gt; NilpotencyClass(N1);
6
</PRE>
Next we compute a metabelian quotient N2 of G, construct the natural
epimorphism from N1 onto N2 and check its kernel. (The functions applied
to the nilpotent quotients are described in Chapter <A  HREF = "text831.htm#9567">POLYCYCLIC GROUPS</A>.)
To get a metabelian quotient we adjoin 4 variables and a relation to the
presentation of G and use the "free variables" facility.
<P>
<P>
<PRE>
&gt; M := Group&lt;w,x,y,z|((w,x),(y,z))&gt;; // metabelian identity
&gt; D := FreeProduct(G,M); // adjoin to G
&gt; N2, pi2 := NilpotentQuotient(D, 0: NumberOfFreeVariables := 4); 
&gt; NilpotencyClass(N2);
4
&gt; DerivedLength(N2);
2
&gt; f := hom&lt; N1-&gt;N2 | [ pi1(G.i)-&gt;pi2(D.i) : i in [1..Ngens(G)] ] &gt;; 
&gt; PCGenerators(Kernel(f), N1);
{@ x[14], x[15] * x[17], x[16], x[17]^2, x[18], x[19], x[20],
x[21], x[22], x[23], x[24], x[25], x[26], x[27], x[28], x[29],
x[30], x[31] @}
</PRE>
We compute a quotient N3 of G satisfying the 4 th Engel law,
construct the natural epimorphism from N1 onto N3 and again check the
kernel. (The functions applied to the nilpotent quotients are described
in Chapter <A  HREF = "text831.htm#9567">POLYCYCLIC GROUPS</A>.)
<P>
<P>
<PRE>
&gt; N3, pi3 := NilpotentQuotient(G, 0 : Engel := 4);
&gt; NilpotencyClass(N3);
4
&gt; DerivedLength(N3);
3
&gt; h := hom&lt; N1-&gt;N3 | [ pi1(g)-&gt;pi3(g) : g in Generators(G) ] &gt;; 
&gt; PCGenerators(Kernel(h), N1);
{@ x[19], x[20], x[21], x[22], x[23], x[24], x[25], x[26], x[27],
x[28], x[29], x[30], x[31] @}
</PRE>
<HR>
<H4><A NAME = "9282">Soluble Quotient</A></H4>

<P>
<P>
<P>
A soluble quotient algorithm computes a consistent power-conjugate
presentation of the largest finite soluble quotient of a finitely
presented group, subject to certain algorithmic and user supplied
restrictions. In this section we describe only the simplest use of
such an algorithm within Magma. For more information the user is referred to
Chapter <A  HREF = "text823.htm#9460">FINITELY PRESENTED GROUPS: ADVANCED</A>.


<H5><A NAME = "9283">SolvableQuotient(G : parameters): GrpFP, RngIntElt                                             -&gt; GrpPC, Map, SeqEnum, MonStgElt</A></H5>
<H5>SolubleQuotient(G : parameters): GrpFP, RngIntElt                                            -&gt; GrpPC, Map, SeqEnum, MonStgElt</H5>
<BLOCKQUOTE>
Let G be a finitely presented group. The function constructs the largest
finite soluble quotient of G.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "9284">Example <TT>GrpFP_1_SolubleQuotient1 (H75E47)</TT></A></H3>
We compute the soluble quotient of the group
 &lt; a, b   |  a<sup>2</sup>, b<sup>4</sup>,
                      ab<sup> - 1</sup>ab(abab<sup> - 1</sup>)<sup>5</sup>ab<sup>2</sup>ab<sup> - 2</sup> &gt;.
<P>
<P>
<PRE>
&gt; G&lt;a,b&gt; := Group&lt; a, b | a^2, b^4,
&gt;                     a*b^-1*a*b*(a*b*a*b^-1)^5*a*b^2*a*b^-2 &gt;; 
&gt; Q := SolubleQuotient(G);
&gt; Q;
GrpPC : Q of order 1920 = 2^7 * 3 * 5
PC-Relations:
    Q.1^2 = Q.4, 
    Q.2^2 = Id(Q), 
    Q.3^2 = Q.6, 
    Q.4^2 = Id(Q), 
    Q.5^2 = Q.7, 
    Q.6^2 = Id(Q), 
    Q.7^2 = Id(Q), 
    Q.8^3 = Id(Q), 
    Q.9^5 = Id(Q), 
    Q.2^Q.1 = Q.2 * Q.3, 
    Q.3^Q.1 = Q.3 * Q.5, 
    Q.3^Q.2 = Q.3 * Q.6, 
    Q.4^Q.2 = Q.4 * Q.5 * Q.6 * Q.7, 
    Q.4^Q.3 = Q.4 * Q.6 * Q.7, 
    Q.5^Q.1 = Q.5 * Q.6, 
    Q.5^Q.2 = Q.5 * Q.7, 
    Q.5^Q.4 = Q.5 * Q.7, 
    Q.6^Q.1 = Q.6 * Q.7, 
    Q.8^Q.1 = Q.8^2, 
    Q.8^Q.2 = Q.8^2, 
    Q.9^Q.1 = Q.9^3, 
    Q.9^Q.2 = Q.9^4, 
    Q.9^Q.4 = Q.9^4
</PRE>
<HR>
<H5><A NAME = "9285">SolvableQuotient(F, n : parameters): GrpFP, RngIntElt -&gt; GrpPC, Map, SeqEnum, MonStgElt</A></H5>
<H5>SolubleQuotient(F, n : parameters): GrpFP, RngIntElt -&gt; GrpPC, Map, SeqEnum, MonStgElt</H5>
<H5>SolvableQuotient(F, P : parameters): GrpFP, Set -&gt; GrpPC, Map, SeqEnum, MonStgElt</H5>
<H5>SolubleQuotient(F, P : parameters): GrpFP, Set -&gt; GrpPC, Map, SeqEnum, MonStgElt</H5>
<BLOCKQUOTE>
Find a soluble quotient G and the epimorphism &pi;:F mapsur G
with a specified order. n must be a nonnegative integer.
P must be a set of primes.
<P>
The three forms reflect possible information about the order of an
expected soluble quotient. In the first form the order of G is given 
by n, if n is greater than zero. If n equals zero, nothing about 
the order is known and the relevant primes will be calculated completely.
<P>
The second form, with no n argument, is equivalent to the first with
n = 0.
This is a standard argument, and usually it is the most efficient way 
to calculate soluble quotients. 
<P>
Note that, if n&gt;0 is not the order of the maximal finite soluble
quotient, it may happen that no group of order n can be found, 
since an epimorphic image of size n may not be exhibited by the chosen
series.
<P>
In the third form a set P of relevant primes is given. The algorithm 
calculates the biggest quotient such that the order has prime divisors 
only in P. P may have a zero as element, this is just for 
consistency reasons. It is equivalent to the first form with n equal 
zero.
<P>
For a description of the algorithm used and of the set of parameters
available for this function, see Chapter <A  HREF = "text823.htm#9460">FINITELY PRESENTED GROUPS: ADVANCED</A>. Other more
specialised functions for computing soluble quotients and some examples can
be found there as well.
<P>
</BLOCKQUOTE>
<HR>
<H3><A NAME = "9286">Example <TT>GrpFP_1_SolubleQuotient2 (H75E48)</TT></A></H3>
Consider the group G defined by the presentation
 &lt; x, y |  x<sup>3</sup>, y<sup>8</sup>, [x, y<sup>4</sup>], x<sup> - 1</sup>yx<sup> - 1</sup>y<sup> - 1</sup>xyxy<sup> - 1</sup>,
                   (xy<sup> - 2</sup>)<sup>2</sup>(x<sup> - 1</sup>y<sup> - 2</sup>)<sup>2</sup>(xy<sup>2</sup>)<sup>2</sup>(x<sup> - 1</sup>y<sup>2</sup>)<sup>2</sup>, 
                   (x<sup> - 1</sup>y<sup> - 2</sup>)<sup>6</sup>(x<sup> - 1</sup>y<sup>2</sup>)<sup>6</sup> &gt;. 
<P>
<P>
<PRE>
&gt; G&lt;x, y&gt; := Group&lt; x, y | 
&gt;     x^3, y^8, (x,y^4), x^-1*y*x^-1*y^-1*x*y*x*y^-1,
&gt;     (x*y^-2)^2*(x^-1*y^-2)^2*(x*y^2)^2*(x^-1*y^2)^2, 
&gt;     (x^-1*y^-2)^6*(x^-1*y^2)^6 &gt;; 
</PRE>
We apply the soluble quotient algorithm to G and compute the order of the
soluble quotient Q.
<P>
<P>
<PRE>
&gt; time Q := SolubleQuotient(G); 
Time: 116.920
&gt; Order(Q); 
165888
</PRE>
Note that 165888 = 2<sup>11</sup> .3<sup>4</sup>. If we knew the possible primes in
advance  the soluble quotient can be computed much more quickly by using this
knowledge.
<P>
<P>
<PRE>
&gt; time Q := SolubleQuotient(G, {2, 3});
Time: 39.400
</PRE>
Note that this reduces the execution time by a factor of almost three. 
<P>
<P>
<P>
<P>
We now assume that G is finite and try to compute its order by means of the
Todd-Coxeter algorithm.
<P>
<P>
<PRE>
&gt; Order(G);
165888
</PRE>
Hence the group is finite and soluble and G is isomorphic to Q. We may
use the tools for finite soluble groups to investigate the structure of G.
For example we can easily find the number of involutions in G.
<P>
<P>
<PRE>
&gt; cls := ConjugacyClasses(Q);
&gt; &amp;+ [ cl[2] : cl in cls | cl[1] eq 2 ];
511
</PRE>
<HR>
<PRE></PRE> <A  HREF = "text814.htm">[Next]</A><A  HREF = "text812.htm">[Prev]</A> <A  HREF = "text814.htm">[Right]</A> <A  HREF = "text812.htm">[Left]</A> <A  HREF = "text808.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<br><small>Version: V2.22 of <I>
Thu Jun  9 16:37:49 EST 2016
</I></small>
</body></html>