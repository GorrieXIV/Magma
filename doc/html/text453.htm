<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <link rel='stylesheet' href='help.css' type='text/css'>
  <TITLE>Elements</TITLE>
</head>
<body BGCOLOR="#FFFFFF">

 <A  HREF = "text454.htm">[Next]</A><A  HREF = "text452.htm">[Prev]</A> <A  HREF = "text454.htm">[Right]</A> <A  HREF = "text452.htm">[Left]</A> <A  HREF = "text442.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<PRE></PRE><H3><A NAME = "4697">Elements</A></H3>

<P>
<P>
<P>
The function field
F = k(x, &alpha;<sub>1</sub>, ..., &alpha;<sub>r</sub>, &alpha;) may be viewed as 
n-dimensional vector space over
k(x, &alpha;<sub>1</sub>, ..., &alpha;<sub>r</sub>), where n is the degree of the 
field extension F/k(x, &alpha;<sub>1</sub>, ..., &alpha;<sub>r</sub>). 
Note that F is
spanned by the powers 1, &alpha;, ..., &alpha;<sup>n - 1</sup>. Within Magma,
function field elements are printed as linear combinations of
these powers of &alpha; over the coefficient field.
<P>
An order can be viewed as a free R-module of rank n where R is
its coefficient ring (a polynomial ring or the degree valuation ring
of k(x) or an order which is a lesser degree extension of k[x]) 
and n equals the degree F/k(x, &alpha;<sub>1</sub>, ..., &alpha;<sub>r</sub>). It has a basis
consisting of n elements. Within Magma, function field order
elements are printed as a sequence of coefficients of the 
R-linear combination of such a basis.
<P>
Elements can also be represented as a product of other function field or order
elements. This is referred to as the product representation. Product 
representations can be useful for large elements, however, it is expensive
to put such elements in a set or to test them for equality as this 
involves finding coefficients for the element.



<H5>Subsections</H5>
<UL>
<LI> <A  HREF = "text453.htm#4698">Creation of Elements</A>
<LI> <A  HREF = "text453.htm#4708">Parent and Category</A>
<LI> <A  HREF = "text453.htm#4709">Sequence Conversions</A>
<LI> <A  HREF = "text453.htm#4716">Arithmetic Operators</A>
<LI> <A  HREF = "text453.htm#4720">Equality and Membership</A>
<LI> <A  HREF = "text453.htm#4721">Predicates on Elements</A>
<LI> <A  HREF = "text453.htm#4728">Functions related to Norm and  Trace</A>
<LI> <A  HREF = "text453.htm#4737">Functions related to Orders and Integrality</A>
<LI> <A  HREF = "text453.htm#4746">Functions related to Places and Divisors</A>
<LI> <A  HREF = "text453.htm#4764">Other Operations on Elements</A>
</UL>
<H4><A NAME = "4698">Creation of Elements</A></H4>



<H5>One(F) : FldFun -&gt; FldFunElt</H5>

<H5>One(O) : RngFunOrd -&gt; RngFunOrdElt</H5><P>


<H5>Identity(F) : FldFun -&gt; FldFunElt</H5>

<H5>Identity(O) : RngFunOrd -&gt; RngFunOrdElt</H5><P>


<H5>Zero(F) : FldFun -&gt; FldFunElt</H5>

<H5>Zero(O) : RngFunOrd -&gt; RngFunOrdElt</H5><P>


<H5>Representative(F) : FldFun -&gt; FldFunElt</H5>

<H5>Representative(O) : RngFunOrd -&gt; RngFunOrdElt</H5><P>


These generic functions (cf. Chapter <A  HREF = "text145.htm#999">INTRODUCTION TO RINGS</A>)
create 1, 1, 0, and 0 respectively in the function field F or
order O.


<H5><A NAME = "4699">F . 1 : FldFun -&gt; FldFunElt</A></H5>
<H5>F . 2 : FldFun -&gt; FldFunElt</H5>
<BLOCKQUOTE>
<DL COMPACT class='compact'>
<DT>(i)</DT><DD>Return the generator for the function field F over 
k(x, &alpha;<sub>1</sub>, ..., &alpha;<sub>r</sub>), 
that is, &alpha; &isin;F such that 
F = k(x, &alpha;<sub>1</sub>, ..., &alpha;<sub>r</sub>, &alpha;).
<DT>(ii)</DT><DD>Return the first and second generators for 
the function field 
 F over k, that is, &alpha; &isin;F and x &isin;F such that 
F = k(x, &alpha;).</DL>
</BLOCKQUOTE>
<H5><A NAME = "4700">Name(F, i) : FldFun, RngIntElt -&gt; FldFunElt</A></H5>
<BLOCKQUOTE>
Given a function field F, return the i-th generator,
i.e. return the element <TT>F.1</TT> or <TT>F.2</TT> of F.
</BLOCKQUOTE>
<H5><A NAME = "4701">O . i : RngFunOrd, RngIntElt -&gt; FldFunOrdElt</A></H5>
<H5>FF . i : FldFunOrd, RngIntElt -&gt; FldFunOrdElt</H5>
<BLOCKQUOTE>
Return the ith basis element of the order O or its field of fractions FF.
</BLOCKQUOTE>
<H5><A NAME = "4702">F ! a : FldFun, . -&gt; FldFunElt</A></H5>
<H5>elt&lt;F | a&gt; : FldFun, . -&gt; FldFunElt</H5>
<BLOCKQUOTE>
Create the element of the function field F specified by a; here a is allowed
to be an element coercible into F, which means that a may be:
<DL COMPACT class='compact'>
<DT>(i)</DT><DD>an element of F,
<DT>(ii)</DT><DD>an element of the coefficient field of F,
<DT>(iii)</DT><DD>an element of another representation of F.
<P>
</DL>
For F an extension of k(x) we additionally have
<DL COMPACT class='compact'>
<DT>(iv)</DT><DD>an element of an order of F,
<DT>(v)</DT><DD>an element being coercible into k(x),
<DT>(vi)</DT><DD>a sequence of elements being coercible into the coefficient 
field of F of
length equal to the degree of F over its coefficient field. In this case the
element a<sub>0</sub> + a<sub>1</sub> &alpha; + ... + a<sub>n - 1</sub> &alpha;<sup>n - 1</sup> is created,
where a=[a<sub>0</sub>, ..., a<sub>n - 1</sub>] and &alpha; is the generator <TT>F.1</TT> of F over its coefficient field.</DL>
</BLOCKQUOTE>
<H5><A NAME = "4703">O ! a : RngFunOrd, . -&gt; RngFunOrdElt</A></H5>
<H5>elt&lt;O | a&gt; : RngFunOrd, . -&gt; RngFunOrdElt</H5>
<BLOCKQUOTE>
Create the element of the order O specified by a; here a is allowed to be
an element coercible into O, which means that mathematically a &isin;O and that a may be any of:
<DL COMPACT class='compact'>
<DT>(i)</DT><DD>an element of the function field F,
<DT>(ii)</DT><DD>an element of an order of the function field F,
<DT>(iii)</DT><DD>an element that can be coerced into k(x),
<DT>(iv)</DT><DD>an element that can be coerced into its coefficient field,
<DT>(v)</DT><DD>a sequence of elements being coercible into the coefficient 
field of O of
length equal to the rank of O over its coefficient field. In this case the
element a<sub>1</sub> &omega;<sub>1</sub> + a<sub>2</sub> &omega;<sub>2</sub> + ... + a<sub>n</sub> &omega;<sub>n</sub> is created,
where a=[a<sub>1</sub>, ..., a<sub>n</sub>] and &omega;<sub>1</sub>, &omega;<sub>2</sub>, ..., &omega;<sub>n</sub> is 
the basis of O as returned by <TT>Basis(O)</TT>. </DL>
</BLOCKQUOTE>
<H5><A NAME = "4704">FF ! a : FldFunOrd, Any -&gt; FldFunOrdElt</A></H5>
<H5>elt&lt;FF | a&gt; : FldFunOrd, Any -&gt; FldFunOrdElt</H5>
<BLOCKQUOTE>
Create the element of the field of fractions FF of an order O 
specified by a, where a may be any of the above such that d * a is 
mathematically in O for some d &isin;O.
</BLOCKQUOTE>
<H5><A NAME = "4705">elt&lt; F | a<sub>0</sub>, a<sub>1</sub>, ..., a<sub>n - 1</sub>&gt; : FldFun, RngElt , ..., RngElt -&gt; FldFunElt</A></H5>
<BLOCKQUOTE>
Create the element a<sub>0</sub> + a<sub>1</sub> &alpha; + ... + a<sub>n - 1</sub> &alpha;<sup>n - 1</sup>
where a<sub>0</sub>, ..., a<sub>n - 1</sub> are coercible into the coefficient field of 
the function field F, 
n equals the
degree of F over its coefficient field and &alpha; is the generator 
<TT>F.1</TT> of F over k(x).
</BLOCKQUOTE>
<H5><A NAME = "4706">elt&lt; O | a<sub>1</sub>, a<sub>2</sub>, ..., a<sub>n</sub>&gt; : RngFunOrd, RngElt , ..., RngElt -&gt; RngFunOrdElt</A></H5>
<H5>elt&lt; FF | a<sub>1</sub>, a<sub>2</sub>, ..., a<sub>n</sub>&gt; : FldFunOrd, RngElt , ..., RngElt -&gt; FldFunOrdElt</H5>
<BLOCKQUOTE>
Create the element a<sub>1</sub> &omega;<sub>1</sub> + a<sub>2</sub> &omega;<sub>2</sub> + ... + a<sub>n</sub>
&omega;<sub>n</sub> where a<sub>1</sub>, ..., a<sub>n</sub> are coercible into 
the coefficient ring of the order O, n
equals the rank of O over its coefficient ring and 
&omega;<sub>1</sub>, &omega;<sub>2</sub>, ...,
&omega;<sub>n</sub> is the basis of O as returned by <TT>Basis(O)</TT>, (where O is
the ring of integers of the field of fractions FF).
</BLOCKQUOTE>
<H5><A NAME = "4707">Random(F, m) : FldFunG, RngIntElt -&gt; FldFunElt</A></H5>
<H5>Random(O, m) : RngFunOrd, RngIntElt -&gt; RngFunOrdElt</H5>
<BLOCKQUOTE>
A "random" element of the global function field F or one of its 
orders O. The size of the 
coefficients of the element are determined by m.
</BLOCKQUOTE>
<H4><A NAME = "4708">Parent and Category</A></H4>



<H5>Parent(a) : FldFunElt -&gt; FldFun</H5>

<H5>Parent(a) : RngFunOrdElt -&gt; RngFunOrd</H5>

<H5>Category(a) : FldFunElt -&gt; Cat</H5>

<H5>Category(a) : RngFunOrdElt -&gt; Cat</H5>
<P>


<H4><A NAME = "4709">Sequence Conversions</A></H4>

<P>
<P>
<P>
The sequence conversions refer to the function field F as a vector 
space of dimension n over the coefficient field of F where F is a finite
degree extension (degree n) of its coefficient field.


<H5><A NAME = "4710">ElementToSequence(a) : FldFunElt -&gt; SeqEnum[FldElt]</A></H5>
<H5>ElementToSequence(a) : RngFunOrdElt -&gt; SeqEnum[RngElt]</H5>
<H5>ElementToSequence(a) : FldFunOrdElt -&gt; SeqEnum[RngElt]</H5>
<H5>Eltseq(a) : FldFunElt -&gt; SeqEnum[FldElt]</H5>
<H5>Eltseq(a) : RngFunOrdElt -&gt; SeqEnum[RngElt]</H5>
<H5>Eltseq(a) : FldFunOrdElt -&gt; SeqEnum[RngElt]</H5>
<BLOCKQUOTE>
The sequence [a<sub>1</sub>, ..., a<sub>n</sub>] of elements of the coefficient field
of the parent of the function field or order element 
a such that a = a<sub>1</sub> &omega;<sub>1</sub> + a<sub>2</sub> &omega;<sub>2</sub> + ... + a<sub>n</sub>
&omega;<sub>n</sub> where &omega;<sub>1</sub>, &omega;<sub>2</sub>, ..., &omega;<sub>n</sub> is a basis of
the parent of a. 
</BLOCKQUOTE>
<H5><A NAME = "4711">Eltseq(a, R) : FldFunElt, FldFunG -&gt; [FldFunGElt]</A></H5>
<BLOCKQUOTE>
A sequence of coefficients of the function field element a in the coefficient
field R.
</BLOCKQUOTE>
<H5><A NAME = "4712">Flat(a) : FldFunElt -&gt; [FldFunGElt]</A></H5>
<BLOCKQUOTE>
A sequence of coefficients of the function field element a in the bottom 
coefficient field of the parent of a.
</BLOCKQUOTE>
<H5><A NAME = "4713">F ! [ a<sub>0</sub>, a<sub>1</sub>, ..., a<sub>n - 1</sub> ] : FldFun, SeqEnum -&gt; FldFunElt</A></H5>
<BLOCKQUOTE>
The element a = a<sub>0</sub> + a<sub>1</sub>&alpha; + ... + a<sub>n - 1</sub>&alpha;<sup>n - 1</sup> where the 
function field F = k(x, &alpha;<sub>1</sub>, ..., &alpha;<sub>r</sub>, &alpha;) and the 
a<sub>i</sub> may be coerced into k(x, &alpha;<sub>1</sub>, ..., &alpha;<sub>r</sub>).
</BLOCKQUOTE>
<H5><A NAME = "4714">O ! [ a<sub>1</sub>, a<sub>2</sub>, ..., a<sub>n</sub> ] : RngFunOrd, SeqEnum -&gt; RngFunOrdElt</A></H5>
<BLOCKQUOTE>
The element a = a<sub>1</sub> &omega;<sub>1</sub> + a<sub>2</sub> &omega;<sub>2</sub> + ... + a<sub>n</sub> &omega;<sub>n</sub>
where &omega;<sub>1</sub>, &omega;<sub>2</sub>, ..., &omega;<sub>n</sub> is a basis of the order O 
and the a<sub>i</sub> are coercible into the coefficient ring of O.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "4715">Example <TT>FldFunG_Elements (H44E25)</TT></A></H3>
<P>
<P>
<PRE>
&gt; R&lt;x&gt; := FunctionField(GF(5));
&gt; P&lt;y&gt; := PolynomialRing(R);
&gt; f := y^3 + (4*x^3 + 4*x^2 + 2*x + 2)*y^2 + (3*x + 3)*y + 2;
&gt; F&lt;alpha&gt; := FunctionField(f);
&gt; Evaluate(f, alpha);
0
&gt; F.1;
alpha
&gt; b := x + alpha + 1/x*alpha^2;
&gt; b;
1/x*alpha^2 + alpha + x
&gt; b eq F ! [x, 1, 1/x];
true
</PRE>
<HR>
<H4><A NAME = "4716">Arithmetic Operators</A></H4>

<P>
<P>
<P>
The following binary arithmetic operations can also be
performed in the case where one operand is an element of the function field 
F or an order O and the other operand is a ring element which can 
naturally be mapped into F or O.
<P>
<P>
<P>


<H5>+ a : FldFunElt -&gt; FldFunElt</H5>

<H5>+ a : RngFunOrdElt -&gt; RngFunOrdElt</H5>

<H5>+ a : FldFunOrdElt -&gt; FldFunOrdElt</H5>

<H5>- a : FldFunElt -&gt; FldFunElt</H5>

<H5>- a : RngFunOrdElt -&gt; RngFunOrdElt</H5>

<H5>- a : FldFunOrdElt -&gt; FldFunOrdElt</H5><P>


<H5>a + b : FldFunElt, FldFunElt -&gt; FldFunElt</H5>

<H5>a + b : RngFunOrdElt, RngFunOrdElt -&gt; RngFunOrdElt</H5>

<H5>a + b : FldFunOrdElt, FldFunOrdElt -&gt; FldFunOrdElt</H5>

<H5>a - b : FldFunElt, FldFunElt -&gt; FldFunElt</H5>

<H5>a - b : RngFunOrdElt, RngFunOrdElt -&gt; RngFunOrdElt</H5>

<H5>a - b : FldFunOrdElt, FldFunOrdElt -&gt; FldFunOrdElt</H5>

<H5>a * b : FldFunElt, FldFunElt -&gt; FldFunElt</H5>

<H5>a * b : RngFunOrdElt, RngFunOrdElt -&gt; RngFunOrdElt</H5>

<H5>a * b : FldFunOrdElt, FldFunOrdElt -&gt; FldFunOrdElt</H5>

<H5>a div b : FldFunElt, FldFunElt -&gt; FldFunElt</H5>

<H5>a div b : FldFunElt, RngElt -&gt; FldFunElt</H5>

<H5>a div b : RngFunOrdElt, RngFunOrdElt -&gt; RngFunOrdElt</H5>

<H5>a div b : RngFunOrdElt, RngElt -&gt; RngFunOrdElt</H5>

<H5>a / b : FldFunElt, FldFunElt -&gt; FldFunElt</H5>

<H5>a / b : RngFunOrdElt, RngFunOrdElt -&gt; FldFunGElt</H5>

<H5>a / b : FldFunOrdElt, FldFunOrdElt -&gt; FldFunOrdElt</H5>

<H5>a ^ k : FldFunElt, RngIntElt -&gt; FldFunElt</H5>

<H5>a ^ k : RngFunOrdElt, RngIntElt -&gt; RngFunOrdElt</H5>

<H5>a ^ k : FldFunOrdElt, RngIntElt -&gt; FldFunOrdElt</H5>



<H5><A NAME = "4717">Modexp(a, k, m) : RngFunOrdElt, RngIntElt, RngUPolElt -&gt; RngFunOrdElt</A></H5>
<H5>Modexp(a, k, m) : RngFunOrdElt, RngIntElt, RngValElt -&gt; RngFunOrdElt</H5>
<BLOCKQUOTE>
Return a<sup>k</sup> mod m where m is an element of k[x] or o<sub>&infin;</sub>
according to whether the parent of a is a finite or infinite order.
</BLOCKQUOTE>
<H5><A NAME = "4718">a mod I : RngFunOrdElt, RngFunOrdIdl -&gt; RngFunOrdElt</A></H5>
<BLOCKQUOTE>
Return the element a belonging to the order O as an element of O/I.
</BLOCKQUOTE>
<H5><A NAME = "4719">Modinv(a, m) : RngFunOrdElt, RngFunOrdIdl -&gt; RngFunOrdElt</A></H5>
<H5>Modinv(a, m) : RngFunOrdElt, RngUPolElt -&gt; RngFunOrdElt</H5>
<H5>Modinv(a, m) : RngFunOrdElt, RngValElt -&gt; RngFunOrdElt</H5>
<BLOCKQUOTE>
Return the inverse of the element a of an order of a function field
modulo m where m is an element of k[x] or o<sub>&infin;</sub>
according to whether the order of a is a finite or infinite order
or an ideal of the order of a.
</BLOCKQUOTE>
<H4><A NAME = "4720">Equality and Membership</A></H4>

<P>
<P>
<P>
The following binary arithmetic operations can also be performed in the 
case where one operand is an element of the function field F or an order O
and the other operand is a ring element which can naturally be mapped into F
or O.
<P>
<P>
<P>


<H5>a eq b : FldFunElt, FldFunElt -&gt; BoolElt</H5>

<H5>a eq b : RngFunOrdElt, RngFunOrdElt -&gt; BoolElt</H5>

<H5>a eq b : FldFunOrdElt, FldFunOrdElt -&gt; BoolElt</H5>

<H5>a ne b : FldFunElt, FldFunElt -&gt; BoolElt</H5>

<H5>a ne b : RngFunOrdElt, RngFunOrdElt -&gt; BoolElt</H5>

<H5>a ne b : FldFunOrdElt, FldFunOrdElt -&gt; BoolElt</H5><P>


<H5>a in F : RngElt, FldFun -&gt; BoolElt</H5>

<H5>a in O : RngElt, RngFunOrd -&gt; BoolElt</H5>

<H5>a in FF : RngElt, FldFunOrd -&gt; BoolElt</H5>
<P>

<H5>a notin F : RngElt, FldFun -&gt; BoolElt</H5>

<H5>a notin O : RngElt, RngFunOrd -&gt; BoolElt</H5>

<H5>a notin FF : RngElt, FldFunOrd -&gt; BoolElt</H5>
<P>



<H4><A NAME = "4721">Predicates on Elements</A></H4>

<P>
<P>
<P>
The functions in this section list 
the general ring element predicates that apply to function fields and 
orders of a function field.


<H5>IsZero(a) : FldFunElt -&gt; BoolElt</H5> 

<H5>IsZero(a) : RngFunOrdElt -&gt; BoolElt</H5> 

<H5>IsZero(a) : FldFunOrdElt -&gt; BoolElt</H5> 

<H5>IsOne(a) : FldFunElt -&gt; BoolElt</H5> 

<H5>IsOne(a) : RngFunOrdElt -&gt; BoolElt</H5> 

<H5>IsOne(a) : FldFunOrdElt -&gt; BoolElt</H5> 

<H5>IsMinusOne(a) : FldFunElt -&gt; BoolElt</H5>

<H5>IsMinusOne(a) : RngFunOrdElt -&gt; BoolElt</H5>

<H5>IsMinusOne(a) : FldFunOrdElt -&gt; BoolElt</H5><P>

<H5>IsNilpotent(a) : FldFunElt -&gt; BoolElt</H5> 

<H5>IsNilpotent(a) : RngFunOrdElt -&gt; BoolElt</H5> 

<H5>IsIdempotent(a) : FldFunElt -&gt; BoolElt</H5>

<H5>IsIdempotent(a) : RngFunOrdElt -&gt; BoolElt</H5><P>

<H5>IsUnit(a) : FldFunElt -&gt; BoolElt</H5> 

<H5>IsUnit(a) : RngFunOrdElt -&gt; BoolElt</H5> 

<H5>IsUnit(a) : FldFunOrdElt -&gt; BoolElt</H5> 

<H5>IsZeroDivisor(a) : FldFunElt -&gt; BoolElt</H5> 

<H5>IsZeroDivisor(a) : RngFunOrdElt -&gt; BoolElt</H5> 

<H5>IsRegular(a) : FldFunElt -&gt; BoolElt</H5>

<H5>IsRegular(a) : RngFunOrdElt -&gt; BoolElt</H5><P>

<H5>IsIrreducible(a) : FldFunElt -&gt; BoolElt</H5> 

<H5>IsIrreducible(a) : RngFunOrdElt -&gt; BoolElt</H5> 

<H5>IsPrime(a) : FldFunElt -&gt; BoolElt</H5>

<H5>IsPrime(a) : RngFunOrdElt -&gt; BoolElt</H5><P>


<H5><A NAME = "4722">IsDivisibleBy(a, b) : FldFunElt, FldFunElt -&gt; BoolElt, FldFunElt</A></H5>
<H5>IsDivisibleBy(a, b) : RngFunOrdElt, RngFunOrdElt -&gt; BoolElt, RngFunOrdElt</H5>
<BLOCKQUOTE>
Given elements a and b belonging to a function field F or an order O, 
returns <TT>true</TT> if there exists c &isin;F or c &isin;O such that a = bc 
and returns c as well, 
provided that b not=0.
<P>
</BLOCKQUOTE>
<H5><A NAME = "4723">IsSeparating(a) : FldFunGElt -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if the function field element 
a is a separating element (has a non zero differential).
</BLOCKQUOTE>
<H5><A NAME = "4724">IsConstant(a) : FldFunGElt -&gt; BoolElt, RngElt</A></H5>
<H5>IsConstant(a) : RngFunOrdElt -&gt; BoolElt, RngElt</H5>
<BLOCKQUOTE>
Whether the algebraic function a is constant; if so it is returned as
an element of the exact constant field.
</BLOCKQUOTE>
<H5><A NAME = "4725"></A><A NAME = "Field:Elements:IsGlobalUnit">IsGlobalUnit</A>(a) : FldFunElt -&gt; BoolElt</H5>
<BLOCKQUOTE>
Whether the function field element 
a is a global unit, i.e. a constant (equivalent to <TT>IsConstant</TT>)
</BLOCKQUOTE>
<H5><A NAME = "4726"></A><A NAME = "Field:Elements:IsGlobalUnitWithPreimage">IsGlobalUnitWithPreimage</A>(a) : FldFunElt -&gt; BoolElt, GrpAbElt</H5>
<BLOCKQUOTE>
Returns <TT>true</TT> and the preimage of the function field element 
a in the global unit group, <TT>false</TT> otherwise.
The function field must be global.
</BLOCKQUOTE>
<H5><A NAME = "4727"></A><A NAME = "Orders:Elements:IsUnitWithPreimage">IsUnitWithPreimage</A>(a) : RngFunOrdElt -&gt; BoolElt, GrpAbElt</H5>
<BLOCKQUOTE>
Returns <TT>true</TT> and the preimage of the order element a in the unit group of O if a is a unit, 
<TT>false</TT> otherwise. The function field has to be global.
</BLOCKQUOTE>
<H4><A NAME = "4728">Functions related to Norm and  Trace</A></H4>

<P>
<P>
<P>
Multiplication by a &isin;F or a &isin;O defines a linear map of the
vector space F over its coefficient field where F is a finite 
extension of its coefficient field.
The following functions work with respect to this mapping.  


<H5>Trace(a) : FldFunGElt -&gt; FldFunGElt</H5>

<H5>Trace(a) : RngFunOrdElt -&gt; RngElt</H5>

<H5>Norm(a) : FldFunGElt -&gt; FldFunGElt</H5>

<H5>Norm(a) : RngFunOrdElt -&gt; RngElt</H5><P>


<H5>MinimalPolynomial(a) : FldFunElt -&gt; RngUPolElt</H5>

<H5>MinimalPolynomial(a) : RngFunOrdElt -&gt; RngUPolElt</H5>

<H5>MinimalPolynomial(a) : FldFunOrdElt -&gt; RngUPolElt</H5><P>


<H5>CharacteristicPolynomial(a) : FldFunElt -&gt; RngUPolElt</H5>

<H5>CharacteristicPolynomial(a) : RngFunOrdElt -&gt; RngUPolElt</H5><P>


<H5><A NAME = "4729">RepresentationMatrix(a) : FldFunGElt -&gt; AlgMatElt</A></H5>
<H5>RepresentationMatrix(a) : RngFunOrdElt -&gt; AlgMatElt</H5>
<BLOCKQUOTE>
Returns the matrix M &isin;R<sup>n x n</sup> such that a (&omega;<sub>1</sub>,
&omega;<sub>2</sub>, ..., &omega;<sub>n</sub>) = (&omega;<sub>1</sub>, &omega;<sub>2</sub>, ..., &omega;<sub>n</sub>)
 M, where &omega;<sub>1</sub>, &omega;<sub>2</sub>, ..., &omega;<sub>n</sub> is a R-basis of
the parent of the function field or order element
a and R is the coefficient ring of the parent of a.
</BLOCKQUOTE>
<H5><A NAME = "4730">Trace(a, R) : FldFunElt, Rng -&gt; RngElt</A></H5>
<H5>Trace(a, R) : RngFunOrdElt, Rng -&gt; RngElt</H5>
<BLOCKQUOTE>
The trace of the function field or order element a over R, a coefficient ring or field of 
the parent of a.
</BLOCKQUOTE>
<H5><A NAME = "4731">Norm(a, R) : FldFunElt, Rng -&gt; RngElt</A></H5>
<H5>Norm(a, R) : RngFunOrdElt, Rng -&gt; RngElt</H5>
<BLOCKQUOTE>
The norm of the order or algebraic function field element a over R, a 
coefficient ring or field of the parent of a.
</BLOCKQUOTE>
<H5><A NAME = "4732">CharacteristicPolynomial(a, R) : FldFunElt, Rng -&gt; RngUPolElt</A></H5>
<H5>CharacteristicPolynomial(a, R) : RngFunOrdElt, Rng -&gt; RngUPolElt</H5>
<BLOCKQUOTE>
The characteristic polynomial of the order or algebraic function field element
a over R, a coefficient ring or field of the parent of a.
</BLOCKQUOTE>
<H5><A NAME = "4733">MinimalPolynomial(a, R) : FldFunElt, Rng -&gt; RngUPolElt</A></H5>
<H5>MinimalPolynomial(a, R) : RngFunOrdElt, Rng -&gt; RngUPolElt</H5>
<BLOCKQUOTE>
The minimal polynomial of the order or algebraic function field element
a over R, a coefficient ring or field of the parent of a.
</BLOCKQUOTE>
<H5><A NAME = "4734">AbsoluteMinimalPolynomial(a) : FldFunElt -&gt; RngUPolElt</A></H5>
<BLOCKQUOTE>
The minimal polynomial of the function field element a over the rational
function field.
</BLOCKQUOTE>
<H5><A NAME = "4735">RepresentationMatrix(a, R) : FldFunGElt, Rng -&gt; AlgMatElt</A></H5>
<H5>RepresentationMatrix(a, R) : RngFunOrdElt, Rng -&gt; AlgMatElt</H5>
<BLOCKQUOTE>
Returns the matrix M &isin;R<sup>n x n</sup> such that a (&omega;<sub>1</sub>,
&omega;<sub>2</sub>, ..., &omega;<sub>n</sub>) = (&omega;<sub>1</sub>, &omega;<sub>2</sub>, ..., &omega;<sub>n</sub>)
 M, where &omega;<sub>1</sub>, &omega;<sub>2</sub>, ..., &omega;<sub>n</sub> is a R-basis of
the parent of the function field or order element
a and R is a coefficient ring of the parent of a.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "4736">Example <TT>FldFunG_elements-norm-trace (H44E26)</TT></A></H3>
<P>
<P>
<PRE>
&gt; P&lt;x&gt; := PolynomialRing(Integers());
&gt; N&lt;n&gt; := NumberField(x^6 - 6);
&gt; P&lt;x&gt; := PolynomialRing(N);
&gt; P&lt;y&gt; := PolynomialRing(P);
&gt; F&lt;c&gt; := FunctionField(y^8 - x^3*N.1^5);
&gt; P&lt;y&gt; := PolynomialRing(F);
&gt; F2&lt;d&gt; := FunctionField(y^3 + N.1*F!x - c);
&gt; d^10;
(c^3 - 3*n*x*c^2 + 3*n^2*x^2*c - n^3*x^3)*d
&gt; Norm(d^10);
-120*n^3*x^3*c^7 + 210*n^4*x^4*c^6 - 252*n^5*x^5*c^5 + 1260*x^6*c^4 - 
    720*n*x^7*c^3 + (270*n^2*x^8 + n^5*x^3)*c^2 + (-60*n^3*x^9 - 60*x^4)*c + 
    6*n^4*x^10 + 270*n*x^5
&gt; Norm(d^10, CoefficientField(F));
13060694016*n^2*x^80 - 21767823360*n^5*x^75 + 97955205120*n^2*x^70 - 
    43535646720*n^5*x^65 + 76187381760*n^2*x^60 - 15237476352*n^5*x^55 + 
    12697896960*n^2*x^50 - 1209323520*n^5*x^45 + 453496320*n^2*x^40 - 
    16796160*n^5*x^35 + 1679616*n^2*x^30
&gt; Trace(d^10, CoefficientField(F)); 
0
&gt; Trace(d^10);
0
</PRE>
<HR>
<H4><A NAME = "4737">Functions related to Orders and Integrality</A></H4>



<H5><A NAME = "4738">IntegralSplit(a, O) : FldFunElt, RngFunOrd -&gt; RngFunOrdElt, RngElt</A></H5>
<H5>IntegralSplit(a, O) : RngFunOrdElt, RngFunOrd -&gt; RngFunOrdElt, RngElt</H5>
<H5>IntegralSplit(a, O) : FldFunOrdElt, RngFunOrd -&gt; RngFunOrdElt, RngElt</H5>
<BLOCKQUOTE>
Split the element function field or order element 
a into a numerator and denominator with respect to the order O.
</BLOCKQUOTE>
<H5><A NAME = "4739">Numerator(a, O) : FldFunElt, RngFunOrd -&gt; RngFunOrdElt</A></H5>
<BLOCKQUOTE>
The numerator of the function field element a with respect to the order O.
</BLOCKQUOTE>
<H5><A NAME = "4740">Numerator(a) : FldFunOrdElt -&gt; RngFunOrdElt</A></H5>
<BLOCKQUOTE>
Given an element a in a field of fractions of an order O return the 
numerator of a with respect to O.
</BLOCKQUOTE>
<H5><A NAME = "4741">Numerator(a, O) : FldFunOrdElt, RngFunOrd -&gt; RngElt</A></H5>
<BLOCKQUOTE>
Given an element a in a field of fractions of an order and an order O of a 
function field return the
numerator of a with respect to O.
</BLOCKQUOTE>
<H5><A NAME = "4742">Denominator(a, O) : FldFunElt, RngFunOrd -&gt; RngElt</A></H5>
<BLOCKQUOTE>
The denominator of the function field element a with respect to the order O.
</BLOCKQUOTE>
<H5><A NAME = "4743">Denominator(a) : FldFunOrdElt -&gt; RngElt</A></H5>
<BLOCKQUOTE>
Given an element a in a field of fractions of an order O return the
denominator of a with respect to O.
</BLOCKQUOTE>
<H5><A NAME = "4744">Denominator(a, O) : FldFunOrdElt, RngFunOrd -&gt; RngElt</A></H5>
<BLOCKQUOTE>
Given an element a in a field of fractions of an order and an order O of a 
function field return the
denominator of a with respect to O.
</BLOCKQUOTE>
<H5><A NAME = "4745">Min(a, O) : FldFunElt, RngFunOrd -&gt; RngElt, RngElt</A></H5>
<H5>Minimum(a, O) : FldFunElt, RngFunOrd -&gt; RngElt, RngElt</H5>
<H5>Minimum(a, O) : RngFunOrdElt, RngFunOrd -&gt; RngElt, RngElt</H5>
<H5>Min(a, O) : RngFunOrdElt, RngFunOrd -&gt; RngElt, RngElt</H5>
<BLOCKQUOTE>
A generator of the ideal R &cap;(d x a x O) where R is the 
coefficient ring of 
the order O and d is the denominator of the
function field or order element a wrt O (d is the second return 
value).
</BLOCKQUOTE>
<H4><A NAME = "4746">Functions related to Places and Divisors</A></H4>



<H5><A NAME = "4747">Evaluate(a, P) : FldFunElt, PlcFunElt -&gt; RngElt</A></H5>
<H5>Evaluate(a, P) : RngFunOrdElt, PlcFunElt -&gt; RngElt</H5>
<BLOCKQUOTE>
Evaluate the algebraic function a at the place P. If it is not
defined at P, infinity is returned.
</BLOCKQUOTE>
<H5><A NAME = "4748">Lift(a, P) : RngElt, PlcFunElt -&gt; FldFunElt</A></H5>
<BLOCKQUOTE>
Lift the element a of the residue class field of the place P 
(including infinity) to an algebraic function.
</BLOCKQUOTE>
<H5><A NAME = "4749">Valuation(a, P) : FldFunElt, PlcFunElt -&gt; RngIntElt</A></H5>
<H5>Valuation(a, P) : RngFunOrdElt, PlcFunElt -&gt; RngIntElt</H5>
<BLOCKQUOTE>
The valuation of the function field or order element a at the place P.
</BLOCKQUOTE>
<H5><A NAME = "4750">Expand(a, P) : FldFunGElt, PlcFunElt -&gt; RngSerElt, FldFunGElt</A></H5>

<PRE>    RelPrec: RngIntElt                  Default: 10</PRE>

<PRE>    AbsPrec: RngIntElt                  Default: </PRE>
<BLOCKQUOTE>
Expand the algebraic function a to a series of given precision at
the place P and return the local parameter.
</BLOCKQUOTE>
<H5><A NAME = "4751">Divisor(a) : FldFunGElt -&gt; DivFunElt</A></H5>
<H5>Divisor(a) : RngFunOrdElt -&gt; DivFunElt</H5>
<H5>PrincipalDivisor(a) : FldFunGElt -&gt; DivFunElt</H5>
<H5>PrincipalDivisor(a) : RngFunOrdElt -&gt; DivFunElt</H5>
<BLOCKQUOTE>
The (principal) divisor (a) of the function field or order element a.
</BLOCKQUOTE>
<H5><A NAME = "4752">Zeros(a) : FldFunGElt -&gt; [PlcFunElt]</A></H5>
<H5>Zeros(a) : RngFunOrdElt -&gt; [PlcFunElt]</H5>
<H5>Zeroes(a) : FldFunGElt -&gt; [PlcFunElt]</H5>
<H5>Zeroes(a) : RngFunOrdElt -&gt; [PlcFunElt]</H5>
<BLOCKQUOTE>
A sequence containing the zeros of the algebraic function a.
</BLOCKQUOTE>
<H5><A NAME = "4753">Zeros(F, a) : FldFunG, FldFunGElt -&gt; [PlcFunElt]</A></H5>
<H5>Zeroes(F, a) : FldFunG, FldFunGElt -&gt; [PlcFunElt]</H5>
<BLOCKQUOTE>
The zeros of the function field element a in the function field F.
</BLOCKQUOTE>
<H5><A NAME = "4754">Poles(a) : FldFunGElt -&gt; SeqEnum[PlcFunElt]</A></H5>
<H5>Poles(a) : RngFunOrdElt -&gt; SeqEnum[PlcFunElt]</H5>
<BLOCKQUOTE>
A sequence containing the poles of the algebraic function a.
</BLOCKQUOTE>
<H5><A NAME = "4755">Poles(F, a) : FldFun, FldFunGElt -&gt; [PlcFunElt]</A></H5>
<BLOCKQUOTE>
A sequence containing the poles of the function field element a in the function field F.
</BLOCKQUOTE>
<H5><A NAME = "4756">Degree(a) : FldFunElt -&gt; RngIntElt</A></H5>
<H5>Degree(a) : RngFunOrdElt -&gt; RngIntElt</H5>
<BLOCKQUOTE>
The degree of the algebraic function a, being defined as the degree
of the pole (or zero) divisor of a.
</BLOCKQUOTE>
<H5><A NAME = "4757">CommonZeros(L) : [FldFunGElt] -&gt; [PlcFunElt]</A></H5>
<BLOCKQUOTE>
Return the common zeros of the function field elements in the sequence L.
</BLOCKQUOTE>
<H5><A NAME = "4758">CommonZeros(F, L) : FldFunG, SeqEnum[ FldFunGElt ] -&gt; SeqEnum[ PlcFunElt ]</A></H5>
<BLOCKQUOTE>
Return the common zeros in the function
field F of the function field elements in the sequence L.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "4759">Example <TT>FldFunG_elements (H44E27)</TT></A></H3>
<P>
<P>
<P>
<PRE>
&gt; R&lt;x&gt; := FunctionField(GF(9));
&gt; P&lt;y&gt; := PolynomialRing(R);
&gt; f := y^3 + y + x^5 + x + 1;
&gt; F&lt;a&gt; := FunctionField(f);
&gt; MinimalPolynomial(a);
y^3 + y + x^5 + x + 1
&gt; RepresentationMatrix(a);
[                  0                   1                   0]
[                  0                   0                   1]
[    2*x^5 + 2*x + 2                   2                   0]
&gt; O := IntegralClosure(ValuationRing(R), F);
&gt; Denominator(a, O);
1/x^2
&gt; O := IntegralClosure(PolynomialRing(GF(9)), F);
&gt; Denominator(a, O);
1
&gt; Zeros(a);
[ (x + 2, a), (x^3 + 2*x^2 + 1, a + x^3 + 2*x^2 + 1) ]
&gt; Degree(a);
5
&gt; P := RandomPlace(F, 2);
&gt; P;
(x^2 + $.1^2*x + $.1^6, a + x^2 + $.1^5*x + 1)
&gt; b := Evaluate(a, P);
&gt; b;
$.1^3*$.1 + $.1^3
&gt; c := Lift(b, P);
&gt; c;
$.1^3*x + $.1^3
&gt; Valuation(a, P);
0
&gt; Valuation(a-c, P);
1
</PRE>
<HR>
<H5><A NAME = "4760">Module(L, R) : SeqEnum[ FldFunGElt ], Rng -&gt; Mod, Map, SeqEnum[ ModElt ]</A></H5>

<PRE>    IsBasis: BoolElt                    Default: <TT>false</TT></PRE>

<PRE>    PreImages: BoolElt                  Default: <TT>false</TT></PRE>
<BLOCKQUOTE>
The R-module generated by the function field elements in the sequence L as an
abstract module, together with the map into the algebraic function
field. The resulting modules can be used for intersection and inner
sum computations. <P>
<P>
If the optional parameter <TT>IsBasis</TT> is set <TT>true</TT> the function
assumes that the given elements form a basis of the module to be
computed. <P>
<P>
If the optional parameter <TT>PreImages</TT> is set <TT>true</TT> then the
preimages of the given elements under the map are returned as the
third return value. <P>
<P>
Both optional parameters are mainly used to save computation time. 
</BLOCKQUOTE>
<H5><A NAME = "4761">Relations(L, R) : SeqEnum[ FldFunElt ], Rng -&gt; ModTupRng</A></H5>
<H5>Relations(L, R, m) : SeqEnum[ FldFunElt ], Rng, RngIntElt -&gt; ModTupRng</H5>
<BLOCKQUOTE>
The module of R-linear relations between the function field elements of the
sequence L.  The integer m is used for the following: Let the
elements of L be a<sub>1</sub>, ..., a<sub>n</sub>, V be the relation module
&sube;R<sup>n</sup> and define M := { &sum;<sub>i=1</sub><sup>m</sup> v<sub>i</sub> a<sub>i</sub>  | v =
(v<sub>i</sub>)<sub>i</sub> &isin;V  }.  The function tries to compute a generating
system of V such that the corresponding generating system of M
consists of "small" elements.
</BLOCKQUOTE>
<H5><A NAME = "4762">Roots(f, D) : RngUPolElt, DivFunElt -&gt; SeqEnum[ FldFunElt ]</A></H5>
<BLOCKQUOTE>
Compute the roots of the polynomial 
f which lie in the Riemann-Roch space of the divisor D.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "4763">Example <TT>FldFunG_module (H44E28)</TT></A></H3>
This example shows the capability of <TT>Module</TT> and <TT>Relations</TT> with 
relative function fields.
<P>
<P>
<PRE>
&gt; PR&lt;x&gt; := PolynomialRing(Rationals());
&gt; P&lt;y&gt; := PolynomialRing(PR);
&gt; FR1&lt;a&gt; := FunctionField(y^3 - x);
&gt; P&lt;y&gt; := PolynomialRing(FR1);
&gt; FR2&lt;c&gt; := FunctionField(y^2 - a);
&gt; MFR1F := MaximalOrderFinite(FR1);
&gt; m, f := Module([c, c + a], MFR1F);
&gt; f(m.1);
1
&gt; f(m.2);
c
&gt; m, f := Module([c, c + a], FR1);
&gt; f(m.1);
c
&gt; f(m.2);
1
&gt; m;
KModule m of dimension 2 over FR1
&gt; Relations([c, c + a], FR1, 1);
Vector space of degree 2, dimension 0 over FR1
User basis:
Matrix with 0 rows and 2 columns
</PRE>
<HR>
<H4><A NAME = "4764">Other Operations on Elements</A></H4>



<H5><A NAME = "4765">ProductRepresentation(a) : FldFunGElt -&gt; [FldFunGElt], [RngIntElt]</A></H5>
<H5>ProductRepresentation(a) : RngFunOrdElt -&gt; [RngElt], [RngIntElt]</H5>
<BLOCKQUOTE>
Return a product representation for the function field or order element a.
</BLOCKQUOTE>
<H5><A NAME = "4766">ProductRepresentation(Q, S) : [FldFunGElt], [RngIntElt] -&gt; FldFunGElt</A></H5>
<H5>PowerProduct(Q, S) : [FldFunGElt], [RngIntElt] -&gt; FldFunGElt</H5>
<BLOCKQUOTE>
Return the element given by the product representation of function field
elements in the sequence Q
and exponents in the sequence S. It is expensive to put large elements in product 
representation into sets or to test for them for equality.
</BLOCKQUOTE>
<H5><A NAME = "4767">RationalFunction(a) : FldFunGElt -&gt; RngElt</A></H5>
<H5>RationalFunction(a, R) : FldFunGElt, Rng -&gt; RngElt</H5>
<BLOCKQUOTE>
Return the algebraic function a as a rational function in free
variables with respect to the defining polynomial over the coefficient field.
<P>
If the ring R is provided it must appear in the tower of coefficient fields
of the parent of a and the result is a polynomial over R with respect
to all the defining polynomials of the extensions in between.
</BLOCKQUOTE>
<H5><A NAME = "4768">Differentiation(x, a) : FldFunGElt, FldFunGElt -&gt; FldFunGElt</A></H5>
<BLOCKQUOTE>
The first differentiation resp. derivative of the function field 
element a with respect to
the separating element x.
</BLOCKQUOTE>
<H5><A NAME = "4769"></A><A NAME = "FldFunGElt:Differentiation">Differentiation</A>(x, n, a) : FldFunGElt, RngIntElt, FldFunGElt -&gt; FldFunGElt</H5>
<BLOCKQUOTE>
The nth differentiation of the function field element a with respect to the separating
element x. In characteristic zero the nth differentiation equals the
nth derivative times 1/n!.
</BLOCKQUOTE>
<H5><A NAME = "4770">DifferentiationSequence(x, n, a) : FldFunGElt, RngIntElt, FldFunGElt -&gt; SeqEnum</A></H5>
<BLOCKQUOTE>
The 0-th up to the n-th differentiation of the function field element 
a with respect to the separating element x.
</BLOCKQUOTE>
<H5><A NAME = "4771">PrimePowerRepresentation(x, k, a) : FldFunGElt, RngIntElt, FldFunGElt -&gt; SeqEnum</A></H5>
<BLOCKQUOTE>
Return the coefficients of the representation of the function field 
element a as a
linear combination of k-th prime powers and powers of the function field 
element x. More
precisely, let p &gt; 0 be the characteristic of F. Then F<sup>p<sup>k</sup></sup> is
a subfield of F of index p<sup>k</sup> and F can be viewed as a
F<sup>p<sup>k</sup></sup>-vector space. A basis is given by 1, x, ..., x<sup>p<sup>k</sup> - 1</sup>
for x a separating element. The function returns &lambda;<sub>1</sub>, ...,
&lambda;<sub>p<sup>k</sup> - 1</sub> &isin;F<sup>p<sup>k</sup></sup> such that a = &sum;<sub>i</sub> &lambda;<sub>i</sub> x<sup>i</sup>.
</BLOCKQUOTE>
<H5><A NAME = "4772">Different(a) : RngFunOrdElt -&gt; RngFunOrdElt</A></H5>
<BLOCKQUOTE>
The different of the element a of an order of an algebraic function field.
</BLOCKQUOTE>
<H5><A NAME = "4773">RationalReconstruction(e, f) : FldFunElt, RngUPolElt -&gt; BoolElt, FldFunElt</A></H5>
<BLOCKQUOTE>
For an element e of some function field K with integral
coefficients e = &sum;e<sub>i</sub>&alpha;<sup>i</sup>, e<sub>i</sub>&isin;k[x] and some polynomial
f&isin;k[x] find the (essentially) unique E = &sum;E<sub>i</sub>&alpha;<sub>i</sub>
with E<sub>i</sub>&isin;k(x) and E<sub>i</sub> = e<sub>i</sub> mod f, where the numerator and
denominator of the E<sub>i</sub> have degree bounded by half the degree of f.
If such E<sub>i</sub> exists they are unique, the corresponding element
&sum;E<sub>i</sub>&alpha;<sup>i</sup> for the function field will be returned as a second return 
value, the first being <TT>true</TT> to indicate success.
If no such element exists, <TT>false</TT> will be returned.
</BLOCKQUOTE>
<H5><A NAME = "4774">CoefficientHeight(a) : RngFunOrdElt -&gt; RngIntElt</A></H5>
<H5>CoefficientHeight(a) : FldFunElt -&gt; RngIntElt</H5>
<BLOCKQUOTE>
The (naive) height of the element as defined as the largest degree of any
coefficient or denominator polynomial occurring in the coefficients of a.
</BLOCKQUOTE>
<H5><A NAME = "4775">CoefficientLength(a) : RngFunOrdElt -&gt; RngIntElt</A></H5>
<H5>CoefficientLength(a) : FldFunElt -&gt; RngIntElt</H5>
<BLOCKQUOTE>
The (naive) length or size of the element, defined as the sum of the degrees
of all polynomials occurring as coefficients or denominators in the
coefficient representation of a.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "4776">Example <TT>FldFunG_elements-other_ops (H44E29)</TT></A></H3>
<P>
<P>
<PRE>
&gt; F&lt;z&gt; := GF(13, 3);
&gt; PF&lt;x&gt; := PolynomialRing(F);
&gt; P&lt;y&gt; := PolynomialRing(PF);
&gt; FF1&lt;b&gt; := ext&lt;FieldOfFractions(PF) | y^2 - x&gt;;
&gt; P&lt;y&gt; := PolynomialRing(FF1);
&gt; FF2&lt;d&gt; := ext&lt;FF1 | y^3 - ConstantField(FF1).1&gt;;
&gt; ProductRepresentation([Random(FF2, 2) : i in [1 .. 3]], [2, 3, 2]);
(((z^476*x + z^319)*b + (z^1861*x + z^439))*d^2 + ((z^348*x + z^931)*b + 
    (z^328*x + z^2076))*d + (z^152*x + z^1723)*b + z^1044*x + z^1119)^2 * 
(((z^1024*x + z^2085)*b + (z^798*x + z^335))*d^2 + ((z^310*x + z^932)*b + 
    (z^281*x + z^1393))*d + (z^1844*x + z^66)*b + z^2127*x + z^1788)^3 * 
(((z^1478*x + z^1782)*b + (z^687*x + z^1898))*d^2 + ((z^560*x + z^425)*b + 
    (z^2081*x + z^164))*d + (z^60*x + z^890)*b + z^258*x + z^1739)^2
&gt; ProductRepresentation($1);
[
    ((z^476*x + z^319)*b + (z^1861*x + z^439))*d^2 + ((z^348*x + z^931)*b + 
        (z^328*x + z^2076))*d + (z^152*x + z^1723)*b + z^1044*x + z^1119,
    ((z^1024*x + z^2085)*b + (z^798*x + z^335))*d^2 + ((z^310*x + z^932)*b + 
        (z^281*x + z^1393))*d + (z^1844*x + z^66)*b + z^2127*x + z^1788,
    ((z^1478*x + z^1782)*b + (z^687*x + z^1898))*d^2 + ((z^560*x + z^425)*b + 
        (z^2081*x + z^164))*d + (z^60*x + z^890)*b + z^258*x + z^1739
]
[ 2, 3, 2 ]
&gt; r := Random(FF2, 3);
&gt; RationalFunction(r);
((z^1568*x^2 + z^1591*x + z^1260)*b + (z^746*x^2 + z^1405*x + z^1721))*y^2 + 
    ((z^990*x^2 + z^689*x + z^470)*b + (z^1324*x^2 + z^195*x + z^1082))*y + 
    (z^331*x^2 + z^1995*x + z^1521)*b + z^1323*x^2 + z^852*x + z^2162
&gt; RationalFunction(r, CoefficientField(FF2));
((z^1568*x^2 + z^1591*x + z^1260)*b + (z^746*x^2 + z^1405*x + z^1721))*$.1^2 + 
    ((z^990*x^2 + z^689*x + z^470)*b + (z^1324*x^2 + z^195*x + z^1082))*$.1 + 
    (z^331*x^2 + z^1995*x + z^1521)*b + z^1323*x^2 + z^852*x + z^2162
&gt; RationalFunction(r, PF);                   
(z^1568*x^2 + z^1591*x + z^1260)*$.1^2*$.2 + (z^746*x^2 + z^1405*x + 
    z^1721)*$.1^2 + (z^990*x^2 + z^689*x + z^470)*$.1*$.2 + (z^1324*x^2 + 
    z^195*x + z^1082)*$.1 + (z^331*x^2 + z^1995*x + z^1521)*$.2 + z^1323*x^2 + 
    z^852*x + z^2162
&gt; Differentiation(FF2!x, r);
((z^836*x^2 + z^2140*x + z^1077)/x*b + (z^929*x + z^1405))*d^2 + ((z^258*x^2 + 
    z^1238*x + z^287)/x*b + (z^1507*x + z^195))*d + (z^1795*x^2 + z^348*x + 
    z^1338)/x*b + z^1506*x + z^852
&gt; Differentiation(FF2!b, r);
((z^1112*x + z^1588)*b + (z^1019*x^2 + z^127*x + z^1260))*d^2 + ((z^1690*x + 
    z^378)*b + (z^441*x^2 + z^1421*x + z^470))*d + (z^1689*x + z^1035)*b + 
    z^1978*x^2 + z^531*x + z^1521
&gt; Differentiation(FF2!d, r);
&gt;&gt; Differentiation(FF2!d, r);
                  ^
Runtime error in 'Differentiation': First element must be a separating element
&gt; MFR2I := MaximalOrderInfinite(FF2);
&gt; Different(Numerator(r, MFR2I));    
[ [ (z^1095*x^5 + z^849*x^4 + z^111*x^3 + z^853*x^2 + z^224*x + z^1340)/x^6, 
    (z^666*x^4 + z^1902*x^3 + z^2086*x^2 + z^1119*x + z^1973)/x^5 ], [ 
    (z^1673*x^5 + z^699*x^4 + z^1465*x^3 + z^1060*x^2 + z^761*x + z^1979)/x^6, 
    (z^1034*x^4 + z^1185*x^3 + z^833*x^2 + z^2044*x + z^1701)/x^5 ], [ 
    (z^516*x^5 + z^1545*x^4 + z^509*x^3 + z^832*x^2 + z^606*x + z^700)/x^6, 
    (z^1033*x^4 + z^983*x^3 + z^1375*x^2 + z^89*x + z^271)/x^5 ] ]
</PRE>
<HR>
<PRE></PRE> <A  HREF = "text454.htm">[Next]</A><A  HREF = "text452.htm">[Prev]</A> <A  HREF = "text454.htm">[Right]</A> <A  HREF = "text452.htm">[Left]</A> <A  HREF = "text442.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<br><small>Version: V2.22 of <I>
Thu Jun  9 16:37:49 EST 2016
</I></small>
</body></html>