<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <link rel='stylesheet' href='help.css' type='text/css'>
  <TITLE>Module Operations</TITLE>
</head>
<body BGCOLOR="#FFFFFF">

 <A  HREF = "text1264.htm">[Next]</A><A  HREF = "text1262.htm">[Prev]</A> <A  HREF = "text1264.htm">[Right]</A> <A  HREF = "text1262.htm">[Left]</A> <A  HREF = "text1254.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<PRE></PRE><H3><A NAME = "13891">Module Operations</A></H3>

<P>
<P>
The following functions perform some fundamental module operations.


<H5><A NAME = "13892">MinimalBasis(M) : ModMPol -&gt; [ ModMPolElt ]</A></H5>
<BLOCKQUOTE>
Given an R-module M, return a minimal basis B of M.
If M is graded, or if R is a local ring, then the cardinality
of B (the rank) is guaranteed to be unique (so is the
absolutely minimal number of elements needed to generate M).
<P>
Otherwise the cardinality of B is not unique: B will only satisfy
the rule that the i-th element of B is not in the submodule
generated by elements 1 to i - 1 of B.
<P>
In the graded case or local cases, a minimal basis is computed in
the usual way
starting from any basis B consisting of homogeneous elements. B
gives a particular presentation whose relation matrix R consists of
homogeneous polynomials. If R contains a non-zero constant term
(or more generally a unit in the local case),
an element of B can be eliminated and R recalculated. This can
be continued until all non-zero terms of R have positive degree.
</BLOCKQUOTE>
<H5><A NAME = "13893">MinimalBasis(S) : [ ModMPolElt ] -&gt; [ ModMPolElt ]</A></H5>
<H5>MinimalBasis(S) : { ModMPolElt } -&gt; [ ModMPolElt ]</H5>
<BLOCKQUOTE>
Given a set or sequence S of homogeneous module elements from a module
M, return a minimal basis of the submodule of M generated by S.
</BLOCKQUOTE>
<H5><A NAME = "13894"></A><A NAME = "PMod:Rank">Rank</A>(M) : ModMPol -&gt; RngIntElt</H5>
<BLOCKQUOTE>
Given an R-module M, return the rank of M.  This is simply
defined to be the cardinality of the minimal basis of M, returned
by the function <TT>MinimalBasis</TT>.  Thus if M is graded, or if
R is a local ring, then the rank is guaranteed to be unique (and
is the absolutely minimal number of elements needed to generate M).
Otherwise the result is not an invariant of M, but simply reflects the
minimum as found by the <TT>MinimalBasis</TT> algorithm.
</BLOCKQUOTE>
<H5><A NAME = "13895">ColonModule(M, J) : ModMPol, RngMPol -&gt; ModMPol</A></H5>
<BLOCKQUOTE>
Given an R-module M and an ideal J of R, return the 
colon module M:J which is the submodule of the ambient module A of M
consisting of all f&isin;A such that f.g&isin;M for all g&isin;J.
When J is generated by a single element, this easily reduces to a syzygy
computation in A and in the general case, we intersect the colon modules
for a set of generators of J.
</BLOCKQUOTE>
<H5><A NAME = "13896">ColonIdeal(M, N) : ModMPol, ModMPol -&gt; RngMPol</A></H5>
<BLOCKQUOTE>
Given an R-modules M and N which are both submodules of a common
supermodule, return the colon ideal M:N, which is the ideal of R
consisting of all f&isin;R such that f.N &sub;M.
The algorithm used is as described in section 2.8.4 of <A  HREF = "text1253.htm#bib_GrPf02">[GP02]</A>.
</BLOCKQUOTE>
<H5><A NAME = "13897">Annihilator(M) : ModMPol -&gt; RngMPol</A></H5>
<BLOCKQUOTE>
Given an R-module M, return the annihilator ideal of M.
This is the ideal I of R consisting of all f&isin;R such
that f.M = 0 (which can be seen to equal the ideal 0<sub>M</sub> : M,
where 0<sub>M</sub> is the zero submodule of M, so is a special case of
<TT>ColonIdeal</TT>).
</BLOCKQUOTE>
<H5><A NAME = "13898">FittingIdeal(M, i) : ModMPol, RngIntElt -&gt; RngMPol</A></H5>
<BLOCKQUOTE>
Given an R-module M of degree r and an integer i&ge;0, return the i-th
Fitting ideal of M, which is the ideal of R generated by
the (r - i)-th minors of the presentation matrix of M, where r
is the degree of M.  See <A  HREF = "text1253.htm#bib_UAG_CLO">[CLO98, p.229]</A> or
<A  HREF = "text1253.htm#bib_EisenbudCommAlg">[Eis95, Sec. 20.2]</A>.
</BLOCKQUOTE>
<H5><A NAME = "13899">FittingIdeals(M) : ModMPol -&gt; RngMPol</A></H5>
<BLOCKQUOTE>
Given an R-module M of degree r, return the Fitting ideals (for
from 0 to r) as a sequence of ideals of R.
</BLOCKQUOTE>
<H5><A NAME = "13900">SyzygyModule(M) : ModMPol -&gt; [ ModMPolElt ]</A></H5>
<BLOCKQUOTE>
Given a module M, return the syzygy module S of M.  If the basis B of
M has length k, the syzygy module S has degree k and elements of
S express a syzygy amongst the k elements of the basis B.  Note that
the degree of the resulting module thus depends on the current basis of M.
</BLOCKQUOTE>
<H5><A NAME = "13901">MinimalSyzygyModule(M) : ModMPol -&gt; [ ModMPolElt ]</A></H5>
<BLOCKQUOTE>
Given a homogeneous module M, return the syzygy module S of the
minimal basis of M.  If the minimal basis B of
M has length k, the syzygy module S has degree k and elements of
S express a syzygy amongst the k elements of the minimal basis B.
</BLOCKQUOTE>
<H5><A NAME = "13902">SyzygyModule(Q) : [ RngMPolElt ] -&gt; ModTupRng</A></H5>
<BLOCKQUOTE>
Given a sequence Q of polynomials from a multivariate polynomial ring P,
return the module of syzygies of Q.  This is a module over P of degree
k, where k is the length of Q, consisting of all vectors v such that
the sum of v[i] * Q[i] for i=1, ... k is zero.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "13903">Example <TT>PMod_Rank (H115E5)</TT></A></H3>
In this example we note that a certain module M has rank 3
(equal to its degree 3), since no generator is redundant.  If
we move to the localization of M, then (1 + x - z) becomes a unit,
so the first generator becomes redundant.
<P>
<P>
<PRE>
&gt; R&lt;x,y,z&gt; := PolynomialRing(RationalField(), 3, "grevlex");
&gt; F := RModule(R, 3);
&gt; M := quo&lt;F | [x + 1, y, z], [z, y, 0]&gt;;
&gt; M;
Reduced Module R^3/&lt;relations&gt;
Relations:
[x + 1,     y,     z],
[    z,     y,     0]
&gt; Degree(M);
3
&gt; Rank(M);
3
&gt; ML := Localization(M);
&gt; ML;
Reduced Module R^3/&lt;relations&gt; (local)
Relations:
[1 + x - z,         0,         z],
[        z,         y,         0]
&gt; Rank(ML);
2
&gt; MinimalBasis(ML);
[
    [0, 1, 0],
    [0, 0, 1]
]
</PRE>
<HR>
<PRE></PRE> <A  HREF = "text1264.htm">[Next]</A><A  HREF = "text1262.htm">[Prev]</A> <A  HREF = "text1264.htm">[Right]</A> <A  HREF = "text1262.htm">[Left]</A> <A  HREF = "text1254.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<br><small>Version: V2.22 of <I>
Thu Jun  9 16:37:49 EST 2016
</I></small>
</body></html>