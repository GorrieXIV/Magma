<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <link rel='stylesheet' href='help.css' type='text/css'>
  <TITLE>Rational Points and Point Sets</TITLE>
</head>
<body BGCOLOR="#FFFFFF">

 <A  HREF = "text1329.htm">[Next]</A><A  HREF = "text1327.htm">[Prev]</A> <A  HREF = "text1329.htm">[Right]</A> <A  HREF = "text1327.htm">[Left]</A> <A  HREF = "text1321.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<PRE></PRE><H3><A NAME = "14493">Rational Points and Point Sets</A></H3>

<P>
<P>
<P>
<P>
There are two ways to think of points.
If X is a scheme defined over a ring k and L is a k-algebra, then
there is a set, called a <I>point set</I> and denoted X(L) which is
the set of points of X having coordinates in L or, in Magma terminology,
the <I>parent</I> of such points.
Note that in Magma a k-algebra is interpreted to mean any ring which
admits coercion from k or which is the codomain of a ring homomorphism
whose domain is k.
When thinking of points as a sequence of coordinates on some scheme
this type of point should be used. It is created by coercing the
sequence of coordinates into the required point set using a statement such as
<P>
<P>
<PRE>
&gt; X(L) ! [1,2,3];
</PRE>
Alternatively, if the universe of the sequence is equal to the base ring
of the scheme, one may simply coerce the sequence into the scheme.
<P>
<P>
<PRE>
&gt; X ! [1,2,3];
</PRE>
When the universe of the sequence is the integers, Magma will coerce them
into the base ring of the scheme and again this shorthand will work.
<P>
<B>The word point always refers to an object whose parent is some point set.</B>
<P>
When a scheme is defined over a finite field, there are intrinsics
which list all of its points defined over that field or over any
finite extension of it.
<P>
An alternative approach is to consider points, or sets of points, as
schemes in their own right. They can be defined by equations, after all.
We call such zero-dimensional schemes <I>clusters</I>.
They are more general than simply collections of points since
their ideals could be nonradical.
They are discussed in the Section <A  HREF = "text1329.htm#14513">Zero-dimensional Schemes</A> together with intrinsics
which translate between points and clusters.
<P>
If p is a point, there are two ways of accessing its coordinates.
The intrinsic <TT>Coordinates</TT> returns the sequence of all coordinates
of p while <TT>p[i]</TT> returns the i-th coordinate alone.
For example,
<P>
<P>
<PRE>
&gt; p := X ! [1,2,3];
&gt; Coordinates(p);
[ 1, 2, 3 ]
&gt; p[1];
1
</PRE>
See Section <A  HREF = "text1323.htm#14409">Prelude to Points</A> for descriptions of these and some other
basic functions.


<H5><A NAME = "14494">X(L) : Sch,Rng -&gt; SetPt</A></H5>
<H5>PointSet(X,L) : Sch,Rng -&gt; SetPt</H5>
<H5>X(m) : Sch,Map -&gt; SetPt</H5>
<H5>PointSet(X,m) : Sch,Map -&gt; SetPt</H5>
<BLOCKQUOTE>
The point set of the scheme X of points whose coordinates lie in the
ring L or in the codomain of the map m.
The map m is a ring homomorphism from the base ring of X to some other ring.
Coercion from the base ring of X to L must be possible if m is not given.
</BLOCKQUOTE>
<H5><A NAME = "14495">P eq Q : SetPt,SetPt -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if and only if the point sets P and Q where created
on the same scheme and with the same map from the base ring of that
scheme.
</BLOCKQUOTE>
<H5><A NAME = "14496">Scheme(P) : SetPt -&gt; Sch</A></H5>
<BLOCKQUOTE>
The scheme X associated to the point set P where
P is of the form X(L) for some extension L of the base ring of X.
</BLOCKQUOTE>
<H5><A NAME = "14497">Curve(P) : SetPt -&gt; Crv</A></H5>
<BLOCKQUOTE>
The smallest scheme in the inclusion chain above the scheme associated to 
the point set P which is a curve.
</BLOCKQUOTE>
<H5><A NAME = "14498">Ring(P) : SetPt -&gt; Rng</A></H5>
<BLOCKQUOTE>
The ring L associated to the point set P where
P is of the form X(L) for some scheme X.
</BLOCKQUOTE>
<H5><A NAME = "14499">RingMap(P) : SetPt -&gt; Map</A></H5>
<BLOCKQUOTE>
The map from the base ring of the scheme of P to the ring of the pointset P.
</BLOCKQUOTE>
<H5><A NAME = "14500">X ! Q : Sch,SeqEnum -&gt; Pt</A></H5>
<H5>X(L) ! Q : SetPt,SeqEnum -&gt; Pt</H5>
<BLOCKQUOTE>
The point of the scheme X or the point set X(L) (where X is a scheme and
L is some extension ring of its base ring) determined by the sequence
of coordinates Q.
The universe of the sequence Q must be the base ring of X, or the ring L
or some ring from which coercion into one of these is possible.
</BLOCKQUOTE>
<H5><A NAME = "14501">p eq q : Pt,Pt -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if and only if the points p and q lie in some common scheme
(possibly after coercion) and their coordinates are equal.
</BLOCKQUOTE>
<H5><A NAME = "14502">p in X : Pt,Sch -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if and only if the point p lies in the scheme X or is coercible into
it.
</BLOCKQUOTE>
<H5><A NAME = "14503">Scheme(p) : Pt -&gt; Sch</A></H5>
<BLOCKQUOTE>
The scheme on which the point p lies.
</BLOCKQUOTE>
<H5><A NAME = "14504">Curve(p) : Pt -&gt; Crv</A></H5>
<BLOCKQUOTE>
The smallest scheme in the inclusion chain above the scheme on which the
point p lies which is a curve.
</BLOCKQUOTE>
<H5><A NAME = "14505">Q in X : SeqEnum,Sch -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if and only if all of the points of the set or sequence Q lie in the
scheme X or are coercible into it.
</BLOCKQUOTE>
<H5><A NAME = "14506">S subset X : Setq,Sch -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if and only if all points of the set S lie in
the scheme X or are coercible into it.
</BLOCKQUOTE>
<H5><A NAME = "14507">IsCoercible(X,Q) : Sch,SeqEnum -&gt; BoolElt,Pt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if and only if the sequence Q is the sequence of coordinates of
some point of the scheme X. In that case, also return the point.
</BLOCKQUOTE>
<H5><A NAME = "14508">RationalPoints(X) : Sch -&gt; SetIndx</A></H5>
<H5>RationalPoints(X,L) : Sch, Rng -&gt; SetIndx</H5>
<H5>Points(X) : Sch -&gt; SetIndx</H5>
<H5>Points(X,L) : Sch, Rng -&gt; SetIndx</H5>

<PRE>    Bound: RngIntElt                    Default: 1000</PRE>
<BLOCKQUOTE>
An indexed set containing points in the point set X(L), where L
is an extension of the base field of X.
When not specified, L is taken to be the base field of X.
This is implemented in the following situations: 
(i) L is a finite field,
(ii) X has dimension zero,
(iii) L is <TT>Rationals()</TT>.
In cases (i) and (ii), all the points in X(L) are found.
In case (iii), a call to <TT>PointSearch</TT> is made, which searches
for points with height up to the specified <TT>Bound</TT> (but note 
that it does not guarantee finding all of them).
<P>
In most cases, the first step is to determine the dimension of X by 
computing the Groebner basis of its defining ideal.  This may be
time-consuming; to avoid this one may directly call the relevant 
search: <TT>Ratpoints</TT> over finite fields, or <TT>PointSearch</TT> 
(specifying the <TT>Dimension</TT>) over the <TT>Rationals()</TT>.
</BLOCKQUOTE>
<H5><A NAME = "14509">RationalPointsByFibration(X) : Sch -&gt; SetIndx</A></H5>

<PRE>    UseHypersurface: BoolElt            Default: <TT>false</TT></PRE>
<BLOCKQUOTE>
This is one of the methods used by <TT>RationalPoints</TT> when X is an 
affine or ordinary projective scheme over a finite field. 
<P>
The basic idea is to work with a Noether Normalisation of the coordinate
ring of X which, in the affine or projective case, gives an everywhere
defined map with finite fibres to a linear subspace. We then run over all
the points in the subspace adding in the points of X in the finite fibre.
Determining the points on a zero-dimensional scheme is relatively fast
and so we get a fairly efficient method for listing all points.
<P>
There is a variant to the basic algorithm. Rather than running over
the linear subspace, it can take fibrations over a hypersurface
of dimension one bigger the linear subspace. The points on these as
fibred over the subspace may be quicker to find than for a general finite
fibration and the finite fibres over the hypersurface are of smaller
degree. For example, the general fibre contains only one point when
the extra hypersurface equation generates X generically over the
subspace.
<P>
However it is often slower to use the hypersurface because of the
extra computation at the start and the two-stage processing so 
the default for <TT>UseHypersurface</TT> is <TT>false</TT>.
The user may set this parameter to <TT>true</TT> for the variant
to be applied. 
</BLOCKQUOTE>
<H5><A NAME = "14510">Random(S) : SetPt -&gt; Pt</A></H5>
<BLOCKQUOTE>
Returns a random point in the pointset S = X(k) where X is a scheme 
defined over a finite field, and k is a finite field.  An error results
if the pointset is empty.  (Here `random' simply means all points can 
occur, but not with uniform distribution.)
<P>
This is implemented using the Noether normalisation of X (similarly 
to <TT>RationalPointsByFibration</TT>).
</BLOCKQUOTE>
<H5><A NAME = "14511">HasNonsingularPoint(X) : Sch -&gt; BoolElt,Pt</A></H5>
<H5>HasNonsingularPoint(X,L) : Sch,FldFin -&gt; BoolElt,Pt</H5>
<BLOCKQUOTE>
Return <TT>true</TT> if and only if the scheme X defined over a finite field
contains a nonsingular point (defined over the
finite field L if it appears as a second argument).
In that case, also return such a point.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "14512">Example <TT>Scheme_scheme-points (H118E16)</TT></A></H3>
In this example we define a scheme over a finite field
and compute some points on it.
Note that there are two point constructors used here.
The first is simply <TT>X ! Q</TT> where Q is a sequence of integers
(or base ring elements).
In the second, we try to coerce a sequence Q whose elements do not
lie in the base ring.
The coercion into X cannot be used here. Instead one must be explicit
about the intended point set. We have used the <TT>IsCoercible(X,Q)</TT>
intrinsic which creates the point as a side-effect.
One could also use the <TT>X(L) ! Q</TT> coercion to create the same point.
<P>
<P>
<PRE>
&gt; A&lt;x,y&gt; := AffineSpace(FiniteField(7),2);
&gt; X := Scheme(A,x^2 + y^2 + 1);
&gt; X ! [2,3];
(2, 3)
&gt; L&lt;w&gt; := ext&lt; BaseRing(X) | 2 &gt;;
&gt; IsCoercible(X,[w^4,w^4]);
false
&gt; IsCoercible(X(L),[w^4,w^4]);
true (w^4, w^4)
</PRE>
Finding those points was not simply good luck.
In fact, we worked backwards and computed all points over the base field
or L and chose one from each of those sets.
<P>
<P>
<PRE>
&gt; RationalPoints(X);
{@ (3, 2), (4, 2), (2, 3), (5, 3), (2, 4), (5, 4), (3, 5), (4, 5) @}
&gt; #RationalPoints(X,L);
48
</PRE>
<P>
We now consider an example of a curve in projective 3-space. In 
older versions of Magma this ran very slowly indeed. Now however,
finding points over a fibration, it only takes a few seconds on a
fast machine.
<P>
<P>
<PRE>
&gt; k := GF(7823);
&gt; R&lt;x,y,z,w&gt; := PolynomialRing(k, 4);
&gt; I := ideal&lt;R | 4*x*z + 2*x*w + y^2 + 4*y*w + 7821*z^2 + 7820*w^2,
&gt;  4*x^2 + 4*x*y + 7821*x*w + 7822*y^2 + 7821*y*w + 
&gt;  7821*z^2 + 7819*z*w + 7820*w^2&gt;;
&gt; C := Curve(Proj(R), I);
&gt; // a genus 0 curve with 1 cusp as singularities =&gt; 7823+1 points
&gt; pts := RationalPointsByFibration(C); // could also just use RationalPoints
&gt; #pts;
7824
</PRE>
Note that Magma has very fast machinery for computations like this
for elliptic and hyperelliptic curves.
<HR>
<PRE></PRE> <A  HREF = "text1329.htm">[Next]</A><A  HREF = "text1327.htm">[Prev]</A> <A  HREF = "text1329.htm">[Right]</A> <A  HREF = "text1327.htm">[Left]</A> <A  HREF = "text1321.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<br><small>Version: V2.22 of <I>
Thu Jun  9 16:37:49 EST 2016
</I></small>
</body></html>