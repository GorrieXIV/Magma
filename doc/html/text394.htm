<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <link rel='stylesheet' href='help.css' type='text/css'>
  <TITLE>Ideals and Quotients</TITLE>
</head>
<body BGCOLOR="#FFFFFF">

 <A  HREF = "text395.htm">[Next]</A><A  HREF = "text393.htm">[Prev]</A> <A  HREF = "text395.htm">[Right]</A> <A  HREF = "text393.htm">[Left]</A> <A  HREF = "text383.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<PRE></PRE><H3><A NAME = "3929">Ideals and Quotients</A></H3>

<P>
<P>
<P>
<P>
Ideals of orders are of two types. All ideals are fractional and inherit 
from type <TT>RngOrdFracIdl</TT>. Integral ideals can have (the sub--)type 
<TT>RngOrdIdl</TT>.
Some functions only apply to integral ideals and only ideals
with the integral type can be prime. An ideal with fractional type but
trivial denominator can be converted to have the integral type and any
integral ideal can be converted to fractional type.
<P>
Ideals can be taken of orders over Z and orders defined over a 
maximal order. A few functions are not implemented for the latter.
<P>
Where an element or elements are returned from a function the elements are 
usually in the field of fractions if the ideal has the fractional type and
in the order if it has integral type.



<H5>Subsections</H5>
<UL>
<LI> <A  HREF = "text394.htm#3930">Creation of Ideals in Orders</A>
<LI> <A  HREF = "text394.htm#3935">Invariants</A>
<LI> <A  HREF = "text394.htm#3955">Basis Representation</A>
<LI> <A  HREF = "text394.htm#3962">Two--Element Presentations</A>
<LI> <A  HREF = "text394.htm#3967">Predicates on Ideals</A>
<LI> <A  HREF = "text394.htm#3991">Ideal Arithmetic</A>
<LI> <A  HREF = "text394.htm#4015">Roots of Ideals</A>
<LI> <A  HREF = "text394.htm#4020">Factorization and Primes</A>
<LI> <A  HREF = "text394.htm#4030">Other Ideal Operations</A>
<LI> <A  HREF = "text394.htm#4043">Quotient Rings</A>
</UL>
<H4><A NAME = "3930">Creation of Ideals in Orders</A></H4>

<P>
<P>
The general ideal constructor can be used to create ideals in
orders of algebraic fields, as described below. 
Since ideals in orders are allowed to be <I>fractional ideals</I>,
algebraic field elements are allowed as generators.
Ideals can also be created how they are written on paper: as an
element multiplied by an order.


<H5><A NAME = "3931">x * O : RngElt, RngOrd -&gt; RngOrdFracIdl</A></H5>
<H5>O * x : RngElt, RngOrd -&gt; RngOrdFracIdl</H5>
<BLOCKQUOTE>
Create the ideal x * O for element x and order O. 
If the ideal is integral it will be returned with 
the integral type.
</BLOCKQUOTE>
<H5><A NAME = "3932">F !! I : RngOrd, RngInt -&gt; RngOrdFracIdl</A></H5>
<H5>F !! I : FldOrd, RngOrdFracIdl -&gt; RngOrdFracIdl</H5>
<H5>O !! I : RngOrd, RngOrdFracIdl -&gt; RngOrdIdl</H5>
<BLOCKQUOTE>
Make the ideal I either fractional (first case where F is a 
field of fractions compatible with the order of I) or integral
(second case where O is an order compatible with the order of I).
</BLOCKQUOTE>
<H5><A NAME = "3933">ideal&lt; O | a<sub>1</sub>, a<sub>2</sub>, ... , a<sub>m</sub> &gt; : RngOrd, RngElt, ..., RngElt -&gt; RngOrdFracIdl</A></H5>
<H5>ideal&lt;O | x&gt; : RngOrd, RngIntElt -&gt; RngOrdIdl</H5>
<H5>ideal&lt;O | M, d&gt; : RngOrd, AlgMatElt, RngIntElt -&gt; RngOrdFracIdl</H5>
<H5>ideal&lt;O | M, d&gt; : RngOrd, ModDed, RngIntElt -&gt; RngOrdFracIdl</H5>
<H5>ideal&lt;O | M, I1, ..., In&gt; : RngOrd, AlgMatElt, RngOrdFracIdl, ..., RngOrdFracIdl -&gt; RngOrdFracIdl</H5>
<H5>ideal&lt;O | M, [I1, ..., In]&gt; : RngOrd, AlgMatElt, [RngOrdFracIdl] -&gt; RngOrdFracIdl</H5>
<BLOCKQUOTE>
Given an order O, as well as anything that can be used to produce
a sequence of elements of the field of fractions of O return the ideal
generated by those elements. If the ideal is integral then it 
will be returned with the integral type.
<P>
A single integer may be given in which case the principal ideal
it generates will be returned. A matrix or a module over an order (<TT>ModDed</TT>)
(or a matrix and ideals which the module could be created from)
can be supplied as the basis for the resulting ideal. An optional second
argument is a denominator given as an integer, (except when ideals are given).
</BLOCKQUOTE>
<HR>
<H3><A NAME = "3934">Example <TT>RngOrd_Ideals (H38E25)</TT></A></H3>
We give an example of the creation of an ideal generated by
an element from an order.
<P>
<P>
<PRE>
&gt; R&lt;x&gt; := PolynomialRing(Integers());
&gt; f := x^4-420*x^2+40000;
&gt; K&lt;y&gt; := NumberField(f);
&gt; E := EquationOrder(K);
&gt; O := MaximalOrder(K);
&gt; elt := O ! (y^2/40+y/4);
&gt; elt in E;
false
&gt; I := ideal&lt; O | elt &gt;;
&gt; I;
Principal Ideal of O
Generator:
    [0, 0, 1, 0]
&gt; FieldOfFractions(O)!!I;
Principal Ideal of O
Generator:
    O.3
&gt; O!!$1 eq I;
true
</PRE>
<HR>
<H4><A NAME = "3935">Invariants</A></H4>

<P>
<P>
Some information describing an ideal can be retrieved.


<H5><A NAME = "3936">Order(I) : RngOrdFracIdl -&gt; RngOrd</A></H5>
<BLOCKQUOTE>
The order O which the ideal I is of.
</BLOCKQUOTE>
<H5><A NAME = "3937">Denominator(I) : RngOrdFracIdl -&gt; RngIntElt</A></H5>
<BLOCKQUOTE>
The denominator of the fractional ideal I. This is the smallest
positive integer d such that d I is an integral ideal.
</BLOCKQUOTE>
<H5><A NAME = "3938">PrimitiveElement(I) : RngOrdIdl -&gt; RngOrdElt</A></H5>
<H5>PrimitiveElement(I) : RngOrdFracIdl -&gt; FldOrdElt</H5>
<H5>UniformizingElement(P) : RngOrdIdl -&gt; RngOrdElt</H5>
<BLOCKQUOTE>
A primitive element of an ideal I is an element a which is in I
but not in the square of I.  This function returns such an element
a. <TT>UniformizingElement</TT> returns the primitive element of a prime
ideal.
</BLOCKQUOTE>
<H5><A NAME = "3939">Index(O, I) : RngOrd, RngOrdIdl -&gt; RngIntElt</A></H5>
<BLOCKQUOTE>
The index of the integral ideal I, when viewed as a submodule
of the order O. This is the same as the cardinality of
the finite quotient ring O/I.
</BLOCKQUOTE>
<H5><A NAME = "3940">Norm(I) : RngOrdIdl -&gt; RngIntElt</A></H5>
<H5>Norm(I) : RngOrdFracIdl -&gt; FldRatElt</H5>
<H5>Norm(I) : RngOrdFracIdl -&gt; RngOrdFracIdl</H5>
<BLOCKQUOTE>
The norm of the fractional ideal I. This returns the index of
the ideal if the ideal is integral, and is defined on fractional
ideals by multiplicativity so that the norm of I<sup> - 1</sup> equals
the reciprocal of the norm of I.
</BLOCKQUOTE>
<H5><A NAME = "3941">MinimalInteger(I) : RngOrdIdl -&gt; RngElt</A></H5>
<BLOCKQUOTE>
Given an ideal I of an order in some number field, 
the function returns the least positive integer 
contained in the ideal.
</BLOCKQUOTE>
<H5><A NAME = "3942">Minimum(I) : RngOrdFracIdl -&gt; RngElt</A></H5>
<H5>Min(I) : RngOrdFracIdl -&gt; RngElt</H5>
<BLOCKQUOTE>
Given an ideal I, this function returns the least positive integer m if 
the ideal is integral
or the least positive rational r if is fractional contained in I. 
</BLOCKQUOTE>
<H5><A NAME = "3943">AbsoluteNorm(I) : RngOrdIdl -&gt; RngIntElt</A></H5>
<H5>AbsoluteNorm(I) : RngOrdFracIdl -&gt; FldRatElt</H5>
<H5>NormAbs(I) : RngOrdIdl -&gt; RngIntElt</H5>
<H5>NormAbs(I) : RngOrdFracIdl -&gt; FldRatElt</H5>
<BLOCKQUOTE>
The absolute norm of the fractional ideal I. This returns the index of
the ideal if the ideal is integral, and is defined on fractional
ideals by multiplicativity so that the norm of I<sup> - 1</sup> equals
the reciprocal of the norm of I.
</BLOCKQUOTE>
<H5><A NAME = "3944">CoefficientHeight(I) : RngOrdIdl -&gt; RngIntElt</A></H5>
<H5>CoefficientHeight(I) : RngOrdFracIdl -&gt; RngIntElt</H5>
<BLOCKQUOTE>
For an ideal I the coefficient height is defined to be the
maximum integer occurring in the current representation of the ideal:
If the ideal is given via two elements, this will be the maximal 
coefficient height of the generators, otherwise the maximal entry of
the basis matrix.
</BLOCKQUOTE>
<H5><A NAME = "3945">CoefficientLength(I) : RngOrdIdl -&gt; RngIntElt</A></H5>
<H5>CoefficientLength(I) : RngOrdFracIdl -&gt; RngIntElt</H5>
<BLOCKQUOTE>
For an ideal I the coefficient length is defined to be the
size of the current representation:
If the ideal is given via two elements, this will be the sum  of the 
coefficient lengths of the generators, otherwise the sum of the entries of
the basis matrix.
</BLOCKQUOTE>
<H5><A NAME = "3946">RamificationIndex(I, p) : RngOrdIdl, RngIntElt -&gt; RngIntElt</A></H5>
<H5>RamificationDegree(I, p) : RngOrdIdl, RngIntElt -&gt; RngIntElt</H5>
<BLOCKQUOTE>
For a prime ideal I of an order O such that p &isin;I
returns the maximal exponent e such that I<sup>e</sup> divides the principal 
ideal pO. If p is not given it is taken to be the minimal integer 
of I.
</BLOCKQUOTE>
<H5><A NAME = "3947">RamificationDegree(I) : RngOrdIdl -&gt; RngIntElt</A></H5>
<H5>RamificationIndex(I) : RngOrdIdl -&gt; RngIntElt</H5>
<BLOCKQUOTE>
Computes the relative ramification index of the prime ideal I
over the coefficient ring. To be more precise: Let I be a prime ideal of
some order O with coefficient ring o. Then I &cap;o is an
prime ideal p in o.
The ramification index e = e(I|p)
is the maximal exponent e such that I<sup>e</sup> divides pO.
</BLOCKQUOTE>
<H5><A NAME = "3948">AbsoluteRamificationDegree(I) : RngOrdIdl -&gt; RngIntElt</A></H5>
<H5>AbsoluteRamificationIndex(I) : RndOrdIdl -&gt; RngIntElt</H5>
<BLOCKQUOTE>
Return the ramification index of the prime ideal I as an extension of the
prime integer which is its minimum.
</BLOCKQUOTE>
<H5><A NAME = "3949">ResidueClassField(O, I) : RngOrd, RngOrdIdl -&gt; FldFin, Map</A></H5>
<H5>ResidueClassField(I) : RngOrdIdl -&gt; FldFin, Map</H5>
<BLOCKQUOTE>
If I is a prime ideal of O, this function returns the finite field
F isomorphic to O/I and the map O -&gt; F.
</BLOCKQUOTE>
<H5><A NAME = "3950">Degree(I) : RngOrdIdl -&gt; RngIntElt</A></H5>
<H5>InertiaDegree(I) : RngOrdIdl -&gt; RngIntElt</H5>
<BLOCKQUOTE>
Given a prime ideal I this function returns the relative degree f of the
residue class field of the ideal I. To be more precise: Let I be
a prime ideal in some order O with coefficient ring o. Then p := o &cap;I
is a prime ideal in o and the residue class field O/I is a finite
extension of degree f=f(I|p) of the residue class field o/p.
</BLOCKQUOTE>
<H5><A NAME = "3951">AbsoluteInertiaDegree(I) : RngOrdIdl -&gt; RngIntElt</A></H5>
<H5>AbsoluteInertiaIndex(I) : RngOrdIdl -&gt; RngIntElt</H5>
<BLOCKQUOTE>
Return the inertia index of the prime ideal I as an extension of the prime
integer which is its minimum.
</BLOCKQUOTE>
<H5><A NAME = "3952">Valuation(I, p) : RngOrdFracIdl, RngOrdIdl -&gt; RngIntElt</A></H5>
<BLOCKQUOTE>
Given an ideal I and a prime ideal p in an order O, returns
the valuation v<sub>p</sub>(I) of I at p, that is, the number of factors
p in the prime ideal decomposition of I. Note that, since the
ideal I is allowed to be a fractional ideal, the returned value may be
a negative integer.
</BLOCKQUOTE>
<H5><A NAME = "3953">Content(I) : RngOrdFracIdl -&gt; RngIntElt</A></H5>
<BLOCKQUOTE>
The content of the ideal I, i.e. the maximal ideal of the base ring dividing I.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "3954">Example <TT>RngOrd_ideal-invar (H38E26)</TT></A></H3>
The retrieval of some properties of an ideal is illustrated.
<P>
<P>
<PRE>
&gt; R&lt;x&gt; := PolynomialRing(Integers());
&gt; M := MaximalOrder(x^5 + 4*x^4 - x^3 + 7*x^2 - 1);
&gt; R&lt;x&gt; := PolynomialRing(M);         
&gt; O := MaximalOrder(x^3 - 2);
&gt; M;
Maximal Equation Order with defining polynomial x^5 + 4*x^4 - x^3 + 7*x^2 - 1 
over Z
&gt; O;
Maximal Order of Equation Order with defining polynomial x^3 - [2, 0, 0, 0, 0] 
over M
&gt; I := 19/43*M.4*O.3*O;
&gt; I;
Fractional Principal Ideal of O
Generator:
    19/43*M.4*O.3
&gt; Order(I);
Maximal Order of Equation Order with defining polynomial x^3 - [2, 0, 0, 0, 0] 
over M
&gt; Norm(Norm(I));
15545474078591793458176/3177070365797955661914307
&gt; FactorizationOfQuotient($1);
[ &lt;2, 10&gt;, &lt;19, 15&gt;, &lt;43, -15&gt; ]
&gt; Norm(Norm(O.3));
1024
&gt; Norm(M.4);
1
&gt; Denominator(I);
43
&gt; Denominator(O.3);
1
&gt; PrimitiveElement(I);
19/43*M.4*O.3
&gt; Minimum(I); 
19/43
&gt; [ Norm(Norm(tuple[1])) : tuple in Factorization(I) ];
[ 2, 4, 4, 43, 43, 43, 6859, 341&equiv;, 341&equiv;, 341&equiv;, 2213314919066161 ]
</PRE>
<HR>
<H4><A NAME = "3955">Basis Representation</A></H4>

<P>
<P>
The basis of an ideal can be computed as well as related matrices.


<P>
For relative extensions, a different method is available:
<H5><A NAME = "3956">Basis(I) : RngOrdIdl -&gt; [RngOrdElt]</A></H5>
<H5>Basis(I) : RngOrdFracIdl -&gt; [FldOrdElt]</H5>
<H5>Basis(I, R) : RngOrdFracIdl, Rng -&gt; [RngElt]</H5>
<BLOCKQUOTE>
Given an ideal I of an order O of the algebraic field F,
this function returns a basis for I
as a sequence of elements of F (if fractional), O (if integral) 
or the ring R if given.
</BLOCKQUOTE>
<H5><A NAME = "3957">BasisMatrix(I) : RngOrdFracIdl -&gt; MtrxSpcElt</A></H5>
<BLOCKQUOTE>
Returns the basis matrix for the ideal I
of the order O.
The basis matrix consists of the elements of a basis for the
ideal written as rows of rational coefficients with respect to the
basis of O. The entries of the matrix are elements of Z for an 
integral ideal
of an order over Z only or the 
field of fractions of the coefficient ring of O.
</BLOCKQUOTE>
<H5><A NAME = "3958">TransformationMatrix(I) : RngOrdFracIdl -&gt; MtrxSpcElt, RngIntElt</A></H5>
<BLOCKQUOTE>
Returns the transformation matrix for the ideal I
of the order O, as well as a denominator.
The transformation matrix consists of the elements of a basis for the
ideal written as rows of coefficients with respect to the basis
of the order O. The entries of the matrix are elements of 
Z for an integral ideal of an order over Z or the 
field of fractions of the coefficient ring of O.
</BLOCKQUOTE>
<H5><A NAME = "3959">CoefficientIdeals(I) : RngOrdFracIdl -&gt; [RngOrdFracIdl]</A></H5>
<BLOCKQUOTE>
The coefficient ideals of the ideal I in a relative extension. These are 
the ideals {A<sub>i</sub>} of the coefficient ring of the order of I such that for every element 
e &isin;I, e = &sum;<sub>i</sub> a<sub>i</sub> * b<sub>i</sub> where {b<sub>i</sub>}
is the basis returned for I and each a<sub>i</sub> &isin;A<sub>i</sub>.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "3960">Example <TT>RngOrd_ideal-basis (H38E27)</TT></A></H3>
Continuing from the last example, the use of the basis functions for ideals
is shown.
<P>
<P>
<PRE>
&gt; Basis(I);
[
    19/43*M.4*O.3,
    19/86*M.4*O.1,
    19/43*M.4*O.2
]
&gt; Basis(I, NumberField(O));
[
    19/86*$.1^3*$.1^2,
    19/86*$.1^3,
    19/86*$.1^3*$.1
]
&gt; BasisMatrix(I);
[0 0 19/43*M.4]
[19/86*M.4 0 0]
[0 19/43*M.4 0]
&gt; TransformationMatrix(I);
[M.1 0 0]
[0 M.1 0]
[0 0 M.1]
1
</PRE>
<HR>
<H5><A NAME = "3961">Module(I) : RngOrdFracIdl -&gt; ModDed, Map</A></H5>
<BLOCKQUOTE>
For an ideal I in some relative extension, return a Dedekind module
over the coefficient ring with the "same" basis. 
</BLOCKQUOTE>
<H4><A NAME = "3962">Two--Element Presentations</A></H4>

<P>
<P>
All ideals of maximal orders can be generated by one or two elements of the 
field of fractions of the order they are an ideal of.


<P>
<H5><A NAME = "3963">Generators(I) : RngOrdIdl -&gt; [ RngOrdElt ]</A></H5>
<H5>Generators(I) : RngOrdFracIdl -&gt; [ FldOrdElt ]</H5>
<BLOCKQUOTE>
Given a (fractional) ideal I of O, return a sequence containing
two elements that generate I as an ideal.
The elements will be in the order iff the ideal is integral, otherwise
they will come from the field of fractions of O.
</BLOCKQUOTE>
<H5><A NAME = "3964">TwoElement(I) : RngOrdFracIdl -&gt; FldOrdElt, FldOrdElt</A></H5>
<BLOCKQUOTE>
Given a (fractional) ideal I of O, return two elements of (the
field of fractions of) O that generate I as an ideal.
</BLOCKQUOTE>
<H5><A NAME = "3965">TwoElementNormal(I) : RngOrdIdl -&gt; RngOrdElt, RngOrdElt, RngIntElt</A></H5>
<BLOCKQUOTE>
Given an integral ideal I of O (a maximal order over Z), 
return two elements 
of O that form a two-element normal presentation
for I, as well as an integer g such that I is g-normal.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "3966">Example <TT>RngOrd_ideal-two (H38E28)</TT></A></H3>
The generators and two element presentation of I are compared.
<P>
<P>
<PRE>
&gt; Generators(I);
[
    19/43*M.4*O.3
]
&gt; TwoElement(I);
19/43*M.4*O.3
19/43*M.4*O.3
</PRE>
<HR>
<H4><A NAME = "3967">Predicates on Ideals</A></H4>

<P>
<P>
Ideals may be tested for various properties and whether given elements lie 
in the ideal.


<H5>I eq J : RngOrdFracIdl, RngOrdFracIdl -&gt; BoolElt</H5>

<H5>I ne J : RngOrdFracIdl, RngOrdFracIdl -&gt; BoolElt</H5>


<H5>x in I : FldOrdElt, RngOrdFracIdl -&gt; BoolElt</H5>

<H5>x in I : RngOrdElt, RngOrdFracIdl -&gt; BoolElt</H5>

<H5>x notin I : FldOrdElt, RngOrdFracIdl -&gt; BoolElt</H5>

<H5>x notin I : RngOrdElt, RngOrdFracIdl -&gt; BoolElt</H5>

<H5>I subset J : RngOrdIdl, RngOrdIdl -&gt; BoolElt</H5>
<P>




<H5><A NAME = "3968">IsIntegral(I) : RngOrdFracIdl -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if and only if the fractional ideal I is integral.
</BLOCKQUOTE>
<H5><A NAME = "3969">IsZero(I) : RngOrdFracIdl -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if the ideal I is the zero ideal, <TT>false</TT> otherwise.
</BLOCKQUOTE>
<H5><A NAME = "3970">IsOne(I) : RngOrdIdl -&gt; BoolElt</A></H5>
<H5>IsOne(I) : RngOrdFracIdl -&gt; BoolElt</H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if the ideal I is the ideal generated by 1, <TT>false</TT> otherwise.
</BLOCKQUOTE>
<H5><A NAME = "3971">IsPrime(I) : RngOrdIdl -&gt; BoolElt, RngOrdIdl</A></H5>
<H5>IsPrime(I) : RngOrdFracIdl -&gt; BoolElt</H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if and only if the ideal I is a prime ideal of <TT>Order(I)</TT>.
If <TT>Order(I)</TT> is maximal and I is a proper ideal of type <TT>RngOrdIdl</TT>,
then in the case I is not prime, the function also returns a proper divisor.
</BLOCKQUOTE>
<H5><A NAME = "3972">IsPrincipal(I) : RngOrdFracIdl -&gt; BoolElt, FldOrdElt</A></H5>

<PRE>    SetVerbose("ClassGroup", n):        Maximum: 5</PRE>
<BLOCKQUOTE>
Returns <TT>true</TT> if the fractional ideal I of the order O
is a principal ideal, otherwise <TT>false</TT>.
If I is principal, a generator (as an element of the field of
fractions of O) is also returned.
<P>
If it is known or easy to decide whether I is principal the 
function will return quickly. If it is necessary to compute the class group 
of O the function will be slower. If the generator is required this may
cause the function to take longer as well. If I is an ideal of a non-maximal
order the Unit group may be required also. Class group and unit group 
computations will be carried out to the most rigorous proof level, if this
level of proof is not required then the <A  HREF = "text392.htm#RngOrd:UnitGroup">UnitGroup</A> should be 
precomputed and 
<A  HREF = "text391.htm#RngOrd:ClassGroup">ClassGroup</A> bounds set before calling <TT>IsPrincipal</TT>.
</BLOCKQUOTE>
<H5><A NAME = "3973">IsRamified(P) : RngOrdIdl -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> iff the ramification index of the prime ideal
P is greater than 1.
</BLOCKQUOTE>
<H5><A NAME = "3974">IsRamified(P, O) : RngOrdIdl, RngOrd -&gt; BoolElt</A></H5>
<H5>IsRamified(P, O) : RngIntElt, RngOrd -&gt; BoolElt</H5>
<BLOCKQUOTE>
Returns <TT>true</TT> iff for any prime ideal Q lying above
P in the order O, the ramification index of Q is greater than 1.
P must be a prime ideal of the base ring of O or a prime number (if
O is an absolute order).
</BLOCKQUOTE>
<H5><A NAME = "3975">IsTotallyRamified(P) : RngOrdIdl -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> iff the ramification index of the prime ideal P equals
the degree of its order over the base field.
</BLOCKQUOTE>
<H5><A NAME = "3976">IsTotallyRamified(P, O) : RngOrdIdl, RngOrd -&gt; BoolElt</A></H5>
<H5>IsTotallyRamified(P, O) : RngIntElt, RngOrd -&gt; BoolElt</H5>
<BLOCKQUOTE>
Returns <TT>true</TT> iff for any prime ideal Q lying above
P in the order O, the ramification index of Q equals
the field degree.
P must be a prime ideal of the base ring of O or a prime number (if
O is an absolute order).
</BLOCKQUOTE>
<H5><A NAME = "3977">IsTotallyRamified(K) : FldAlg -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if all primes dividing the discriminant the maximal order of
the algebraic field K are totally ramified over the coefficient field of K.
</BLOCKQUOTE>
<H5><A NAME = "3978">IsTotallyRamified(O) : RngOrd -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if all primes dividing the discriminant of the maximal order
O are totally ramified over the coefficient ring of O.
</BLOCKQUOTE>
<H5><A NAME = "3979">IsWildlyRamified(P) : RngOrdIdl -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> iff the ramification index of the prime ideal 
P is a multiple
of the characteristic of the residue class field of P.
</BLOCKQUOTE>
<H5><A NAME = "3980">IsWildlyRamified(P, O) : RngOrdIdl, RngOrd -&gt; BoolElt</A></H5>
<H5>IsWildlyRamified(P, O) : RngIntElt, RngOrd -&gt; BoolElt</H5>
<BLOCKQUOTE>
Returns <TT>true</TT> iff for any prime ideal Q of the order O lying above
P, the ramification index e(Q|P) is a multiple
of the characteristic of the residue class field of Q.
P must be a prime ideal of the base ring of O or a prime number (if
O is an absolute order).
</BLOCKQUOTE>
<H5><A NAME = "3981">IsTamelyRamified(P) : RngOrdIdl -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> iff the prime ideal P is not wildly ramified.
</BLOCKQUOTE>
<H5><A NAME = "3982">IsTamelyRamified(P, O) : RngOrdIdl, RngOrd -&gt; BoolElt</A></H5>
<H5>IsTamelyRamified(P, O) : RngIntElt, RngOrd -&gt; BoolElt</H5>
<BLOCKQUOTE>
Returns <TT>true</TT> iff the prime ideal or integer P is not wildly ramified in 
the order O.
</BLOCKQUOTE>
<H5><A NAME = "3983">IsUnramified(P) : RngOrdIdl -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> iff the ramification index of the prime ideal P is 1.
</BLOCKQUOTE>
<H5><A NAME = "3984">IsUnramified(P, O) : RngOrdIdl, RngOrd -&gt; BoolElt</A></H5>
<H5>IsUnramified(P, O) : RngIntElt, RngOrd -&gt; BoolElt</H5>
<BLOCKQUOTE>
Returns <TT>true</TT> iff for all prime ideals Q lying above
P in the order O, the ramification index of Q is 1.
P must be a prime ideal of the base ring of O or a prime number 
(if O is an absolute order).
</BLOCKQUOTE>
<H5><A NAME = "3985">IsInert(P) : RngOrdIdl -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> iff the inertia degree of the prime ideal
P is the field degree.
</BLOCKQUOTE>
<H5><A NAME = "3986">IsInert(P, O) : RngOrdIdl, RngOrd -&gt; BoolElt</A></H5>
<H5>IsInert(P, O) : RngIntElt, RngOrd -&gt; BoolElt</H5>
<BLOCKQUOTE>
Returns <TT>true</TT> iff the prime integer or ideal P in
the base ring of the order O is inert, i.e. PO is an unramified prime 
ideal of O.
</BLOCKQUOTE>
<H5><A NAME = "3987">IsSplit(P) : RngOrdIdl -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> iff the prime ideal P is not the only prime ideal
which lies above its intersection with the base ring of its order.
</BLOCKQUOTE>
<H5><A NAME = "3988">IsSplit(P, O) : RngOrdIdl, RngOrd -&gt; BoolElt</A></H5>
<H5>IsSplit(P, O) : RngIntElt, RngOrd -&gt; BoolElt</H5>
<BLOCKQUOTE>
Returns <TT>true</TT> iff at least two prime ideals in the order O lie above the prime integer or
ideal P of the base ring of O. 
</BLOCKQUOTE>
<H5><A NAME = "3989">IsTotallySplit(P) : RngOrdIdl -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> iff there are as many prime ideals lying above the intersection
of the prime ideal P with the base ring of its order as the degree of the 
order of P.
</BLOCKQUOTE>
<H5><A NAME = "3990">IsTotallySplit(P, O) : RngOrdIdl, RngOrd -&gt; BoolElt</A></H5>
<H5>IsTotallySplit(P, O) : RngIntElt, RngOrd -&gt; BoolElt</H5>
<BLOCKQUOTE>
Returns <TT>true</TT> iff as many prime ideals in the order O 
lying above the prime integer or ideal P of the base ring of O as the
degree of O.
</BLOCKQUOTE>
<H4><A NAME = "3991">Ideal Arithmetic</A></H4>

<P>
<P>
<P>
Ideals can be multiplied in several ways, divided and added. Powers of
ideals, the least common multiple and the intersection of two ideals 
can also be calculated.


<H5><A NAME = "3992">I * J : RngOrdFracIdl, RngOrdFracIdl -&gt; RngOrdFracIdl</A></H5>
<BLOCKQUOTE>
The product IJ of the (fractional) ideals I and J, generated by the
products of elements in I and elements in J.
</BLOCKQUOTE>
<H5><A NAME = "3993">x * I : RngElt, RngOrdFracIdl -&gt; RngOrdFracIdl</A></H5>
<H5>I * x : RngOrdFracIdl, RngElt -&gt; RngOrdFracIdl</H5>
<BLOCKQUOTE>
Given an element x of (or coercible into) a field of fractions F, and
a (fractional) ideal I in the order of F, return the product
of the ideal and the principal ideal generated by x.
</BLOCKQUOTE>
<H5><A NAME = "3994">&amp;* L : [RngOrdFracIdl] -&gt; RngOrdFracIdl</A></H5>
<H5>&amp;* L : { RngOrdFracIdl } -&gt; RngOrdFracIdl</H5>
<BLOCKQUOTE>
The product of all ideals in the sequence or set L.
</BLOCKQUOTE>
<H5><A NAME = "3995">I div J : RngOrdIdl, RngOrdIdl -&gt; RngOrdIdl</A></H5>
<BLOCKQUOTE>
For integral ideals I and J of some maximal order
such that J divides I (or equivalently that J is contained in I),
return the integral ideal K such that JK=I.
</BLOCKQUOTE>
<H5><A NAME = "3996">I / J : RngOrdFracIdl, RngOrdFracIdl -&gt; RngOrdFracIdl</A></H5>
<H5>I div J : RngOrdFracIdl, RngOrdFracIdl -&gt; RngOrdFracIdl</H5>
<BLOCKQUOTE>
The quotient of the (fractional) ideals I and J of a maximal order O.
This is the fractional ideal K of O with the property that JK=I.
<P>
There are some considerations to be made here.
Firstly, the "I/J" notation is interpreted as above,
and not (say) as an ideal of the quotient O/J
(see also the example with (Z) as a number field order in
Section <A  HREF = "text173.htm#1370">Ideals of Z</A> and <A  HREF = "text174.htm#1373">Z as a Number Field Order</A>).
Secondly, since I/J is only defined (in Magma) for <I>maximal</I> orders,
this is the same (in Magma) as the <TT>ColonIdeal</TT> (or <TT>IdealQuotient</TT>)
as noted below. Thirdly, I/J and <TT>I div J</TT> are not truly synonyms,
as I/J will work for I, J of type <TT>RngOrdIdl</TT> even when J
does not divide I, while <TT>I div J</TT> will give an error in that case.
</BLOCKQUOTE>
<H5><A NAME = "3997">I / x : RngOrdFracIdl, RngElt -&gt; RngOrdFracIdl</A></H5>
<BLOCKQUOTE>
Given an ideal I and an element x construct the fractional ideal I / x.
</BLOCKQUOTE>
<H5><A NAME = "3998">I + J : RngOrdFracIdl, RngOrdFracIdl -&gt; RngOrdFracIdl</A></H5>
<BLOCKQUOTE>
The sum of the (fractional) ideals I and J, generated by the
sums of elements in I and elements in J.
</BLOCKQUOTE>
<H5><A NAME = "3999">I ^ k : RngOrdFracIdl, RngIntElt -&gt; RngOrdFracIdl</A></H5>
<BLOCKQUOTE>
The k-th power of the (fractional) ideal I (for an integer k).
If I has integral type and k is negative the result will have
fractional type.
</BLOCKQUOTE>
<H5><A NAME = "4000">I eq J : RngOrdFracIdl, RngOrdFracIdl -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Tests if the ideals I and J are equal.
</BLOCKQUOTE>
<H5><A NAME = "4001">I subset J : RngOrdIdl, RngOrdIdl -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Tests if the two ideals I and J of the same order are contained in each
other. For invertible ideals this is equivalent to checking if J divides
I,
</BLOCKQUOTE>
<H5><A NAME = "4002">E in I: RngOrdElt, RngOrdIdl -&gt; BoolElt</A></H5>
<H5>E in I: RngOrdElt, RngOrdFracIdl -&gt; BoolElt</H5>
<H5>E in I: FldAlgElt, RngOrdFracIdl -&gt; BoolElt</H5>
<BLOCKQUOTE>
Tests if the element E is actually in the ideal I. The element and the
ideal have to be compatible, i.e., live in the same number field.
</BLOCKQUOTE>
<H5><A NAME = "4003">LCM(I, J) : RngOrdFracIdl, RngOrdFracIdl -&gt; RngOrdFracIdl</A></H5>
<H5>Lcm(I, J) : RngOrdFracIdl, RngOrdFracIdl -&gt; RngOrdFracIdl</H5>
<H5>LeastCommonMultiple(I, J) : RngOrdFracIdl, RngOrdFracIdl -&gt; RngOrdFracIdl</H5>
<BLOCKQUOTE>
Return the least common multiple of ideals I and J.  They must both
be of the same maximal order.
</BLOCKQUOTE>
<H5><A NAME = "4004">GCD(I, J) : RngOrdFracIdl, RngOrdFracIdl -&gt; RngOrdFracIdl</A></H5>
<H5>Gcd(I, J) : RngOrdFracIdl, RngOrdFracIdl -&gt; RngOrdFracIdl</H5>
<H5>GreatestCommonDivisor(I, J) : RngOrdFracIdl, RngOrdFracIdl -&gt; RngOrdFracIdl</H5>
<BLOCKQUOTE>
The greatest common divisor of the ideals I and J of some maximal
order of an algebraic number field.
</BLOCKQUOTE>
<H5><A NAME = "4005">Content(M) : Mtrx -&gt; RngOrdFracIdl</A></H5>
<BLOCKQUOTE>
For a matrix M with entries in some number field k, compute the
gcd of all elements as principal ideals in the maximal order of k.
</BLOCKQUOTE>
<H5><A NAME = "4006">I meet J : RngOrdFracIdl, RngOrdFracIdl -&gt; RngOrdFracIdl</A></H5>
<BLOCKQUOTE>
The intersection of the (fractional) ideals I and J. For ideal in
the maximal order this is the same as the lcm.
</BLOCKQUOTE>
<H5><A NAME = "4007">&amp;meet S : [RngOrdFracIdl] -&gt; RngOrdFracIdl</A></H5>
<H5>&amp;meet S : { RngOrdFracIdl } -&gt; RngOrdFracIdl</H5>
<BLOCKQUOTE>
The intersection of all ideals I of the sequence or set S. For
ideals in some maximal order this is the same as the lcm.
</BLOCKQUOTE>
<H5><A NAME = "4008">I meet R : RngOrdFracIdl, Rng -&gt; Any</A></H5>
<H5>R meet I : Rng, RngOrdFracIdl -&gt; Any</H5>
<BLOCKQUOTE>
The intersection of the ideal I with the compatible ring R. If R = Q an
error will occur since ideals of Q cannot be created. If such information
is required use <TT>Minimum</TT> instead. An ideal of R is returned.
</BLOCKQUOTE>
<H5><A NAME = "4009">a mod I : RngOrdElt, RngOrdIdl -&gt; RngOrdElt</A></H5>
<BLOCKQUOTE>
A representative of the element a of an order O in the quotient O/I.
</BLOCKQUOTE>
<H5><A NAME = "4010">InverseMod(E, M) : RngOrdElt, RngIntElt -&gt; RngOrdElt</A></H5>
<H5>InverseMod(E, M) : RngOrdElt, RngOrdIdl -&gt; RngOrdElt</H5>
<H5>Modinv(E, M) : RngOrdElt, RngOrdIdl -&gt; RngOrdElt</H5>
<H5>Modinv(E, M) : RngOrdElt, RngIntElt -&gt; RngOrdElt</H5>
<BLOCKQUOTE>
An element y such that y * E = 1 mod M where M is an integral ideal
or an integer and E is an element of an order.
</BLOCKQUOTE>
<H5><A NAME = "4011">ColonIdeal(I, J) : RngOrdFracIdl, RngOrdFracIdl -&gt; RngOrdFracIdl</A></H5>
<H5>IdealQuotient(I, J) : RngOrdFracIdl, RngOrdFracIdl -&gt; RngOrdFracIdl</H5>
<BLOCKQUOTE>
In Magma, the colon ideal (or ideal quotient) [I:J]
for two fractional ideals I, J is defined as the fractional ideal
(I:J)={ x&isin;(Frac)(O) : x J &sube;I},
where O is the order to which I and J belong.
In this definition we have x&isin;(Frac)(O) rather than x&isin;O,
and so this differs from <TT>ColonIdeal</TT> for other structures,
where the result would be an ideal rather than a fractional ideal.
<P>
For ideals of a maximal order (or in general for <I>invertible</I> ideals)
the <TT>ColonIdeal</TT> is equivalent to I/J (see above),
otherwise only J(I:J)&sub;I holds. Here is an example of the latter.
<P>
<P>
<P>
<PRE>
&gt; O := EquationOrder(Polynomial([4,0,1]));
&gt; z := O.2; // z^2 = -4
&gt; I := ideal&lt;O|1&gt;; // O as an ideal
&gt; J := ideal&lt;O|[2,z]&gt;; // noninvertible ideal
&gt; ColonIdeal(I,J)*J eq I;
false
</PRE>
<P>
Currently <TT>ColonIdeal</TT> and <TT>IdealQuotient</TT> do not
exist for <TT>RngInt</TT> types, so there is a slight incompatibility
for <B>Z</B> as a number field order (see Para<A  HREF = "text174.htm#1373">Z as a Number Field Order</A>).
</BLOCKQUOTE>
<H5><A NAME = "4012">IntegralSplit(I) : RngOrdFracIdl -&gt; RngOrdIdl, RngElt</A></H5>
<BLOCKQUOTE>
Given an ideal I, return an integral ideal J and a minimal positive integer d
such that I = J/d.
</BLOCKQUOTE>
<H5><A NAME = "4013">Different(I) : RngOrdFracIdl -&gt; RngOrdFracIdl</A></H5>
<BLOCKQUOTE>
The different of the (possibly fractional) ideal I of an order of 
an algebraic number field.
</BLOCKQUOTE>
<H5><A NAME = "4014">Codifferent(I) : RngOrdFracIdl -&gt; RngOrdFracIdl</A></H5>
<BLOCKQUOTE>
The codifferent of the ideal I. This will be the inverse of the different of 
I if I is an ideal of a maximal order.
</BLOCKQUOTE>
<H4><A NAME = "4015">Roots of Ideals</A></H4>

<P>
<P>
It is possible to ask for the k-th root of an ideal where k is 
a positive integer.


<H5><A NAME = "4016">Root(I, k) : RngOrdFracIdl, RngIntElt -&gt; RngOrdFracIdl</A></H5>
<BLOCKQUOTE>
Find the kth root of the ideal I if it exists.
</BLOCKQUOTE>
<H5><A NAME = "4017">IsPower(I, k) : RngOrdFracIdl, RngIntElt -&gt; BoolElt, RngOrdFracIdl</A></H5>
<BLOCKQUOTE>
Return <TT>true</TT> if the ideal I is a kth power of an ideal and the ideal it
is a power of otherwise <TT>false</TT>.
</BLOCKQUOTE>
<H5><A NAME = "4018">SquareRoot(I) : RngOrdFracIdl -&gt; RngOrdFracIdl</A></H5>
<H5>Sqrt(I) : RngOrdFracIdl -&gt; RngOrdFracIdl</H5>
<BLOCKQUOTE>
Return the square root of the ideal I if I is square.
</BLOCKQUOTE>
<H5><A NAME = "4019">IsSquare(I) : RngOrdFracIdl -&gt; BoolElt, RngOrdFracIdl</A></H5>
<BLOCKQUOTE>
Return <TT>true</TT> if the ideal I is the square of an ideal and the ideal it is a square
of otherwise <TT>false</TT>.
</BLOCKQUOTE>
<H4><A NAME = "4020">Factorization and Primes</A></H4>

<P>
<P>
The factorization of an ideal into prime ideals and the divisors
of an ideal can be determined.


<H5><A NAME = "4021">Decomposition(O, p) : RngOrd, RngIntElt -&gt; [&lt;RngOrdIdl, RngIntElt&gt;]</A></H5>
<H5>Decomposition(O, p) : RngOrd, RngOrdIdl -&gt; [ &lt;RngOrdIdl, RngIntElt&gt; ]</H5>

<PRE>    SetVerbose("IdealDecompose", n):    Maximum: 5</PRE>
<BLOCKQUOTE>
Given an order O and a rational prime number p or a prime ideal p of 
the coefficient ring of O, return a sequence of tuples
consisting of prime ideals and exponents, according to the decomposition of
p in O.
</BLOCKQUOTE>
<H5><A NAME = "4022">DecompositionType(O, p) : RngOrd, RngIntElt -&gt; [&lt;RngIntElt, RngIntElt&gt;]</A></H5>
<H5>DecompositionType(O, p) : FldAlg, RngIntElt -&gt; [&lt;RngIntElt, RngIntElt&gt;]</H5>
<H5>DecompositionType(O, p) : FldAlg, RngOrdIdl -&gt; [&lt;RngIntElt, RngIntElt&gt;]</H5>
<H5>DecompositionType(O, p) : RngOrd, RngOrdIdl -&gt; [ &lt;RngIntElt, RngIntElt&gt; ]</H5>

<PRE>    SetVerbose("IdealDecompose", n):    Maximum: 5</PRE>
<BLOCKQUOTE>
Given an order O and a rational prime number p or a prime ideal p of 
the coefficient ring of O, return the decomposition type, ie.  a sequence of
tuples consisting of the degree of the prime ideals and their ramification
index, according to the decomposition of p in O.
</BLOCKQUOTE>
<H5><A NAME = "4023">Factorization(I) : RngOrdFracIdl -&gt; [&lt;RngOrdIdl, RngIntElt&gt;]</A></H5>
<H5>Factorisation(I) : RngOrdFracIdl -&gt; [&lt;RngOrdIdl, RngIntElt&gt;]</H5>

<PRE>    SetVerbose("IdealDecompose", n):    Maximum: 5</PRE>
<BLOCKQUOTE>
Returns the prime ideal factorization of an ideal
I in an order O, as a sequence
of 2-tuples (prime ideal and integer exponent).
</BLOCKQUOTE>
<H5><A NAME = "4024">Divisors(I) : RngOrdIdl -&gt; [&lt;RngOrdIdl, RngIntElt&gt;]</A></H5>
<BLOCKQUOTE>
Return the ideals which divide the ideal I which must be of a maximal order.
</BLOCKQUOTE>
<H5><A NAME = "4025">Support(I) : RngOrdFracIdl -&gt; RngOrdIdl</A></H5>
<BLOCKQUOTE>
For a non-zero ideal I of some maximal order,
return the set of prime ideals p dividing I.
</BLOCKQUOTE>
<H5><A NAME = "4026">Support(L) : [RngOrdFracIdl] -&gt; RngOrdIdl</A></H5>
<H5>Support(L) : [FldAlgElt] -&gt; RngOrdIdl</H5>

<PRE>    GaloisStable: BoolElt               Default: <TT>false</TT></PRE>

<PRE>    CoprimeOnly: BoolElt                Default: <TT>false</TT></PRE>

<PRE>    UseBernstein: BoolElt               Default: <TT>false</TT></PRE>
<BLOCKQUOTE>
For a sequence L of ideals in some maximal order (or of number field
elements representing principal ideals), return the set of prime ideals
dividing at least one of the ideals.
If <TT>CoprimeOnly</TT> is given, the set returned will not in general be
containing prime ideals, but will satisfy the following:
<DL COMPACT class='compact'>
<DT></DT><DD>Every ideal in L can be uniquely decomposed into a power product 
  of ideals in the set returned
<DT></DT><DD>The set is minimal and closed under gcd, ie. for two elements in the set, 
  their gcd will be one.
<P>
<P>
<P>
</DL>
If the number field is normal and if <TT>GaloisStable</TT> is given, then
the set returned will be closed under the action of the galois group.
Depending on the (unknown) factorisation pattern of the ideals, taking
the Galois action into account will in general refine the coprime
factorisation.
<P>
In general, this function will first construct a coprime basis, and the
factorise the result of this step.
<P>
If <TT>UseBernstein</TT> is given, then Dan Berstein's asymptoically fast
algorithm (<A  HREF = "text382.htm#bib_Bernstein2005">[Ber05]</A>, 
which runs in time essentially linear in #L) is used. 
</BLOCKQUOTE>
<H5><A NAME = "4027">CoprimeBasis(L) : [RngOrdFracIdl] -&gt; RngOrdIdl</A></H5>

<PRE>    GaloisStable: BoolElt               Default: <TT>false</TT></PRE>

<PRE>    UseBernstein: BoolElt               Default: <TT>false</TT></PRE>
<BLOCKQUOTE>
Given a sequence L of ideals in some maximal order, a coprime
basis C for L is constructed. That means
<DL COMPACT class='compact'>
<DT></DT><DD>- every element in L has a unique representation as a power product
  with elements in C
<DT></DT><DD>- C is closed under gcd, the ideals in C are pairwise coprime.
<P>
</DL>
If the field is normal and if <TT>GaloisStable</TT> is given, the input sequence
is supplemented by the action of the automorphism group, thus potentially
refining the coprime basis.
<P>
If <TT>UseBernstein</TT> is given then instead of the naive algorithm
with quadratic complexity in #L, an asymptotically fast, almost
linear algorithm by Dan Berstein is used, <A  HREF = "text382.htm#bib_Bernstein2005">[Ber05]</A>.
</BLOCKQUOTE>
<H5><A NAME = "4028">CoprimeBasisInsert(~L, I) : [RngOrdIdl], RngOrdFracIdl  -&gt;</A></H5>

<PRE>    GaloisStable: BoolElt               Default: <TT>false</TT></PRE>

<PRE>    UseBernstein: BoolElt               Default: <TT>false</TT></PRE>
<BLOCKQUOTE>
Given a coprime basis in the sequence L, enlarge it by the ideal 
I, ie. enlarge L in
such a way that L stays a coprime basis but allows the decomposition
of I as well.
If the ideals are in a normal field and if <TT>GaloisStable</TT> is given,
then in addition of I all its Galois conjugates are inserted as well.
Furthermore, a fractional ideal is always decomposed into the
numerator and denominator ideal, ach of which is inserted independently.
<P>
If <TT>UseBernstein</TT> is given then instead of the naive algorithm
with quadratic complexity in #L, an asymptotically fast, almost
linear algorithm by Dan Berstein is used, <A  HREF = "text382.htm#bib_Bernstein2005">[Ber05]</A>.
</BLOCKQUOTE>
<H5><A NAME = "4029">PowerProduct(B, E) : [RngOrdFracIdl], [RngIntElt] -&gt; RngOrdFracIdl</A></H5>
<BLOCKQUOTE>
Given sequences B of ideals of some maximal order and E of integers,
compute the ideal &prod;B[i]<sup>E[i]</sup>.
</BLOCKQUOTE>
<H4><A NAME = "4030">Other Ideal Operations</A></H4>

<P>
<P>
Various other functions can be applied to ideals.
In addition to those listed, the completion of an order at a prime ideal
can also be taken  (see <A  HREF = "text389.htm#RngOrd:Completion1">Completion</A> and Chapter <A  HREF = "text481.htm#5218">p-ADIC RINGS AND THEIR EXTENSIONS</A>).


<H5><A NAME = "4031">ChineseRemainderTheorem(I1, I2, e1, e2) : RngOrdIdl, RngOrdIdl, RngOrdElt, RngOrdElt -&gt; RngOrdElt</A></H5>
<H5>ChineseRemainderTheorem(X, M) : SeqEnum[RngOrdElt], SeqEnum[RngOrdIdl] -&gt; RngOrdElt</H5>
<H5>CRT(I1, I2, e1, e2) : RngOrdIdl, RngOrdIdl, RngOrdElt, RngOrdElt -&gt; RngOrdElt</H5>
<H5>CRT(X, M) : SeqEnum[RngOrdElt], SeqEnum[RngOrdIdl] -&gt; RngOrdElt</H5>
<BLOCKQUOTE>
Returns an element e of the order O such that (e<sub>1</sub> - e) is in the ideal
I<sub>1</sub>  of O and
(e<sub>2</sub> - e) is in the ideal I<sub>2</sub>.
If a sequence of elements X and a sequence of ideals M is given then the
element e will be such that (X[i] - e) is in M[i]
for all i.
</BLOCKQUOTE>
<H5><A NAME = "4032"></A><A NAME = "RngOrd:ChineseRemainderTheoremInf">CRT</A>(I1, L1, e1, L2) : RngOrdIdl, [RngIntElt], RngOrdElt, [RngIntElt] -&gt; RngOrdElt</H5>
<H5>ChineseRemainderTheorem(I1, L1, e1, L2) : RngOrdIdl, [RngIntElt], RngOrdElt, [RngIntElt] -&gt; RngOrdElt</H5>
<BLOCKQUOTE>
Returns an element e of the order O such that (e<sub>1</sub> - e) is in the ideal 
I<sub>1</sub> of O and
the signs of the conjugates listed in L1 are the same as in L2.
<P>
L1, a sorted sequence of integers 0&lt;l<sub>i</sub>&lt;= r1, is meant to be formal 
product of infinite places. The signs of the l<sub>i</sub>'th conjugate
of e will be the same as the sign of L2[i].
</BLOCKQUOTE>
<H5><A NAME = "4033">WeakApproximation(I, V) : [RngOrdIdl], [RngIntElt] -&gt; FldOrdElt</A></H5>
<BLOCKQUOTE>
Compute an element in the field of fractions of the order of the ideals in I
which has valuation V[i] at the prime ideal I[i].
</BLOCKQUOTE>
<H5><A NAME = "4034">Idempotents(I, J) : RngOrdIdl, RngOrdIdl -&gt; BoolElt, RngOrdElt, RngOrdElt</A></H5>
<BLOCKQUOTE>
For coprime integral ideals I and J return <TT>true</TT> and elements
i&isin;I and j&isin;J such that i + j=1.
</BLOCKQUOTE>
<H5><A NAME = "4035">CoprimeRepresentative(I, J) : RngOrdIdl, RngOrdIdl -&gt; FldOrdElt</A></H5>
<H5>MakeCoprime(I, J) : RngOrdIdl, RngOrdIdl -&gt; FldOrdElt</H5>
<BLOCKQUOTE>
Given two integral ideals I and J in the same maximal order, 
find an element q in the field of fractions of this order such that
qI is coprime to J.
</BLOCKQUOTE>
<H5><A NAME = "4036">ClassRepresentative(I) : RngOrdFracIdl -&gt; RngOrdFracIdl</A></H5>
<BLOCKQUOTE>
Let I be an ideal in the absolute maximal order O of the number field
K. Further, assume that the class group of O has been computed.
The class group calculation will have chosen a set of ideal class
representatives. This function returns the representative ideal for
the ideal class to which I belongs.
</BLOCKQUOTE>
<H5><A NAME = "4037">SUnitGroup(I) : RngOrdFracIdl -&gt; GrpAb, Map</A></H5>
<H5><A NAME = "RngOrd:SUnitGroup">SUnitGroup</A>(S) : [ RngOrdIdl ] -&gt; GrpAb, Map</H5>

<PRE>    Raw: BoolElt                        Default: <TT>false</TT></PRE>

<PRE>    SetVerbose("ClassGroup", n):        Maximum: 5</PRE>
<BLOCKQUOTE>
This function computes the group of S-units for the set S of prime ideals,
where S may be input as a sequence or as an ideal (in which case S is the
set of primes appearing in its factorization).
An element mu is an S-unit iff v<sub>p</sub>(mu) = 0 for all primes p not in S.
<P>
The function returns (by default) an abstract abelian group A, and a map
from A to the field.
<P>
When <TT>Raw</TT> is <TT>true</TT>, the S-units are represented as power-products
rather than as ordinary elements.  
A fixed sequence L of field elements is given, and each unit is specified
as a vector of integers e (of the same length as L) such that the unit
equals &prod;L<sub>i</sub><sup>e<sub>i</sub></sup>.
Three values are returned in the <TT>Raw</TT> case: an abstract abelian group A,
a map from A to exponent vectors, and the sequence L.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "4038">Example <TT>RngOrd_S-Units (H38E29)</TT></A></H3>
First we compute the 3-units of Q(&#8730;10).
<P>
<P>
<PRE>
&gt; K := QuadraticField(10);
&gt; M := MaximalOrder(K);
&gt; U, mU := SUnitGroup(3*M);
&gt; U;
Abelian Group isomorphic to Z/2 + Z + Z + Z
Defined on 4 generators
Relations:
    2*U.1 = 0
&gt; mU;
Mapping from: GrpAb: U to Field of Fractions of M
&gt; u := mU(U.3); u;
7/1*M.1 - 2/1*M.2
&gt; Decomposition(u);
[
  &lt;Prime Ideal of M
    Two element generators:
      3
      $.2 + 1, 2&gt;
]
</PRE>
So u is indeed a 3 unit, as the factorization contains only prime
ideals over 3. Next we do the same computation but using the <TT>Raw</TT> option:
<P>
<P>
<PRE>
&gt; U, mU, base := SUnitGroup(3*M:Raw);
&gt; mU;
Mapping from: GrpAb: U to Full RSpace of degree 14 over Integer Ring
&gt; mU(U.3);
( 0  2  1  0  0  0  0  0  0  0 -2)
&gt; PowerProduct(base, $1);
7/1*M.1 - 2/1*M.2
&gt; base[2]^2 * base[3]^1 * base[11]^-2;
7/1*M.1 - 2/1*M.2
</PRE>
This representation is of particular importance for large degree fields or
fields with large units. To illustrate this, consider the following field
from the pari-mailing list:
<P>
<P>
<PRE>
&gt; K := NumberField(Polynomial([ 13824, -3894, -1723, 5, 1291, 1 ]));
&gt; L := LLL(MaximalOrder(K));
&gt; C, mC := ClassGroup(L : Proof:="GRH");
&gt; U, mU, base := SUnitGroup(1*L:Raw);
&gt; logs := Matrix([Logs(x) : x in Eltseq(base)]);
&gt; mU(U.3)*logs;
(2815256.998090806477937318458440358713392011019115562
    -636746.05251910981832558348350489744160309616673457
    -770882.44652629342064307574571528191509290934280166)
</PRE>
As the logarithm of the absolute value of the real embeddings is of the order
10<sup>6</sup>, we expect that a basis representation will have
coefficients requiring roughly 10<sup>6</sup> digits. While it is
feasible to compute them (using <TT>PowerProduct</TT>), this will take
a long time.
<HR>
<H5><A NAME = "4039">SUnitAction(SU, Act, S) : Map, Map, SeqEnum[RngOrdIdl] -&gt; Map</A></H5>

<PRE>    Base: SeqEnum[RngOrdElt]            Default: []</PRE>
<BLOCKQUOTE>
Given a description of the S-unit group as computed by <A  HREF = "text394.htm#RngOrd:SUnitGroup">SUnitGroup</A>
and a (multiplicative) map of the underlying number field, this function
computes the induced map on the abstract abelian group.
<P>
The argument S should be a sequence of ideals as in <TT>SUnitGroup</TT>.
The argument SU should either be the map returned by 
<A  HREF = "text394.htm#RngOrd:SUnitGroup">SUnitGroup</A><TT>(S)</TT> as
second return value - in which
case <TT>Base</TT> is trivial (and not specified) or the
second return value of <A  HREF = "text394.htm#RngOrd:SUnitGroup">SUnitGroup</A><TT>(S:Raw)</TT> in which case 
<TT>Base</TT> should equal the third computed value.
<P>
The argument Act must be any (multiplicative) function of the underlying
number field or any order, that acts on the S-unit group.
<P>
On return, a endomorphism of the domain of SU is obtained.
</BLOCKQUOTE>
<H5><A NAME = "4040">SUnitAction(SU, Act, S) : Map, SeqEnum[Map], SeqEnum[RngOrdIdl] -&gt; [Map]</A></H5>

<PRE>    Base: SeqEnum[RngOrdElt]            Default: []</PRE>
<BLOCKQUOTE>
Given a description of the S-unit group as computed by <TT>SUnitGroup</TT>
and a sequence of (multiplicative) maps of the underlying number field, 
this function computes the induced maps on the abstract abelian group.
<P>
The argument S should be a sequence of ideals as in <TT>SUnitGroup</TT>.
The argument SU should either be the map returned by <TT>SUnitGroup(S)</TT> as
second return value - in which
case <TT>Base</TT> is trivial (and not specified) or the
second return value of <TT>SUnitGroup(S:Raw)</TT> in which case <TT>Base</TT>
should equal the third computed value.
<P>
The argument Act must be a sequence of (multiplicative) functions of
the underlying number field or any order, that acts on the S-unit group.
<P>
On return, a sequence of endomorphisms of the domain of SU is obtained.
</BLOCKQUOTE>
<H5><A NAME = "4041">SUnitDiscLog(SU, x, S) : Map, FldAlgElt, SeqEnum[RngOrdIdl] -&gt; GrpAbElt</A></H5>
<H5>SUnitDiscLog(SU, L, S) : Map, SeqEnum[FldAlgElt], SeqEnum[RngOrdIdl] -&gt; GrpAbElt</H5>

<PRE>    Base: SeqEnum[RngOrdElt]            Default: []</PRE>
<BLOCKQUOTE>
Given a description of the S-unit group as computed by <TT>SUnitGroup</TT>
and a (multiplicative) map of the underlying number field, this function
computes the induced map on the abstract abelian group.
<P>
The argument S should be a sequence of ideals as in <TT>SUnitGroup</TT>.
The argument SU should either be the map returned by <TT>SUnitGroup(S)</TT> as
second return value - in which
case <TT>Base</TT> is trivial (and not specified) or the
second return value of <TT>SUnitGroup(S:Raw)</TT> in which case <TT>Base</TT>
should equal the third computed value.
<P>
This function solves the discrete logarithm problem for the S-unit group and
the algebraic number x. That is, an element in the abstract abelian
group representing the S-unit group is computed which corresponds to x.
If a list of algebraic numbers L is passed into this function, the discrete logarithm
is computed for each of them.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "4042">Example <TT>RngOrd_S-Units, advanced (H38E30)</TT></A></H3>
<P>
<P>
<PRE>
&gt; M := MaximalOrder(Polynomial([ 25, 0, -30, 0, 1 ]));
&gt; S := [ x[1] : x in Factorisation(30*M)];
&gt; U, mU := SUnitGroup(S);
&gt; L := Automorphisms(NumberField(M));
&gt; s2 := SUnitAction(mU, L[2], S);
&gt; s2;
Mapping from: GrpAb: U to GrpAb: U
&gt; L[2](mU(U.2)) eq mU(s2(U.2));
</PRE>
Now the same in <TT>Raw</TT> representation:
<P>
<P>
<PRE>
&gt; R, mR, Base := SUnitGroup(S:Raw);
&gt; S2 := SUnitAction(mR, L[2], S:Base := Base);
&gt; [S2(R.i) : i in [1..Ngens(R)]];
[
    R.1,
    R.1 - R.2,
    R.3,
    R.1 + R.3 - R.4,
    R.1 + R.5,
    R.1 + R.3 + R.7,
    R.1 - R.3 + R.6,
    R.8
]
</PRE>
If we combine <TT>SUnitAction</TT> with <TT>SUnitDiscLog</TT> we
can solve norm equations:
<P>
<P>
<PRE>
&gt; N := map&lt;M -&gt; M | x:-&gt; L[1](x) * L[2](x)&gt;;
&gt; NR := SUnitAction(mR, N, S:Base := Base);
</PRE>
Now <TT>NR</TT> is the norm function with respect to the field fixed
by <TT>L[2]</TT>.
<P>
<P>
<PRE>
&gt; SUnitDiscLog(mR, FieldOfFractions(M)!5, S:Base := Base);
2*R.5
&gt; $1 in Image(NR);
true
&gt; $2 @@ NR;
R.2 + R.5
&gt; PowerProduct(Base, mR($1));
-3/1*M.1 - 2/1*M.2 + M.4
&gt; N($1);
[5, 0, 0, 0]
</PRE>
<HR>
<H4><A NAME = "4043">Quotient Rings</A></H4>

<P>
<P>
Quotients of orders defined over maximal orders and their integral ideals
can be formed resulting in an object with type <TT>RngOrdRes</TT>. Elements 
of such orders can be created and elementary arithmetic and predicates 
may be applied to them.


<H5><A NAME = "4044">Operations on Quotient Rings</A></H5>

<P>
<P>
The creation of quotient rings and the functions which may be applied to them
are described.


<H5><A NAME = "4045">quo&lt; O | I &gt; : RngOrd, RngOrdIdl -&gt; RngOrdRes</A></H5>
<H5>quo&lt; O | M &gt; : RngOrd, ModDed -&gt; RngOrdRes</H5>
<H5>quo&lt; O | M &gt; : RngOrd, AlgMatElt -&gt; RngOrdRes</H5>
<H5>quo&lt; O | S &gt; : RngOrd, RngElt, ..., RngElt -&gt; RngOrdRes</H5>
<BLOCKQUOTE>
Creates the quotient ring Q=O/I of the order O. The right hand side of the constructor 
may contain an ideal or anything that the ideal constructor can create
an ideal from.
</BLOCKQUOTE>
<H5><A NAME = "4046">UnitGroup(OQ) : RngOrdRes -&gt; GrpAb, Map</A></H5>
<H5>MultiplicativeGroup(OQ) : RngOrdRes -&gt; GrpAb, Map</H5>
<BLOCKQUOTE>
Returns an abelian group and the map from the group into OQ,
a quotient of an absolute maximal order.
</BLOCKQUOTE>
<H5><A NAME = "4047">Modulus(OQ) : RngOrdRes -&gt; RngOrdIdl</A></H5>
<BLOCKQUOTE>
Return the denominator of the quotient ring OQ, i.e. I where OQ = O/I.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "4048">Example <TT>RngOrd_quotient (H38E31)</TT></A></H3>
Creation of quotient rings in shown. The orders are the same as for the ideal
examples, however an integral ideal is now required.
<P>
<P>
<PRE>
&gt; I := Denominator(I)*I;
&gt; I;
Principal Ideal of O
Generator:
    38/1*M.4*O.3
&gt; Basis(I);
[
    38/1*M.4*O.3,
    19/1*M.4*O.1,
    38/1*M.4*O.2
]
&gt; Q := quo&lt;Order(I) | I&gt;;
&gt; Q;
Quotient Ring of Principal Ideal of O
Generator:
    [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 38, 0]]
&gt; Modulus(Q);
Principal Ideal of O
Generator:
    [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 38, 0]]
</PRE>
<HR>
<H5><A NAME = "4049">Elements of Quotients</A></H5>

<P>
<P>
Functions for elements of the quotient rings are predominantly arithmetic.
Elements of quotient rings can be looped through using 
<TT>for x in OQ do ... end for</TT>.


<H5>a * b : RngOrdResElt, RngOrdResElt -&gt; RngOrdResElt</H5>

<H5>a + b : RngOrdResElt, RngOrdResElt -&gt; RngOrdResElt</H5>

<H5>a - b : RngOrdResElt, RngOrdResElt -&gt; RngOrdResElt</H5>

<H5>a / b : RngOrdResElt, RngOrdResElt -&gt; RngOrdResElt</H5>

<H5>- a : RngOrdResElt -&gt; RngOrdResElt</H5>

<H5>a ^ n : RngOrdResElt, RngIntElt -&gt; RngOrdResElt</H5>



<H5>a eq b : RngOrdResElt, RngOrdResElt -&gt; BoolElt</H5>

<H5>a ne b : RngOrdResElt, RngOrdResElt -&gt; BoolElt</H5>



<H5>a div b : RngOrdResElt, RngOrdResElt -&gt; RngOrdResElt</H5>

<H5>a mod b : RngOrdResElt, RngOrdResElt -&gt; RngOrdResElt</H5>

<H5>Quotrem(a, b) : RngOrdResElt, RngOrdResElt -&gt; RngOrdResElt, RngOrdResElt</H5>



<H5>Lcm(a, b) : RngOrdResElt, RngOrdResElt -&gt; RngOrdResElt </H5>

<H5>Gcd(a, b) : RngOrdResElt, RngOrdResElt -&gt; RngOrdResElt</H5>

<H5>XGcd(a, b) : RngOrdResElt, RngOrdResElt -&gt; RngOrdResElt, RngOrdResElt, RngOrdResElt</H5>
<P>


<H5><A NAME = "4050">OQ ! a : RngOrdRes, Elt -&gt; RngOrdResElt</A></H5>
<BLOCKQUOTE>
Coerce the element a into the quotient OQ where a is anything
that can be coerced into the order OQ is a quotient of.
</BLOCKQUOTE>
<H5><A NAME = "4051">Random(OQ) : RngOrdRes -&gt; RngOrdResElt</A></H5>
<BLOCKQUOTE>
A random element of the quotient ring OQ.
</BLOCKQUOTE>
<H5><A NAME = "4052">a mod I : RngOrdElt, RngOrdIdl -&gt; RngOrdElt</A></H5>
<BLOCKQUOTE>
A canonical representative of the element 
a (belonging to an order O) in the quotient ring
O/I.
</BLOCKQUOTE>
<H5><A NAME = "4053">IsZero(a) : RngOrdResElt -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if and only if the quotient ring element
a is the zero element of the quotient ring OQ.
</BLOCKQUOTE>
<H5><A NAME = "4054">IsOne(a) : RngOrdResElt -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if and only if the quotient ring element
a is the one element of the quotient ring OQ.
</BLOCKQUOTE>
<H5><A NAME = "4055">IsMinusOne(a) : RngOrdResElt -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if and only if the quotient ring element
a is the minus one element of the quotient ring OQ.
</BLOCKQUOTE>
<H5><A NAME = "4056">IsUnit(a) : RngOrdResElt -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if and only if the quotient ring element
a has an inverse in the quotient ring OQ.
</BLOCKQUOTE>
<H5><A NAME = "4057">Eltseq(a) : RngOrdResElt -&gt; []</A></H5>
<H5>ElementToSequence(a) : RngOrdResElt -&gt; []</H5>
<BLOCKQUOTE>
The coefficients of the quotient ring element
a in the field of fractions of the coefficient 
ring of the order of the quotient ring containing a. 
</BLOCKQUOTE>
<H5><A NAME = "4058">EuclideanNorm(a) : RngOrdResElt -&gt; RngIntElt</A></H5>
<BLOCKQUOTE>
Return the Euclidean norm of the element a of a quotient ring OQ, 
where the Euclidean norm is the function that makes OQ into a Euclidean ring.
</BLOCKQUOTE>
<H5><A NAME = "4059">Annihilator(a) : RngOrdResElt -&gt; RngOrdResElt</A></H5>
<BLOCKQUOTE>
The annihilator of the element a in the quotient ring OQ.
</BLOCKQUOTE>
<H5><A NAME = "4060">Reconstruction</A></H5>

<P>
<P>
<P>
Given an element e in some order O, known modulo some
ideal I, a common problem in several algorithms is to
recover e, ie. a unique minimal element f&isin;O such that
e - f&isin;I and f is as "small" as possible. An equally
common variation would be to ask for some field element f/d with
d an integer, such that f - de &isin;I and f as well as d are small.
<P>
In the case of O being the ring of integers and I a power of
a prime (ideal), this is usually done by moving to the
symmetric residue system in the first case and by rational
reconstruction in the second. Here, we use techniques based on the
LLL algorithm as described in <A  HREF = "text382.htm#bib_FiFi2000">[FF00]</A>.
<P>
Since the method is more complicated than in the case of the integer
ring, one first has to create a "reconstruction environment" 
of type <A NAME = "RngOrdRecoEnv"><TT>RngOrdRecoEnv</TT></A>, which is subsequently used to
reconstruct any number of elements.


<H5><A NAME = "4061">ReconstructionEnvironment(p, k) : RngOrdIdl, RngIntElt -&gt; RngOrdRecoEnv</A></H5>
<H5>ReconstructionEnvironment(p, k) : RngIntElt, RngIntElt -&gt; RngOrdRecoEnv</H5>
<BLOCKQUOTE>
Given a (prime) ideal p and an exponent k, initialize the
reconstruction process for the ideal I=p<sup>k</sup>, that is, the 
object returned can be used to reconstruct elements from
"approximations" modulo p<sup>k</sup>.
</BLOCKQUOTE>
<H5><A NAME = "4062">Reconstruct(x, R) : RngOrdElt, RngOrdRecoEnv -&gt; RngOrdElt</A></H5>
<H5>Reconstruct(x, R) : RngIntElt, RngOrdRecoEnv -&gt; RngIntElt</H5>

<PRE>    UseDenominator: BoolElt             Default: <TT>false</TT></PRE>
<BLOCKQUOTE>
Given an order element e, thought to be an approximation modulo
p<sup>k</sup> where p and k are stored in the reconstruction environment R,
return the unique minimal f in the same order such that e - g&isin;p<sup>k</sup>.
Is <TT>UseDenominator</TT> is <TT>true</TT>, then a field element is computed, otherwise
a ring element will be found.
</BLOCKQUOTE>
<H5><A NAME = "4063">ChangePrecision(~ R, k) : RngOrdRecoEnv, RngIntElt -&gt;</A></H5>
<BLOCKQUOTE>
Change the ideal I=p<sup>l</sup> stored in R to p<sup>k</sup>.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "4064">Example <TT>RngOrd_order-reco (H38E32)</TT></A></H3>
We illustrate the use of the reconstruction environment to find roots
of some polynomial over a number field.
We will first compute the roots over some completion, up to some 
precision, then "list" the elements back from the completion into the 
starting order and finally use reconstruction to get the roots.
<P>
<P>
<PRE>
&gt; f := Polynomial([1,1,1,1,1]);
&gt; M := MaximalOrder(f);
&gt; P := Decomposition(M, 11)[1][1]; P;
Prime Ideal of M
Two element generators:
    [11, 0, 0, 0]
    [2, 1, 0, 0]
&gt; C, mC := Completion(M, P:Precision :=  10);    
&gt; fC := Polynomial([c@ mC : c in Eltseq(f)]);
&gt; rt := Roots(fC); rt;
&gt; R := ReconstructionEnvironment(P, 10);
&gt; [Reconstruct((x[1]) @@ mC, R) : x in rt];
[
    M.4,
    M.3,
    -M.1 - M.2 - M.3 - M.4,
    M.2
]
&gt; [ Evaluate(f, x) : x in $1];
[
    0,
    0,
    0,
    0
 ]
</PRE>
<HR>
<PRE></PRE> <A  HREF = "text395.htm">[Next]</A><A  HREF = "text393.htm">[Prev]</A> <A  HREF = "text395.htm">[Right]</A> <A  HREF = "text393.htm">[Left]</A> <A  HREF = "text383.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<br><small>Version: V2.22 of <I>
Thu Jun  9 16:37:49 EST 2016
</I></small>
</body></html>