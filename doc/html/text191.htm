<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <link rel='stylesheet' href='help.css' type='text/css'>
  <TITLE>Structure Operations</TITLE>
</head>
<body BGCOLOR="#FFFFFF">

 <A  HREF = "text192.htm">[Next]</A><A  HREF = "text190.htm">[Prev]</A> <A  HREF = "text192.htm">[Right]</A> <A  HREF = "text190.htm">[Left]</A> <A  HREF = "text188.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<PRE></PRE><H3><A NAME = "1610">Structure Operations</A></H3>




<H5>Subsections</H5>
<UL>
<LI> <A  HREF = "text191.htm#1611">Related Structures</A>
<LI> <A  HREF = "text191.htm#1622">Numerical Invariants</A>
<LI> <A  HREF = "text191.htm#1625">Defining Polynomial</A>
<LI> <A  HREF = "text191.htm#1628">Ring Predicates and Booleans</A>
<LI> <A  HREF = "text191.htm#1631">Roots</A>
</UL>
<H4><A NAME = "1611">Related Structures</A></H4>



<H5>Category(F) : FldFin -&gt; Cat</H5>

<H5>Parent(F) : FldFin -&gt; PowerStructure</H5>

<H5>Centre(F) : FldFin -&gt; FldFin</H5><P>

<H5>PrimeRing(F) : FldFin -&gt; FldFin</H5>

<H5>PrimeField(F) : FldFin -&gt; FldFin</H5><P>

<H5>FieldOfFractions(F) : FldFin -&gt; FldFin</H5><P>



<H5><A NAME = "1612">AdditiveGroup(F) : FldFin -&gt; GrpAb, Map</A></H5>
<BLOCKQUOTE>
Given F=GF(q), create the finite additive abelian group A of order 
q=p<sup>r</sup> that is the direct sum of r copies of the cyclic group of order p,
together with the corresponding isomorphism from the group A to the field F.
</BLOCKQUOTE>
<H5><A NAME = "1613">MultiplicativeGroup(F) : FldFin -&gt; GrpAb, Map</A></H5>
<H5>UnitGroup(F) : FldFin -&gt; GrpAb, Map</H5>
<BLOCKQUOTE>
Given F=GF(q), create the multiplicative group of R as an abelian group.
This returns the (additive) cyclic group A of order q - 1, together
with a map from A to F - 0,
sending 1 to a primitive element of F.
</BLOCKQUOTE>
<H5><A NAME = "1614">Set(F) : FldFin -&gt; SetEnum</A></H5>
<BLOCKQUOTE>
Create the enumerated set consisting of the elements of finite field F.
</BLOCKQUOTE>
<H5><A NAME = "1615">VectorSpace(F, E) : FldFin, FldFin -&gt; ModTupFld, Map</A></H5>
<BLOCKQUOTE>
Given a finite field F that is an extension of degree n of E,
define the natural isomorphism
between F  and the n-dimensional vector 
space E<sup>n</sup>.
The function returns two values:
<DL COMPACT class='compact'>
<DT>(a)</DT><DD>A vector space V isomorphic to E<sup>n</sup>;
<DT>(b)</DT><DD>The isomorphism &phi; : F -&gt; V.
<P>
<P>
</DL>
The basis of V is chosen to correspond with the power
basis &alpha;<sup>0</sup>, &alpha;<sup>1</sup>, ..., &alpha;<sup>n - 1</sup> of F, 
where &alpha; is the generator returned by <TT>Generator(F, E)</TT>,
so that V=E.1 x E.&alpha; x ... x E.&alpha;<sup>n - 1</sup>
and &phi; : &alpha;<sup>i</sup> -&gt; e<sub>i + 1</sub>, (for i = 0, ..., n - 1),
where e<sub>i</sub> is the basis vector of V having all 
components zero, except the i-th, which is one.
</BLOCKQUOTE>
<H5><A NAME = "1616">VectorSpace(F, E, B) : FldFin, FldFin, [ FldFinElt ] -&gt; ModTupFld, Map</A></H5>
<BLOCKQUOTE>
Given a finite field F that is an extension of degree n of E,
define the isomorphism between F and the n-dimensional vector space
E<sup>n</sup> defined by the basis B for F over E.
The function returns two values:
<DL COMPACT class='compact'>
<DT>(a)</DT><DD>A vector space V isomorphic to E<sup>n</sup>;
<DT>(b)</DT><DD>The isomorphism &phi; : F -&gt; V.
<P>
<P>
</DL>
The basis of V is chosen to correspond with the basis B=&beta;<sub>1</sub>, &beta;<sub>2</sub>, ..., &beta;<sub>n</sub> of F over E, as specified by the user,
so that 
V=E.&beta;<sub>1</sub> x E.&beta;<sub>2</sub> x ... x E.&beta;<sub>n</sub>.
&phi; : &beta;<sub>i</sub> -&gt; e<sub>i</sub>, (for i = 1, ..., n),
where e<sub>i</sub> is the basis vector of V having all 
components zero, except the i-th, which is one.
</BLOCKQUOTE>
<H5><A NAME = "1617">MatrixAlgebra(F, E) : FldFin, FldFin -&gt; AlgMat, Map</A></H5>
<BLOCKQUOTE>
Let F be a finite field that is an extension of degree n of E.
The function returns two values:
<DL COMPACT class='compact'>
<DT>(a)</DT><DD>A matrix algebra A of degree n, such that A is isomorphic to F;
<DT>(b)</DT><DD>An isomorphism &phi; : F -&gt; A.
<P>
<P>
</DL>
The matrix algebra A will be the subalgebra of the full algebra
of n x n matrices over E generated by the companion
matrix C of the defining polynomial of F over E.  The generator
<TT>Generator(F, E)</TT> of F over E is thus mapped to C.
</BLOCKQUOTE>
<H5><A NAME = "1618">MatrixAlgebra(A, E) : AlgMat, FldFin -&gt; AlgMat, Map</A></H5>
<BLOCKQUOTE>
Let F be a finite field. Let A be a matrix algebra over F, 
and E be a subfield of F.
The function returns two values:
<DL COMPACT class='compact'>
<DT>(a)</DT><DD>A matrix algebra N over E isomorphic to A, obtained from A 
by expanding each component of an element of A into the block matrix associated with it;
<DT>(b)</DT><DD>An E-isomorphism &phi; : A -&gt; N.
<P>
<P>
</DL>
The matrix algebra N is A considered as an E-matrix algebra.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "1619">Example <TT>FldFin_VectorSpace (H21E2)</TT></A></H3>
Given the field F of 7<sup>4</sup> elements defined as an extension of the
field F49 of 7<sup>2</sup> elements as above, we can construct two vector spaces,
one of dimension 2, and the other of dimension 4:
<P>
<P>
<PRE>
&gt; F7 := FiniteField(7);
&gt; F49&lt;w&gt; := ext&lt; F7 | 2 &gt;;
&gt; F&lt;z&gt; := ext&lt; F49 | 2 &gt;;
&gt; v2, i2 := VectorSpace(F, F49);
&gt; v2;
Full Vector space of degree 2 over GF(7^2)
&gt; i2(z^12);
(   w w^28)
&gt; v4, i4 := VectorSpace(F, PrimeField(F));
&gt; v4;
Full Vector space of degree 4 over GF(7)
&gt; i4(z^12);
(5 3 6 4)
</PRE>
<HR>
<H5><A NAME = "1620">GaloisGroup(K, k) : FldFin, FldFin -&gt; GrpPerm, [FldFinElt]</A></H5>
<BLOCKQUOTE>
Compute the Galois group (which is of course cyclic)
of K/k as a permutation group. The group is returned as well as the
roots of the defining polynomial of K/k in a compatible ordering.
</BLOCKQUOTE>
<H5><A NAME = "1621">AutomorphismGroup(K, k) : FldFin, FldFin -&gt; GrpPerm, [Map], Map</A></H5>
<BLOCKQUOTE>
Computes the (cyclic) group of k-automorphisms of K. The
group is returned as well as a sequence of all automorphisms and
a map sending an element of the abstract automorphism group to
an explicit automorphism.
</BLOCKQUOTE>
<H4><A NAME = "1622">Numerical Invariants</A></H4>



<H5>Characteristic(F) : FldFin -&gt; RngIntElt</H5>

<H5># F : FldFin -&gt; FldFinElt</H5><P>



<H5><A NAME = "1623">Degree(F) : FldFin -&gt; RngIntElt</A></H5>
<BLOCKQUOTE>
The absolute degree of F, that is, the degree over its
prime subfield.
</BLOCKQUOTE>
<H5><A NAME = "1624">Degree(F, E) : FldFin, FldFin -&gt; RngIntElt</A></H5>
<BLOCKQUOTE>
Given a finite field F that has been constructed as an
extension of a field E, return the degree of F over 
E.
</BLOCKQUOTE>
<H4><A NAME = "1625">Defining Polynomial</A></H4>



<H5><A NAME = "1626">DefiningPolynomial(F) : FldFin -&gt; RngUPolElt</A></H5>
<BLOCKQUOTE>
Given a finite field F that has been constructed as an
extension of a field E, return the polynomial with coefficients
in E that was used to define F as an extension of E.
This is the minimum polynomial of <TT>F.1</TT>.
</BLOCKQUOTE>
<H5><A NAME = "1627">DefiningPolynomial(F, E) : FldFin -&gt; RngUPolElt</A></H5>
<BLOCKQUOTE>
Given a finite field F and a subfield E,
return the polynomial with coefficients
in E used to define F as an extension of E.
This is the same as the minimum polynomial of the generator
<TT>Generator(F, E)</TT> over E.
</BLOCKQUOTE>
<H4><A NAME = "1628">Ring Predicates and Booleans</A></H4>



<H5>IsCommutative(F) : FldFin -&gt; BoolElt</H5>

<H5>IsUnitary(F) : FldFin -&gt; BoolElt</H5><P>

<H5>IsFinite(F) : FldFin -&gt; BoolElt</H5>

<H5>IsOrdered(F) : FldFin -&gt; BoolElt</H5><P>

<H5>IsField(F) : FldFin -&gt; BoolElt</H5>

<H5>IsEuclideanDomain(F) : FldFin -&gt; BoolElt</H5><P>

<H5>IsPID(F) : FldFin -&gt; BoolElt</H5>

<H5>IsUFD(F) : FldFin -&gt; BoolElt</H5><P>

<H5>IsDivisionRing(F) : FldFin -&gt; BoolElt</H5>

<H5>IsEuclideanRing(F) : FldFin -&gt; BoolElt</H5><P>

<H5>IsPrincipalIdealRing(F) : FldFin -&gt; BoolElt</H5>

<H5>IsDomain(F) : FldFin -&gt; BoolElt</H5><P>

<H5>F eq G : FldFin, Rng -&gt; BoolElt</H5>

<H5>F ne G : FldFin, Rng -&gt; BoolElt</H5><P>


<H5><A NAME = "1629">IsConway(F) : FldFin -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Given a finite field F, this function returns <TT>true</TT> iff F is
defined over its prime field using a Conway polynomial.
</BLOCKQUOTE>
<H5><A NAME = "1630">IsDefault(F) : FldFin -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Given a finite field F, this function returns <TT>true</TT> iff F is
a default field.
</BLOCKQUOTE>
<H4><A NAME = "1631">Roots</A></H4>



<H5><A NAME = "1632">Roots(f) : RngUPolElt -&gt; [ &lt; FldFinElt, RngIntElt&gt; ]</A></H5>
<BLOCKQUOTE>
Given a polynomial f over a finite field F, this function finds all roots
of f in F, and returns a sorted sequence of tuples (pairs),
each consisting of a root of f in F and its multiplicity.
</BLOCKQUOTE>
<H5><A NAME = "1633">RootsInSplittingField(f) : RngUPolElt[FldFin] -&gt; [&lt;RngUPolElt, RngIntElt&gt;], FldFin</A></H5>
<BLOCKQUOTE>
Given a univariate polynomial f over a finite field K, compute the 
minimal splitting field S of f as an extension field of K, and return the 
roots of f in S, together with S.  Using this function will be
faster than computing the roots of f anew over the splitting field.
</BLOCKQUOTE>
<H5><A NAME = "1634">FactorizationOverSplittingField(f) : RngUPolElt[FldFin] -&gt; [&lt;RngUPolElt, RngIntElt&gt;], FldFin</A></H5>
<H5>FactorisationOverSplittingField(f) : RngUPolElt[FldFin] -&gt; [&lt;RngUPolElt, RngIntElt&gt;], FldFin</H5>
<BLOCKQUOTE>
Given a univariate polynomial f over a finite field K, compute the 
minimal splitting field S of f as an extension field of K, and return the 
factorization (into linears) of f over S, together with S.  Using
this function will be faster than factorizing f anew over the splitting
field.
</BLOCKQUOTE>
<H5><A NAME = "1635">RootOfUnity(n, K) : RngIntElt, FldFin -&gt; FldFinElt</A></H5>
<BLOCKQUOTE>
Return a primitive n-th root of unity in the smallest possible extension
field of K.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "1636">Example <TT>FldFin_Functions (H21E3)</TT></A></H3>
We compute the roots of a certain degree-20 polynomial f in
its minimal splitting field.
<P>
<P>
<PRE>
&gt; K := GF(2);
&gt; P&lt;x&gt; := PolynomialRing(GF(2));
&gt; f := x^20 + x^11 + 1;
&gt; Factorization(f);
[
    &lt;x^3 + x^2 + 1, 1&gt;,
    &lt;x^8 + x^7 + x^3 + x^2 + 1, 1&gt;,
    &lt;x^9 + x^7 + x^6 + x^4 + 1, 1&gt;
]
&gt; time r, S&lt;w&gt; := RootsInSplittingField(f);
Time: 0.040
</PRE>
We note that the splitting field S has degree 72 and there are 20 roots
of f in S of course.  We check that the evaluation of f at each root
is zero.
<P>
<P>
<PRE>
&gt; S;
Finite field of size 2^72
&gt; DefiningPolynomial(S);
x^72 + x^48 + x^47 + x^44 + x^38 + x^35 + x^32 + x^31 + x^30 +
    x^29 + x^27 + x^25 + x^23 + x^22 + x^21 + x^18 + x^15 +
    x^12 + x^8 + x^4 + 1
&gt; #r;
20
&gt; r[1];
&lt;w^68 + w^67 + w^64 + w^62 + w^60 + w^59 + w^56 + w^50 + w^49 + 
    w^48 + w^47 + w^44 + w^43 + w^39 + w^37 + w^35 + w^33 + w^32 
    + w^30 + w^29 + w^28 + w^25 + w^21 + w^19 + w^18 + w^16 + 
    w^15 + w^14 + w^12 + w^10 + w^6 + w, 1&gt;
&gt; [IsZero(Evaluate(f, t[1])): t in r];
[ true, true, true, true, true, true, true, true, true, true, true, true,
true, true, true, true, true, true, true, true ]
</PRE>
<HR>
<PRE></PRE> <A  HREF = "text192.htm">[Next]</A><A  HREF = "text190.htm">[Prev]</A> <A  HREF = "text192.htm">[Right]</A> <A  HREF = "text190.htm">[Left]</A> <A  HREF = "text188.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<br><small>Version: V2.22 of <I>
Thu Jun  9 16:37:49 EST 2016
</I></small>
</body></html>