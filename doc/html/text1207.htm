<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <link rel='stylesheet' href='help.css' type='text/css'>
  <TITLE>Gr&ouml;bner Bases</TITLE>
</head>
<body BGCOLOR="#FFFFFF">

 <A  HREF = "text1208.htm">[Next]</A><A  HREF = "text1206.htm">[Prev]</A> <A  HREF = "text1208.htm">[Right]</A> <A  HREF = "text1206.htm">[Left]</A> <A  HREF = "text1203.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<PRE></PRE><H3><A NAME = "13477">Gr&ouml;bner Bases</A></H3>

<P>
<P>
Computation in ideals of multivariate polynomial rings is possible because
of the construction of Gr&ouml;bner bases of such ideals.
In Magma, it is possible to create ideals and compute
their Gr&ouml;bner bases for polynomial rings defined not only over fields
but also over general Euclidean rings.
<P>
Different monomial orderings give different Gr&ouml;bner bases for a fixed
ideal.  When an ideal I is created from a polynomial ring P or
another ideal J, then the monomial order of I is taken to be the
monomial order of P or J.  Ideals can only be compatible if they
have the same monomial order.



<H5>Subsections</H5>
<UL>
<LI> <A  HREF = "text1207.htm#13478">Gr&ouml;bner Bases over Fields</A>
<LI> <A  HREF = "text1207.htm#13479">Gr&ouml;bner Bases over Euclidean  Rings</A>
<LI> <A  HREF = "text1207.htm#13480">Construction of Gr&ouml;bner Bases</A>
<LI> <A  HREF = "text1207.htm#13486">The Dense Variant of the F<sub>4</sub> algorithm</A>
<LI> <A  HREF = "text1207.htm#13487">Related Functions</A>
<LI> <A  HREF = "text1207.htm#13501">Gr&ouml;bner Bases of Boolean Polynomial Rings</A>
<LI> <A  HREF = "text1207.htm#13505">Verbosity</A>
<LI> <A  HREF = "text1207.htm#13519">Degree-d Gr&ouml;bner Bases</A>
</UL>
<H4><A NAME = "13478">Gr&ouml;bner Bases over Fields</A></H4>

<P>
<P>
Gr&ouml;bner bases of ideals defined over fields have been studied for
some time now, and there is a large literature concerning them.
<P>
For ideals defined over fields,
a basis is called <I>minimal</I> if each polynomial in it is monic
and not contained in the ideal generated by all the other polynomials
<A  HREF = "text1202.htm#bib_CLO">[CLO96, Chap. 2, Para 7, Def. 4]</A>.
A basis is called <I>reduced</I> if each polynomial in it is monic
and, for every
monomial of each polynomial in the basis,
that monomial is not divisible by the leading monomial of any other
polynomial in the basis (equivalently, each leading monomial does not
divide any monomial in any of the other polynomials)
<A  HREF = "text1202.htm#bib_CLO">[CLO96, Chap. 2, Para 7, Def. 5]</A>.
<P>
For a given fixed monomial ordering,
every ideal of a polynomial ring over a field possesses a <B>unique</B>
sorted minimal reduced Gr&ouml;bner basis (GB)
<A  HREF = "text1202.htm#bib_CLO">[CLO96, Chap. 2, Para 7, Prop. 7]</A>.
This unique Gr&ouml;bner basis (with respect to the order defined by the user)
will be computed automatically when needed by Magma.
Before this happens, an ideal will usually possess a basis which is
not a Gr&ouml;bner basis, but that will be changed into the unique
Gr&ouml;bner basis when needed.  Thus the original basis will be discarded.
See the procedure <A  HREF = "text1207.htm#GB:Groebner">Groebner</A> below
for details on the algorithms available.


<H4><A NAME = "13479">Gr&ouml;bner Bases over Euclidean  Rings</A></H4>

<P>
<P>
Since V2.8 (July 2001), Magma provides facilities for computing with
Gr&ouml;bner bases of ideals of polynomial rings over Euclidean rings
(including the important case of the integer ring Z).  Such
Gr&ouml;bner bases are computed in Magma by an extension, due to Allan
Steel (unpublished), of Jean-Charles Faug&egrave;re's F<sub>4</sub> algorithm
<A  HREF = "text1202.htm#bib_FaugereF4">[Fau99]</A>, which uses sparse linear algebra.
<P>
The current Euclidean rings in Magma supported are: the integer
ring Z, the integer residue class rings Z<sub>m</sub>, the univariate
polynomial rings K[x] over any field K, Galois rings,
p-adic quotient rings, and valuation rings.
<P>
We first outline some of the things which are peculiar to
Gr&ouml;bner bases defined over a Euclidean ring.
Let I be an ideal of a polynomial ring defined over a Euclidean ring
R.  A subset G of I is called a <I>Gr&ouml;bner basis</I> for I in Magma
if, for every f&isin;I, there exists a g&isin;G such that the leading
<B>term</B> of g divides the leading <B>term</B> of f.  Recall that
"leading term" here means the leading coefficient times the leading
monomial, so the leading coefficient of g must divide the leading
coefficient of f in the base ring R.  If R were a
field, then obviously the leading coefficients would be insignificant and
the Gr&ouml;bner basis elements could be normalized (made monic) to yield
an equivalent Gr&ouml;bner basis.  But if R is not a field, the leading
coefficients are quite significant.  For example, over the ring Z,
the set { x<sup>2</sup>, 2x } is a Gr&ouml;bner basis and the polynomial x<sup>2</sup>
is not redundant since 2 does not divide 1, but over Q, the
polynomial x<sup>2</sup> would be redundant.
<P>
Note that the definition here for a Gr&ouml;bner basis in Magma is
actually what some authors (e.g., <A  HREF = "text1202.htm#bib_AdamsLoustaunau">[AL94, Def. 4.5.6]</A>)
call a <I>strong</I> Gr&ouml;bner basis.  <I>Weak</I> Gr&ouml;bner bases have
also been defined, but strong Gr&ouml;bner bases satisfy stronger
conditions, yield a simple effective normal form algorithm, provide
more information about the ideal, are easier to get into a unique
form, and are no more difficult to compute using the algorithm
implemented in Magma.  Thus Magma <B>always</B> computes a strong
Gr&ouml;bner basis, so the distinction between weak and strong
is ignored.  Magma also effectively computes a D-Gr&ouml;bner
basis as defined in <A  HREF = "text1202.htm#bib_BeckerWeispfenning">[BW93, Def. 10.4, Table 10.1]</A>,
although Magma also allows Euclidean rings which are not integral
domains (i.e., which have zero divisors).
<P>
Over Euclidean rings, the definition of a minimal basis is practically
the same as for fields (there must be no polynomial in the ideal
generated by the others and each polynomial must be normalized), but
the definition of a reduced basis is more subtle.  A basis is called
<I>reduced</I> if each polynomial in it is normalized and if, for every
term c.s of every polynomial in the basis (where c is the
coefficient and s is the monomial), then if some other polynomial in
the basis has leading term d.t, with t dividing s, then the
Euclidean quotient of c by d must be zero (the remainder will be
non-zero of course).  Informally, this means that each polynomial is
reduced modulo all the other polynomials, where each coefficient must
be reduced modulo all other appropriate leading coefficients.  As an
example, suppose f<sub>1</sub> = x<sup>2</sup> + 14xy and f<sub>2</sub> = 5y + 9 are in
Z[x, y].  Then { f<sub>1</sub>, f<sub>2</sub> } is not reduced, since the second term
of f<sub>1</sub> can be reduced by f<sub>2</sub> (y divides xy and the Euclidean
quotient of 14 by 5 is 2, with remainder 4).  But if we were to replace
f<sub>1</sub> by f<sub>1</sub> - 2xf<sub>2</sub> = x<sup>2</sup> + 4xy - 18x, then { f<sub>1</sub>, f<sub>2</sub> } would
now be reduced.
<P>
Magma's extension of Faug&egrave;re's algorithm depends on sparse linear
algebra over Euclidean rings.  (Note also that the advanced criteria
for eliminating useless pairs in <A  HREF = "text1202.htm#bib_MoellerCriteria">[M&ouml;l88]</A>) are also
implemented in this extension to work for general Euclidean rings
as well.)  Magma now contains an algorithm for computing a unique
echelon form of a sparse matrix over such a ring; uniqueness is ensured
because there is a unique Euclidean quotient-remainder algorithm
for each Euclidean ring (and zero divisors are also handled
properly).  Consequently, based on this unique echelon form algorithm
and some other techniques, Magma ensures that a Gr&ouml;bner basis over
a Euclidean ring is not only minimal (contains no redundant
polynomials), but it is also <B>reduced</B>, and <B>unique</B>.
<P>
Thus every ideal of a polynomial ring over a Euclidean ring possesses a
<B>unique</B> sorted minimal reduced Gr&ouml;bner basis (with respect to some fixed
monomial ordering), just as for ideals defined over fields.  Also, as
for ideals defined over fields, this unique Gr&ouml;bner basis will be
computed automatically when needed by Magma, and before this
happens, an ideal will usually possess a basis which is not a Gr&ouml;bner
basis, but that will be changed into the unique Gr&ouml;bner basis when
needed.
<P>
The uniqueness of the Gr&ouml;bner basis also ensures that the normal form
of an element with respect to an ideal for a fixed monomial order is
always unique.  All of this holds even for Euclidean rings which have
zero divisors.
<P>
See the examples below for illustrations of the points made above,
and also how one can effectively compute with Gr&ouml;bner bases of
ideals defined over rings which are not even Euclidean.


<H4><A NAME = "13480">Construction of Gr&ouml;bner Bases</A></H4>

<P>
<P>
The following functions and procedures allow one to construct Gr&ouml;bner
bases.
Note that a Gr&ouml;bner basis for an ideal will be automatically generated
when necessary; the <TT>Groebner</TT> procedure below simply allows
control of the algorithms used to compute the Gr&ouml;bner basis.
<P>
<B>NOTE:</B> Magma applies a special monomial representation
and a special variant of the F<sub>4</sub> algorithm if the ideal I is defined
over GF(2) and the polynomials (x<sub>i</sub>)<sup>2</sup> + x<sub>i</sub> for all i are present
in the input basis of the ideal I.  So if one wishes to solve a system
of equations over GF(2), then one should include these polynomials in
the input basis (they can be at any place and in any order; as long as
there is at least one copy of (x<sub>i</sub>)<sup>2</sup> + x<sub>i</sub> present for each i).
Alternatively (since V2.15), one can create a boolean polynomial
ring (via the function <A  HREF = "text1207.htm#GB:BooleanPolynomialRing">BooleanPolynomialRing</A> below) and construct
the ideal within this.
See also Example <A  HREF = "text1207.htm#13513">H111E5</A> below.


<H5><A NAME = "13481"></A><A NAME = "GB:Groebner">Groebner</A>(I: parameters) : RngMPol -&gt;</H5>
<BLOCKQUOTE>
(Procedure.)
Explicitly force a Gr&ouml;bner basis (GB) for the ideal I to be constructed.
This procedure is normally not necessary, as Magma will automatically
compute the GB when needed, but it does allow
one to control how the GB is constructed by various parameters.
<P>
By default, the parameters are set to default values which tend to work
best for the particular kinds of inputs which are given, 
but there exist many inputs for which setting
at least one of the parameters to a non-default value will lead to a
dramatic improvement.  (A general strategy for the computation of
GBs is very difficult to design.)
<P>
If I is defined over a Euclidean ring, then Magma always uses
the extension of the Faug&egrave;re algorithm directly, and of the
parameters given below, only <TT>Homogenize</TT> is applicable.
So the rest of this description assumes that I is defined over a field.
<P>
We call a GB algorithm <B>direct</B> if
it takes the initial basis of the ideal I (with no structure) and
computes the unique minimal reduced GB of I with respect to some monomial
order.
Since V2.11 (May 2004), Magma has two direct algorithms for
computing GBs over fields:
<P>
<DL COMPACT class='compact'>
<DT>(1)</DT><DD>The Faug&egrave;re F<sub>4</sub> algorithm <A  HREF = "text1202.htm#bib_FaugereF4">[Fau99]</A>, which works
	   by specialized sparse linear algebra and is applicable to
	   ideals defined over a finite field or the rational field;
<DT>(2)</DT><DD>The Buchberger algorithm <A  HREF = "text1202.htm#bib_CLO">[CLO96, Chap. 2, Para 7]</A> for ideals
	   defined over any field.
<P>
<P>
<P>
<P>
</DL>
Both direct algorithms use the advanced criteria for eliminating useless
pairs in <A  HREF = "text1202.htm#bib_MoellerCriteria">[M&ouml;l88]</A>.
Magma also uses two <B>order change</B> algorithms
which both change the GB of an ideal
with respect to one monomial order to the GB
with respect to another monomial order:
<P>
<DL COMPACT class='compact'>
<DT>(1)</DT><DD>The FGLM algorithm <A  HREF = "text1202.htm#bib_FGLM">[FGLM93]</A>, which works by efficient
linear algebra and is only applicable if I is zero-dimensional;
<DT>(2)</DT><DD>The Gr&ouml;bner Walk algorithm <A  HREF = "text1202.htm#bib_GWalk">[CKM97]</A>.
<P>
<P>
<P>
<P>
</DL>
This parameter affects the main strategy:
<P>
<P>
<PRE>
     Al: MonStgElt                       Default: "Default"
</PRE>
<P>
The parameter <TT>Al</TT> may be set to one of: <TT>"Default"</TT>,
<TT>"Direct"</TT>, <TT>"FGLM"</TT> or <TT>"Walk"</TT>.
The value <TT>"Direct"</TT> specifies that Magma should compute the
GB of I (with respect to the order of I) by a direct algorithm alone,
so that an order-conversion algorithm is not used (the parameter <TT>Faugere</TT>
below controls which direct algorithm is used).
<P>
The alternative strategy is to compute the GB first with respect to an
"easy" order, and then to convert this to the GB with respect to the
order of I.  Setting <TT>Al</TT> to the values <TT>"FGLM"</TT> or <TT>"Walk"</TT>
will cause this strategy to be used, where the order change algorithm
will be the FGLM algorithm or Gr&ouml;bner Walk algorithm, respectively.
<P>
If no algorithm is specified,
or if <TT>"Default"</TT> is specified, an appropriate strategy
is chosen by Magma, which is usually the FGLM method if the ideal
is zero-dimensional and over a finite field or the rational field,
and the Walk method otherwise.
<P>
<P>
<P>
The following parameters affect the direct algorithms:
<P>
<P>
<PRE>
     Faugere: BoolElt                    Default: <TT>true</TT>
</PRE>
<P>
<PRE>
     Dense: BoolElt                      Default: 
</PRE>
<P>
<PRE>
     HomogeneousWeights: BoolElt         Default: <TT>true</TT>
</PRE>
<P>
<PRE>
     Homogenize: BoolElt                 Default: <TT>true</TT>
</PRE>
<P>
<PRE>
     DegreeStart: RngIntElt              Default: <TT>true</TT>
</PRE>
<P>
<PRE>
     GlobalModular: BoolElt              Default: <TT>true</TT>
</PRE>
<P>
If the parameter <TT>Faugere</TT> is set to <TT>true</TT>, then the Faug&egrave;re
F<sub>4</sub> algorithm will be used (if the field is a finite field or the rational
field); otherwise the Buchberger algorithm is used.
<P>
The current implementation of the Faug&egrave;re algorithm is usually very
much faster than the Buchberger algorithm and usually does not take much
more memory, so that it is why it is now selected by default.  However,
there may be examples for which it may be more desirable to use the
Buchberger algorithm (particularly to save some memory).
<P>
Since V2.20, the <TT>Dense</TT> parameter controls the
dense variant of F<sub>4</sub>; see the next subsection.
<P>
Since V2.12, if the input basis is not homogeneous, then
Magma first attempts to find a weight vector W
with respect to which the ideal is
homogeneous; if such a W is found, then the "easy" order
used internally for the direct algorithm (accessed by <A  HREF = "text1207.htm#EasyIdeal">EasyIdeal</A>)
is taken to be the <TT>grevlexw</TT> order with respect to W
(see subsection <A  HREF = "text1205.htm#13444">Graded Reverse Lexicographical  (Weighted): <TT>grevlexw</TT></A>), since the GB is likely
to be smaller with respect to this order.  The selection of such an order
may be suppressed by setting the parameter <TT>HomogeneousWeights</TT>
to {<TT>false</TT>}.
<P>
If no appropriate <TT>grevlexw</TT> order is used, then setting <TT>Homogenization</TT> to <TT>true</TT> specifies that the ideal should first be <I>homogenized</I>: a GB of the homogenization of the ideal is computed and
then the homogenization variable is removed and the final basis
reduced.  This parameter has the default value of <TT>true</TT> over the
rational field and <TT>false</TT> over all other fields, since most
computations are improved by these defaults.
<P>
If the parameter <TT>DegreeStart</TT> is set to an integer d, then any
S-polynomial pairs of degree less than d will be ignored.
<P>
Since V2.22 (May 2016), when computing the GB of an ideal I defined over K=Q
or an algebraic number field K=Q(&alpha;), Magma by default uses a Monte-Carlo
`global modular' algorithm where the complete GB of I is computed modulo successive
primes and the GB of I over K is reconstructed from these
modular GBs.  The probability of incorrectness for this new algorithm
is of the order of 1 in 10<sup>28</sup>.  This algorithm can be also
turned off by setting the parameter <TT>GlobalModular</TT> to {<TT>false</TT>},
so that the
computation will revert to using the previous `step by step' modular
F<sub>4</sub> algorithm where
there is only one full GB computation and the GB polynomials are constructed
over K in each matrix step.
<P>
<P>
<P>
<P>
The following parameters affect the Faug&egrave;re F<sub>4</sub> algorithm:
<P>
<P>
<PRE>
     AllPairs: BoolElt                   Default: <TT>false</TT>
</PRE>
<P>
<PRE>
     PairsLimit: BoolElt                 Default: 0
</PRE>
<P>
<PRE>
     ReversePairs: BoolElt               Default: <TT>false</TT>
</PRE>
<P>
<PRE>
     HFE: BoolElt                        Default: <TT>false</TT>
</PRE>
<P>
<PRE>
     Boolean: BoolElt                    Default: <TT>false</TT>
</PRE>
<P>
<PRE>
     Nthreads: RngIntElt                 Default: 1
</PRE>
By default, the Faug&egrave;re F<sub>4</sub> algorithm includes all pairs of the
next degree at each step (see <A  HREF = "text1202.htm#bib_FaugereF4">[Fau99, Sec.2.5]</A>), since this
usually produces the best performance.  However, setting the
parameter <TT>AllPairs</TT> to <TT>true</TT> will cause the algorithm to include
<I>all</I> pairs currently in the queue at each new step; this generally
makes the matrix larger and is usually less efficient, but for some inputs
(e.g., inhomogeneous ideals where there are only a small number of pairs
for each degree at each step) this option may yield a significant
improvement.
<P>
Alternatively, setting the parameter <TT>PairsLimit</TT> to
a positive integer n will cause the algorithm to include at most
n pairs from the queue at each step; this will usually make the
matrix smaller, thus saving memory, but will often also make the running
time longer.  Setting also the parameter <TT>ReversePairs</TT> to {<TT>true</TT>}
will reverse the list of pairs of the current degree from which the
restricted set of pairs is taken: this may help a lot for certain types
of input, since this may lead to new polynomials of lower degree being
found more quickly.  (If there is no pairs limit, then the value of <TT>ReversePairs</TT> is irrelevant since all pairs of the current degree are
taken at each step.)
<P>
If the input basis is an HFE system over GF(2) such that the
secret degree d is less than or equal to 127, then one should set
the <TT>HFE</TT> parameter to {<TT>true</TT>}.  In this case, Magma can apply
various optimizations which save memory and time (only pairs of degree of
most 4 are considered, as this is sufficient for systems for which d&le;127).
<P>
Since V2.18, if the base ring is the finite field GF(p), where p
is a prime with 2&lt;p&lt;2<sup>23.5</sup>, then a multi-threaded version of the
algorithm is available if POSIX threads are enabled in the current Magma
version.  In this case, setting the parameter <TT>Nthreads</TT> to a positive
integer n will cause the F<sub>4</sub> algorithm to use n threads within the linear
algebra phase of each step.  One can alternatively use the
procedure <A  HREF = "text49.htm#Env:SetNthreads">SetNthreads</A> to set the global number of threads
to a value n so that n threads are always used by default in this
algorithm (unless overridden by the <TT>Nthreads</TT> parameter).
<P>
<P>
<P>
<P>
The following parameters affect the Buchberger algorithm:
<P>
<P>
<PRE>
     ReduceInitial: BoolElt              Default: <TT>true</TT>
</PRE>
<P>
<PRE>
     RemoveRedundant: BoolElt            Default: <TT>true</TT>
</PRE>
<P>
<PRE>
     ReduceByNew: BoolElt                Default: <TT>true</TT>
</PRE>
Setting <TT>ReduceInitial</TT> to <TT>true</TT> specifies that the basis of the
ideal should be first reduced (see the function <TT>Reduce</TT>)
before any S-polynomial pairs are considered.
Setting <TT>RemoveRedundant</TT> to <TT>true</TT> specifies that redundant polynomials
in the input (which reduce to zero with respect to the other polynomials)
should first be removed.
Setting <TT>ReduceByNew</TT> to <TT>true</TT> specifies that when a new polynomial f
is inserted into the current GB being constructed, the
current basis should be reduced by f (thus the basis stays close to
being fully reduced throughout the algorithm).
<P>
Each of these control parameters usually have the default values of
<TT>true</TT> (it depends on the coefficient ring).
<P>
<P>
<P>
The following parameters affect the Walk algorithm:
<P>
<P>
<PRE>
     SigmaEpsilon: FldRatElt             Default: 1/2
</PRE>
<P>
<PRE>
     TauEpsilon: FldRatElt               Default: 1/n
</PRE>
<P>
<PRE>
     SigmaVectors: RngIntElt             Default: n
</PRE>
<P>
<PRE>
     TauVectors: RngIntElt               Default: &lceil;n/2 &rceil;
</PRE>
<P>
The parameters <TT>SigmaEpsilon</TT> and <TT>TauEpsilon</TT> control the
factor &epsilon; which is used in the Walk algorithm to perturb the
initial weight vector &sigma; and the final weight vector &tau;
respectively.  The parameters <TT>SigmaVectors</TT> and <TT>TauVectors</TT>
determine how many weight vectors of the initial and final orders are
used to perturb the initial weight vector &sigma; and the final weight
vector &tau; respectively.  By default, the &epsilon; factor and
number of weight vectors for &sigma; are determined dynamically to be
"optimal", while the &epsilon; factor for &tau; is taken to be
1/n and the number of weight vectors for &tau; is taken to be
&lceil;n/2 &rceil;, where n is the rank of I.
</BLOCKQUOTE>
<H5><A NAME = "13482"></A><A NAME = "GB:GroebnerBasis">GroebnerBasis</A>(I: parameters) : RngMPol -&gt; [ RngMPolElt ]</H5>
<BLOCKQUOTE>
Given an ideal I, force the Gr&ouml;bner basis of I to be computed,
and then return that.
The parameters are the same as those for the procedure <A  HREF = "text1207.htm#GB:Groebner">Groebner</A>.
<P>
See also the function <A  HREF = "text1207.htm#dpoly_gb_deg">GroebnerBasis</A><TT>(S,d)</TT> below, which creates
a truncated degree-d Gr&ouml;bner basis.
</BLOCKQUOTE>
<H5><A NAME = "13483">GroebnerBasis(S: parameters) : [ RngMPolElt ] -&gt; [ RngMPolElt ]</A></H5>
<H5>GroebnerBasis(S: parameters) : { RngMPolElt } -&gt; [ RngMPolElt ]</H5>
<BLOCKQUOTE>
Given a set or sequence S of polynomials, return the unique Gr&ouml;bner
basis of the ideal generated by S as a sorted sequence.  This function
is useful for computing Gr&ouml;bner bases without the need to construct
ideals.
The parameters are the same as those for the procedure <A  HREF = "text1207.htm#GB:Groebner">Groebner</A>.
<P>
See also the function <A  HREF = "text1207.htm#dpoly_gb_deg">GroebnerBasis</A><TT>(S,d)</TT> below, which creates
a truncated degree-d Gr&ouml;bner basis.
</BLOCKQUOTE>
<H5><A NAME = "13484">GroebnerBasisUnreduced(S: parameters) : [ RngMPolElt ] -&gt; [ RngMPolElt ]</A></H5>
<H5>GroebnerBasisUnreduced(S: parameters) : { RngMPolElt } -&gt; [ RngMPolElt ]</H5>

<PRE>    Homogenize: BoolElt                 Default: <TT>true</TT></PRE>

<PRE>    ReduceInitial: BoolElt              Default: <TT>true</TT></PRE>

<PRE>    ReduceByNew: BoolElt                Default: <TT>true</TT></PRE>
<BLOCKQUOTE>
Given a set or sequence S of polynomials, return an unreduced Gr&ouml;bner
basis of the ideal generated by S as a sorted sequence.  This function
is useful for computing Gr&ouml;bner bases without the need to construct
ideals and when the reduction of the Gr&ouml;bner basis is very expensive.
The parameters behave the same as for the procedure <A  HREF = "text1207.htm#GB:Groebner">Groebner</A>.
</BLOCKQUOTE>
<H5><A NAME = "13485"></A><A NAME = "dpoly_gb_deg">GroebnerBasis</A>(S, d: parameters) : [ RngMPol ], RngInt -&gt; RngMPolElt</H5>
<BLOCKQUOTE>
Given a set or sequence S of polynomials, return the degree-d Gr&ouml;bner 
basis of the ideal generated by S, which is the truncated Gr&ouml;bner basis
obtained by ignoring S-polynomial pairs whose total degree is greater than d.
<P>
If the ideal is homogeneous, then it is guaranteed that the result G<sub>d</sub>
is equal to the set of all polynomials in the full Gr&ouml;bner basis of
the ideal whose total degree is less than or equal to d, and thus
a polynomial whose total degree is less than or equal to d is in
the ideal iff its normal form with respect to the degree-d
Gr&ouml;bner basis G<sub>d</sub> is zero.   But if the ideal is not homogeneous,
these last properties may not hold, but it may be still useful to
construct the truncated basis.
<P>
The parameters are the same as those for the procedure <A  HREF = "text1207.htm#GB:Groebner">Groebner</A>.
See the section on graded polynomial rings below for an example.
See also <A  HREF = "text1202.htm#bib_BeckerWeispfenning">[BW93, section 10.2]</A>, for further discussion.
</BLOCKQUOTE>
<H4><A NAME = "13486">The Dense Variant of the F<sub>4</sub> algorithm</A></H4>

<P>
<P>
Since V2.20, Magma includes a new dense variant of the F<sub>4</sub> algorithm.
The dense variant is <B>currently only practically applicable</B> to input
systems over a finite field where the input polynomials are considered
"dense"; that is, if the input polynomials are written as a matrix
with columns labelled by the monomials, then the input matrix should be
dense. Equivalently: if the field size is q and the set of all monomials
occurring in the input has size m, then the number of monomials in each
input polynomial should be reasonably close to (1 - 1/q).m.
<P>
Dense input systems which are applicable include various cryptographic
inputs such as HFE, MQQ and Minrank systems, but
systems which do not involve the solving of simultaneous equations
are also applicable.
(The algorithm does work correctly on sparser input systems
but is usually not as efficient as the standard F<sub>4</sub> algorithm for such
inputs.)
<P>
Some key features of the dense variant of the F<sub>4</sub> algorithm are
as follows:
<DL COMPACT class='compact'>
<DT>(1)</DT><DD>This variant essentially uses the same matrices as in the
    standard F<sub>4</sub> algorithm (i.e., uses the same S-polynomials and reductors
    as usual) but exploits dense portions of the matrices where possible
    in the linear algebra phase, leading to significant speedups for
    larger examples.
<DT>(2)</DT><DD>There is often also significant savings in memory usage over the
    standard F<sub>4</sub> algorithm.
<DT>(3)</DT><DD>If an NVIDIA GPU is available, then this is also exploited
    (in a special CUDA-enabled Magma executable),
    yielding greater speedups for larger examples.
<DT>(4)</DT><DD>Finally, there is a new experimental optional heuristic which can
    be selected
    for the algorithm when solving systems of equations over GF(2),
    called the <B>Reduction Heuristic</B>
    which can give an even greater reduction in time and memory usage
    for some large examples.
<P>
</DL>
When computing a Gr&ouml;bner basis, Magma will by default automatically
select the dense variant of the F<sub>4</sub> algorithm if it considers that
the input system is sufficiently dense. But one can force the dense
variant to be used or not by setting the parameter <TT>Dense</TT> to {<TT>true</TT>}
or {<TT>false</TT>} respectively. If the dense variant is turned off, Magma
will use the standard F<sub>4</sub> algorithm.
<P>
The <B>Reduction Heuristic</B> is a new experimental heuristic which
can be selected in the dense variant of F<sub>4</sub> when attempting
to solve certain kinds of systems of equations over GF(2) where it is
assumed that there is a very small number of solutions, so the Groebner
basis will consist of mostly linear polynomials or collapse to {1}
when there is no solution.
The heuristic attempts to reduce the size of the matrices involved in the
linear algebra phase of each F<sub>4</sub> step.  When the heuristic is selected,
the run may simply fail, but when it succeeds, it often saves significant
time and memory usage.  The kinds of systems for which the saving in time and memory usage
tends to be greatest
are those such that in the F<sub>4</sub> steps of maximal degree D,
the number of S-polynomials is relatively small compared to the total
number of monomials of degree D.
<P>
Currently the Reduction Heuristic depends on a manual choice by the user of a
numerical parameter M.
Thus if B is the sequence of input polynomials, to select the Reduction
Heuristic with parameter M, one should currently invoke the algorithm
with something like the following:
<P>
<P>
<TT>GroebnerBasis(B, D: ReductionHeuristic := M);</TT>
<P>
<P>
<P>
where M is the expected maximal degree reached in the computation.
<P>
If M is large enough, then the computation will finish correctly
and hopefully in considerably less time than the default algorithm without
the heuristic.  If M is too small, then the algorithm
will fail: a runtime error is usually triggered at the point that the
algorithm realizes that M was too small.  Also, conceivably the algorithm
could fail to discover that M is too small and so a wrong Groebner basis
could be returned (thus making the algorithm Monte-Carlo).  However: (1)
a value of M which is too small is usually detected by Magma
(and a runtime error is triggered); (2) the algorithm can actually be
considered Las Vegas when solving a typical system known to have at least
one solution since potential solutions can be trivially checked at the end
(so coupled with checking, the algorithm either finds correct solutions
or simply fails).
<P>
At the moment, it is impossible to suggest what is a suitable choice for
M for any given system.  But it is currently recommended in practice
that one start with M=500 or 1000, and if there is failure, one should
increase M successively by 500 or 1000 and restart from scratch
and repeat this until the algorithm succeeds.  Note that making M
much larger than necessary reduces the effectiveness of the heuristic,
so one should not just set M to a very large value.
<P>
It may seem inefficient if one has to try several runs with potential
failure, but this is often alleviated as follows:
<DL COMPACT class='compact'>
<DT>(1)</DT><DD>Since the algorithm often runs much faster with a small
    value for M (whether it succeeds or not), the total time taken for all runs including the ones
    which fail may still be significantly
    less than running without the heuristic selected.
<DT>(2)</DT><DD>Each run with the heuristic may use much less memory than the
    default run without the heuristic would use, so no matter
    how much time is taken, one will eventually be able to solve systems
    with the heuristic which are not solvable in the available memory without the heuristic.
<DT>(3)</DT><DD>When solving a whole class of systems of the same type, one
    can determine a suitable M for one system and then use that for
    all the others.  This includes multiple systems arising from
    evaluating a number of variables in some original system.
<P>
<P>
<P>
</DL>
For some timing examples of the new dense variant of the
F<sub>4</sub> algorithm (including uses of the Reduction Heuristic)
and further information, please see the webpage:
<P>
<P>
<P>
{<TT>tinyurl.com/DenseF4</TT>}


<H4><A NAME = "13487">Related Functions</A></H4>

<P>
<P>
The following functions and procedures perform operations related to Gr&ouml;bner
bases.


<H5><A NAME = "13488">HasGroebnerBasis(I) : RngMPol -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Given an ideal I, return whether the Gr&ouml;bner basis of I can
be computed.  This depends on the type of base ring of I:
the base ring must currently be a field or a Euclidean ring.
</BLOCKQUOTE>
<H5><A NAME = "13489"></A><A NAME = "EasyIdeal">EasyIdeal</A>(I) : RngMPol -&gt; RngMPol</H5>
<BLOCKQUOTE>
Given an ideal I, return the ideal E which is mathematically equal
to I but whose basis is the Gr&ouml;bner basis of I with
respect to an "easy" order,
together with an isomorphism f from I onto E.
The easy order is usually the <TT>grevlex</TT> order or <TT>grevlexw</TT> order
with suitable weights, and the easy basis
(the Gr&ouml;bner basis of the easy ideal) of I is used extensively by
Magma in many of its internal algorithms; this function allows one to
access this "easy" Gr&ouml;bner basis directly.
</BLOCKQUOTE>
<H5><A NAME = "13490"></A><A NAME = "EasyBasis">EasyBasis</A>(I) : RngMPol -&gt; [ RngMPolElt ]</H5>
<BLOCKQUOTE>
Given an ideal I, return the Gr&ouml;ebner basis of the easy ideal of I.
</BLOCKQUOTE>
<H5><A NAME = "13491">SmallBasis(I) : RngMPol -&gt; [ RngMPolElt ]</A></H5>
<BLOCKQUOTE>
Given an ideal I, return the basis of I with shortest length which
is currently known.  This may be the original basis with which I
was constructed, or a Gr&ouml;bner basis, but the result is always has the
the same monomial order as the main monomial order of I.
</BLOCKQUOTE>
<H5><A NAME = "13492">MarkGroebner(I) : RngMPol -&gt;</A></H5>
<BLOCKQUOTE>
(Procedure.)
Given an ideal I, mark the current basis of I to be <I>the</I>
Gr&ouml;bner basis of the ideal w.r.t. the monomial order of the ideal.
Note that the current basis must exactly equal the unique (reverse)
sorted minimal reduced Gr&ouml;bner basis for the ideal, as returned by
the function <A  HREF = "text1207.htm#GB:GroebnerBasis">GroebnerBasis</A>.  This procedure is useful when one
creates an ideal with a basis known to be the Gr&ouml;bner basis of the
ideal from a previous computation or for other reasons.  If the basis
is not the unique Gr&ouml;bner basis, the results are unpredictable.
</BLOCKQUOTE>
<H5><A NAME = "13493">IsGroebner(S) : { RngMPolElt } -&gt; BoolElt</A></H5>
<H5>IsGroebner(S) : [ RngMPolElt ] -&gt; BoolElt</H5>
<BLOCKQUOTE>
Given a set or sequence S of polynomials describing a basis of an ideal,
return whether the basis is itself a (not necessarily minimal or reduced)
Gr&ouml;bner basis of the ideal.
</BLOCKQUOTE>
<H5><A NAME = "13494"></A><A NAME = "GB:Coordinates">Coordinates</A>(I, f) : RngMPol, RngMPolElt -&gt; [ RngMPolElt ]</H5>
<BLOCKQUOTE>
Given an ideal I of a polynomial ring P, together with a polynomial
f in I, and supposing that I has basis b<sub>1</sub>, ..., b<sub>k</sub>, return
a sequence [g<sub>1</sub>, ..., g<sub>k</sub>] of elements of P so that f = g<sub>1</sub> *
b<sub>1</sub> + ... + g<sub>k</sub> * b<sub>k</sub>.  If I was created by
<A  HREF = "text1206.htm#GB:IdealWithFixedBasis">IdealWithFixedBasis</A>(B), then the fixed basis B is used as
the basis b<sub>1</sub>, ..., b<sub>k</sub>; otherwise the (unique) Gr&ouml;bner basis of
I is used as the basis b<sub>1</sub>, ..., b<sub>k</sub>.  The resulting sequence is
not necessarily unique.
</BLOCKQUOTE>
<H5><A NAME = "13495"></A><A NAME = "GB:CoordinateMatrix">CoordinateMatrix</A>(I) : RngMPol -&gt; Matrix</H5>
<BLOCKQUOTE>
Given an ideal I such that I has a fixed basis (i.e., such that
I was created via the function <A  HREF = "text1206.htm#GB:IdealWithFixedBasis">IdealWithFixedBasis</A>),
return the coordinate matrix C of I.  The i-th row of C gives
the coordinates of the i-th element of the Gr&ouml;ebner basis of I
w.r.t. the fixed basis of I.  The Gr&ouml;ebner basis of I is first
computed if it has not been already.
</BLOCKQUOTE>
<H5><A NAME = "13496">NormalForm(f, I) : RngMPolElt, RngMPol -&gt; RngMPolElt</A></H5>
<BLOCKQUOTE>
Given a polynomial f from a polynomial ring P, together with an ideal
I of P, return the unique normal form of f with respect to
(the Gr&ouml;bner basis of) I.  The normal form of f is zero if and
only if f is in I.
</BLOCKQUOTE>
<H5><A NAME = "13497">NormalForm(f, S) : RngMPolElt, [ RngMPolElt ] -&gt; RngMPolElt, [ RngMPolElt ]</A></H5>
<BLOCKQUOTE>
Given a polynomial f from a polynomial ring P, together with a set
or sequence S of polynomials from P, return a normal form g of f
with respect to S.  (This is not unique in general.  If the normal
form of f is zero then f is in the ideal generated by S, but the
converse is false in general.  In fact, the normal form is unique if
and only if S forms a Gr&ouml;bner basis.)  If S is a sequence, one
may also assign a second return value C which gives the coordinates of
the reduction, so that C[i].S[i] is subtracted from f for
each i to yield g.
</BLOCKQUOTE>
<H5><A NAME = "13498">SPolynomial(f, g) : RngMPolElt, RngMPolElt -&gt; RngMPolElt</A></H5>
<BLOCKQUOTE>
Given elements f and g from a polynomial ring P, return the S-polynomial
of f and g.
</BLOCKQUOTE>
<H5><A NAME = "13499"></A><A NAME = "GB:Reduce">Reduce</A>(S) : [ RngMPolElt ] -&gt; [ RngMPolElt ]</H5>
<H5>Reduce(S) : { RngMPolElt } -&gt; [ RngMPolElt ]</H5>
<BLOCKQUOTE>
Given a set or sequence S of polynomials, return
the sequence consisting of the reduction of S.
The reduction is obtained by reducing to normal form
each element of S with respect to the other elements and sorting
the resulting non-zero elements left.  Note that all Gr&ouml;bner bases
returned by Magma are automatically reduced so that this function
would usually only be used just to simplify a set or sequence of
polynomials which is not a Gr&ouml;bner basis.
</BLOCKQUOTE>
<H5><A NAME = "13500">ReduceGroebnerBasis(S) : [ RngMPolElt ] -&gt; [ RngMPolElt ]</A></H5>
<H5>ReduceGroebnerBasis(S) : { RngMPolElt } -&gt; [ RngMPolElt ]</H5>
<BLOCKQUOTE>
Given a set or sequence S of polynomials which is assumed to be
a (not necessarily minimal or reduced) Gr&ouml;bner basis for an ideal,
return the sequence consisting of the reduction of S.
The reduction is obtained by first
removing each redundant polynomial whose leading term is a multiple
of another leading term and then reducing the remaining polynomials
as in the function <A  HREF = "text1207.htm#GB:Reduce">Reduce</A>.
This function would usually only be used to reduce a set or sequence of
polynomials which is known to be a non-reduced Gr&ouml;bner basis
(created in some way other than by one of Magma's internal Gr&ouml;bner basis
construction algorithms).
</BLOCKQUOTE>
<H4><A NAME = "13501">Gr&ouml;bner Bases of Boolean Polynomial Rings</A></H4>

<P>
<P>
Since V2.15, a special type of polynomial ring is available: the <B>boolean
polynomial ring</B> in n variables.  Such a ring is a multivariate polynomial
ring defined over GF(2) but such that all monomials
are reduced modulo the <I>field relations</I> x<sub>i</sub><sup>2</sup> = x<sub>i</sub> for each i (so
a bit vector representation can be used for monomials).   Technically,
the ring is thus the quotient algebra
GF(2)[x<sub>1</sub>, ..., x<sub>n</sub>] / &lt; x<sub>1</sub><sup>2</sup> + x<sub>1</sub>, ..., x<sub>n</sub><sup>2</sup> + x<sub>n</sub> &gt;.
<P>
Besides the basic creation and access functions for elements
and ideals of such a ring, the main interest is to compute and
examine a Gr&ouml;bner basis of an ideal.
Since the field relations are always present,
an ideal represents a zero-dimensional system of multivariate polynomial equations over
GF(2) with the solution components always lying in GF(2); these
are particularly of interest for algebraic attacks on cryptosystems.
Otherwise, there are not many other operations applicable to such rings and
their elements.
<P>
Note that if one creates an ideal I of GF(2)[x<sub>1</sub>, ..., x<sub>n</sub>]
such that the basis of I includes the <I>field polynomials</I> (x<sub>i</sub><sup>2</sup> +
x<sub>i</sub> for each i), then Magma automatically uses the boolean
polynomial ring representation internally, so this is basically
equivalent to using the boolean polynomial ring type, except
that Magma will have to move back to the original ring GF(2)[x<sub>1</sub>, ..., x<sub>n</sub>] at the end, and this may take much more time and memory.  So it
is preferable to use the boolean polynomial ring from the outset if one
wishes to create the Gr&ouml;bner basis of such an ideal and examine it
(particularly if it does not collapse down to a sequence of linear
polynomials).
<P>
See example <A  HREF = "text1207.htm#13513">H111E5</A> below for simple uses of boolean
polynomial rings.


<H5><A NAME = "13502"></A><A NAME = "GB:BooleanPolynomialRing">BooleanPolynomialRing</A>(n) : RngIntElt -&gt; RngMPolBool</H5>
<BLOCKQUOTE>
Create the boolean polynomial ring with n variables (whose
coefficients lie in GF(2)).  The default monomial order chosen
is the lexicographical (<TT>lex</TT>) order.
</BLOCKQUOTE>
<H5><A NAME = "13503">BooleanPolynomialRing(n, order) : RngIntElt, MonStgElt -&gt; RngMPolBool</A></H5>
<BLOCKQUOTE>
Create the boolean polynomial ring with n variables (whose
coefficients lie in GF(2)) and with the given order {order} on the
monomials.  Currently, {order} must be one of the following strings:
<TT>"lex"</TT>,
<TT>"grevlex"</TT>,
<TT>"glex"</TT>.
</BLOCKQUOTE>
<H5><A NAME = "13504">BooleanPolynomialRing(B, Q) : RngMPolBool, [RngIntElt] -&gt; RngMPolBoolElt</A></H5>
<BLOCKQUOTE>
Given a boolean polynomial ring B of rank n and a sequence Q of
integers, create the boolean polynomial in B whose monomials are given
by the entries of Q: each integer must be in the range [0 ... 2<sup>n</sup> -
1] and its binary expansion gives the exponents of the monomial in order
(the resulting monomials are sorted w.r.t. the monomial order of B,
so may be given in any order and duplicate monomials are added).
<P>
This function is simply provided so that boolean polynomials may be
stored and read back in a compact form; otherwise, one can create a
boolean polynomial in the usual way from the generators of B after
B is created.  Note also that if one prints B, an ideal of B,
or an element of B with the <TT>Magma</TT> print level, then this function
will be used to print the elements in a compact form.
</BLOCKQUOTE>
<H4><A NAME = "13505">Verbosity</A></H4>

<P>
<P>
<P>
This subsection describes the verbose flags available for the
Gr&ouml;bner basis algorithms.
There are separate verbose flags for each algorithm (<TT>Buchberger</TT>, etc.),
but the all-encompassing verbose flag <TT>Groebner</TT> includes all these
flags implicitly.
<P>
For each procedure provided for setting one of these flags, the value
{<TT>false</TT>} is equivalent to level 0 (nothing), and {<TT>true</TT>} is equivalent to level
1 (minimal verbosity).  For each <TT>Set-</TT> procedure, there is also
a corresponding <TT>Get-</TT> function to return the value of the corresponding
flag.


<H5><A NAME = "13506">SetVerbose("Groebner", v) : MonStgElt, RngIntElt -&gt;</A></H5>
<BLOCKQUOTE>
(Procedure.)
Change the verbose printing level for all Gr&ouml;bner basis algorithms
to be v.
This includes all of the algorithms whose verbosity is controlled
by flags subsequently listed, as well as some other minor related algorithms.
Currently the legal levels are 0, 1, 2, 3, or 4.
One would normally set this flag to 1 for minimal verbosity for
Gr&ouml;bner basis-type computations, and possibly also set one or more
of the following flags to levels higher than 1 for more verbosity.
</BLOCKQUOTE>
<H5><A NAME = "13507">SetVerbose("Buchberger", v) : MonStgElt, RngIntElt -&gt;</A></H5>
<BLOCKQUOTE>
(Procedure.)
Change the verbose printing level for the Buchberger algorithm to be v.
Currently the legal levels are 0, 1, 2, 3, or 4.
If the value w of the <TT>Groebner</TT> verbose flag is greater than v,
then w is taken to be the current value of this flag.
</BLOCKQUOTE>
<H5><A NAME = "13508">SetVerbose("Faugere", v) : MonStgElt, RngIntElt -&gt;</A></H5>
<BLOCKQUOTE>
(Procedure.)
Change the verbose printing level for the Faug&egrave;re algorithm to be v.
Currently the legal levels are 0, 1, 2, or 3.
If the value w of the <TT>Groebner</TT> verbose flag is greater than v,
then w is taken to be the current value of this flag.
</BLOCKQUOTE>
<H5><A NAME = "13509">SetVerbose("FGLM", v) : MonStgElt, RngIntElt -&gt;</A></H5>
<BLOCKQUOTE>
(Procedure.)
Change the verbose printing level for the FGLM order change algorithm to be v.
Currently the legal levels are 0, 1, 2, or 3.
If the value w of the <TT>Groebner</TT> verbose flag is greater than v,
then w is taken to be the current value of this flag.
</BLOCKQUOTE>
<H5><A NAME = "13510">SetVerbose("GroebnerWalk", v) : MonStgElt, RngIntElt -&gt;</A></H5>
<BLOCKQUOTE>
(Procedure.)
Change verbose printing for the Gr&ouml;bner Walk order change algorithm to be v.
Currently the legal levels are 0, 1, 2, or 3.
If the value w of the <TT>Groebner</TT> verbose flag is greater than v,
then w is taken to be the current value of this flag.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "13511">Example <TT>GB_Cyclic6 (H111E3)</TT></A></H3>
We compute the Gr&ouml;bner basis of the "Cyclic-6" ideal with
respect to the lexicographical order.
The ideal is an ideal of the polynomial ring
Q(x, y, z, t, u, v).  We also note that the last polynomial in
the Gr&ouml;bner basis is univariate (since, in fact, the ideal is
zero-dimensional and the monomial order is lexicographical) and
observe that it has a nice factorization.  Note especially that
in this example, homogenizing at first and keeping the Gr&ouml;bner
basis reduced makes this computation very fast; without using
these features (i.e., if the parameters <TT>Homogenize := false</TT>
or <TT>ReduceByNew := false</TT> are given), the computation is
much more expensive (takes hundreds of seconds on the same
computer).
<P>
<P>
<PRE>
&gt; Q := RationalField();
&gt; P&lt;x, y, z, t, u, v&gt; := PolynomialRing(Q, 6);
&gt; I := ideal&lt;P |
&gt;     x + y + z + t + u + v,
&gt;     x*y + y*z + z*t + t*u + u*v + v*x,
&gt;     x*y*z + y*z*t + z*t*u + t*u*v + u*v*x + v*x*y,
&gt;     x*y*z*t + y*z*t*u + z*t*u*v + t*u*v*x + u*v*x*y + v*x*y*z,
&gt;     x*y*z*t*u + y*z*t*u*v + z*t*u*v*x + t*u*v*x*y + u*v*x*y*z + v*x*y*z*t,
&gt;     x*y*z*t*u*v - 1&gt;;
&gt; time B := GroebnerBasis(I);
Time: 1.140
&gt; #B;
17
&gt; B[17];
v^48 - 2554*v^42 - 399710*v^36 - 499722*v^30 + 499722*v^18 + 399710*v^12 + 
    2554*v^6 - 1
&gt; time Factorization(B[17]);
[
    &lt;v - 1, 1&gt;,
    &lt;v + 1, 1&gt;,
    &lt;v^2 + 1, 1&gt;,
    &lt;v^2 - 4*v + 1, 1&gt;,
    &lt;v^2 - v + 1, 1&gt;,
    &lt;v^2 + v + 1, 1&gt;,
    &lt;v^2 + 4*v + 1, 1&gt;,
    &lt;v^4 - v^2 + 1, 1&gt;,
    &lt;v^4 - 4*v^3 + 15*v^2 - 4*v + 1, 1&gt;,
    &lt;v^4 + 4*v^3 + 15*v^2 + 4*v + 1, 1&gt;,
    &lt;v^8 + 4*v^6 - 6*v^4 + 4*v^2 + 1, 1&gt;,
    &lt;v^8 - 6*v^7 + 16*v^6 - 24*v^5 + 27*v^4 - 24*v^3 +
        16*v^2 - 6*v + 1, 1&gt;,
    &lt;v^8 + 6*v^7 + 16*v^6 + 24*v^5 + 27*v^4 + 24*v^3 +
        16*v^2 + 6*v + 1, 1&gt;
]
Time: 0.060
</PRE>
<HR>
<H3><A NAME = "13512">Example <TT>GB_RungeKutta2 (H111E4)</TT></A></H3>
We solve the system of equations Runge-Kutta 2 from the paper
"Some Examples for Solving Systems of Algebraic Equations by Calculating
Groebner Bases" by Boege, Gebauer, and Kredel (J. Symbolic Computation
(1986) <B>1</B>, 83--98).  The coefficient field K is the rational
function field Q(c2, c3), and the polynomial ring
K[c4, b4, b3, b2, b1, a21, a31, a32, a41, a42, a43] has 11 variables with the
lexicographical ordering on monomials.  The
resulting Gr&ouml;bner basis contains a linear polynomial for each variable
so there is exactly one solution to the system.
<P>
<P>
<PRE>
&gt; K&lt;c2, c3&gt; := FunctionField(IntegerRing(), 2);
&gt; P&lt;c4, b4, b3, b2, b1, a21, a31, a32, a41, a42, a43&gt; := PolynomialRing(K, 11);
&gt; I := ideal&lt;P |
&gt;    b1 + b2 + b3 + b4 - 1,
&gt;    b2*c2 + b3*c3 + b4*c4 - 1/2,
&gt;    b2*c2^2 + b3*c3^2 + b4*c4^2 - 1/3,
&gt;    b3*a32*c2 + b4*a42*c2 + b4*a43*c3 - 1/6,
&gt;    b2*c2^3 + b3*c3^3 + b4*c4^3 - 1/4,
&gt;    b3*c3*a32*c2 + b4*c4*a42*c2 + b4*c4*a43*c3 - 1/8,
&gt;    b3*a32*c2^2 + b4*a42*c2^2 + b4*a43*c3^2 - 1/12,
&gt;    b4*a43*a32*c2 - 1/24,
&gt;    c2 - a21,
&gt;    c3 - a31 - a32,
&gt;    c4 - a41 - a42 - a43&gt;;
&gt; time Groebner(I);
Time: 0.110
&gt; I;
Ideal of Polynomial ring of rank 11 over Multivariate rational function field
    of rank 2 over Integer Ring
Order: Lexicographical
Variables: c4, b4, b3, b2, b1, a21, a31, a32, a41, a42, a43
Inhomogeneous, Dimension 0
Groebner basis:
[
    c4 - 1,
    b4 + (-6*c2*c3 + 4*c2 + 4*c3 - 3)/(12*c2*c3 - 12*c2 - 12*c3 + 12),
    b3 + (2*c2 - 1)/(12*c2*c3^2 - 12*c2*c3 - 12*c3^3 + 12*c3^2),
    b2 + (-2*c3 + 1)/(12*c2^3 - 12*c2^2*c3 - 12*c2^2 + 12*c2*c3),
    b1 + (-6*c2*c3 + 2*c2 + 2*c3 - 1)/(12*c2*c3),
    a21 - c2,
    a31 + (-4*c2^2*c3 + 3*c2*c3 - c3^2)/(4*c2^2 - 2*c2),
    a32 + (-c2*c3 + c3^2)/(4*c2^2 - 2*c2),
    a41 + (-12*c2^2*c3^2 + 12*c2^2*c3 - 4*c2^2 + 12*c2*c3^2 - 15*c2*c3 + 6*c2 - 
        4*c3^2 + 5*c3 - 2)/(12*c2^2*c3^2 - 8*c2^2*c3 - 8*c2*c3^2 + 6*c2*c3),
    a42 + (-c2^2 + 4*c2*c3^2 - 5*c2*c3 + 3*c2 - 4*c3^2 + 5*c3 - 2)/(12*c2^3*c3 -
        8*c2^3 - 12*c2^2*c3^2 + 6*c2^2 + 8*c2*c3^2 - 6*c2*c3),
    a43 + (-2*c2^2*c3 + 2*c2^2 + 3*c2*c3 - 3*c2 - c3 + 1)/(6*c2^2*c3^2 - 
        4*c2^2*c3 - 6*c2*c3^3 + 3*c2*c3 + 4*c3^3 - 3*c3^2)
]
</PRE>
<HR>
<H3><A NAME = "13513">Example <TT>GB_SolveOverGF2 (H111E5)</TT></A></H3>
We demonstrate how one can solve a system of multivariate equations
over GF(2).
<P>
We construct a sequence B of 4 polynomials in 5 variables, and
note that the Gr&ouml;bner basis of B contains monomials having degrees
greater than 1.
<P>
<P>
<PRE>
&gt; P&lt;a,b,c,d,e&gt; := PolynomialRing(GF(2), 5);
&gt; B := [a*b + c*d + 1, a*c*e + d*e, a*b*e + c*e, b*c + c*d*e + 1];
&gt; GroebnerBasis(B);
[
    a + c^2*d + c + d^2*e,
    b*c + d^3*e^2 + d^3*e + d^2*e^2 + d*e + e + 1,
    b*e + d*e^2 + d*e + e,
    c*e + d^3*e^2 + d^3*e + d^2*e^2 + d*e,
    d^4*e^2 + d^4*e + d^3*e + d^2*e^2 + d^2*e + d*e + e
]
</PRE>
If one wanted to consider solutions over an algebraic closure of GF(2),
then one would have to work with this ideal.  But to solve over GF(2)
itself, one can add the <I>field polynomials</I> a<sup>2</sup> + a, b<sup>2</sup> + b, etc.
Magma recognizes these extra polynomials and uses an optimized
representation; this makes the computation much faster for larger examples.
The resulting polynomials (besides any remaining field polynomials) will always 
have degree at most 1 in each variable.
In this example, we see that there are 2 solutions over GF(2) for
the system.
<P>
<P>
<PRE>
&gt; L := [P.i^2 + P.i: i in [1 .. Rank(P)]];
&gt; BB := B cat L;
&gt; BB;
[
    a*b + c*d + 1,
    a*c*e + d*e,
    a*b*e + c*e,
    b*c + c*d*e + 1,
    a^2 + a,
    b^2 + b,
    c^2 + c,
    d^2 + d,
    e^2 + e
]
&gt; GroebnerBasis(BB);
[
    a + d + 1,
    b + 1,
    c + 1,
    d^2 + d,
    e
]
&gt; I := ideal&lt;P|BB&gt;;             
&gt; Variety(I);
[ &lt;0, 1, 1, 1, 0&gt;, &lt;1, 1, 1, 0, 0&gt; ]
</PRE>
Since V2.15, an alternative way to solve the system over GF(2)
is to use the boolean polynomial ring type as follows.
<P>
<P>
<PRE>
&gt; P&lt;a,b,c,d,e&gt; := BooleanPolynomialRing(5, "grevlex");
&gt; B := [a*b + c*d + 1, a*c*e + d*e, a*b*e + c*e, b*c + c*d*e + 1];
&gt; I := Ideal(B);
&gt; I;
Ideal of Boolean polynomial ring of rank 5 over GF(2)
Order: Graded Reverse Lexicographical (bit vector word)
Variables: a, b, c, d, e
Basis:
[
    a*b + c*d + 1,
    a*c*e + d*e,
    a*b*e + c*e,
    c*d*e + b*c + 1
]
&gt; GroebnerBasis(I);
[
    a + d + 1,
    b + 1,
    c + 1,
    e
]
&gt; Variety(I);
[ &lt;0, 1, 1, 1, 0&gt;, &lt;1, 1, 1, 0, 0&gt; ]
</PRE>
In general, if one wishes to solve a system over GF(2) from the
outset, it is best to use the boolean polynomial ring type so
as to save memory (and to avoid internal conversion to and from the
bit vector representation for monomials).   Note also that because of
the implicit field relations, the Gr&ouml;bner basis of an ideal generated by
only one polynomial may have several polynomials.  In the following example,
the Gr&ouml;bner basis of an ideal generated by just one polynomial
has linear polynomials alone.
<P>
<P>
<PRE>
&gt; R&lt;[x]&gt; := BooleanPolynomialRing(10, "grevlex");
&gt; R;
Boolean polynomial ring of rank 10 over GF(2)
Order: Graded Reverse Lexicographical (bit vector word)
Variables: x[1], x[2], x[3], x[4], x[5], x[6], x[7], x[8], x[9], x[10]
&gt; f := x[2]*x[3]*x[5]*x[7] + x[2]*x[4]*x[5]*x[8] + x[3]*x[4]*x[5]*x[9] + 
&gt;    x[3]*x[6]*x[7]*x[9] + x[2]*x[3]*x[5] + x[2]*x[4]*x[5] + x[2]*x[3]*x[7] +
&gt;    x[2]*x[5]*x[7] + x[3]*x[5]*x[7] + x[3]*x[6]*x[7] + x[2]*x[4]*x[8] + 
&gt;    x[2]*x[5]*x[8] + x[4]*x[5]*x[8] + x[3]*x[6]*x[9] + x[3]*x[7]*x[9] + 
&gt;    x[6]*x[7]*x[9] + x[2]*x[3] + x[2]*x[4] + x[3]*x[5] + x[4]*x[5] + 
&gt;    x[3]*x[6] + x[2]*x[7] + x[5]*x[7] + x[6]*x[7] + x[2]*x[8] + x[4]*x[8] + 
&gt;    x[5]*x[8] + x[3]*x[9] + x[6]*x[9] + x[7]*x[9] + x[1]*x[10] + x[1] + x[4]
&gt;    + x[6] + x[8] + x[9] + x[10];
&gt; I := Ideal([f]);
&gt; G := GroebnerBasis(I);
&gt; #G;
38
&gt; [Length(f): f in G];
[ 188, 50, 80, 82, 26, 22, 20, 26, 20, 20, 26, 32, 8, 8, 8, 8, 32, 32, 8, 8, 8, 
8, 8, 8, 8, 8, 8, 32, 8, 8, 8, 8, 40, 5, 8, 8, 8, 8 ]
&gt; G[38];
x[1]*x[4]*x[7]*x[10] + x[1]*x[5]*x[7]*x[10] + x[1]*x[4]*x[7] + x[1]*x[5]*x[7] + 
    x[4]*x[7]*x[10] + x[5]*x[7]*x[10] + x[4]*x[7] + x[5]*x[7]
</PRE>
<HR>
<H3><A NAME = "13514">Example <TT>GB_GBoverZ (H111E6)</TT></A></H3>
This simple example illustrates some of the peculiarities of
Gr&ouml;bner bases over Euclidean rings.  We first create
a simple ideal I in Z[x, y, z] and compute its Gr&ouml;bner basis.
<P>
<P>
<PRE>
&gt; P&lt;x, y, z&gt; := PolynomialRing(IntegerRing(), 3);
&gt; I := ideal&lt;P| x^2 - 1, y^2 - 1, 2*x*y - z&gt;;
&gt; GroebnerBasis(I);
[
    x^2 - 1,
    x*z - 2*y,
    2*x - y*z,
    y^2 - 1,
    z^2 - 4
]
</PRE>
Notice that the Gr&ouml;bner basis contains polynomials whose leading
terms are x<sup>2</sup>, xz and 2x, but the third cannot eliminate the
first two since the leading coefficient 2 does not divide the other
leading coefficients 1 and 1.
<P>
<P>
<P>
When we compute normal forms modulo I, x is clearly
not reducible by any polynomial, while 2x can be reduced by
the 2x - yz polynomial.
<P>
<P>
<PRE>
&gt; NormalForm(x, I);  
x
&gt; NormalForm(2*x, I);
y*z
</PRE>
If we compute the normal form of ( - x) modulo I, then even though the
x monomial cannot be reduced, the result is NOT the negative of
the normal form of x, since one can use the 2x - yz polynomial
and the fact that (( - 1) mod 2) is 1 to reduce the polynomial
to a unique normal form.
This behaviour differs from that for ideals defined
over fields, where the normal form of -f will always be the negative
of the normal form of f.
<P>
<P>
<PRE>
&gt; NormalForm(-x, I); 
x - y*z
</PRE>
If we reduce the Gr&ouml;bner basis modulo various primes, we obtain
familiar Gr&ouml;bner bases over fields:
<P>
<P>
<PRE>
&gt; GroebnerBasis(ChangeRing(I, GF(2)));
[
    x^2 + 1,
    y^2 + 1,
    z
]
&gt; GroebnerBasis(ChangeRing(I, GF(3)));
[
    x + y*z,
    y^2 + 2,
    z^2 + 2
]
</PRE>
But if we reduce modulo 4, using the ring of integers modulo 4, then
the Gr&ouml;bner basis still has a structure not encountered when working
over fields:
<P>
<P>
<PRE>
&gt; GroebnerBasis(ChangeRing(I, IntegerRing(4)));
[
    x^2 + 3,
    x*z + 2*y,
    2*x + y*z,
    y^2 + 3,
    z^2,
    2*z
]
</PRE>
In fact, the new polynomial 2z has been included in this Gr&ouml;bner basis.
<HR>
<H3><A NAME = "13515">Example <TT>GB_FindingPrimes (H111E7)</TT></A></H3>
This example shows how one can use Gr&ouml;bner bases over the integers
to find the primes modulo which a system of equations has a solution,
when the system has no solutions over the rationals.
<P>
<P>
<P>
We first form a certain ideal I in Z[x, y, z], and note
that the Gr&ouml;bner basis of I over Q contains 1, so there
are no solutions over Q or an algebraic closure of it
(this is not surprising as there are 4 equations in 3 unknowns).
<P>
<P>
<PRE>
&gt; P&lt;x, y, z&gt; := PolynomialRing(IntegerRing(), 3);
&gt; I := ideal&lt;P | x^2 - 3*y, y^3 - x*y, z^3 - x, x^4 - y*z + 1&gt;;
&gt; GroebnerBasis(ChangeRing(I, RationalField()));
[
    1
]
</PRE>
However, when we compute the Gr&ouml;bner basis of I (defined over Z),
we note that there is a certain integer in the ideal which is not 1.
<P>
<P>
<PRE>
&gt; GroebnerBasis(I);                               
[
    x + 170269749119,
    y + 2149906854,
    z + 170335012540,
    282687803443
]
</PRE>
Now for each prime p dividing this integer 282687803443, the
Gr&ouml;bner basis of I modulo p will be non-trivial and will
thus give a solution of the original system modulo p.
<P>
<P>
<PRE>
&gt; Factorization(282687803443);
[ &lt;101, 1&gt;, &lt;103, 1&gt;, &lt;27173681, 1&gt; ]
&gt; GroebnerBasis(ChangeRing(I, GF(101)));
[
    x + 19,
    y + 48,
    z + 68
]
&gt; GroebnerBasis(ChangeRing(I, GF(103)));
[
    x + 39,
    y + 8,
    z + 85
]
&gt; GroebnerBasis(ChangeRing(I, GF(27173681)));
[
    x + 26637654,
    y + 3186055,
    z + 10380032
]
</PRE>
Of course, modulo any other prime the Gr&ouml;bner basis is trivial so
there are no other solutions.  For example:
<P>
<P>
<PRE>
&gt; GroebnerBasis(ChangeRing(I, GF(3)));
[
    1
]
</PRE>
Note that the problem can also be solved by using resultants,
but this may yield many extraneous potential primes, while
the Gr&ouml;bner basis technique yields the exact list of primes
for which there are modular solutions.
<HR>
<H3><A NAME = "13516">Example <TT>GB_QuadraticOrderGB (H111E8)</TT></A></H3>
This example shows how one can effectively compute in Magma
with Gr&ouml;bner bases over a ring which is not Euclidean (and may not
even be a principal ideal ring), by starting with Z and adding
appropriate defining relations.  The input for this example is based on
<A  HREF = "text1202.htm#bib_AdamsLoustaunau">[AL94, Ex. 4.2.13]</A>.
<P>
<P>
<P>
Let R = Z[Sqrt( - 5)].  R is the maximal order of Q(Sqrt( - 5))
and is <B>NOT</B> a PIR.  We consider the ideal I of R[x, y] generated
by f<sub>1</sub> = 2xy + Sqrt( - 5)y and f<sub>2</sub> = (1 + Sqrt( - 5))x<sup>2</sup> - xy.
To work over R, we simply compute over Z, introduce a new
variable S to represent Sqrt( - 5), make sure that S is less
than both x and y in the monomial order,
and include the polynomial (S<sup>2</sup> + 5) in the ideal I.
We then print out the Gr&ouml;bner basis of I.
<P>
<P>
<PRE>
&gt; P&lt;x, y, S&gt; := PolynomialRing(IntegerRing(), 3);
&gt; f1 := 2*x*y + S*y;          
&gt; f2 := (1 + S)*x^2 - x*y;
&gt; I := ideal&lt;P | f1, f2, S^2 + 5&gt;;
&gt; GroebnerBasis(I);
[
    x^2*S + x^2 + 5*y^3 + 13*y*S - 25*y,
    6*x^2 + 5*y^2 + 3*y*S - 10*y,
    x*y + 5*y^3 + 13*y*S - 25*y,
    y^2*S + 5*y^2 - 15*y,
    10*y^2 + 5*y*S - 25*y,
    S^2 + 5
]
</PRE>
In <A  HREF = "text1202.htm#bib_AdamsLoustaunau">[AL94, p. 224]</A>, a (weak) Gr&ouml;bner basis for the ideal
is given as {f<sub>2</sub>, f<sub>5</sub>, f<sub>7</sub>, f<sub>9</sub>}, where
f<sub>5</sub> = (5 + Sqrt( - 5))y<sup>2</sup> - 15y,
f<sub>7</sub> = - 2Sqrt( - 5)y<sup>2</sup> + 5(1 + Sqrt( - 5))y, and
f<sub>9</sub> = xy + Sqrt( - 5)y<sup>3</sup> - 5Sqrt( - 5)y<sup>2</sup> + 8Sqrt( - 5)y.
We can easily verify that the ideal J generated by these 4 polynomials
describes the same ideal as I (and so has the same Gr&ouml;bner basis
in Magma).
<P>
<P>
<PRE>
&gt; f5 := (5 + S)*y^2 - 15*y;
&gt; f7 := -2*S*y^2 + (5 + 5*S)*y;
&gt; f9 := x*y + S*y^3 - 5*S*y^2 + 8*S*y;
&gt; J := ideal&lt;P |  f2, f5, f7, f9, S^2 + 5&gt;;
&gt; I eq J;
true
&gt; GroebnerBasis(I) eq GroebnerBasis(J);
true
</PRE>
We can even write f<sub>5</sub>, f<sub>7</sub> and f<sub>9</sub> as combinations of the Gr&ouml;bner
basis elements of I, as follows.
<P>
<P>
<PRE>
&gt; Coordinates(I, f5);
[
    0, 0, 0, 1, 0, 0
]
&gt; Coordinates(I, f7);
[
    0, 0, 0, -2, 1, 0
]
&gt; Coordinates(I, f9);
[
    0, 0, 1, y, -y - 1, 0
]
</PRE>
We can see that these elements are fairly trivially derived from the
Gr&ouml;bner basis which Magma computes for I.
But if we now create J again using the <A  HREF = "text1206.htm#GB:IdealWithFixedBasis">IdealWithFixedBasis</A>
function and the sequence
Q = [f<sub>2</sub>, f<sub>5</sub>, f<sub>7</sub>, f<sub>9</sub>, S<sup>2</sup> + 5],
then we can see the coordinates of any element 
of I=J as a linear combination of the elements of Q.
We find the coordinates of the second element
of Magma's original Gr&ouml;bner basis of I with respect to Q.
The resulting coordinates are rather non-trivial.
<P>
<P>
<PRE>
&gt; Q := [f2, f5, f7, f9, S^2 + 5];         
&gt; J := IdealWithFixedBasis(Q);                        
&gt; J eq I;
true
&gt; g := GroebnerBasis(I)[2];
&gt; g;
6*x^2 + 5*y^2 + 3*y*S - 10*y
&gt; C := Coordinates(J, g);
&gt; C;
[
    -S + 1,
    -5*y + 1,
    -x - y^2*S + 7*y*S - 2*y - 7*S - 2,
    -2*y*S + 4*S + 6,
    x^2 + 5*y^3 - 13*y^2 + 3*y
]
</PRE>
We check that multiplying out the expression recovers g.
<P>
<P>
<PRE>
&gt; &amp;+[C[i]*Q[i]: i in [1 .. #C]] eq g;
true
</PRE>
Note that in the terminology of Adams and Loustaunau, Magma is here
computing a "strong" Gr&ouml;bner basis (for this representation which
uses an extra variable for Sqrt( - 5)), while these authors show that
{f<sub>2</sub>, f<sub>5</sub>, f<sub>7</sub>, f<sub>9</sub>} constitutes a "weak" Gr&ouml;bner basis for I
over the ring Z[Sqrt( - 5)].  The fact that the coordinates of g
with respect to Q are rather non-trivial shows that Magma's strong
Gr&ouml;bner basis computation has computed a lot more information than
the weak Gr&ouml;bner basis (i.e., g, which must be included in the
strong Gr&ouml;bner basis, is not trivially derived from Q).
<P>
<P>
<P>
Most importantly of all, the fact that we have done all this by defining
things over Z with the extra variable S has been no less
powerful: we can still do full membership testing, normal forms,
coordinate computations, etc. with this representation.
Also, see below for an elimination computation which continues this example.
<P>
<P>
<P>
Gr&ouml;bner bases over very many other general rings can be
effectively handled in just the same way as that presented in this example!
For example, if we need &alpha; = (1 + Sqrt(5))/2, we can introduce a
variable new A and the polynomial (2A - 1)<sup>2</sup> - 5.
<HR>
<H3><A NAME = "13517">Example <TT>GB_Coordinates (H111E9)</TT></A></H3>
We construct an ideal I of the polynomial ring P = Q[x, y]
with a specific fixed basis S, determine that I
is the full polynomial ring P, and then find coordinates of the polynomial
1 of P with respect to S.  Note that we use the function
<A  HREF = "text1206.htm#GB:IdealWithFixedBasis">IdealWithFixedBasis</A>
to construct the ideal so that the fixed basis will be remembered.
<P>
<P>
<PRE>
&gt; P&lt;x, y&gt; := PolynomialRing(RationalField(), 2);
&gt; S := [x^2 - y, x^3 + y^2, x*y^3 - 1];       
&gt; I := IdealWithFixedBasis(S);                              
&gt; 1 in I;
true
&gt; C := Coordinates(I, P!1);
&gt; C;
[
    -1/2*x^2*y^3 - 1/2*x^2*y^2 + 1/2*x^2*y + 1/2*x^2 + 1/2*x*y^3 +
        1/2*x*y^2 - 1/2*x*y - 1/2*y^4 - 1/2*y^3 + 1/2*y^2 + 1/2*y,
    1/2*x*y^3 + 1/2*x*y^2 - 1/2*x*y - 1/2*x - 1/2*y^3 - 1/2*y^2 + 1/2*y,
    -1/2*y^2 + 1
]
</PRE>
Now we check that multiplying out by the coordinates gives 1.
<P>
<P>
<PRE>
&gt; C[1]*S[1] + C[2]*S[2] + C[3]*S[3];
1
</PRE>
Now we move the problem to being over the integer ring Z.
<P>
<P>
<PRE>
&gt; P&lt;x, y&gt; := PolynomialRing(IntegerRing(), 2);
&gt; S := [x^2 - y, x^3 + y^2, x*y^3 - 1];       
&gt; I := IdealWithFixedBasis(S);                              
&gt; 1 in I;
false
&gt; GroebnerBasis(I);
[
    x + 1,
    y + 1,
    2
]
</PRE>
We note that 1 is not in the ideal this time, but 2 is!  So we compute
the coordinates of 2 with respect to I this time.
<P>
<P>
<PRE>
&gt; C := Coordinates(I, P!2);
&gt; C;
[
    x^2*y^2 - x^2*y - x^2 - x*y^2 + x*y + x + y^4 + y^3 - y^2 - y - 1,
    -x*y^2 + x*y + x + y^3 + y^2 - y - 1,
    -x^2 - x*y + y - 2
]
</PRE>
Note that C is the same as above, except that each polynomial has
been scaled by 2 to make it integral.
Finally we check again that multiplying out by the coordinates gives 2.
<P>
<P>
<PRE>
&gt; C[1]*S[1] + C[2]*S[2] + C[3]*S[3];
2
</PRE>
Incidentally, we can see from the Gr&ouml;bner basis of I over Z
that the only solution to the system of equations described by S
is the local solution x=y=1 over GF(2).
<HR>
<H3><A NAME = "13518">Example <TT>GB_ValuationRing (H111E10)</TT></A></H3>
Gr&ouml;bner bases can be constructed over any exact Euclidean ring in Magma,
not just the ring of integers and its residue class rings.
<P>
We construct an ideal I of the polynomial ring P = Q[x, y]
with a specific fixed basis S, determine that I
is the full polynomial ring P, and then find coordinates of the polynomial
1 of P with respect to S.  Note that we use the function
<A  HREF = "text1206.htm#GB:IdealWithFixedBasis">IdealWithFixedBasis</A>
to construct the ideal so that the fixed basis will be remembered.
<P>
<P>
<PRE>
&gt; P&lt;x, y&gt; := PolynomialRing(RationalField(), 2);
&gt; S := [x^2 - y, x^3 + y^2, x*y^3 - 1];       
&gt; I := IdealWithFixedBasis(S);                              
&gt; 1 in I;
true
&gt; C := Coordinates(I, P!1);
&gt; C;
[
    -1/2*x^2*y^3 - 1/2*x^2*y^2 + 1/2*x^2*y + 1/2*x^2 + 1/2*x*y^3 +
        1/2*x*y^2 - 1/2*x*y - 1/2*y^4 - 1/2*y^3 + 1/2*y^2 + 1/2*y,
    1/2*x*y^3 + 1/2*x*y^2 - 1/2*x*y - 1/2*x - 1/2*y^3 - 1/2*y^2 + 1/2*y,
    -1/2*y^2 + 1
]
</PRE>
Now we check that multiplying out by the coordinates gives 1.
<P>
<P>
<PRE>
&gt; C[1]*S[1] + C[2]*S[2] + C[3]*S[3];
1
</PRE>
Now we move the problem to being over the integer ring Z.
<P>
<P>
<PRE>
&gt; P&lt;x, y&gt; := PolynomialRing(IntegerRing(), 2);
&gt; S := [x^2 - y, x^3 + y^2, x*y^3 - 1];       
&gt; I := IdealWithFixedBasis(S);                              
&gt; 1 in I;
false
&gt; GroebnerBasis(I);
[
    x + 1,
    y + 1,
    2
]
</PRE>
We note that 1 is not in the ideal this time, but 2 is!  So we compute
the coordinates of 2 with respect to I this time.
<P>
<P>
<PRE>
&gt; C := Coordinates(I, P!2);
&gt; C;
[
    x^2*y^2 - x^2*y - x^2 - x*y^2 + x*y + x + y^4 + y^3 - y^2 - y - 1,
    -x*y^2 + x*y + x + y^3 + y^2 - y - 1,
    -x^2 - x*y + y - 2
]
</PRE>
Note that C is the same as above, except that each polynomial has
been scaled by 2 to make it integral.
Finally we check again that multiplying out by the coordinates gives 2.
<P>
<P>
<PRE>
&gt; C[1]*S[1] + C[2]*S[2] + C[3]*S[3];
2
</PRE>
Incidentally, we can see from the Gr&ouml;bner basis of I over Z
that the only solution to the system of equations described by S
is the local solution x=y=1 over GF(2).
<HR>
<H4><A NAME = "13519">Degree-d Gr&ouml;bner Bases</A></H4>



<H5><A NAME = "13520">GroebnerBasis(S, d : parameters) : [ RngMPolElt ], RngInt -&gt; RngMPolElt</A></H5>
<BLOCKQUOTE>
Given a set or sequence S of polynomials from a graded polynomial ring P,
return the weighted degree-d Gr&ouml;bner 
basis of the ideal generated by S, which is the truncated Gr&ouml;bner basis
obtained by ignoring S-polynomial pairs whose weighted degree (with
respect to the grading on P) is greater than d.
<P>
If the ideal is homogeneous, then it is guaranteed that the result
is equal to the set of all polynomials in the full Gr&ouml;bner basis of
the ideal whose weighted degree is less than or equal to d, and
a polynomial whose weighted degree is less than or equal to d is in
the ideal iff its normal form with respect to this truncated basis
is zero.   But if the ideal is not homogeneous, these last properties
may not hold, but it may be still useful to construct the truncated
basis.
<P>
The parameters are the same as those for the procedure <A  HREF = "text1207.htm#GB:Groebner">Groebner</A>.
See also <A  HREF = "text1202.htm#bib_BeckerWeispfenning">[BW93, section 10.2]</A> for further discussion.
Note that the base ring may be a field or Euclidean ring.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "13521">Example <TT>GB_Degree-d (H111E11)</TT></A></H3>
We create a graded polynomial ring and compute the degree-d Gr&ouml;bner
basis of a sequence L of homogeneous polynomials for various d.
Since the polynomials are homogeneous (with respect to the grading),
we check that the result for each d contains the set of
all polynomials in the full Gr&ouml;bner basis of L having
weighted degree less than or equal to d.
<P>
<P>
<PRE>
&gt; P&lt;a,b,c,d&gt; := PolynomialRing(RationalField(), [4,3,2,1]);
&gt; L := [a*b - c^2*d^3, b*c*d + c^3, c^2*d - d^5, a*d - b*c];
&gt; [IsHomogeneous(f): f in L];
[ true, true, true, true ]
&gt; [Degree(f): f in L];
[ 7, 6, 5, 5 ]
&gt; G:=GroebnerBasis(L);
&gt; G;
[
    a*b - d^7,
    a*c^3 + d^10,
    a*d - b*c,
    b^2*c - d^8,
    b*c^3 + d^9,
    b*c*d + c^3,
    b*d^5 + c^4,
    c^5 - d^10,
    c^2*d - d^5,
    c*d^7 - d^9
]
&gt; #G;
10
&gt; [Degree(f): f in G];
[ 7, 10, 5, 8, 9, 6, 8, 10, 5, 9 ]
&gt; for D := 1 to 10 do
&gt;     T := GroebnerBasis(L, D);
&gt;     printf "D = %o, #GB = %o, contains all degree-D polynomials: %o\n",
&gt;         D, #T, {f: f in G | Degree(f) le D} subset T;
&gt; end for;
D = 1, #GB = 4, contains all degree-D polynomials: true
D = 2, #GB = 4, contains all degree-D polynomials: true
D = 3, #GB = 4, contains all degree-D polynomials: true
D = 4, #GB = 4, contains all degree-D polynomials: true
D = 5, #GB = 4, contains all degree-D polynomials: true
D = 6, #GB = 4, contains all degree-D polynomials: true
D = 7, #GB = 4, contains all degree-D polynomials: true
D = 8, #GB = 6, contains all degree-D polynomials: true
D = 9, #GB = 8, contains all degree-D polynomials: true
D = 10, #GB = 10, contains all degree-D polynomials: true
&gt; GroebnerBasis(L, 5);
[
    a*b - d^7,
    a*d - b*c,
    b*c*d + c^3,
    c^2*d - d^5
]
&gt; GroebnerBasis(L, 8);
[
    a*b - d^7,
    a*d - b*c,
    b^2*c - d^8,
    b*c*d + c^3,
    b*d^5 + c^4,
    c^2*d - d^5
]
</PRE>
<HR>
<PRE></PRE> <A  HREF = "text1208.htm">[Next]</A><A  HREF = "text1206.htm">[Prev]</A> <A  HREF = "text1208.htm">[Right]</A> <A  HREF = "text1206.htm">[Left]</A> <A  HREF = "text1203.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<br><small>Version: V2.22 of <I>
Thu Jun  9 16:37:49 EST 2016
</I></small>
</body></html>