<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <link rel='stylesheet' href='help.css' type='text/css'>
  <TITLE>Cocycles</TITLE>
</head>
<body BGCOLOR="#FFFFFF">

 <A  HREF = "text779.htm">[Next]</A><A  HREF = "text777.htm">[Prev]</A> <A  HREF = "text779.htm">[Right]</A> <A  HREF = "text777.htm">[Left]</A> <A  HREF = "text773.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<PRE></PRE><H3><A NAME = "8835">Cocycles</A></H3>

<P>
<P>
<P>
Before invoking the functions in this section, it is necessary to first 
invoke the function <TT>CohomologyGroup(CM, n)</TT> for the appropriate n.
<P>
For n = 0, 1 or 2, an <I>n-cocycle</I> is a function
from G<sup>n</sup> to the module M, where elements of G<sup>n</sup> are represented
as an n-tuple &lt; g<sub>1</sub>, ..., g<sub>n</sub> &gt; of group elements,
for which a certain relation is satisfied.
These relations are consistent with the Magma convention of the use of
right actions, and so they are slightly different from those encountered
in many textbooks, where left actions are more common. 
<P>
0-, 1- and 2-cocycles z, o and t, respectively, satisfy the
following relations for all g, h, &isin;G.
z(&lt; &gt;)<sup>g</sup> = z(&lt; &gt;); 
 o(&lt; gh &gt;) = o(&lt; g &gt;)<sup>h</sup> + o(&lt; h &gt;); 
 t(&lt; gh, k &gt;) + t(&lt; g, h &gt;)<sup>k</sup> 
= t(&lt; g, hk &gt;) + t(&lt; h, k &gt;) .


<H5><A NAME = "8836">ZeroCocycle(CM, s) : ModCoho, SeqEnum -&gt; UserProgram</A></H5>
<H5>ZeroCocycle(CM, s) : ModCoho, ModTupRngElt -&gt; UserProgram</H5>
<BLOCKQUOTE>
Given a cohomology module CM constructed from the K[G]-module M 
and an element s of the cohomology group H<sup>0</sup>(G, M) associated with 
CM, this function returns the corresponding zero-cocycle. The 
zero-cocycle is returned as a function of the 0-tuple &lt; &gt;,
of which the image is an element of the fixed point submodule of M. 
The argument s may either be given as an element of H<sup>0</sup>(G, M) or 
as a sequence of integers defining such an element. 
</BLOCKQUOTE>
<H5><A NAME = "8837">IdentifyZeroCocycle(CM, s) : ModCoho, UserProgram -&gt; ModTupRngElt</A></H5>
<H5>IdentifyZeroCocycle(CM, s) : ModCoho, UserProgram -&gt; ModTupRngElt</H5>
<BLOCKQUOTE>
Given a cohomology module CM constructed from the K[G]-module M 
and a zero-cocycle given as a function of the 0-tuple &lt; &gt;,
of which the image is an element of the fixed point submodule of M,
this function returns the corresponding element of H<sup>0</sup>(G, M).
Hence this function is the inverse function to <TT>ZeroCocycle</TT>.  
</BLOCKQUOTE>
<H5><A NAME = "8838">OneCocycle(CM, s) : ModCoho, SeqEnum -&gt; UserProgram</A></H5>
<H5>OneCocycle(CM, s) : ModCoho, ModTupRngElt -&gt; UserProgram</H5>
<BLOCKQUOTE>
Given a cohomology module CM constructed from the K[G]-module M 
and an element s of the cohomology group H<sup>1</sup>(G, M) associated with 
CM, the function returns a corresponding one-cocycle. The one-cocycle 
is returned as a function from G to the module M, where elements
g of G are represented as 1-tuples &lt; g &gt;.
The argument s may either be given as an element of H<sup>1</sup>(G, M) or as a
sequence of integers defining such an element. 
</BLOCKQUOTE>
<H5><A NAME = "8839">IdentifyOneCocycle(CM, s) : ModCoho, UserProgram -&gt; ModTupRngElt</A></H5>
<BLOCKQUOTE>
Given a cohomology module CM constructed from the K[G]-module M 
and a one-cycle s for CM, specified as a function from G to the 
module M (where elements g of G are represented as 1-tuples
&lt; g &gt;), this function returns the corresponding
element of H<sup>1</sup>(G, M). Thus, the function is the inverse to <TT>OneCocycle</TT>. 
</BLOCKQUOTE>
<H5><A NAME = "8840">IsOneCoboundary(CM, s) : ModCoho, UserProgram -&gt; BoolElt, UserProgram</A></H5>
<BLOCKQUOTE>
Given a cohomology module CM constructed from the K[G]-module M
and a one-cycle s for CM, specified as a function from G to the
module M (where elements g of G are represented as 1-tuples
&lt; g &gt;), this function determines whether the cocyle is
a 1-coboundary; that is, whether it corresponds to the zero element of
H<sup>1</sup>(G, M). If so, then it also returns a corresponding 0-cochain
t(&lt; &gt;)
that satisfies s(&lt; g &gt;) = t(&lt; &gt;) -
t(&lt; &gt;)<sup>g</sup> for all g &isin;G.
</BLOCKQUOTE>
<H5><A NAME = "8841">TwoCocycle(CM, s) : ModCoho, SeqEnum -&gt; UserProgram</A></H5>
<H5>TwoCocycle(CM, s) : ModCoho, ModTupRngElt -&gt; UserProgram</H5>
<BLOCKQUOTE>
Given a cohomology module CM constructed from the K[G]-module M 
and an element s of the cohomology group H<sup>2</sup>(G, M) associated with 
CM, the function returns a corresponding two-cocycle. The two-cocycle 
is returned as a function from G x G to the module M, where
elements of G x G are represented as 2-tuples
&lt; g<sub>1</sub>, g<sub>2</sub> &gt;. The argument s may either be given as an element
of H<sup>2</sup>(G, M) or as a sequence of integers defining such an element. 
</BLOCKQUOTE>
<H5><A NAME = "8842">IdentifyTwoCocycle(CM, s) : ModCoho, UserProgram -&gt; ModTupRngElt</A></H5>
<BLOCKQUOTE>
Given a cohomology module CM constructed from the K[G]-module M 
and a two-cycle s for CM, specified as a function from G x G 
to the module M (where elements of G x G are represented as 2-tuples
&lt; g<sub>1</sub>, g<sub>2</sub> &gt;), this function returns the corresponding
element of H<sup>2</sup>(G, M).  Thus, the function is the inverse to <TT>TwoCocycle</TT>. 
</BLOCKQUOTE>
<H5><A NAME = "8843">IsTwoCoboundary(CM, s) : ModCoho, UserProgram -&gt; BoolElt, UserProgram</A></H5>
<BLOCKQUOTE>
Given a cohomology module CM constructed from the K[G]-module M
and a two-cycle s for CM, specified as a function from G to the
module M (where elements of G x G are represented as 2-tuples
&lt; g<sub>1</sub>, g<sub>2</sub> &gt;), this function determines whether the cocyle is
a 2-coboundary; that is, whether it corresponds to the zero element of
H<sup>2</sup>(G, M). If so, then it also returns a corresponding 1-cochain
t(&lt; g &gt;)
that satisfies s(&lt; g, h &gt;) = t(&lt; g &gt;)<sup>h</sup> +
t(&lt; h &gt;) - t(&lt; gh &gt;) for all g, h &isin;G.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "8844">Example <TT>GrpCoh_cocycles (H73E4)</TT></A></H3>
An easy example where the module is an abelian group defined by its invariant 
factors.
<P>
<P>
<P>
<PRE>
&gt; G := PermutationGroup&lt; 4 | (1,2,3,4) &gt;;
&gt; invar:=[2,4,4];
&gt; mats := [ Matrix(Integers(),3,3,[1,2,0,0,0,1,0,1,2]) ];
&gt; X := CohomologyModule(G,invar,mats);
&gt; C := CohomologyGroup(X,0);
&gt; C;
Full Quotient RSpace of degree 1 over Integer Ring
Column moduli:
[ 4 ]
&gt; ZeroCocycle(X,[3]);
function(tp) ... end function
&gt; IdentifyZeroCocycle(X,func&lt;x|-$1(&lt;&gt;)&gt;);
(1)
&gt; C := CohomologyGroup(X,1);
&gt; C;
Full Quotient RSpace of degree 2 over Integer Ring
Column moduli:
[ 2, 2 ]
&gt; z1 := OneCocycle(X,[1,0]);
&gt; z2 := OneCocycle(X,[0,1]);
&gt; z1(&lt;G.1&gt;);
(1 0 0)
&gt; z := func&lt; x | z1(x)+z2(x) &gt;; 
&gt; IdentifyOneCocycle(X,z);
(1 1)
&gt; C := CohomologyGroup(X,2);
&gt; C;
Full Quotient RSpace of degree 1 over Integer Ring
Column moduli:
[ 4 ]
&gt; z1 := TwoCocycle(X,[1]);
&gt; z1(&lt;G.1,G.1^2&gt;);
(1 1 3)
&gt; z := func&lt; xy | z1(xy)+z1(xy) &gt;; 
&gt; IdentifyTwoCocycle(X,z);
(2)
</PRE>
<HR>
<PRE></PRE> <A  HREF = "text779.htm">[Next]</A><A  HREF = "text777.htm">[Prev]</A> <A  HREF = "text779.htm">[Right]</A> <A  HREF = "text777.htm">[Left]</A> <A  HREF = "text773.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<br><small>Version: V2.22 of <I>
Thu Jun  9 16:37:49 EST 2016
</I></small>
</body></html>