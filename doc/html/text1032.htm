<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <link rel='stylesheet' href='help.css' type='text/css'>
  <TITLE>Standard Constructions</TITLE>
</head>
<body BGCOLOR="#FFFFFF">

 <A  HREF = "text1033.htm">[Next]</A><A  HREF = "text1031.htm">[Prev]</A> <A  HREF = "text1033.htm">[Right]</A> <A  HREF = "text1031.htm">[Left]</A> <A  HREF = "text1028.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<PRE></PRE><H3><A NAME = "11639">Standard Constructions</A></H3>

<P>
<P>
Given one or more existing modules, various standard constructions are 
available to construct new modules.



<H5>Subsections</H5>
<UL>
<LI> <A  HREF = "text1032.htm#11640">Changing the Coefficient Ring</A>
<LI> <A  HREF = "text1032.htm#11643">Writing a Module over a Smaller  Field</A>
<LI> <A  HREF = "text1032.htm#11657">Direct Sum</A>
<LI> <A  HREF = "text1032.htm#11660">Tensor Products of K[G]-Modules</A>
<LI> <A  HREF = "text1032.htm#11665">Induction and Restriction</A>
<LI> <A  HREF = "text1032.htm#11671">The Fixed-point Space of a Module</A>
<LI> <A  HREF = "text1032.htm#11673">Changing Basis</A>
</UL>
<H4><A NAME = "11640">Changing the Coefficient Ring</A></H4>

<P>
<P>
In this collection of functions will be found utilities for changing
the base ring of the module. Note that several of the functions for
rewriting over a minimal field are restricted to rings K[G] where
K is a finite field.


<H5><A NAME = "11641">ChangeRing(M, S) : ModRng, Rng -&gt; ModRng, Map</A></H5>
<BLOCKQUOTE>
Given an A-module M with base ring R, together with a ring S, 
such that there is a natural homomorphism from R to S, construct
the module N with base ring S where N is obtained from M by 
coercing the components of the vectors of M into N. The corresponding
homomorphism from M to N is returned as a second value.
</BLOCKQUOTE>
<H5><A NAME = "11642">ChangeRing(M, S, f) : ModRng, Rng, Map -&gt; ModRng, Map</A></H5>
<BLOCKQUOTE>
Given a module M with base ring R, together with a ring S,
and a homomorphism f: R -&gt; S, construct the module N 
with base ring S, where N is obtained from M by applying f 
to the components of the vectors of M. The corresponding 
homomorphism from M to N is returned as a second value.
</BLOCKQUOTE>
<H4><A NAME = "11643">Writing a Module over a Smaller  Field</A></H4>

<P>
<P>
The functions in this section currently only apply to K[G]-modules defined
over a finite field K.


<H5><A NAME = "11644">IsRealisableOverSmallerField(M) : ModGrp -&gt; BoolElt, ModGrp</A></H5>
<BLOCKQUOTE>
Given a K[G]-module M, where K is a finite field, return true if
M can be realised over a proper subfield F of K. The equivalent
F[G]-module is also returned. The Glasby-Howlett algorithm is used 
to determine the smallest field over which M can be realised.
</BLOCKQUOTE>
<H5><A NAME = "11645">IsRealisableOverSubfield(M, F) : ModGrp, FldFin -&gt; BoolElt, ModGrp</A></H5>
<BLOCKQUOTE>
Let M be a K[G]-module, where K is a finite field of characteristic
p, and let F be a finite field also of characteristic p.  If it
is possible to realise M over the subfield F of K, return true and 
the equivalent F[G]-module.
</BLOCKQUOTE>
<H5><A NAME = "11646">WriteOverSmallerField(M, F) : ModGrp, FldFin -&gt; ModGrp, Map</A></H5>
<BLOCKQUOTE>
Given a module M of dimension d over a finite field E having degree e
and a subfield F of E having degree f, write the action of M as
d * e/f by d * e/f matrices over F and return the module and the isomorphism.
</BLOCKQUOTE>
<H5><A NAME = "11647">AbsoluteModuleOverMinimalField(M, F) : ModGrp, FldFin -&gt; ModGrp</A></H5>
<BLOCKQUOTE>
Let M be a K[G]-module, where K is a finite field of characteristic
p, and let F be a finite field also of characteristic p. This
function returns the module obtained by writing M over the smallest 
possible field containing F subject to the condition that the dimension 
of M does not increase. The Glasby-Howlett algorithm is used to determine
the smallest field over which M can be realised.
</BLOCKQUOTE>
<H5><A NAME = "11648">AbsoluteModuleOverMinimalField(M) : ModGrp -&gt; ModGrp</A></H5>

<PRE>    SetVerbose("Reduce", n):            Maximum: 2</PRE>

<PRE>    SetVerbose("Cohomology", n):        Maximum: 2</PRE>

<PRE>    SetVerbose("GrunwaldWang", n):      Maximum: 2</PRE>
<BLOCKQUOTE>
Let M be a K[G]-module, where K is a finite field of characteristic
p or a number field. This
function returns the module obtained by writing M over a field of smallest 
possible degree subject to the condition that the dimension 
of M does not increase. For modules over finite fields, a field of
smallest degree is always a subfield of K, in this case, the Glasby-Howlet
algorithm is used. For number fields, a
different field might be necessary and a combination of Plesken's
method and a constructive version of the Grunwald-Wang theorem is used.
</BLOCKQUOTE>
<H5><A NAME = "11649">Minimize(R) : Map -&gt; Map</A></H5>

<PRE>    All: BoolElt                        Default: <TT>false</TT></PRE>

<PRE>    Char: AlgChtrElt                    Default: <TT>false</TT></PRE>

<PRE>    FindSmallest: BoolElt               Default: <TT>false</TT></PRE>

<PRE>    SetVerbose("Reduce", n):            Maximum: 2</PRE>

<PRE>    SetVerbose("Cohomology", n):        Maximum: 2</PRE>

<PRE>    SetVerbose("GrunwaldWang", n):      Maximum: 2</PRE>
<BLOCKQUOTE>
Let R:G to Gl(n, K) be an absolutely irreducible representation 
over some number field K.
This
function tries to find minimal subfields k of K that afford R,
ie. it tries to write the representation over a smaller field.
In general however, there might be number field k not contained in K
of smaller degree that afford R.
If <TT>All</TT> is given, then instead of a single representation over a minimal
degree subfield of K, a list of representations over all minimal subfields
of K is returned instead.
If <TT>Char</TT> is given, it should be set to the character of the 
representation.
If <TT>FindSmallest</TT> is given, the field K will be extended by some
auxiliary field A such that KA will contain a minimal degree field
affording R. This involves a constructive version of the Grunwald-Wang
theorem and can be computationally expensive if the degree of KA
is too large.
</BLOCKQUOTE>
<H5><A NAME = "11650">AbsoluteModulesOverMinimalField(Q, F) : [ ModGrp ], FldFin -&gt; [ ModGrp ]</A></H5>
<BLOCKQUOTE>
Let Q be a sequence of K[G]-modules, where K is a finite field of 
characteristic p, and let F be a finite field also of characteristic p. 
This function returns the sequence of modules obtained by writing 
each module M of Q over the smallest possible field containing F 
subject to the condition that the dimension of M does 
not increase. Thus, the effect of the function is to apply the
function <TT>AbsoluteModuleOverMinimalField</TT> to each module of Q.
The Glasby-Howlett algorithm is used to determine the smallest field 
over which the modules M of Q can be realised.
</BLOCKQUOTE>
<H5><A NAME = "11651">ModuleOverSmallerField(M, F) : ModGrp, FldFin -&gt; ModGrp</A></H5>
<BLOCKQUOTE>
Let M be a K[G]-module of dimension d, where K is a finite field of 
characteristic p, and let F be a subfield of K of index n. This 
function returns the F[G]-module N obtained by writing the action of 
M as dn x dn matrices over F.
</BLOCKQUOTE>
<H5><A NAME = "11652">ModulesOverSmallerField(Q, F) : SeqEnum, FldFin -&gt; ModGrp</A></H5>
<BLOCKQUOTE>
Let Q be a sequence of K[G]-modules, where K is a finite field of 
characteristic p, and let F be a subfield of K of index n. This 
function returns the sequence R of F[G]-modules obtained by applying
the function <TT>ModuleOverSmallerField</TT> to each term of Q. That is,
each term N of R is formed by writing the action of the corresponding
term of Q as dn x dn matrices over F. 
</BLOCKQUOTE>
<H5><A NAME = "11653">ModulesOverCommonField(M, N) : ModGrp, ModGrp -&gt; ModGrp, ModGrp</A></H5>
<BLOCKQUOTE>
Given K[G]-modules M and N, change their base fields to K, where K is the 
smallest field containing the base fields of M and N.
</BLOCKQUOTE>
<H5><A NAME = "11654">WriteGModuleOver(M, K) : ModGrp, FldAlg -&gt; ModGrp</A></H5>

<PRE>    Char: AlgChtrElt                    Default: <TT>false</TT></PRE>

<PRE>    Subfield: BoolElt                   Default: <TT>false</TT></PRE>

<PRE>    SetVerbose("Reduce", n):            Maximum: 2</PRE>

<PRE>    SetVerbose("Cohomology", n):        Maximum: 2</PRE>

<PRE>    SetVerbose("GrunwaldWang", n):      Maximum: 2</PRE>
<BLOCKQUOTE>
Given a L[G] module M and some number field K, try to write M
over K. If <TT>Char</TT> is specified, it should be set to the character
of this module. If <TT>Subfield</TT> is given, the module will be
rewritten over a minimal degree subfield of K.
</BLOCKQUOTE>
<H5><A NAME = "11655">WriteRepresentationOver(R, K) : Map, FldAlg -&gt; Map</A></H5>

<PRE>    Char: AlgChtrElt                    Default: <TT>false</TT></PRE>

<PRE>    Subfield: BoolElt                   Default: <TT>false</TT></PRE>

<PRE>    SetVerbose("Reduce", n):            Maximum: 2</PRE>

<PRE>    SetVerbose("Cohomology", n):        Maximum: 2</PRE>

<PRE>    SetVerbose("GrunwaldWang", n):      Maximum: 2</PRE>
<BLOCKQUOTE>
Given an absolutely irreducible representation R:G to Gl(n, L)
and some normal number field K, try to write R
over K. If <TT>Char</TT> is specified, it should be set to the character
of this representation. If <TT>Subfield</TT> is given, the representation will be
rewritten over a minimal degree subfield of K.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "11656">Example <TT>ModGrp_minimal-field (H96E11)</TT></A></H3>
We will work with the G-module and character of the unique
2-dimensional character of Q<sub>8</sub>. It is well known that, while the
character is defined over Q, the corresponding representation can only
be defined over fields where -1 is the sum of 2 squares.
<P>
<P>
<PRE>
&gt; G := TransitiveGroup(8, 5);
&gt; TransitiveGroupDescription(G);
Q_8(8);
&gt; R := AbsolutelyIrreducibleModules(G, Rationals());
&gt; R;
[
    GModule of dimension 1 over Rational Field,
    GModule of dimension 1 over Rational Field,
    GModule of dimension 1 over Rational Field,
    GModule of dimension 1 over Rational Field,
    GModule of dimension 2 over Cyclotomic Field
    of order 4 and degree 2
]
&gt; R := R[5];
&gt; WriteGModuleOver(R, CyclotomicField(5));
GModule of dimension 2 over Cyclotomic Field 
of order 5 and degree 4
</PRE>
So Q(&zeta;<sub>5</sub>) is an example of a field affording the module
but having no minimal degree subfield (of degree 2 here) affording
R!. 
<P>
<P>
<PRE>
&gt; AbsoluteModuleOverMinimalField($1);
GModule of dimension 2 over Number Field with
defining polynomial Qx.1^2 - Qx.1 + 1 over the
Rational Field
</PRE>
Note that the base field returned here is Q(&zeta;<sub>3</sub>) which is 
of degree 2 but different from Q(&zeta;<sub>4</sub>) that was found initially.
In general there are infinetely many minimal degree splitting fields.
<P>
If we try to realize R over a field where -1 cannot be written
as a sums of two squares we get an error:
<P>
<P>
<PRE>
&gt; WriteGModuleOver(R, QuadraticField(3));

&gt;&gt; WriteGModuleOver(R, QuadraticField(3));
                   ^
Runtime error in 'WriteGModuleOver': The G-module 
cannot be realised over K
</PRE>
We can try to find a minimal field containing Q(&#8730;3) by
computing the local Schur-indices and then obtain a splitting field:
<P>
<P>
<PRE>
&gt; k := QuadraticField(3);
&gt; SchurIndices(Character(R), k);
[ &lt;1st place at infinity, 2&gt;, &lt;2nd place at
infinity, 2&gt; ]
&gt; A := SplittingField($1);
&gt; A;
FldAb, defined by (&lt;3&gt;, [1      2])
of structure: Z/2
</PRE>
So the splitting field is returned as an abelian extension. We can
see that A is of degree 2 over k and will be ramified at most
at 3
and both infinite places. In order to use it to rewrite
the module, we need to convert to a number field over Q first:
<P>
<P>
<PRE>
&gt; A := NumberField(A);
&gt; A;
Number Field with defining polynomial $.1^2 + 1
over k
&gt; A := AbsoluteField(A);
&gt; A;
Number Field with defining polynomial Qx.1^4 -
    4*Qx.1^2 + 16 over the Rational Field

&gt; WriteGModuleOver(R, A);
GModule of dimension 2 over A
&gt; WriteGModuleOver(R, A:Subfield);
GModule of dimension 2 over Number Field with
defining polynomial Qx.1^2 - Qx.1 + 1 over the
Rational Field
</PRE>
<HR>
<H4><A NAME = "11657">Direct Sum</A></H4>



<H5><A NAME = "11658">DirectSum(M, N) : ModGrp, ModGrp -&gt; ModGrp, Map, Map, Map, Map</A></H5>
<BLOCKQUOTE>
Given K[G]-modules M and N, construct the direct sum D of M and N
as an K[G]-module.  The embedding maps from M into D and from N into
D respectively and the projection maps from D onto M and from D onto
N respectively are also returned.
</BLOCKQUOTE>
<H5><A NAME = "11659">DirectSum(Q) : [ ModGrp ] -&gt; [ ModGrp ], [ Map ], [ Map ]</A></H5>
<BLOCKQUOTE>
Given a sequence Q of K[G]-modules, construct the direct sum D of these
modules.  The embedding maps from each of the elements of Q into D and
the projection maps from D onto each of the elements of Q are also
returned.
</BLOCKQUOTE>
<H4><A NAME = "11660">Tensor Products of K[G]-Modules</A></H4>



<H5><A NAME = "11661">TensorProduct(M, N) : ModGrp, ModGrp -&gt; ModGrp</A></H5>
<BLOCKQUOTE>
Let M and N be two K[G] modules.  This function constructs the 
tensor product, M tensor <sub>A</sub> N, with diagonal action.
</BLOCKQUOTE>
<H5><A NAME = "11662">TensorPower(M, n) : ModGrp, RngIntElt -&gt; ModGrp</A></H5>
<BLOCKQUOTE>
Given a K[G]-module M and an integer n &ge;1, construct 
the n-th tensor power of M.
</BLOCKQUOTE>
<H5><A NAME = "11663">ExteriorSquare(M) : ModGrp -&gt; ModGrp</A></H5>
<BLOCKQUOTE>
Given a K[G]-module M, construct the A-submodule of M tensor <sub>A</sub> M 
consisting of the skew tensors.
</BLOCKQUOTE>
<H5><A NAME = "11664">SymmetricSquare(M) : ModGrp -&gt; ModGrp</A></H5>
<BLOCKQUOTE>
Given a K[G]-module M, construct the A-submodule of M tensor <sub>A</sub> M 
consisting of the symmetric tensors.
</BLOCKQUOTE>
<H4><A NAME = "11665">Induction and Restriction</A></H4>

<P>
<P>


<H5><A NAME = "11666">Dual(M) : ModGrp -&gt; ModGrp</A></H5>
<BLOCKQUOTE>
Given an K[G]-module M, construct the K[G]-module which is 
the K-dual, Hom<sub>K</sub>(M, K), of M.
<P>
<P>
</BLOCKQUOTE>
<H5><A NAME = "11667">Induction(M, G) : ModGrp, Grp -&gt; ModGrp</A></H5>
<BLOCKQUOTE>
Given a K[H]-module M and a supergroup G of H, construct the
K[G]-module obtained by inducing M up to G.
</BLOCKQUOTE>
<H5><A NAME = "11668">Induction(R, G) : Map, Grp -&gt; Map</A></H5>
<BLOCKQUOTE>
Given a representation R of a subgroup of G, construct the
representation of G obtained by inducing R up to G.
<P>
</BLOCKQUOTE>
<H5><A NAME = "11669">Restriction(M, H) : ModGrp, Grp -&gt; ModGrp</A></H5>
<BLOCKQUOTE>
Given a K[G]-module M and a subgroup H of G, form the 
K[H]-module corresponding to the restriction of M to the 
subgroup H.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "11670">Example <TT>ModGrp_GModules1 (H96E12)</TT></A></H3>
Starting with the permutation module M over GF(2) for the
Mathieu group M<sub>22</sub>, we apply the induction and restriction
functions to find new irreducible modules for M<sub>22</sub>.
<P>
<P>
<PRE>
&gt; SetSeed(1);
&gt; G := PermutationGroup&lt; 22 |
&gt;         (1,2,4,8,16,9,18,13,3,6,12)(5,10,20,17,11,22,21,19,15,7,14),
&gt;         (1,18,4,2,6)(5,21,20,10,7)(8,16,13,9,12)(11,19,22,14,17),
&gt;         (1,18,2,4)(3,15)(5,9)(7,16,21,8)(10,12,20,13)(11,17,22,14) &gt;;
&gt; M := PermutationModule(G, GaloisField(2));
&gt; M;
GModule M of dimension 22 with base ring GF(2)
&gt; CM := Constituents(M);
&gt; CM;
[
    GModule of dimension 1 over GF(2),
    GModule of dimension 10 over GF(2),
    GModule of dimension 10 over GF(2)
]
</PRE>
<P>
We restrict the module M to the stabilizer of a point in M<sub>22</sub> 
and then induce back up, a constituent of the restriction.
<P>
<P>
<P>
<PRE>
&gt; L34 := Stabilizer(G, 1);
&gt; N := Restriction(M, L34);
&gt; N;
GModule N of dimension 22 with base ring GF(2)
&gt; CN := Constituents(N);
&gt; CN;
[
    GModule of dimension 1 over GF(2),
    GModule of dimension 9 over GF(2),
    GModule of dimension 9 over GF(2)
]
&gt; Ind1 := Induction(CN[1], G);
&gt; Ind1;
GModule Ind1 of dimension 22 over GF(2)
&gt; Constituents(Ind1);
[
    GModule of dimension 1 over GF(2),
    GModule of dimension 10 over GF(2),
    GModule of dimension 10 over GF(2)
]
&gt; Ind2 := Induction(CN[2], G);
&gt; Ind2;
GModule Ind2 of dimension 198 over GF(2)
&gt; Constituents(Ind2);         
[
    GModule of dimension 1 over GF(2),
    GModule of dimension 10 over GF(2),
    GModule of dimension 10 over GF(2),
    GModule of dimension 34 over GF(2),
    GModule of dimension 98 over GF(2)
]
</PRE>
<P>
Thus, inducing up the 1-dimensional constituent of N gives 
us irreducible modules for G having the same dimensions as those 
appearing as constituents of M. However, inducing up the 
9-dimensional module gives us irreducible modules of new 
dimensions: 34 and 98. Hence starting out with only the
permutation module for M<sub>22</sub> over GF(2), we have found 
5 irreducible modules for the group.
<HR>
<H4><A NAME = "11671">The Fixed-point Space of a Module</A></H4>



<H5><A NAME = "11672">Fix(M): Mod -&gt; Mod</A></H5>
<BLOCKQUOTE>
Given an K[G]-module M, construct the largest submodule of M on 
which G acts trivially, i.e. the fixed-point space of M.
</BLOCKQUOTE>
<H4><A NAME = "11673">Changing Basis</A></H4>



<H5><A NAME = "11674">M ^ T : ModGrp, AlgMatElt -&gt; ModGrp</A></H5>
<BLOCKQUOTE>
Given a K[G]-module M of dimension n over the field K, and a
nonsingular n x n matrix T over K, construct the
K[G]-module N which corresponds to taking the rows of T as a
basis for M.
</BLOCKQUOTE>
<PRE></PRE> <A  HREF = "text1033.htm">[Next]</A><A  HREF = "text1031.htm">[Prev]</A> <A  HREF = "text1033.htm">[Right]</A> <A  HREF = "text1031.htm">[Left]</A> <A  HREF = "text1028.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<br><small>Version: V2.22 of <I>
Thu Jun  9 16:37:49 EST 2016
</I></small>
</body></html>