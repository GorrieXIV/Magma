<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <link rel='stylesheet' href='help.css' type='text/css'>
  <TITLE>Element Operations</TITLE>
</head>
<body BGCOLOR="#FFFFFF">

 <A  HREF = "text391.htm">[Next]</A><A  HREF = "text389.htm">[Prev]</A> <A  HREF = "text391.htm">[Right]</A> <A  HREF = "text389.htm">[Left]</A> <A  HREF = "text383.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<PRE></PRE><H3><A NAME = "3805">Element Operations</A></H3>




<H5>Subsections</H5>
<UL>
<LI> <A  HREF = "text390.htm#3806">Parent and Category</A>
<LI> <A  HREF = "text390.htm#3807">Arithmetic</A>
<LI> <A  HREF = "text390.htm#3816">Equality and Membership</A>
<LI> <A  HREF = "text390.htm#3817">Predicates on Elements</A>
<LI> <A  HREF = "text390.htm#3823">Field Generators</A>
<LI> <A  HREF = "text390.htm#3829">Real and Complex Embeddings</A>
<LI> <A  HREF = "text390.htm#3841">Heights</A>
<LI> <A  HREF = "text390.htm#3847">Norm, Trace, and Minimal Polynomial</A>
<LI> <A  HREF = "text390.htm#3859">Other Functions</A>
</UL>
<H4><A NAME = "3806">Parent and Category</A></H4>



<H5>Parent(a) : FldAlgElt -&gt; FldAlg</H5>

<H5>Parent(w) : RngOrdElt -&gt; RngOrd</H5>

<H5>Category(a) : FldAlgElt -&gt; Cat</H5>

<H5>Category(w) : RngOrdElt -&gt; Cat</H5><P>


<H4><A NAME = "3807">Arithmetic</A></H4>

<P>
<P>
The table below lists the generic arithmetic functions on
algebraic field and order elements. Note that automatic coercion ensures
that the binary operations <TT>+</TT>, <TT>-</TT>, <TT>*</TT>, and <TT>/</TT>
may be applied to an element of an algebraic field and an element of
one of its orders; the result will be an algebraic field element.
Since division of order elements does not generally result in an
order element, the operation <TT>/</TT> applied to two elements of 
an order returns an element in the field of fractions of the order;
similarly if the exponent k in <TT>a^k</TT> is negative.
<P>
For finding the value of an element mod an ideal or the inverse of an element
mod an ideal see Section <A  HREF = "text394.htm#3991">Ideal Arithmetic</A>.


<H5>+ a : FldAlgElt -&gt; FldAlgElt</H5>

<H5>+ w : RngOrdElt -&gt; RngOrdElt</H5>

<H5>- a : FldAlgElt -&gt; FldAlgElt</H5>

<H5>- w : RngOrdElt -&gt; RngOrdElt</H5><P>

<H5>a + b : FldAlgElt, FldAlgElt -&gt; FldAlgElt</H5>

<H5>w + v : RngOrdElt, RngOrdElt -&gt; RngOrdElt</H5>

<H5>a - b : FldAlgElt, FldAlgElt -&gt; FldAlgElt</H5>

<H5>w - v : RngOrdElt, RngOrdElt -&gt; RngOrdElt</H5>

<H5>a * b : FldAlgElt, FldAlgElt -&gt; FldAlgElt</H5>

<H5>w * v : RngOrdElt, RngOrdElt -&gt; RngOrdElt</H5>

<H5>a / b : FldAlgElt, FldAlgElt -&gt; FldAlgElt</H5>

<H5>w / v : RngOrdElt, RngOrdElt -&gt; FldOrdElt</H5>

<H5>a ^ k : FldAlgElt, RngIntElt -&gt; FldAlgElt</H5>

<H5>w ^ k : RngOrdElt, RngIntElt -&gt; RngOrdElt</H5><P>


<H5><A NAME = "3808">w div v : RngOrdElt, RngOrdElt -&gt; RngOrdElt</A></H5>
<BLOCKQUOTE>
The quotient of the order element w by the order element v; v must divide w exactly, (v and w must
be elements of the same order).
</BLOCKQUOTE>
<H5><A NAME = "3809">Modexp(a, n, m) : RngOrdElt, RngIntElt, RngIntElt -&gt; RngOrdElt</A></H5>
<BLOCKQUOTE>
Given a non-negative integer n and an integer m greater than 1,
this function returns the modular power a<sup>n</sup>  mod  m of the order element
a.
</BLOCKQUOTE>
<H5><A NAME = "3810">Sqrt(a) : RngOrdElt -&gt; RngOrdElt</A></H5>
<H5>Sqrt(a) : FldAlgElt -&gt; FldAlgElt</H5>
<H5>SquareRoot(a) : RngOrdElt -&gt; RngOrdElt</H5>
<H5>SquareRoot(a) : FldAlgElt -&gt; FldAlgElt</H5>
<BLOCKQUOTE>
Returns the square root of the element a if it exists in the order or field containing
a.
</BLOCKQUOTE>
<H5><A NAME = "3811">Root(a, n) : RngOrdElt, RngIntElt -&gt; RngOrdElt</A></H5>
<H5>Root(a, n) : FldAlgElt, RngIntElt -&gt; FldAlgElt</H5>
<BLOCKQUOTE>
Returns the n-th root of the element a if it exists in the order or field containing
a.
</BLOCKQUOTE>
<H5><A NAME = "3812">IsPower(a, k) : FldAlgElt, RngIntElt -&gt; BoolElt, FldAlgElt</A></H5>
<H5>IsPower(a, k) : RngOrdElt, RngIntElt -&gt; BoolElt, RngOrdElt</H5>
<H5>IsSquare(a) : FldAlgElt -&gt; BoolElt, FldAlgElt</H5>
<H5>IsSquare(a) : RngOrdElt -&gt; BoolElt, RngOrdElt</H5>
<BLOCKQUOTE>
Return <TT>true</TT> if the element a is a kth power, 
(respectively square) and the root in the order or field containing a if so.
</BLOCKQUOTE>
<H5><A NAME = "3813">Denominator(a) : FldAlgElt -&gt; RngIntElt</A></H5>
<H5>Denominator(a) : RngOrdElt -&gt; RngIntElt</H5>
<BLOCKQUOTE>
Returns the denominator of the element a, that is the least common
multiple of the denominators of the coefficients of a.
</BLOCKQUOTE>
<H5><A NAME = "3814">Numerator(a) : FldAlgElt -&gt; RngIntElt</A></H5>
<BLOCKQUOTE>
Returns the numerator of the element a, that is the element
multiplied by its denominator.
</BLOCKQUOTE>
<H5><A NAME = "3815">Qround(E, M): FldAlgElt, RngIntElt -&gt; FldAlgElt</A></H5>

<PRE>    ContFrac: BoolElt                   Default: <TT>true</TT></PRE>
<BLOCKQUOTE>
Finds an approximation of the field element
E where the denominator is bounded by the integer M.
If <TT>ContFrac</TT> is <TT>true</TT>, the approximation is computed by applying
the continued fraction algorithm to the coefficients of E viewed over Q.
</BLOCKQUOTE>
<H4><A NAME = "3816">Equality and Membership</A></H4>

<P>
<P>
Elements may also be tested for whether they lie in an ideal of an order.
See Section <A  HREF = "text394.htm#3967">Predicates on Ideals</A>.


<H5>a eq b : FldAlgElt, FldAlgElt -&gt; BoolElt</H5>

<H5>w eq v : RngOrdElt, RngOrdElt -&gt; BoolElt</H5>

<H5>a ne b : FldAlgElt, FldAlgElt -&gt; BoolElt</H5>

<H5>w ne v : RngOrdElt, RngOrdElt -&gt; BoolElt</H5><P>

<H5>a in F : FldAlgElt, FldAlg -&gt; BoolElt</H5>

<H5>w in O : RngOrdElt, RngOrd -&gt; BoolElt</H5><P>


<H4><A NAME = "3817">Predicates on Elements</A></H4>

<P>
<P>
In addition to the generic predicates <TT>IsMinusOne</TT>, <TT>IsZero</TT> 
and <TT>IsOne</TT>, the predicates <TT>IsIntegral</TT> and <TT>IsPrimitive</TT>
are defined on elements of algebraic fields and orders.


<H5>IsZero(a) : FldAlgElt -&gt; BoolElt</H5>

<H5>IsZero(w) : RngOrdElt -&gt; BoolElt</H5>

<H5>IsOne(a) : FldAlgElt -&gt; BoolElt</H5>

<H5>IsOne(w) : RngOrdElt -&gt; BoolElt</H5><P>

<H5>IsMinusOne(a) : FldAlgElt -&gt; BoolElt</H5>

<H5>IsMinusOne(w) : RngOrdElt -&gt; BoolElt</H5>


<H5>IsUnit(a) : FldAlgElt -&gt; BoolElt</H5>

<H5>IsUnit(w) : RngOrdElt -&gt; BoolElt</H5><P>

<H5>IsNilpotent(a) : FldAlgElt -&gt; BoolElt</H5>

<H5>IsNilpotent(a) : RngOrdElt -&gt; BoolElt</H5>

<H5>IsIdempotent(a) : FldAlgElt -&gt; BoolElt</H5>

<H5>IsIdempotent(a) : RngOrdElt -&gt; BoolElt</H5>
<P>

<H5>IsZeroDivisor(a) : FldAlgElt -&gt; BoolElt</H5>

<H5>IsZeroDivisor(a) : RngOrdElt -&gt; BoolElt</H5>

<H5>IsRegular(a) : FldAlgElt -&gt; BoolElt</H5>

<H5>IsRegular(a) : RngOrdElt -&gt; BoolElt</H5>
<P>

<H5>IsIrreducible(a) : FldAlgElt -&gt; BoolElt</H5>

<H5>IsIrreducible(a) : RngOrdElt -&gt; BoolElt</H5>

<H5>IsPrime(a) : FldAlgElt -&gt; BoolElt</H5>

<H5>IsPrime(a) : RngOrdElt -&gt; BoolElt</H5><P>


<H5><A NAME = "3818">IsIntegral(a) : FldAlgElt -&gt; BoolElt</A></H5>
<H5>IsIntegral(a) : RngOrdElt -&gt; BoolElt</H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if the element a of an algebraic field F or of an order
in F is contained in the ring of integers of F, <TT>false</TT> otherwise.
This is vacuously true for order elements.
We use the minimal polynomial to determine the answer, which
means that the calculation of the maximal order is <I>not</I> triggered
if it is not known yet.
When a is a field element a denominator d such that d * a is integral
is also returned on request.
</BLOCKQUOTE>
<H5><A NAME = "3819">IsPrimitive(a) : FldAlgElt -&gt; BoolElt</A></H5>
<H5>IsPrimitive(a) : RngOrdElt -&gt; BoolElt</H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if the element a of the algebraic field F or one of its orders O
generates F.
</BLOCKQUOTE>
<H5><A NAME = "3820">IsTorsionUnit(w) : RngOrdElt -&gt; BoolElt</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if and only if the order element w is a unit of
finite order.
</BLOCKQUOTE>
<H5><A NAME = "3821">IsPower(w, n) : RngOrdElt, RngIntElt -&gt; BoolElt, RngOrdElt</A></H5>
<BLOCKQUOTE>
Given an element w in an order O and an integer n&gt;1, this function
returns <TT>true</TT> if and only if there exists an element v&isin;O such that
w=v<sup>n</sup>; if <TT>true</TT>, such an element v is returned as well.
</BLOCKQUOTE>
<H5><A NAME = "3822">IsTotallyPositive(a) : RngOrdElt -&gt; BoolElt</A></H5>
<H5>IsTotallyPositive(a) : FldAlgElt -&gt; BoolElt</H5>
<BLOCKQUOTE>
Returnes <TT>true</TT> iff all real embeddings of the element a are positive. For elements
in absolute fields this is equivalent to all real conjugates being positive.
</BLOCKQUOTE>
<H4><A NAME = "3823">Field Generators</A></H4>



<H5><A NAME = "3824">K . 1 : FldNum -&gt; FldNumElt</A></H5>
<BLOCKQUOTE>
Return the image &alpha; of x in G[x]/f where f is the first defining
polynomial of K and G is the base field of K.
<P>
In case of simple extensions this will be a primitive element.
</BLOCKQUOTE>
<H5><A NAME = "3825">PrimitiveElement(K) : FldNum -&gt; FldNumElt</A></H5>
<H5>PrimitiveElement(F) : FldOrd -&gt; FldOrdElt</H5>
<BLOCKQUOTE>
Returns a primitive element for the simple algebraic field, that is 
an element whose minimal polynomial has the same degree as the field. 
For a number field K this is K.1 but for a field of fractions this is 
F!K.1 where K is the number field of F.
<P>
For non-simple fields, a random element is returned.
</BLOCKQUOTE>
<H5><A NAME = "3826">PrimitiveElement(O) : RngOrd -&gt; RngOrdElt</A></H5>
<BLOCKQUOTE>
Given an order O, returns a primitive element for <TT>FieldOfFractions(O)</TT>.
</BLOCKQUOTE>
<H5><A NAME = "3827">Generators(K): FldAlg -&gt; [FldAlgElt]</A></H5>
<BLOCKQUOTE>
The list of generators of K over its coefficient field, that is a sequence
containing a root of each defining polynomial is returned.
</BLOCKQUOTE>
<H5><A NAME = "3828">Generators(K, k) : FldAlg, FldAlg -&gt; [FldAlgElt]</A></H5>
<H5>Generators(K, Q) : FldAlg, FldRat -&gt; [FldAlgElt]</H5>
<BLOCKQUOTE>
A list of generators of K over k is returned. That is a sequence
containing a root of each defining polynomial for K and its subfield down
to the level of k is returned.
</BLOCKQUOTE>
<H4><A NAME = "3829">Real and Complex Embeddings</A></H4>

<P>
<P>
The default precision for the embeddings can be controlled using <TT>SetKantPrecision</TT>.


<H5><A NAME = "3830">Conjugates(a) : FldAlgElt -&gt; [ FldComElt ]</A></H5>
<H5>Conjugates(a) : RngOrdElt -&gt; [ FldComElt ]</H5>

<PRE>    Precision: RngIntElt                Default: </PRE>
<BLOCKQUOTE>
Given an element a in a number field or order, this returns a sequence
of complex numbers, which are the real and complex embeddings of a.
<P>
When a is an element of an <I>absolute</I> field or order R (i.e. R has
base field Q or Z), the number of embeddings is the degree of R.
The r<sub>1</sub> real conjugates are listed first, followed by the r<sub>2</sub> pairs
of complex conjugates. 
<P>
When a is an element of a <I>relative</I> field or order R, the sequence
contains <TT>Evaluate(a, v)</TT> where v runs through <TT>InfinitePlaces(R)</TT>.
In particular, it contains only r<sub>1</sub> + r<sub>2</sub> numbers.
<P>
In both cases, the conjugates are given in a fixed ordering which depends only
on (the defining polynomials of) the field or order.
</BLOCKQUOTE>
<H5><A NAME = "3831">Conjugate(a, l) : FldAlgElt, RngIntElt -&gt; FldReElt</A></H5>
<H5>Conjugate(a, l) : RngOrdElt, RngIntElt -&gt; FldReElt</H5>

<PRE>    Precision: RngIntElt                Default: </PRE>
<BLOCKQUOTE>
For a in an <I>absolute</I> field or order, this returns <TT>Conjugates(a)[l]</TT>.
</BLOCKQUOTE>
<H5><A NAME = "3832">Conjugate(a, l) : FldAlgElt, [RngIntElt] -&gt; FldReElt</A></H5>

<PRE>    Precision: RngIntElt                Default: </PRE>
<BLOCKQUOTE>
For a in a <I>relative</I> field or order, this returns the conjugate of a
indexed by l, where l = [l<sub>1</sub>, ..., l<sub>n</sub>] is a sequence of integers.
<P>
Let K be the parent of a, defined as a tower of extensions with n steps
Q&sube;K<sub>1</sub>&sube; ... &sube;K<sub>n</sub> = K.  The embedding indexed by
l is defined inductively: it extends the embedding [l<sub>1</sub>, ..., l<sub>n - 1</sub>]
of K<sub>n - 1</sub> and is the l<sub>n</sub>th such extension.  These extensions are ordered
by a fixed rule, depending only on (the defining polynomials of) the field tower.
<P>
The <TT>InfinitePlaces</TT> of K are indexed the same way.
</BLOCKQUOTE>
<H5><A NAME = "3833">AbsoluteValues(a) : FldAlgElt -&gt; [FldReElt]</A></H5>
<H5>AbsoluteValues(a) : RngOrdElt -&gt; [FldReElt]</H5>
<BLOCKQUOTE>
This returns a sequence of r<sub>1</sub> + r<sub>2</sub> positive real numbers. These are
the absolute values of the real and complex embeddings of the element a,
which is required to be an element of an absolute field or order.
</BLOCKQUOTE>
<H5><A NAME = "3834">Logs(a) : FldAlgElt -&gt; [FldReElt]</A></H5>
<H5>Logs(a) : RngOrdElt -&gt; [FldReElt]</H5>
<BLOCKQUOTE>
This returns a sequence of r<sub>1</sub> + r<sub>2</sub> positive real numbers. These are the 
natural logs of the absolute values of the real and complex embeddings of the element a,
which is required to be a nonzero element of an absolute field or order.
</BLOCKQUOTE>
<H5><A NAME = "3835">InfinitePlaces(K) : FldAlg -&gt; [PlcNumElt]</A></H5>
<H5>InfinitePlaces(O) : RngOrd -&gt; [PlcNumElt]</H5>
<BLOCKQUOTE>
This returns a sequence containing all the infinite places of the field.
Each place corresponds to a real embedding or a pair of complex embeddings.
The ordering of the places is fixed.
</BLOCKQUOTE>
<H5><A NAME = "3836">Evaluate(x, p) : FldAlgElt, PlcNumElt -&gt; RngElt</A></H5>
<H5>Evaluate(x, p) : RngOrdElt, PlcNumElt -&gt; RngElt</H5>
<BLOCKQUOTE>
When p is a finite place, this returns the image of x in the
residue class field corresponding to p.
<P>
When p is an infinite place, this returns the image of x under
the corresponding embedding, i.e., a real or complex number.
(This can also be obtained using <TT>Conjugate</TT> or <TT>Conjugates</TT>.)
</BLOCKQUOTE>
<H5><A NAME = "3837">RealEmbeddings(a) : FldAlgElt -&gt; []</A></H5>
<H5>RealEmbeddings(a) : RngOrdElt -&gt; []</H5>
<BLOCKQUOTE>
The sequence of real embeddings of the algebraic number a is computed,
ie. a is evaluated at all real places of the number field.
</BLOCKQUOTE>
<H5><A NAME = "3838">MinkowskiLattice(O) : RngOrd -&gt; Lat, Map</A></H5>
<H5>Lattice(O) : RngOrd -&gt; Lat, Map</H5>

<PRE>    Precision: RngIntElt                Default: </PRE>
<BLOCKQUOTE>
Given an absolute order O, returns the
lattice determined by the real and complex embeddings of O.
</BLOCKQUOTE>
<H5><A NAME = "3839">MinkowskiLattice(I) : RngOrdIdl -&gt; Lat, Map</A></H5>
<H5>Lattice(I) : RngOrdIdl -&gt; Lat, Map</H5>

<PRE>    Precision: RngIntElt                Default: </PRE>
<BLOCKQUOTE>
Given an ideal I in an absolute order, returns the
lattice determined by the real and complex embeddings of I. 
</BLOCKQUOTE>
<H5><A NAME = "3840">MinkowskiSpace(F) : FldAlg -&gt; Lat, Map</A></H5>
<BLOCKQUOTE>
The Minkowski vector space V of the absolute field F
as a real vector space, with
inner product given by the T<sub>2</sub>-norm (<A  HREF = "text390.htm#RngOrd:Length">Length</A>) on F, and by the embedding
F -&gt; V.
</BLOCKQUOTE>
<H4><A NAME = "3841">Heights</A></H4>

<P>
<P>
The real precision of results can be controlled using <TT>SetKantPrecision</TT>.


<H5><A NAME = "3842">AbsoluteLogarithmicHeight(a) : FldAlgElt -&gt; FldReElt</A></H5>
<H5>AbsoluteLogarithmicHeight(a) : RngOrdElt -&gt; FldReElt</H5>
<BLOCKQUOTE>
Let P be the minimal polynomial of the element 
a over Z, with leading coefficient
a<sub>0</sub> and roots &alpha;<sub>1</sub>, ..., &alpha;<sub>n</sub>.  Then the absolute logarithmic
height is defined to be
 h(&alpha;) = (1/n) log(a<sub>0</sub> &prod;<sub>j=1</sub><sup>n</sup> max(1, |&alpha;<sub>j</sub>|)). 
<P>
</BLOCKQUOTE>
<H5><A NAME = "3843">CoefficientHeight(E) : RngOrdElt -&gt; RngIntElt</A></H5>
<H5>CoefficientHeight(E) : FldAlgElt -&gt; RngIntElt</H5>
<BLOCKQUOTE>
Computes the coefficient height of the element E, that is for an
element of an absolute field it returns the maximum of the denominator
and the largest coefficient wrt. to the basis of the parent.
For elements in relative extensions, it returns the maximal coefficient
height of all the coefficients wrt. the basis of the parent.
<P>
This function indicates in some way the difficulty of operations
involving this element.
</BLOCKQUOTE>
<H5><A NAME = "3844">CoefficientLength(E) : RngOrdElt -&gt; RngIntElt</A></H5>
<H5>CoefficientLength(E) : FldAlgElt -&gt; RngIntElt</H5>
<BLOCKQUOTE>
Computes the coefficient length of the element E, that is for an
element of an absolute field it returns the sum of the denominator
and the absolute values of all coefficients wrt. to the basis of the parent.
For elements in relative extensions, it returns the sum of the coefficient
length of all the coefficients wrt. the basis of the parent.
<P>
This function gives an indication on the amount of memory occupied by
this element.
</BLOCKQUOTE>
<H5><A NAME = "3845"></A><A NAME = "RngOrd:Length">Length</A>(a) : FldAlgElt -&gt; FldReElt</H5>
<H5>Length(a) : RngOrdElt -&gt; FldReElt</H5>
<BLOCKQUOTE>
Return the T<sub>2</sub>-norm of the element a, which is a real
number. This equals the sum of the (complex)
norms of the conjugates of a.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "3846">Example <TT>RngOrd_Discriminant (H38E16)</TT></A></H3>
It is not hard to write an alternative discriminant function,
using the <TT>Conjugates</TT> of the basis <TT>[O.1, O.2, ...]</TT>.
<P>
<P>
<PRE>
&gt; function disc(O)
&gt;     B := [ Conjugates(O.i) : i in [1 .. Degree(O)] ];
&gt;     D := Determinant(Matrix(B))^2;
&gt;     return RealField(20) ! D;
&gt; end function;
&gt; _&lt;x&gt; := PolynomialRing(Integers());
&gt; O := MaximalOrder(NumberField(x^4 - 420*x^2 + 40000));
&gt; disc(O);
42025.000000000000001
&gt; Discriminant(O);
42025
</PRE>
The function <TT>disc</TT> obtains a real approximation to the 
exact value given by <TT>Discriminant</TT>.
<P>
Here is an alternative way of getting the T<sub>2</sub> norm returned
by <TT>Length</TT>, using the complex <TT>Norm</TT> function, together with
the <TT>Conjugates</TT> function.
<P>
<P>
<PRE>
&gt; norm := func&lt; a | &amp;+[ Norm(Conjugates(a)[i]) : \
&gt;                      i in [1 .. Degree(Parent(a))] ] &gt;;
</PRE>
<HR>
<H4><A NAME = "3847">Norm, Trace, and Minimal Polynomial</A></H4>

<P>
<P>
The norm, trace and minimal polynomial of order and algebraic field elements 
can be calculated both with respect to the coefficient ring and to Z or Q.


<H5><A NAME = "3848">Norm(a) : FldAlgElt -&gt; FldAlgElt</A></H5>
<H5><A NAME = "RngOrd:Norm">Norm</A>(a) : FldAlgElt -&gt; FldRatElt</H5>
<H5>Norm(a, R) : FldAlgElt, Rng -&gt; RngElt</H5>
<H5>Norm(a) : RngOrdElt -&gt; RngOrdElt</H5>
<H5>Norm(a) : RngOrdElt -&gt; RngIntElt</H5>
<H5>Norm(a, R) : RngOrdElt, Rng -&gt; RngElt</H5>
<BLOCKQUOTE>
The relative norm N<sub>L/F</sub>(a) over F
of the element a of L where F is the field or order over which L
is defined as an extension. If R is given the norm is calculated over R.
In this case, R must occur as a coefficient ring somewhere in the tower
under L.
</BLOCKQUOTE>
<H5><A NAME = "3849">AbsoluteNorm(a) : FldAlgElt -&gt; FldRatElt</A></H5>
<H5>NormAbs(a) : FldAlgElt -&gt; FldRatElt</H5>
<H5>AbsoluteNorm(a) : RngOrdElt -&gt; FldRatElt</H5>
<H5>NormAbs(a) : RngOrdElt -&gt; FldRatElt</H5>
<BLOCKQUOTE>
The absolute norm N<sub>L/Q</sub>(a) over Q of the element a of L
(or one of its orders).
</BLOCKQUOTE>
<H5><A NAME = "3850">Trace(a) : FldAlgElt -&gt; FldAlgElt</A></H5>
<H5><A NAME = "RngOrd:Trace">Trace</A>(a) : FldAlgElt -&gt; FldRatElt</H5>
<H5>Trace(a, R) : FldAlgElt, Rng -&gt; RngElt</H5>
<H5>Trace(a) : RngOrdElt -&gt; RngOrdElt</H5>
<H5>Trace(a) : RngOrdElt -&gt; RngIntElt</H5>
<H5>Trace(a, R) : RngOrdElt, Rng -&gt; RngElt</H5>
<BLOCKQUOTE>
The relative trace Tr<sub>L/F</sub>(a) over F of the element a of L
where F is the field or order over which L is defined as an extension.
If R is given the trace is computed over R.
In this case, R must occur as a coefficient ring somewhere in the tower
under L.
</BLOCKQUOTE>
<H5><A NAME = "3851">AbsoluteTrace(a) : FldAlgElt -&gt; FldRatElt</A></H5>
<H5>TraceAbs(a) : FldAlgElt -&gt; FldRatElt</H5>
<H5>AbsoluteTrace(a) : RngOrdElt -&gt; FldRatElt</H5>
<H5>TraceAbs(a) : RngOrdElt -&gt; FldRatElt</H5>
<BLOCKQUOTE>
The absolute trace Tr<sub>L/Q</sub>(a) over Q of the element a of L
(or one of its orders).
</BLOCKQUOTE>
<H5><A NAME = "3852">CharacteristicPolynomial(a) : FldAlgElt -&gt; RngUPolElt</A></H5>
<H5>CharacteristicPolynomial(a, R) : FldAlgElt, Rng -&gt; RngUPolElt</H5>
<H5>CharacteristicPolynomial(a) : RngOrdElt -&gt; RngUPolElt</H5>
<H5>CharacteristicPolynomial(a, R) : RngOrdElt, Rng -&gt; RngUPolElt</H5>
<BLOCKQUOTE>
Given an element a from an algebraic field or order L, returns
the characteristic polynomial of the element over R if given or 
the subfield or suborder F otherwise
where F is the field or order over which L is defined as an extension.
</BLOCKQUOTE>
<H5><A NAME = "3853">AbsoluteCharacteristicPolynomial(a) : FldAlgElt -&gt; RngUPolElt</A></H5>
<H5>AbsoluteCharacteristicPolynomial(a) : RngOrdElt -&gt; RngUPolElt</H5>
<BLOCKQUOTE>
Given an element a from an algebraic field or one of its orders, this function
returns the characteristic polynomial of the element. For field elements the
polynomial will have coefficients in the rational field, for order
elements the coefficients will be in the ring of integers.
</BLOCKQUOTE>
<H5><A NAME = "3854">MinimalPolynomial(a) : FldAlgElt -&gt; RngUPolElt</A></H5>
<H5>MinimalPolynomial(a, R) : FldAlgElt, Rng -&gt; RngUPolElt</H5>
<H5>MinimalPolynomial(a) : RngOrdElt -&gt; RngUPolElt</H5>
<H5>MinimalPolynomial(a, R) : RngOrdElt, Rng -&gt; RngUPolElt</H5>
<BLOCKQUOTE>
Given an element a from an algebraic field or order L, returns
the minimal polynomial of the element over R if given otherwise 
the subfield or suborder F
where F is the field or order over which L is defined as an extension.
</BLOCKQUOTE>
<H5><A NAME = "3855">AbsoluteMinimalPolynomial(a) : FldAlgElt -&gt; RngUPolElt</A></H5>
<H5>AbsoluteMinimalPolynomial(a) : RngOrdElt -&gt; RngUPolElt</H5>
<BLOCKQUOTE>
Given an element a from an algebraic field or one of its orders, this function
returns the minimal polynomial of the element. For field elements the
polynomial will have coefficients in the rational field, for order
elements the coefficients will be in the ring of integers.
</BLOCKQUOTE>
<H5><A NAME = "3856">RepresentationMatrix(a) : FldAlgElt -&gt; AlgMatElt</A></H5>
<H5>RepresentationMatrix(a, R) : FldAlgElt, Rng -&gt; AlgMatElt</H5>
<H5>RepresentationMatrix(a) : RngOrdElt -&gt; AlgMatElt</H5>
<H5>RepresentationMatrix(a, R) : RngOrdElt, Rng -&gt; AlgMatElt</H5>
<BLOCKQUOTE>
Return the representation matrix of a, that is, the matrix which
represents the linear map given by multiplication by a. If a is
an order element, this matrix is with respect to the basis for the
order; if a is an algebraic field element, the 
basis for the field
is used.
The ith row of the representation matrix gives the coefficients
of aw<sub>i</sub> with respect to the basis w<sub>1</sub>, ..., w<sub>n</sub>.
<P>
If R is given the matrix is over R and with respect to the basis of
the order or field over R.
</BLOCKQUOTE>
<H5><A NAME = "3857">AbsoluteRepresentationMatrix(a) : FldAlgElt -&gt; AlgMatElt</A></H5>
<H5>AbsoluteRepresentationMatrix(a) : RngOrdElt -&gt; AlgMatElt</H5>
<BLOCKQUOTE>
Return the representation matrix of a relative to the Q-basis
of the field constructed using products of the basis elements, where
a is an element of the relative number field L.
<P>
Let L<sub>i</sub> := &sum;L<sub>i - 1</sub> &omega;<sub>i, j</sub>, L := L<sub>n</sub> and L<sub>0</sub> := Q. 
Then the representation matrix is computed with respect to the Q-basis
(&prod;<sub>j</sub> &omega;<sub>i<sub>j</sub>, j</sub>)<sub>i &isin;I</sub> consisting of products of basis elements
of the different levels.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "3858">Example <TT>RngOrd_NormsEtc (H38E17)</TT></A></H3>
We create the norm, trace, minimal polynomial and representation matrix
of the element &alpha;/2 in the quartic field Q(&alpha;).
<P>
<P>
<PRE>
&gt; R&lt;x&gt; := PolynomialRing(Integers());
&gt; K&lt;y&gt; := NumberField(x^4-420*x^2+40000);
&gt; z := y/2;
&gt; Norm(z), Trace(z);
2500 0
&gt; MinimalPolynomial(z);
$.1^4 - 105*$.1^2 + 2500
&gt; RepresentationMatrix(z);
[     0    1/2      0      0]
[     0      0    1/2      0]
[     0      0      0    1/2]
[-20000      0    210      0]
</PRE>
The awkwardness of the printing of the minimal polynomial above
can be overcome by providing a parent for the polynomial, keeping
in mind that it is a univariate polynomial over the rationals:
<P>
<P>
<PRE>
&gt; P&lt;t&gt; := PolynomialRing(RationalField());
&gt; MinimalPolynomial(z);
t^4 - 105*t^2 + 2500
</PRE>
<HR>
<H4><A NAME = "3859">Other Functions</A></H4>



<H5><A NAME = "3860">ElementToSequence(a) : FldAlgElt -&gt; [ FldAlgElt ]</A></H5>
<H5>Eltseq(a) : FldAlgElt -&gt; [ FldAlgElt ]</H5>
<H5>ElementToSequence(a) : RngOrdElt -&gt; [ FldOrdElt ]</H5>
<H5><A NAME = "RngOrd:Eltseq">Eltseq</A>(a) : RngOrdElt -&gt; [ FldOrdElt ]</H5>
<BLOCKQUOTE>
For an element a of an algebraic field F,
a sequence of coefficients of length degree of F
with respect to the basis is returned.
For an element of an order O, the sequence of coefficients of the
element with respect to the basis of O are returned.
<P>
Note however that the universe of the sequence if always a field
since in general in relative extensions integral coefficients cannot be
achieved.
</BLOCKQUOTE>
<H5><A NAME = "3861">Eltseq(E, k) : FldAlgElt, FldAlg -&gt; [RngElt]</A></H5>
<H5>Eltseq(E, k) : FldAlgElt, Rng -&gt; [RngElt]</H5>
<BLOCKQUOTE>
For an algebraic number E&isin;K and a ring k which occurs somewhere
in the defining tower for K, return the list of coefficients of E
over k, that is, apply <TT>Eltseq</TT> to E and to its coefficients
until the list is over k.
</BLOCKQUOTE>
<H5><A NAME = "3862">Flat(e) : FldAlgElt -&gt; [FldRatElt]</A></H5>
<BLOCKQUOTE>
Given an element in a field K, this returns the coordinates of e
with respect to the <TT>AbsoluteBasis</TT> of K over Q.
</BLOCKQUOTE>
<H5><A NAME = "3863">a[i] : FldAlgElt, RngIntElt -&gt; FldRatElt</A></H5>
<H5>a[i] : FldAlgElt, RngIntElt -&gt; FldAlgElt</H5>
<H5>a[i] : RngOrdElt, RngIntElt -&gt; FldRatElt</H5>
<H5>a[i] : RngOrdElt, RngIntElt -&gt; FldOrdElt</H5>
<BLOCKQUOTE>
The coefficient of the ith basis element in the algebraic field or order 
element a.
</BLOCKQUOTE>
<H5><A NAME = "3864">ProductRepresentation(a) : RngOrdElt -&gt; [ RngOrdElt ], [ RngIntElt ]</A></H5>
<H5>ProductRepresentation(a) : FldAlgElt -&gt; [ FldAlgElt ], [ RngIntElt ]</H5>
<BLOCKQUOTE>
Return sequences P and E such that the product of elements in P to
the corresponding exponents in E is the algebraic number a.
</BLOCKQUOTE>
<H5><A NAME = "3865">ProductRepresentation(P, E) : [ FldAlgElt ], [ RngIntElt ] -&gt; FldAlgElt</A></H5>
<H5>PowerProduct(P, E) : [FldAlgElt], [RngIntElt] -&gt; FldAlgElt</H5>
<BLOCKQUOTE>
Return the element a of the universe of the sequence P such that a
is the product of elements of P to the corresponding exponents in the
sequence E.
</BLOCKQUOTE>
<H5><A NAME = "3866">Valuation(w, I) : RngOrdElt, RngOrdIdl -&gt; RngIntElt</A></H5>
<H5>Valuation(w, I) : FldAlgElt, RngOrdIdl -&gt; RngIntElt</H5>
<BLOCKQUOTE>
Given a prime ideal I and an element w of an order or algebraic field,
this function returns the valuation v<sub>I</sub>(w) of w with respect to I;
this valuation will be a non-negative integer. Ideals are discussed in 
Section <A  HREF = "text394.htm#3929">Ideals and Quotients</A>.
</BLOCKQUOTE>
<H5><A NAME = "3867">Decomposition(a) : RngOrdElt -&gt; SeqEnum[&lt;RngOrdIdl, RngIntElt&gt;]</A></H5>
<H5>Decomposition(a) : FldOrdElt -&gt; SeqEnum[&lt;RngOrdIdl, RngIntElt&gt;]</H5>
<BLOCKQUOTE>
The factorization of the order or algebraic field element a into prime ideals.
</BLOCKQUOTE>
<H5><A NAME = "3868">Divisors(a) : RngOrdElt -&gt; SeqEnum[RngOrdElt]</A></H5>
<BLOCKQUOTE>
For an element a in a maximal order return a sequence containing
(up to units) all the elements which divide a.
The elements of the sequence will be generators for all principal ideals
returned by <TT>Divisors(Parent(a)*a)</TT>.
</BLOCKQUOTE>
<H5><A NAME = "3869">Index(a) : RngOrdElt -&gt; RngIntElt</A></H5>
<BLOCKQUOTE>
The index of the module Z[a] in O where a lies in O,
an order over Z. If a is not a primitive element the index is infinite.
</BLOCKQUOTE>
<H5><A NAME = "3870">Different(a) : RngOrdElt -&gt; RngOrdElt</A></H5>
<BLOCKQUOTE>
The different of the element a of an order of a number field.
</BLOCKQUOTE>
<H5><A NAME = "3871">DegreeOnePrimeIdeals(O, B) : RngOrd, RngIntElt -&gt; [ RngOrdIdl ]</A></H5>
<BLOCKQUOTE>
Given an order O as well as a positive integer bound B, return
a sequence consisting of all prime ideals in O whose norm is
a rational prime not exceeding the bound B.
</BLOCKQUOTE>
<PRE></PRE> <A  HREF = "text391.htm">[Next]</A><A  HREF = "text389.htm">[Prev]</A> <A  HREF = "text391.htm">[Right]</A> <A  HREF = "text389.htm">[Left]</A> <A  HREF = "text383.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<br><small>Version: V2.22 of <I>
Thu Jun  9 16:37:49 EST 2016
</I></small>
</body></html>