<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <link rel='stylesheet' href='help.css' type='text/css'>
  <TITLE>Canonical Forms</TITLE>
</head>
<body BGCOLOR="#FFFFFF">

 <A  HREF = "text260.htm">[Next]</A><A  HREF = "text258.htm">[Prev]</A> <A  HREF = "text260.htm">[Right]</A> <A  HREF = "text258.htm">[Left]</A> <A  HREF = "text247.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<PRE></PRE><H3><A NAME = "2409">Canonical Forms</A></H3>




<H5>Subsections</H5>
<UL>
<LI> <A  HREF = "text259.htm#2410">Canonical Forms over General  Rings</A>
<LI> <A  HREF = "text259.htm#2413">Canonical Forms over Fields</A>
<LI> <A  HREF = "text259.htm#2423">Canonical Forms over Euclidean Domains</A>
</UL>
<H4><A NAME = "2410">Canonical Forms over General  Rings</A></H4>

<P>
<P>
The functions defined here apply to matrices defined over fields
or Euclidean domains.
See also the section on Reduction in the Lattices chapter for a description
of the function <A  HREF = "text312.htm#Lat:LLL">LLL</A> and related basis-reduction functions for
matrices.


<H5><A NAME = "2411">EchelonForm(A) : Mtrx -&gt; Mtrx, AlgMatElt</A></H5>
<BLOCKQUOTE>
Given an m x n matrix A over the ring R, return the (reduced)
row echelon form E of A, and also an invertible m x m
transformation matrix T over R such that T.A = E.  Recall 
that T is a product of elementary matrices that transforms A into 
the echelon form E.  If R is a Euclidean domain, the function 
<A  HREF = "text259.htm#Mat:HermiteForm">HermiteForm</A> (described below) is invoked.  Note however, that the
the user cannot set the parameters for <A  HREF = "text259.htm#Mat:HermiteForm">HermiteForm</A> when invoking it
via <TT>EchelonForm</TT>.
</BLOCKQUOTE>
<H5><A NAME = "2412">Adjoint(A) : Mtrx -&gt; AlgMatElt</A></H5>
<BLOCKQUOTE>
Given a square m x m matrix A over the ring R, return the
adjoint of A as an m x m matrix.
The base ring R must be a ring with exact division whose
characteristic is zero or greater than m
(this includes most commutative rings).
</BLOCKQUOTE>
<H4><A NAME = "2413">Canonical Forms over Fields</A></H4>

<P>
<P>
The functions described in this section apply to square matrices defined 
over fields which support factorization of univariate polynomials.
See <A  HREF = "text246.htm#bib_Steel_Canonical">[Ste97]</A> for a description of the single algorithm which is
the basis of most of these functions.


<H5><A NAME = "2414">PrimaryRationalForm(A) : Mtrx -&gt; AlgMatElt, AlgMatElt, [ &lt;RngUPolElt, RngIntElt ]</A></H5>
<BLOCKQUOTE>
Given a square matrix A over a field K such that factorization
of polynomials is possible over K, return the primary rational form
of A.  Each block in the form is the companion matrix of a power of
an irreducible polynomial.  This function returns three values:
<P>
<DL COMPACT class='compact'>
<DT>(a)</DT><DD>The primary rational canonical form F of A;
<DT>(b)</DT><DD>An invertible matrix T such that T.A.T<sup> - 1</sup> = F;
<DT>(c)</DT><DD>A sequence of pairs corresponding to the blocks of F
    where each pair consists of the irreducible polynomial
    and the multiplicity making up the block.  This is the 
    value returned by <TT>PrimaryInvariantFactors(A)</TT>.</DL>
</BLOCKQUOTE>
<H5><A NAME = "2415">JordanForm(A) : Mtrx -&gt; Mtrx, AlgMatElt, [ &lt;RngUPolElt, RngIntElt&gt; ]</A></H5>
<BLOCKQUOTE>
Given a square matrix A over a field K such that factorization
of polynomials is possible over K, return the generalized Jordan form
of A.  Each block in the form is a Jordan block (which itself
is derived from a power of an irreducible polynomial), and
the generalized Jordan form corresponds to the usual Jordan form 
if the minimal polynomial splits over K.  
This function returns three values:
<P>
<DL COMPACT class='compact'>
<DT>(a)</DT><DD>The Jordan canonical form F of A;
<DT>(b)</DT><DD>An invertible matrix T such that T.A.T<sup> - 1</sup> = F;
<DT>(c)</DT><DD>A sequence of pairs corresponding to the blocks of F
    where each pair consists of the irreducible polynomial
    and the multiplicity making up the block.
    This is the value returned by <TT>PrimaryInvariantFactors(A)</TT>.</DL>
</BLOCKQUOTE>
<H5><A NAME = "2416">RationalForm(A) : Mtrx -&gt; Mtrx, AlgMatElt, [ RngUPolElt ]</A></H5>
<BLOCKQUOTE>
Given a square matrix A over a field K such that factorization
of polynomials is possible over K, return the rational form
of A.
For each block other than the final block, the polynomial
corresponding to that block divides the polynomial corresponding to the
next block.  This function returns three values:
<P>
<DL COMPACT class='compact'>
<DT>(a)</DT><DD>The rational form F of A;
<DT>(b)</DT><DD>An invertible matrix T such that T.A.T<sup> - 1</sup> = F;
<DT>(c)</DT><DD>A sequence containing the polynomials corresponding to the
    successive blocks (where each polynomial, other than the last, 
    divides the next polynomial).
    This is the value returned by <TT>InvariantFactors(A)</TT>.</DL>
</BLOCKQUOTE>
<H5><A NAME = "2417">PrimaryInvariantFactors(A) : Mtrx -&gt; [ &lt;RngUPolElt, RngIntElt&gt; ]</A></H5>
<BLOCKQUOTE>
Given a square matrix A over a field K such that factorization
of polynomials is possible over K, return the primary invariant
factors of A.  This is the same as the third return value of <TT>PrimaryRationalForm(A)</TT> or <TT>JordanForm(A)</TT>.
</BLOCKQUOTE>
<H5><A NAME = "2418">InvariantFactors(A) : Mtrx -&gt; [ RngUPolElt ]</A></H5>
<BLOCKQUOTE>
Given a square matrix A over a field K such that factorization
of polynomials is possible over K, return the invariant factors of
A.  This is the same as the third return value of <TT>RationalForm(A)</TT>.
</BLOCKQUOTE>
<H5><A NAME = "2419">IsSimilar(A, B) : AlgMatElt, AlgMatElt -&gt; BoolElt, AlgMatElt</A></H5>
<BLOCKQUOTE>
Given square m x m matrices A and B, both over a field K
such that factorization of polynomials is possible over K,
return <TT>true</TT> iff and only if A is similar to B, and if so, return also
an invertible m x m  transformation matrix T such that
T.A.T<sup> - 1</sup> = B.
</BLOCKQUOTE>
<H5><A NAME = "2420">HessenbergForm(A) : Mtrx -&gt; AlgMatElt</A></H5>
<BLOCKQUOTE>
Given a square m x m matrix A over the ring R, return the
Hessenberg form of A as an m x m matrix.  The form has zero
entries above the super-diagonal.  (This form is used in one of the
characteristic polynomial algorithms.)  The base ring R must be a
field.
</BLOCKQUOTE>
<H5><A NAME = "2421">FrobeniusFormAlternating(A) : AlgMatElt -&gt; SeqEnum</A></H5>
<BLOCKQUOTE>
Given a non-singular 2n x 2n alternating matrix A over the
integers, this function returns the (alternating) Frobenius form F of A. 
That is, a block matrix 
F = (matrix(0 &amp; D cr
 - D &amp; 0)),
where
D is a diagonal matrix with positive diagonal entries, d<sub>i</sub>, satisfying
d<sub>1</sub> | d<sub>2</sub> | ... | d<sub>n</sub>. The second return value is the change of 
basis matrix B, such that BA ()<sup>t</sup>B = F.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "2422">Example <TT>Mat_CanonicalForms (H26E9)</TT></A></H3>
We construct a 5 x 5 matrix over the finite field with 5 elements
and then calculate various canonical forms.  We verify the correctness
of the polynomial invariant factors corresponding to the rational form by
calculating the Smith form of the characteristic matrix of the original
matrix (see below).
<P>
<P>
<PRE>
&gt; K := GF(5);
&gt; A := Matrix(K, 5, 
&gt;     [ 0, 2, 4, 2, 0,
&gt;       2, 2, 2, 3, 3,
&gt;       3, 4, 4, 1, 3,
&gt;       0, 0, 0, 0, 1,
&gt;       0, 0, 0, 1, 0 ]);
&gt; A;
[0 2 4 2 0]
[2 2 2 3 3]
[3 4 4 1 3]
[0 0 0 0 1]
[0 0 0 1 0]
&gt; PrimaryInvariantFactors(A);
[
    &lt;x + 1, 1&gt;,
    &lt;x + 1, 1&gt;,
    &lt;x + 4, 1&gt;,
    &lt;x + 4, 1&gt;,
    &lt;x + 4, 1&gt;
]
&gt; JordanForm(A);
[4 0 0 0 0]
[0 4 0 0 0]
[0 0 1 0 0]
[0 0 0 1 0]
[0 0 0 0 1]
&gt; R, T, F := RationalForm(A);
&gt; R;
[1 0 0 0 0]
[0 0 1 0 0]
[0 1 0 0 0]
[0 0 0 0 1]
[0 0 0 1 0]
&gt; T;
[1 3 0 2 1]
[2 1 2 2 0]
[3 4 3 4 1]
[1 0 0 0 0]
[0 2 4 2 0]
&gt; T*A*T^-1 eq R;
true;
&gt; F;
[
    x + 4,
    x^2 + 4,
    x^2 + 4
]
&gt; P&lt;x&gt; := PolynomialRing(K);
&gt; PM := MatrixAlgebra(P, 5);
&gt; Ax := PM ! x - PM ! A;
&gt; Ax;
[    x     3     1     3     0]
[    3 x + 3     3     2     2]
[    2     1 x + 1     4     2]
[    0     0     0     x     4]
[    0     0     0     4     x]
&gt; SmithForm(Ax);
[      1       0       0       0       0]
[      0       1       0       0       0]
[      0       0   x + 4       0       0]
[      0       0       0 x^2 + 4       0]
[      0       0       0       0 x^2 + 4]
&gt; ElementaryDivisors(Ax);
[
    1,
    1,
    x + 4,
    x^2 + 4,
    x^2 + 4
]
</PRE>
<HR>
<H4><A NAME = "2423">Canonical Forms over Euclidean Domains</A></H4>

<P>
<P>
The functions defined here apply to matrices defined over Euclidean domains.
See also the section on Reduction in the Lattices chapter for a description
of the function <A  HREF = "text312.htm#Lat:LLL">LLL</A> and related functions, which are very useful
for integer matrices.


<H5><A NAME = "2424"></A><A NAME = "Mat:HermiteForm">HermiteForm</A>(A) : Mtrx -&gt; Mtrx, ModMatRngElt</H5>

<PRE>    Al: MonStg                          Default: "Default"</PRE>

<PRE>    Optimize: BoolElt                   Default: <TT>true</TT></PRE>

<PRE>    Integral: BoolElt                   Default: <TT>true</TT></PRE>
<BLOCKQUOTE>
Given an m x n matrix A over the Euclidean ring R, return the
Hermite form H of A, and also an invertible m x m
transformation matrix T over R such that T.A = H.
<P>
The basic algorithm used is the classical
Kannan-Bachem algorithm <A  HREF = "text246.htm#bib_KannanBachem">[KB79]</A>, <A  HREF = "text246.htm#bib_ChouCollins">[CC82]</A>, which
has classical complexity (but does not suffer from bad coefficient growth).
<P>
Since V2.13, for matrices over the integers there is also a fast
modular algorithm by Allan Steel.
By default, Magma chooses between these two algorithms, usually
favouring the new modular algorithm.  But one may set the parameter
<TT>Al</TT> to <TT>"Modular"</TT> to force the modular algorithm to be
used, and to <TT>"Classical"</TT> to force the classical algorithm to be
used.
<P>
If R is the ring of integers Z and the matrix T is requested
(i.e., if an assignment statement is used with two variables on the left
side), then the LLL algorithm will also be used by default to improve T
(using the kernel of A) so that the size of its entries are very small.
If the parameter <TT>Optimize</TT> is set to <TT>false</TT>, then this will not
happen (which will be faster but the entries of T will not be as small).
If the parameter <TT>Integral</TT> is set to <TT>true</TT>, then the integral (de
Weger) LLL method will be used in the LLL step, instead of the default
floating point method.
</BLOCKQUOTE>
<H5><A NAME = "2425"></A><A NAME = "Mat:SmithForm">SmithForm</A>(A) : ModMatRngElt -&gt; ModMatRngElt, ModMatRngElt, ModMatRngElt</H5>
<BLOCKQUOTE>
Given an m x n matrix A over the Euclidean ring R,
return the Smith normal form of A.
This function returns three values:
<DL COMPACT class='compact'>
<DT>(a)</DT><DD>The Smith normal form S of A; and
<DT>(b)</DT><DD>Unimodular matrices P and Q such that P.A.Q = S,
i.e., P and Q are matrices which transform A into Smith normal form.
<P>
</DL>
The algorithm implemented first uses the sparse techniques described in
<A  HREF = "text246.htm#bib_HHR_Smith">[HHR93]</A> to reduce the matrix to a dense submatrix, then,
if this is non-trivial, it either repeatedly calls the Hermite normal form
algorithm (see above) and transposes until a diagonal form is obtained,
or uses the modular algorithm of F. L&uuml;beck <A  HREF = "text246.htm#bib_Luebeck_SmithForm">[L&uuml;b02]</A>.
<P>
Unless one wishes one or both of the transformation matrices, it
is preferable to use the following function <TT>ElementaryDivisors</TT>
since it gives the same information, but saves memory since the
matrix S does not need to be constructed.
</BLOCKQUOTE>
<H5><A NAME = "2426">ElementaryDivisors(A) : Mtrx -&gt; [RngElt]</A></H5>
<BLOCKQUOTE>
Given an m x n matrix A over the Euclidean ring or field R,
return the elementary divisors of A.
These are simply the non-zero diagonal entries of the Smith form of A,
in order.
The divisors are returned as a sequence
[e<sub>1</sub>, ..., e<sub>r</sub>]
of r elements of R (which may include ones),
where r is the rank of A
and e<sub>i</sub> | e<sub>i + 1</sub> for i=1, ..., r - 1.
The divisors are normalized, so the result is unique.
If R is a field, the result is always the sequence of r ones,
where r is the rank of A.
<P>
Note that if m=n=r,
then the determinant of A is the product of the e<sub>i</sub> and if R
is also a domain, then e<sub>r</sub> is the lowest common denominator of
the inverse of A over the field of fractions of R.
</BLOCKQUOTE>
<H5><A NAME = "2427"></A><A NAME = "Mat:Saturation">Saturation</A>(A) : Mtrx -&gt; Mtrx</H5>
<BLOCKQUOTE>
Given an m x n matrix A over the integer ring Z, having rank
r, return an m x n matrix S over Z whose first r rows
form a basis of the saturation w.r.t. Q of the Q-vector space
spanned by the rows of A.  The rows of S thus span the same
space over Q as those of A, while the Z-module spanned by
the rows of S is the set of all v such that for some non-zero scalar
s, s.v is in the Z-module spanned by the rows of A.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "2428">Example <TT>Mat_Forms1 (H26E10)</TT></A></H3>
We illustrate some of these operations for a 4 x 3 matrix over GF(8).
<P>
<P>
<PRE>
&gt; K&lt;w&gt; := GF(8);
&gt; A := Matrix(K, 4, 3, [1,w,w^5, 0,w^3,w^4, w,1,w^6, w^3,1,w^4]);
&gt; A;
[  1   w w^5]
[  0 w^3 w^4]
[  w   1 w^6]
[w^3   1 w^4]
&gt; EchelonForm(A);
[  1   0   0]
[  0   1   0]
[  0   0   1]
[  0   0   0]
</PRE>
We now illustrate some of these operations for a 4 x 5 matrix over Z.
<P>
<P>
<PRE>
&gt; A := Matrix(4, 5,
&gt;     [ 2,-4,12,7,0,
&gt;       3,-3,5,-1,4,
&gt;       2,-1,-4,-5,-12,    
&gt;       0,3,6,-2,0]);
&gt; A;
[  2  -4  12   7   0]
[  3  -3   5  -1   4]
[  2  -1  -4  -5 -12]
[  0   3   6  -2   0]
&gt; Rank(A);
4
&gt; HermiteForm(A);
[   1    1    1    6 -164]
[   0    3    0   16 -348]
[   0    0    2   13 -200]
[   0    0    0   19 -316]
&gt; SmithForm(A);
[1 0 0 0 0]
[0 1 0 0 0]
[0 0 1 0 0]
[0 0 0 2 0]
&gt; ElementaryDivisors(A);
[ 1, 1, 1, 2 ]
</PRE>
<HR>
<PRE></PRE> <A  HREF = "text260.htm">[Next]</A><A  HREF = "text258.htm">[Prev]</A> <A  HREF = "text260.htm">[Right]</A> <A  HREF = "text258.htm">[Left]</A> <A  HREF = "text247.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<br><small>Version: V2.22 of <I>
Thu Jun  9 16:37:49 EST 2016
</I></small>
</body></html>