<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <link rel='stylesheet' href='help.css' type='text/css'>
  <TITLE>Building Root Data</TITLE>
</head>
<body BGCOLOR="#FFFFFF">

 <A  HREF = "text1096.htm">[Next]</A><A  HREF = "text1094.htm">[Prev]</A> <A  HREF = "text1096.htm">[Right]</A> <A  HREF = "text1094.htm">[Left]</A> <A  HREF = "text1089.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<PRE></PRE><H3><A NAME = "12273">Building Root Data</A></H3>



<H5><A NAME = "12274">sub&lt;R | a&gt; : RootDtm, SetEnum -&gt; RootDtm</A></H5>
<BLOCKQUOTE>
The root subdatum of the root datum R generated by the roots
&alpha;<sub>a<sub>1</sub></sub>, ..., &alpha;<sub>a<sub>k</sub></sub> where a={a<sub>1</sub>, ..., a<sub>k</sub>} is a set of
integers.
</BLOCKQUOTE>
<H5><A NAME = "12275">sub&lt;R | s&gt; : RootDtm, SetEnum -&gt; RootDtm</A></H5>
<BLOCKQUOTE>
The root subdatum of the root datum R generated by the roots
&alpha;<sub>s<sub>1</sub></sub>, ..., &alpha;<sub>s<sub>k</sub></sub> where
s=[s<sub>1</sub>, ..., s<sub>k</sub>] is a <I>sequence</I> of integers.  In this version
the roots must be simple in the root subdatum (i.e. none of them may
be a summand of another)  otherwise an error
is signalled.  The simple roots will appear in the subdatum in the
given order.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "12276">Example <TT>RootDtm_RootSubdata (H103E26)</TT></A></H3>
<P>
<P>
<PRE>
&gt; R := RootDatum("A4");
&gt; PositiveRoots(R);
{@
    (1 0 0 0),
    (0 1 0 0),
    (0 0 1 0),
    (0 0 0 1),
    (1 1 0 0),
    (0 1 1 0),
    (0 0 1 1),
    (1 1 1 0),
    (0 1 1 1),
    (1 1 1 1)
@}
&gt; s := sub&lt; R | [6,1,4] &gt;;
&gt; s;
Root datum of type A3
&gt; PositiveRoots(s);
{@
    (0 1 1 0),
    (1 0 0 0),
    (0 0 0 1),
    (1 1 1 0),
    (0 1 1 1),
    (1 1 1 1)
@}
&gt; s := sub&lt; R | [1,5] &gt;;
Error: The given roots are not simple in a subdatum
&gt; s := sub&lt; R | {1,5} &gt;;
&gt; s;
Root datum of type A2
&gt; PositiveRoots(s);
{@
    (1 0 0 0),
    (0 1 0 0),
    (1 1 0 0)
@}
</PRE>
<HR>
<H5><A NAME = "12277">R1 subset R2 : RootDtm, RootDtm -&gt; BoolElt, .</A></H5>
<BLOCKQUOTE>
Returns <TT>true</TT> if and only if the root datum R<sub>1</sub> is a subset of the root datum R<sub>2</sub>.
If true, returns an injection as sequence of roots as second return value.
</BLOCKQUOTE>
<H5><A NAME = "12278">R1 + R2 : RootDtm, RootDtm -&gt; RootDtm</A></H5>
<H5>DirectSum(R1, R2) : RootDtm, RootDtm -&gt; RootDtm</H5>
<BLOCKQUOTE>
The external direct sum of the root data R<sub>1</sub> and R<sub>2</sub>. 
The full (co)root space of the result
is the direct sum of the full (co)root spaces of R<sub>1</sub> and R<sub>2</sub>.
</BLOCKQUOTE>
<H5><A NAME = "12279">R1 join R2 : RootDtm, RootDtm -&gt; RootDtm</A></H5>
<BLOCKQUOTE>
The internal direct sum of the root data R<sub>1</sub> and R<sub>2</sub>. 
The root data must have the
same full (co)root space, which will also be the full (co)root space of the result.
The root data must have disjoint (co)root spaces.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "12280">Example <TT>RootDtm_RootDtmSums (H103E27)</TT></A></H3>
<P>
<P>
<PRE>
&gt; R  := RootDatum("A1A1");
&gt; R1 := sub&lt;R|[1]&gt;;
&gt; R2 := sub&lt;R|[2]&gt;;
&gt; R1 + R2;
Root datum of dimension 4 of type A1 A1
&gt; R1 join R2;
R: Adjoint root datum of dimension 2 of type A1 A1
</PRE>
<HR>
<H5><A NAME = "12281">DirectSumDecomposition(R) : RootDtm -&gt; [], RootDtm, Map</A></H5>
<H5>IndecomposableSummands(R) : RootDtm -&gt; [], RootDtm, Map</H5>
<BLOCKQUOTE>
Returns a sequence Q of irreducible root data, a root datum S which is the
direct sum of the terms of Q, and an isogeny map &phi;:S to R.
The root datum R must be semisimple.
Note that a semisimple root datum R need not be a direct sum of simple root data, but it is isogenous to a direct sum 
of root data S.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "12282">Example <TT>RootDtm_RootDtmDecomp (H103E28)</TT></A></H3>
If the root datum in adjoint or simply connected, then it is a direct sum of
simples.  In this case we get S=R.
<P>
<P>
<PRE>
&gt; R := RootDatum("A4B5" : Isogeny:="SC"); 
&gt; Q, S := DirectSumDecomposition( R );
&gt; R eq S;
true
&gt; R eq Q[1] join Q[2];
true
</PRE>
The join of the summands of the direct sum 
decomposition is the original root datum again:
<P>
<P>
<PRE>
&gt; R eq &amp;join DirectSumDecomposition(R);
true
&gt; R eq &amp;+    DirectSumDecomposition(R);
false
</PRE>
<P>
<P>
<PRE>
&gt; R1 := RootDatum("A3T2B4T3");
&gt; R2 := RootDatum("T3G2T4BC3");
&gt; R1 + R2;
Adjoint root datum of dimension 24 of type A3 B4 G2 BC3
&gt; R1 join R2;
Root datum of dimension 12 of type A3 B4 G2 BC3
</PRE>
Here is an example of a semisimple root datum which is not a direct sum of
simple subdata.  Note that a simple root datum of type A<sub>1</sub> is either simply
connected or adjoint.
<P>
<P>
<PRE>
&gt; G&lt;a,b&gt;:=FundamentalGroup("A1A1");
&gt; _,inj:=sub&lt;G|a*b&gt;;
&gt; R:=RootDatum("A1A1":Isogeny:=inj);
&gt; ad := RootDatum( "A1" : Isogeny:="Ad" );
&gt; sc := RootDatum( "A1" : Isogeny:="SC" );
&gt; IsIsomorphic( R, DirectSum(ad,ad) );
false
&gt; IsIsomorphic( R, DirectSum(ad,sc) );
false
&gt; IsIsomorphic( R, DirectSum(sc,sc) );
false
&gt; Q, S := DirectSumDecomposition( R );  
&gt; R eq S;                             
false
</PRE>
<HR>
<H5><A NAME = "12283">Dual(R) : RootDtm -&gt; RootDtm, Map</A></H5>
<BLOCKQUOTE>
The dual of the root datum R, obtained by swapping the roots and coroots.
The second value returned is the dual morphism from R to its dual.
</BLOCKQUOTE>
<H5><A NAME = "12284">SimplyConnectedVersion(R) : RootDtm -&gt; RootDtm, Map</A></H5>
<BLOCKQUOTE>
The simply connected version of the root datum R.
If R is semisimple then the injection of the simply connected version into
R is returned as the second value.
</BLOCKQUOTE>
<H5><A NAME = "12285">AdjointVersion(R) : RootDtm -&gt; RootDtm, Map</A></H5>
<BLOCKQUOTE>
The adjoint version of the root datum R.
If R is semisimple then the projection from R to its adjoint version
is returned as the second value.
</BLOCKQUOTE>
<H5><A NAME = "12286">IndivisibleSubdatum(R) : RootDtm -&gt; RootDtm</A></H5>
<BLOCKQUOTE>
The root datum consisting of all indivisible roots of the root datum R.
</BLOCKQUOTE>
<H5><A NAME = "12287">Radical(R) : RootDtm -&gt; RootDtm</A></H5>
<BLOCKQUOTE>
The radical of the root datum R, ie, the toral subdatum whose root 
(resp. coroot) space consists of the vectors perpendicular to every coroot
(resp. root).
</BLOCKQUOTE>
<HR>
<H3><A NAME = "12288">Example <TT>RootDtm_DirectSumDualRadical (H103E29)</TT></A></H3>
An adjoint or simply connect root datum is always a direct sum of irreducible
subdata.  In these cases we take S=R.
<P>
<P>
<PRE>
&gt; R1 := RootDatum("A5");
&gt; R2 := RootDatum("B4");
&gt; R := DirectSum(R1, Dual(R2));
&gt; DirectSumDecomposition(R);
{
    Root datum of type A5 ,
    Root datum of type C4 
}
</PRE>
<P>
<P>
<PRE>
&gt; R := RootDatum("BC2");
&gt; I := IndivisibleSubdatum(R); I;
I: Root datum of type B2
&gt; I subset R;
true [ 1, 2, 3, 5, 7, 8, 9, 11 ]
</PRE>
<P>
<P>
<PRE>
&gt; R := StandardRootDatum("A", 3);   
&gt; Radical(R);
Toral root datum of dimension 1
</PRE>
<HR>
<H5><A NAME = "12289">TwistedRootDatum(R) : RootDtm -&gt; RootDtm</A></H5>
<H5>TwistedRootDatum(N) : MonStgElt -&gt; RootDtm</H5>

<PRE>    Twist: Any                          Default: 1</PRE>
<BLOCKQUOTE>
Create a twisted root datum from the root datum R, or from
the semisimple root datum with Cartan name N. The twist may
be specified in any of the following ways:
<P>
<DL COMPACT class='compact'>
<DT><IMG SRC="closed.gif" ALT="" WIDTH=7 HEIGHT=7></DT><DD>An integer, specifying the order of the twist;
<DT><IMG SRC="closed.gif" ALT="" WIDTH=7 HEIGHT=7></DT><DD>A permutation, specifying the action of the primitive roots;
<DT><IMG SRC="closed.gif" ALT="" WIDTH=7 HEIGHT=7></DT><DD>A pair &lt;D, i&gt;, where D is a set of distinguished orbits
as sets of integers, and i is the order of the Dynkin diagram symmetry;
<DT><IMG SRC="closed.gif" ALT="" WIDTH=7 HEIGHT=7></DT><DD>A pair &lt;&Gamma;, Q&gt;, where &Gamma; is the acting group, and Q 
is a sequence containing the permutation of the primitive roots for each of the
generators of &Gamma;;
<DT><IMG SRC="closed.gif" ALT="" WIDTH=7 HEIGHT=7></DT><DD>A homomorphism from &Gamma; to the symmetric group whose order
is the number of roots of R, describing how the acting group &Gamma; acts on
the roots.</DL>
</BLOCKQUOTE>
<HR>
<H3><A NAME = "12290">Example <TT>RootDtm_DirectSumDualRadical (H103E30)</TT></A></H3>
We construct a twisted root datum in a number of ways.
<P>
<P>
<PRE>
&gt; S := TwistedRootDatum("D4" : Twist := 3);
&gt; S;
S: Twisted adjoint root datum of dimension 4 of type 3D4,2 


&gt; R := RootDatum("A1A3");
&gt; DynkinDiagram(R);


A1    1


A3    2 - 3 - 4
&gt; S := TwistedRootDatum(R : Twist := Sym(4)!(2,4));
&gt; S;
S: Twisted adjoint root datum of dimension 4 of type 2(A1 A3)4,3 


&gt; S := TwistedRootDatum("A4" : Twist := &lt;{{1,4},{2,3}}, 2&gt;);
&gt; S;
S: Twisted adjoint root datum of dimension 4 of type 2A4,2 


&gt; R := RootDatum("E6" : Isogeny := "SC");
&gt; DynkinDiagram(R);


E6    1 - 3 - 4 - 5 - 6
              |
              2
&gt; S := TwistedRootDatum(R : Twist := &lt;Sym(2) ,[ Sym(6)!(1,6)(3,5) ]&gt;);
&gt; S;
S: Twisted simply connected root datum of dimension 6 of type 2E6,4 


&gt; R := RootDatum("D4");
&gt; DynkinDiagram(R);


D4    3
     /
1 - 2
     \
      4
&gt; Gamma := Sym(3);
&gt; Gamma.1, Gamma.2;
(1, 2, 3)
(1, 2)
&gt; S := TwistedRootDatum(R : Twist := &lt;Gamma, [ Sym(4) | (1,3,4), (1,4) ]&gt;);
&gt; S;
S: Twisted adjoint root datum of dimension 4 of type 6D4,2 


&gt; R := RootDatum("A2");
&gt; DynkinDiagram(R);


A2    1 - 2
&gt; Roots(R);
{@
    (1 0),
    (0 1),
    (1 1),
    (-1  0),
    ( 0 -1),
    (-1 -1)
@}
&gt; S6 := Sym(#Roots(R));
&gt; phi := hom&lt;Sym(2) -&gt; S6 | S6!(1,2)(4,5)&gt;;
&gt; S := TwistedRootDatum(R : Twist := phi);
</PRE>
<HR>
<H5><A NAME = "12291">UntwistedRootDatum(R) : RootDtm -&gt; RootDtm</A></H5>
<H5>SplitRootDatum(R) : RootDtm -&gt; RootDtm</H5>
<BLOCKQUOTE>
The split version of the (twisted) root datum R.
</BLOCKQUOTE>
<PRE></PRE> <A  HREF = "text1096.htm">[Next]</A><A  HREF = "text1094.htm">[Prev]</A> <A  HREF = "text1096.htm">[Right]</A> <A  HREF = "text1094.htm">[Left]</A> <A  HREF = "text1089.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<br><small>Version: V2.22 of <I>
Thu Jun  9 16:37:49 EST 2016
</I></small>
</body></html>