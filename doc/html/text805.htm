<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <link rel='stylesheet' href='help.css' type='text/css'>
  <TITLE>Homomorphisms</TITLE>
</head>
<body BGCOLOR="#FFFFFF">

 <A  HREF = "text785.htm">[Next]</A><A  HREF = "text804.htm">[Prev]</A> <A  HREF = "text785.htm">[Right]</A> <A  HREF = "text804.htm">[Left]</A> <A  HREF = "text786.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<PRE></PRE><H3><A NAME = "9081">Homomorphisms</A></H3>

<P>
<P>
<P>
Two functions are provided to construct homomorphisms or 
  isomorphisms from one group into another,
  where either of the groups, or both, may be generic abelian 
  groups.


<H5><A NAME = "9082">hom&lt; A -&gt; B | L&gt; : Grp, Grp, List -&gt; Map</A></H5>
<BLOCKQUOTE>
Given groups A and B, construct a homomorphism from 
A to B as defined by the extension L. If one or both of
A and B are generic abelian groups this 
  works as usual, with one minor difference
  as explained below.
Suppose that the generators of A are g<sub>1</sub>, ..., g<sub>n</sub>,
   and that &phi;(g<sub>i</sub>)=h<sub>i</sub> for each i, where &phi; is the 
   homomorphism one wishes to construct.
The list L as required by the constructors  must be one of the following:
<DL COMPACT class='compact'>
<DT>(a)</DT><DD>a list of the n 2-tuples &lt; g<sub>i</sub>, h<sub>i</sub> &gt; (order not important);
<DT>(b)</DT><DD>a list of the n arrow-pairs g<sub>i</sub> -&gt; h<sub>i</sub> 
  (order not important);
<DT>(c)</DT><DD>h<sub>1</sub>, ..., h<sub>n</sub> (order is important).
<P>
<P>
<P>
</DL>
If A is a generic abelian group this rule is relaxed somewhat 
  in the following sense:
If L is a list of n 2-tuples or of n arrow-pairs, the 
  elements g<sub>i</sub> need not be the defining generators of A.
The only requirement is that the set {g<sub>1</sub>, ..., g<sub>n</sub>}
  does actually generate the whole of A.
</BLOCKQUOTE>
<H5><A NAME = "9083">Homomorphism(A, B, X, Y) : Grp, Grp, [ GrpElt ], [ GrpElt ]  -&gt; Map</A></H5>
<BLOCKQUOTE>
Creates a homomorphism
  from A into B as given by the mapping of
  X into Y.
The arguments A and B may be any type of group, including
of course, generic abelian groups.
<P>
<P>
The function <TT>Homomorphism</TT> does not require the
elements of the argument X to be generators of A as given
  by <TT>Generators(A)</TT>, so it
  allows more freedom when creating a homomorphism.
If, however, these elements fail to generate the whole of A
  then the subsequent map application will fail.
</BLOCKQUOTE>
<H5><A NAME = "9084">iso&lt; A -&gt; B | L&gt; : Grp, Grp, List -&gt; Map</A></H5>
<BLOCKQUOTE>
Given groups A and B, construct an isomorphism from
A to B as defined by the extension L. If one or both of
A and B are generic abelian groups this 
  works as usual, with one minor difference
  as explained below.
Suppose that the generators of A are g<sub>1</sub>, ..., g<sub>n</sub>,
   and that &phi;(g<sub>i</sub>)=h<sub>i</sub> for each i, where &phi; is the
   isomorphism one wishes to construct.
The list L as required by the constructors  must be one of the following:
<DL COMPACT class='compact'>
<DT>(a)</DT><DD>a list of the n 2-tuples &lt; g<sub>i</sub>, h<sub>i</sub> &gt; (order not important);
<DT>(b)</DT><DD>a list of the n arrow-pairs g<sub>i</sub> -&gt; h<sub>i</sub>
  (order not important);
<DT>(c)</DT><DD>h<sub>1</sub>, ..., h<sub>n</sub> (order is important).
<P>
<P>
<P>
</DL>
If A is a generic abelian group this rule is relaxed somewhat
  in the following sense:
If L is a list of n 2-tuples or of n arrow-pairs, the
  elements g<sub>i</sub> may not necessarily be generators 
  of A as given by the function <TT>Generators(A)</TT>.
The only requirement is that the set 
   {h<sub>1</sub>, ..., h<sub>n</sub>} does actually generate the whole of B.
</BLOCKQUOTE>
<H5><A NAME = "9085">Isomorphism(A, B, X, Y) : Grp, Grp, [ GrpElt ], [ GrpElt ]  -&gt; Map</A></H5>
<BLOCKQUOTE>
Creates a isomorphism
  from A into B as given by the mapping of
  X into Y.
The arguments A and B can be any type of group, including 
of course, generic abelian groups.
<P>
<P>
The function <TT>Isomorphism</TT> does not require the
elements of the argument X to be generators of A as given 
  by <TT>Generators(A)</TT>, so 
it allows more freedom when creating an isomorphism.
If, however, these elements fail to generate the whole of A
  then the subsequent map application will fail.
</BLOCKQUOTE>
<HR>
<H3><A NAME = "9086">Example <TT>GrpAb_Homomorphisms (H74E15)</TT></A></H3>
Recall that we defined the subgroups GH1<sub>Zm</sub> and GH2<sub>Zm</sub> of
G as:
<P>
<P>
<PRE>
&gt; GH1_Zm;
Generic Abelian Group over
Residue class ring of integers modulo 34384
Abelian Group isomorphic to Z/6 + Z/612
Defined on 2 generators in supergroup G:
  GH1_Zm.1 = G.2 + G.3
  GH1_Zm.2 = G.4
Relations:
  6*GH1_Zm.1 = 0
  612*GH1_Zm.2 = 0
&gt; GH2_Zm;
Generic Abelian Group over
Residue class ring of integers modulo 34384
Abelian Group isomorphic to Z/2 + Z/2 + Z/6 + Z/612
Defined on 4 generators in supergroup G:
  GH2_Zm.1 = G.1
  GH2_Zm.2 = G.2
  GH2_Zm.3 = G.3
  GH2_Zm.4 = G
Relations:
  2*GH2_Zm.1 = 0
  2*GH2_Zm.2 = 0
  6*GH2_Zm.3 = 0
  612*GH2_Zm.4 = 0
</PRE>
We construct the homomorphism 
<P>
<P>
<PRE>
&gt; h := hom&lt;GH1_Zm -&gt; GH2_Zm | GH2_Zm.1, GH2_Zm.2 &gt;;
&gt; h(GH1_Zm);
Generic Abelian Group over
Residue class ring of integers modulo 34384
Abelian Group isomorphic to Z/2 + Z/2
Defined on 2 generators in supergroup GH2_Zm:
  $.1 = GH2_Zm.2
  $.2 = GH2_Zm.1
Relations:
  2*$.1 = 0
  2*$.2 = 0
</PRE>
but we cannot construct the isomorphism
<P>
<P>
<PRE>
&gt; i := iso&lt;GH1_Zm -&gt; GH2_Zm | GH2_Zm.1, GH2_Zm.2 &gt;;

&gt;&gt; i := iso&lt;GH1_Zm -&gt; GH2_Zm | GH2_Zm.1, GH2_Zm.2 &gt;;
           ^
Runtime error in map&lt; ... &gt;: Images do not generate the (whole) codomain
</PRE>
An alternative way of creating the homomorphism h would be
<P>
<P>
<PRE>
&gt; h := Homomorphism(GH1_Zm, GH2_Zm, Generators(GH1_Zm), [GH2_Zm.1, GH2_Zm.2]);
</PRE>
<PRE></PRE> <A  HREF = "text785.htm">[Next]</A><A  HREF = "text804.htm">[Prev]</A> <A  HREF = "text785.htm">[Right]</A> <A  HREF = "text804.htm">[Left]</A> <A  HREF = "text786.htm">[Up]</A> <A  HREF = "ind.htm">[Index]</A> <A  HREF = "MAGMA.htm">[Root]</A>
<br><small>Version: V2.22 of <I>
Thu Jun  9 16:37:49 EST 2016
</I></small>
</body></html>